// Driver to compile main.lx with NEW PR3 codegen
let driver = import "src/driver.lx"
let codegen = import "src/passes/backend/codegen.lx"
let verify = import "src/passes/backend/verify-bytecode.lx"
let ModuleResolution = import "src/module_resolution.lx"

// Timing helper (using perl for low overhead and high precision)
fn now() {
  let result = exec("perl -MTime::HiRes -e 'print Time::HiRes::time()'")
  tonumber(result.out)
}

fn timeToMs(seconds) {
  int(seconds * 1000 + 0.5)
}

let timings = .{
  phases: .{},
  modules: .{}
}

println("=== Building lxlx.h with NEW codegen (PR3) ===")
println("")

// Create driver with NEW codegen (PR3)
let resolver = ModuleResolution.forEntry("lx/main.lx")
let d = driver.make(.{
  profile: "default",
  withTypecheck: false,
  loadSource: fn(path) { resolver.slurpPath(path) }
})

// Codegen with recursive module compilation
println("=== Compiling main.lx and all dependencies ===")

let moduleCache = .{}

fn codegenModule(modulePath) {
  let cached = moduleCache[modulePath]
  if cached { return cached }

  let t0 = now()
  let modResult = d.compileModule(modulePath)
  let t1 = now()

  if !modResult or modResult.status != "done" {
    println("Failed to compile module: " + modulePath)
    return nil
  }

  let passes = modResult.passes or .{}
  let ast = (passes["anf-inline"] and passes["anf-inline"].ast) or
            (passes.anf and passes.anf.ast) or
            (passes.lower and passes.lower.ast)
  let enumInfo =
    (passes.anf and passes.anf.enumInfo) or
    (passes.lower and passes.lower.enumInfo) or
    (passes.parse and passes.parse.enumInfo) or
    .{}
  let t2 = now()
  let cg = codegen(ast, modResult.passes.resolve, .{
    codegenModule: codegenModule,
    enumInfo: enumInfo,
  })
  let t3 = now()

  if !cg.success or len(cg.errors) > 0 {
    println("Codegen errors in " + modulePath + ":")
    for let i = 0; i < len(cg.errors); i = i + 1 {
      println("  " + cg.errors[i].message)
    }
    return nil
  }

  // Verify
  let t4 = now()
  let verifyResult = verify.verifyFunction(cg.function)
  let t5 = now()

  if !verifyResult.success {
    println("Verification failed for " + modulePath)
    return nil
  }

  // Store timings and metrics for this module
  timings.modules[modulePath] = .{
    compile: timeToMs(t1 - t0),
    codegen: timeToMs(t3 - t2),
    verify: timeToMs(t5 - t4),
    total: timeToMs(t5 - t0),
    metrics: cg.metrics or .{},
    bytesEmitted: cg.bytesEmitted or 0
  }

  moduleCache[modulePath] = cg.function
  cg.function
}

let mainFunction = codegenModule("main.lx")
if !mainFunction {
  println("Codegen failed")
  Lx.exit(1)
}

println("Codegen successful")
println("")
println("=== Verification ===")
println("Bytecode verification PASSED")
println("")

// Build object
println("=== Building Object ===")
let tObjStart = now()
let objbuilder = import "src/objbuilder.lx"
let hexBytes = objbuilder(mainFunction, false).bytes()
let tObjEnd = now()
timings.phases["objbuild"] = timeToMs(tObjEnd - tObjStart)
println("Object size: " + str(len(hexBytes)) + " bytes")

// Convert byte numbers to string
let byteString = ""
for let i = 0; i < len(hexBytes); i = i + 1 {
  byteString = byteString + chr(hexBytes[i])
}

let outputPath = "out/lxlx-new.lxobj"
let ok = spit(outputPath, byteString)
if ok != true {
  groanln(ok or "Failed to write output.")
  Lx.exit(1)
}

println("Saved to " + outputPath)
println("")
println("SUCCESS: lxlx bytecode built with NEW codegen")
println("")

// Print timing report
println("=== Performance Report ===")
println("")

// Calculate totals
let totalCompile = 0
let totalCodegen = 0
let totalVerify = 0
let totalPerModule = 0
let totalNodes = 0
let totalEmitCalls = 0
let totalPatchCount = 0
let totalConstAdds = 0
let totalConstLookups = 0
let totalConstHits = 0
let totalBytesEmitted = 0

let moduleKeys = keys(timings.modules)
for let i = 0; i < len(moduleKeys); i = i + 1 {
  let key = moduleKeys[i]
  let m = timings.modules[key]
  totalCompile = totalCompile + m.compile
  totalCodegen = totalCodegen + m.codegen
  totalVerify = totalVerify + m.verify
  totalPerModule = totalPerModule + m.total

  let metrics = m.metrics
  if metrics {
    totalNodes = totalNodes + (metrics.nodesVisited or 0)
    totalEmitCalls = totalEmitCalls + (metrics.emitCalls or 0)
    totalPatchCount = totalPatchCount + (metrics.patchCount or 0)
    totalConstAdds = totalConstAdds + (metrics.constAdds or 0)
    totalConstLookups = totalConstLookups + (metrics.constLookups or 0)
    totalConstHits = totalConstHits + (metrics.constHits or 0)
  }
  totalBytesEmitted = totalBytesEmitted + (m.bytesEmitted or 0)
}

println("Phase breakdown (all modules combined):")
println("  Parse+Lower+ANF+Resolve: " + str(totalCompile) + "ms")
println("  Codegen:                 " + str(totalCodegen) + "ms")
println("  Verification:            " + str(totalVerify) + "ms")
println("  Object building:         " + str(timings.phases["objbuild"]) + "ms")
println("  Total:                   " + str(totalPerModule + timings.phases["objbuild"]) + "ms")
println("")

println("Codegen metrics (all modules combined):")
println("  Nodes visited:           " + str(totalNodes))
println("  Emit calls:              " + str(totalEmitCalls))
println("  Bytes emitted:           " + str(totalBytesEmitted))
println("  Patch count:             " + str(totalPatchCount))
println("  Const adds:              " + str(totalConstAdds))
println("  Const lookups:           " + str(totalConstLookups))
println("  Const hits:              " + str(totalConstHits))
println("")

let msPerNode = totalNodes > 0 and int(totalCodegen * 1000 / totalNodes) or 0
let msPerEmit = totalEmitCalls > 0 and int(totalCodegen * 1000 / totalEmitCalls) or 0
let emitPerByte = totalBytesEmitted > 0 and int(totalEmitCalls * 100 / totalBytesEmitted) / 100 or 0
let constHitRate = totalConstLookups > 0 and int(totalConstHits * 100 / totalConstLookups) or 0

println("Codegen efficiency:")
println("  us/node:                 " + str(msPerNode) + "us")
println("  us/emit:                 " + str(msPerEmit) + "us")
println("  emit-calls/byte:         " + str(emitPerByte))
println("  const hit rate:          " + str(constHitRate) + "%")
println("")

println("Per-module breakdown:")
for let i = 0; i < len(moduleKeys); i = i + 1 {
  let key = moduleKeys[i]
  let m = timings.modules[key]
  println("  " + key + ":")
  println("    Compile:  " + str(m.compile) + "ms")
  println("    Codegen:  " + str(m.codegen) + "ms")
  println("    Verify:   " + str(m.verify) + "ms")
  println("    Total:    " + str(m.total) + "ms")
}
