// Nil-Check Service - Flow-sensitive nil-safety analysis for IDE/LSP
//
// Works with pre-ANF AST (parse → lower → resolve) to provide accurate
// nil-safety diagnostics without dealing with ANF temporaries.
//
// Checks four enforced sites:
// - Member access: a.x
// - Index access: a[x]
// - Function calls: a()
// - Destructuring: let .{x} = a
//
// Features:
// - Flow-sensitive tracking of definitely non-nil variables
// - Conditional refinement: if x { ... } proves x is non-nil in then-branch
// - Conservative analysis: only tracks what we can prove

let .{ NODE } = import "src/types.lx"

// ========================================
// Helpers
// ========================================

fn nodeKeyFor(ctx, node) {
  if !node { return nil }
  if ctx and ctx.nodes and ctx.nodes[node.id] {
    return node.id
  }
  // Composite key format: filename:id
  join([node.filename or "", ":", node.id], "")
}

fn normalizeOperator(op) {
  if !op { return nil }
  if type(op) == "string" { return op }
  op.lexeme or op
}

fn declKeyFromBinding(binding) {
  if !binding { return nil }
  binding.declaredAtKey or binding.declaredAt
}

fn hoistedFuncDeclKey(ctx, funcNode) {
  if !funcNode or funcNode.type != NODE.Function { return nil }
  if !funcNode.name or funcNode.name.type != NODE.Identifier { return nil }

  let binding = ctx.resolvedNames and ctx.resolvedNames[nodeKeyFor(ctx, funcNode.name)]
  if binding {
    return binding.declaredAtKey or binding.declaredAt or nodeKeyFor(ctx, funcNode.name)
  }

  nodeKeyFor(ctx, funcNode.name)
}

fn propNameFromNode(n) {
  if !n { return nil }
  if n.type == NODE.Identifier { return n.name }
  if n.type == NODE.String { return n.value }
  nil
}

fn lastExprFromAst(ast) {
  if ast and ast.expressions and len(ast.expressions) > 0 {
    return ast.expressions[len(ast.expressions) - 1]
  }
  if ast and ast.body and len(ast.body) > 0 {
    return ast.body[len(ast.body) - 1]
  }
  nil
}

fn findRecordField(recordNode, fieldName) {
  if !recordNode or recordNode.type != NODE.Hashmap or !recordNode.pairs {
    return nil
  }

  // Optional: lazy index like query.lx (recommended for performance)
  if !recordNode._fieldIndex {
    recordNode._fieldIndex = .{}
    for let i = 0; i < len(recordNode.pairs); i = i + 1 {
      let pair = recordNode.pairs[i]
      let key = pair and pair.key
      if key and key.type == NODE.String and key.value {
        recordNode._fieldIndex[key.value] = .{ key, value: pair.value }
      }
    }
  }

  recordNode._fieldIndex[fieldName]
}

fn resolveExprToRecord(ctx, expr, seen) {
  if !expr { return nil }

  if expr.id and seen and seen[expr.id] { return nil }
  if expr.id and seen { seen[expr.id] = true }

  // direct record literal
  if expr.type == NODE.Hashmap {
    return expr
  }

  // block: last expression
  if expr.type == NODE.Block {
    let last = lastExprFromAst(expr)
    return resolveExprToRecord(ctx, last, seen)
  }

  // grouping if you have it in your AST
  if expr.type == NODE.Grouping {
    return resolveExprToRecord(ctx, expr.expression, seen)
  }

  // identifier: chase let init
  if expr.type == NODE.Identifier {
    let binding = ctx.resolvedNames[nodeKeyFor(ctx, expr)]
    if !binding { return nil }

    let declKey = binding.declaredAtKey or binding.declaredAt
    if !declKey { return nil }

    let declNode = ctx.nodes and ctx.nodes[declKey] or nil
    if !declNode { return nil }

    // In your query implementation, you locate Let via findLetByNameNode.
    // Nilcheck can simply accept that declNode itself might be the Identifier,
    // and the actual Let is "nearby". But easiest is:
    // - If resolver.declaredAt points to the Let name Identifier, get the Let from ctx.nodes mapping if it exists.
    // If your resolver has a direct mapping, use it. Otherwise, you can:
    // - check if declNode.parentLetId exists (if you track it)
    // - or add a tiny index like query's letsByNameSpan (best long-term)
    //
    // For now, assume declaredAt points to the Identifier node, and that node has ._letId or .letId if you attached it.
    // If you don't, the robust way is to build an index once (see "Recommended indexing" below).
    let letNode = findLetForDecl(ctx, declKey)
    if !letNode or !letNode.init { return nil }

    // Import: resolve to module's return value (last expression)
    if letNode.init.type == NODE.Import and letNode.init.path and letNode.init.path.value {
      let modulePath = letNode.init.path.value
      let moduleAst = ctx.moduleAsts and ctx.moduleAsts[modulePath]
      let moduleReturn = moduleAst and lastExprFromAst(moduleAst)
      if moduleReturn {
        return resolveExprToRecord(ctx, moduleReturn, seen)
      }
      return nil
    }

    return resolveExprToRecord(ctx, letNode.init, seen)
  }

  // dot: base record -> field value
  if expr.type == NODE.Dot {
    let prop = propNameFromNode(expr.property)
    if !prop { return nil }

    let base = resolveExprToRecord(ctx, expr.object, seen)
    if !base { return nil }

    let field = findRecordField(base, prop)
    if field and field.value {
      return resolveExprToRecord(ctx, field.value, seen)
    }
  }

  nil
}

fn ensureNilcheckIndex(ctx) {
  if ctx._nilcheckIndex { return }
  let index = .{ letByNameKey: .{} }

  let ids = keys(ctx.nodes or .{})
  for let i = 0; i < len(ids); i = i + 1 {
    let n = ctx.nodes[ids[i]]
    if n and n.type == NODE.Let and n.name and n.name.type == NODE.Identifier {
      // Use nodeKeyFor so it works for composite or raw
      index.letByNameKey[nodeKeyFor(ctx, n.name)] = n
    }
  }

  ctx._nilcheckIndex = index
}

fn findLetForDecl(ctx, declKey) {
  ensureNilcheckIndex(ctx)
  // First try name-id lookup:
  let letNode = ctx._nilcheckIndex.letByNameKey[declKey]
  if letNode { return letNode }

  // Fallback: if declaredAt points to a Let node key directly:
  let n = ctx.nodes and ctx.nodes[declKey]
  if n and n.type == NODE.Let { return n }

  nil
}

// ========================================
// Type Helpers
// ========================================

fn isNonNilLiteral(node) {
  if !node { return false }
  let t = node.type
  if t == NODE.Number or t == NODE.String or t == NODE.Bool {
    return true
  }
  if t == NODE.Array or t == NODE.Hashmap or t == NODE.Function {
    return true
  }
  if t == NODE.Enum {
    return true
  }
  false
}

fn isNilLiteral(node) {
  if !node { return false }
  node.type == NODE.Nil
}

// ========================================
// Dataflow State Management
// ========================================

fn makeState() {
  .{
    defNonNil: .{},        // declNodeId -> boolean (true = definitely non-nil)
    assignedInLoop: .{},   // declNodeId -> boolean (assigned in current loop)
  }
}

fn cloneState(state) {
  let newDefNonNil = .{}
  for k in keys(state.defNonNil) {
    newDefNonNil[k] = state.defNonNil[k]
  }

  let newAssignedInLoop = .{}
  for k in keys(state.assignedInLoop) {
    newAssignedInLoop[k] = state.assignedInLoop[k]
  }

  .{
    defNonNil: newDefNonNil,
    assignedInLoop: newAssignedInLoop,
  }
}

fn mergeStates(states) {
  // Intersection - only keep bits set in ALL states
  if !states or len(states) == 0 {
    return makeState()
  }

  if len(states) == 1 {
    return cloneState(states[0])
  }

  let result = cloneState(states[0])

  for let i = 1; i < len(states); i = i + 1 {
    let other = states[i]
    for k in keys(result.defNonNil) {
      if !other.defNonNil[k] {
        result.defNonNil[k] = false
      }
    }
  }

  result
}

fn setNonNil(state, declNodeId, value) {
  if declNodeId {
    state.defNonNil[declNodeId] = value
  }
}

fn isDefinitelyNonNil(state, declNodeId) {
  if !declNodeId { return false }
  state.defNonNil[declNodeId] == true
}

fn markAssignedInLoop(state, declNodeId) {
  if declNodeId {
    state.assignedInLoop[declNodeId] = true
  }
}

// ========================================
// Variable Resolution
// ========================================

fn getDeclNodeId(ctx, identNode) {
  if !identNode or identNode.type != NODE.Identifier {
    return nil
  }

  let binding = ctx.resolvedNames[nodeKeyFor(ctx, identNode)]
  if !binding { return nil }

  if binding.kind == "local" or binding.kind == "upvalue" {
    return binding.declaredAtKey or binding.declaredAt
  }

  nil
}

fn isFunctionBinding(ctx, identNode) {
  if !identNode or identNode.type != NODE.Identifier {
    return false
  }

  let binding = ctx.resolvedNames[nodeKeyFor(ctx, identNode)]
  if !binding { return false }

  if binding.kind == "builtin" { return true }

  // If declaration node exists and is a Function, treat as callable/non-nil
  let declKey = binding.declaredAtKey or binding.declaredAt
  if declKey and ctx.nodes and ctx.nodes[declKey] and ctx.nodes[declKey].type == NODE.Function {
    return true
  }

  false
}

// ========================================
// Expression Analysis Helpers
// ========================================

fn isExprDefinitelyNonNil(ctx, expr, state) {
  if !expr { return false }

  // Non-nil literals and constructors
  if isNonNilLiteral(expr) {
    return true
  }

  // Identifiers - check state or function binding
  if expr.type == NODE.Identifier {
    if isFunctionBinding(ctx, expr) {
      return true
    }

    if let declNodeId = getDeclNodeId(ctx, expr) {
      return isDefinitelyNonNil(state, declNodeId)
    }
  }

  // Block expressions - check the last expression
  if expr.type == NODE.Block {
    if expr.expressions and len(expr.expressions) > 0 {
      let lastExpr = expr.expressions[len(expr.expressions) - 1]
      return isExprDefinitelyNonNil(ctx, lastExpr, state)
    }
    return false
  }

  // Dot expression: if it resolves through record/enum namespace to something,
  // treat as non-nil (conservative: require field exists and resolves).
  if expr.type == NODE.Dot {
    let prop = propNameFromNode(expr.property)
    if prop {
      let rec = resolveExprToRecord(ctx, expr.object, .{})
      if rec {
        let field = findRecordField(rec, prop)
        if field and field.value {
          // if you want strictness, recurse to ensure the member is non-nil
          if isExprDefinitelyNonNil(ctx, field.value, state) {
            return true
          }
          // or looser: member exists => treat as non-nil (common for enums)
          // return true
        }
      }
    }
  }

  // If an expression resolves to a record namespace, it's non-nil.
  let rec = resolveExprToRecord(ctx, expr, .{})
  if rec { return true }

  false
}

// ========================================
// Expression Analysis
// ========================================

fn analyzeExpr(ctx, diagnostics, node, state) {
  if !node { return state }

  let t = node.type

  // Literals - no state changes
  if t == NODE.Number or t == NODE.String or t == NODE.Bool or t == NODE.Nil {
    return state
  }

  if t == NODE.Identifier {
    return state
  }

  // Array/Hashmap literals
  if t == NODE.Array {
    if node.elements {
      for elem in node.elements {
        state = analyzeExpr(ctx, diagnostics, elem, state)
      }
    }
    return state
  }

  if t == NODE.Hashmap {
    if node.pairs {
      for pair in node.pairs {
        if pair and pair.value {
          state = analyzeExpr(ctx, diagnostics, pair.value, state)
        }
      }
    }
    return state
  }

  // Function - don't propagate state (intraprocedural)
  if t == NODE.Function {
    return state
  }

  // Binary/Unary operations
  if t == NODE.Binary {
    state = analyzeExpr(ctx, diagnostics, node.left, state)
    state = analyzeExpr(ctx, diagnostics, node.right, state)
    return state
  }

  if t == NODE.Unary {
    state = analyzeExpr(ctx, diagnostics, node.operand, state)
    return state
  }

  // Member access - CHECK SITE
  if t == NODE.Dot {
    state = analyzeExpr(ctx, diagnostics, node.object, state)

    if node.object and !isExprDefinitelyNonNil(ctx, node.object, state) {
      let name = "value"
      if node.object.type == NODE.Identifier {
        name = node.object.name or node.object.lexeme or "value"
      }
      push(diagnostics, .{
        message: "Member access on potentially nil value '" + name + "'",
        severity: "warning",
        phase: "nilcheck",
        filename: node.filename,
        line: node.line,
        col: node.col,
        endLine: node.endLine,
        endCol: node.endCol,
        nodeId: node.id,
      })
    }

    return state
  }

  // Index access - CHECK SITE
  if t == NODE.Index {
    state = analyzeExpr(ctx, diagnostics, node.object, state)
    state = analyzeExpr(ctx, diagnostics, node.index, state)

    if node.object and !isExprDefinitelyNonNil(ctx, node.object, state) {
      let name = "value"
      if node.object.type == NODE.Identifier {
        name = node.object.name or node.object.lexeme or "value"
      }
      push(diagnostics, .{
        message: "Index access on potentially nil value '" + name + "'",
        severity: "warning",
        phase: "nilcheck",
        filename: node.filename,
        line: node.line,
        col: node.col,
        endLine: node.endLine,
        endCol: node.endCol,
        nodeId: node.id,
      })
    }

    return state
  }

  // Call - CHECK SITE
  if t == NODE.Call {
    state = analyzeExpr(ctx, diagnostics, node.callee, state)

    if node.callee {
      let isBuiltin = false
      if node.callee.type == NODE.Identifier {
        let binding = ctx.resolvedNames[nodeKeyFor(ctx, node.callee)]
        isBuiltin = binding and binding.kind == "builtin"
      }

      if !isBuiltin and !isExprDefinitelyNonNil(ctx, node.callee, state) {
        let name = "function"
        if node.callee.type == NODE.Identifier {
          name = node.callee.name or node.callee.lexeme or "function"
        }
        push(diagnostics, .{
          message: "Call on potentially nil value '" + name + "'",
          severity: "warning",
          phase: "nilcheck",
          filename: node.filename,
          line: node.line,
          col: node.col,
          endLine: node.endLine,
          endCol: node.endCol,
          nodeId: node.id,
        })
      }
    }

    if node.args {
      for arg in node.args {
        state = analyzeExpr(ctx, diagnostics, arg, state)
      }
    }

    return state
  }

  // If expression with conditional refinement
  if t == NODE.If {
    state = analyzeExpr(ctx, diagnostics, node.condition, state)

    // Refine state for then branch
    let thenState = cloneState(state)

    // Simple refinement patterns (no ANF unwrapping needed!)
    if node.condition {
      if node.condition.type == NODE.Identifier {
        // if x { ... } - x is non-nil in then branch
        if let declNodeId = getDeclNodeId(ctx, node.condition) {
          setNonNil(thenState, declNodeId, true)
        }
      } else if node.condition.type == NODE.Binary {
        let op = normalizeOperator(node.condition.operator)

        if op == "!=" {
          // if x != nil { ... }
          let left = node.condition.left
          let right = node.condition.right

          if left and left.type == NODE.Identifier and isNilLiteral(right) {
            if let declNodeId = getDeclNodeId(ctx, left) {
              setNonNil(thenState, declNodeId, true)
            }
          } else if right and right.type == NODE.Identifier and isNilLiteral(left) {
            if let declNodeId = getDeclNodeId(ctx, right) {
              setNonNil(thenState, declNodeId, true)
            }
          }
        }
      }
    }

    thenState = analyzeExpr(ctx, diagnostics, node.then, thenState)

    if node.else_ {
      let elseState = cloneState(state)
      elseState = analyzeExpr(ctx, diagnostics, node.else_, elseState)
      return mergeStates([thenState, elseState])
    }

    return mergeStates([thenState, state])
  }

  // Block
  if t == NODE.Block {
    return analyzeBlock(ctx, diagnostics, node, state)
  }

  // For loop - conservative handling
  if t == NODE.For {
    if node.init {
      state = analyzeStmt(ctx, diagnostics, node.init, state)
    }

    if node.condition {
      state = analyzeExpr(ctx, diagnostics, node.condition, state)
    }

    if node.body {
      let bodyState = cloneState(state)
      bodyState = analyzeExpr(ctx, diagnostics, node.body, bodyState)

      // Conservative: clear non-nil bits for all vars assigned in loop
      for declId in keys(bodyState.assignedInLoop) {
        setNonNil(state, declId, false)
      }
    }

    if node.increment {
      state = analyzeExpr(ctx, diagnostics, node.increment, state)
    }

    return state
  }

  // Collect expression
  if t == NODE.Collect {
    if node.init {
      state = analyzeStmt(ctx, diagnostics, node.init, state)
    }

    if node.condition {
      state = analyzeExpr(ctx, diagnostics, node.condition, state)
    }

    if node.body {
      let bodyState = cloneState(state)
      bodyState = analyzeExpr(ctx, diagnostics, node.body, bodyState)

      for declId in keys(bodyState.assignedInLoop) {
        setNonNil(state, declId, false)
      }
    }

    if node.increment {
      state = analyzeExpr(ctx, diagnostics, node.increment, state)
    }

    return state
  }

  // Enum
  if t == NODE.Enum {
    return state
  }

  // Arrow (method call)
  if t == NODE.Arrow {
    state = analyzeExpr(ctx, diagnostics, node.object, state)
    state = analyzeExpr(ctx, diagnostics, node.property, state)
    return state
  }

  state
}

fn analyzeStmt(ctx, diagnostics, node, state) {
  if !node { return state }

  let t = node.type

  // Let statement - track assignment
  if t == NODE.Let {
    // Destructuring - CHECK SITE
    if node.destructure {
      if node.init and !isExprDefinitelyNonNil(ctx, node.init, state) {
        let name = "value"
        if node.init.type == NODE.Identifier {
          name = node.init.name or node.init.lexeme or "value"
        }
        push(diagnostics, .{
          message: "Destructuring potentially nil value '" + name + "'",
          severity: "warning",
          phase: "nilcheck",
          filename: node.filename,
          line: node.line,
          col: node.col,
          endLine: node.endLine,
          endCol: node.endCol,
          nodeId: node.id,
        })
      }

      if node.init {
        state = analyzeExpr(ctx, diagnostics, node.init, state)
      }

      return state
    }

    // Regular let: let x = expr
    if node.init {
      state = analyzeExpr(ctx, diagnostics, node.init, state)

      if node.name and node.name.type == NODE.Identifier {
        let declNodeId = nodeKeyFor(ctx, node.name)

        if isNonNilLiteral(node.init) {
          setNonNil(state, declNodeId, true)
        } else if isNilLiteral(node.init) {
          setNonNil(state, declNodeId, false)
        } else if node.init.type == NODE.Identifier {
          // Copy nil state: let y = x
          let srcDeclNodeId = getDeclNodeId(ctx, node.init)
          if srcDeclNodeId {
            let isNonNil = isDefinitelyNonNil(state, srcDeclNodeId)
            setNonNil(state, declNodeId, isNonNil)
          } else {
            setNonNil(state, declNodeId, false)
          }
        } else if node.init.type == NODE.Block {
          // Block expression - check last expression
          if node.init.expressions and len(node.init.expressions) > 0 {
            let lastExpr = node.init.expressions[len(node.init.expressions) - 1]
            if isExprDefinitelyNonNil(ctx, lastExpr, state) {
              setNonNil(state, declNodeId, true)
            } else {
              setNonNil(state, declNodeId, false)
            }
          } else {
            setNonNil(state, declNodeId, false)
          }
        } else {
          setNonNil(state, declNodeId, false)
        }
      }
    }

    return state
  }

  // Assignment - update tracked variable
  if t == NODE.Assignment {
    if node.value {
      state = analyzeExpr(ctx, diagnostics, node.value, state)
    }

    if node.target and node.target.type == NODE.Identifier {
      if let declNodeId = getDeclNodeId(ctx, node.target) {
        markAssignedInLoop(state, declNodeId)

        if isNonNilLiteral(node.value) {
          setNonNil(state, declNodeId, true)
        } else if isNilLiteral(node.value) {
          setNonNil(state, declNodeId, false)
        } else if node.value and node.value.type == NODE.Identifier {
          let srcDeclNodeId = getDeclNodeId(ctx, node.value)
          if srcDeclNodeId {
            let isNonNil = isDefinitelyNonNil(state, srcDeclNodeId)
            setNonNil(state, declNodeId, isNonNil)
          } else {
            setNonNil(state, declNodeId, false)
          }
        } else {
          setNonNil(state, declNodeId, false)
        }
      }
    }

    return state
  }

  // Return statement
  if t == NODE.Return {
    if node.value {
      state = analyzeExpr(ctx, diagnostics, node.value, state)
    }
    return state
  }

  // Break/Continue
  if t == NODE.Break or t == NODE.Continue {
    return state
  }

  // Expression statement
  state = analyzeExpr(ctx, diagnostics, node, state)
  state
}

fn analyzeBlock(ctx, diagnostics, block, state) {
  if !block or block.type != NODE.Block { return state }
  if !block.expressions { return state }

  for expr in block.expressions {
    state = analyzeStmt(ctx, diagnostics, expr, state)
  }

  state
}

fn analyzeFunction(ctx, diagnostics, funcNode) {
  if !funcNode or funcNode.type != NODE.Function { return }

  let state = makeState()

  // Mark any hoisted functions in the body as non-nil from the start
  if funcNode.body and funcNode.body.type == NODE.Block and funcNode.body.expressions {
    for expr in funcNode.body.expressions {
      if expr.type == NODE.Function and expr.name and expr.name.type == NODE.Identifier {
        let k = hoistedFuncDeclKey(ctx, expr)
        setNonNil(state, k, true)
      }
    }
  }

  if funcNode.body {
    analyzeExpr(ctx, diagnostics, funcNode.body, state)
  }
}

fn analyzeTopLevel(ctx, diagnostics, ast) {
  if !ast { return }

  if ast.type == NODE.Block {
    let state = makeState()

    // First pass: mark all hoisted function names as non-nil
    if ast.expressions {
      for expr in ast.expressions {
        if expr.type == NODE.Function and expr.name and expr.name.type == NODE.Identifier {
          let k = hoistedFuncDeclKey(ctx, expr)
          setNonNil(state, k, true)
        }
      }
    }

    // Second pass: analyze expressions
    if ast.expressions {
      for expr in ast.expressions {
        if expr.type == NODE.Function {
          analyzeFunction(ctx, diagnostics, expr)
        } else if expr.type == NODE.Let and expr.init and expr.init.type == NODE.Function {
          analyzeFunction(ctx, diagnostics, expr.init)
          state = analyzeStmt(ctx, diagnostics, expr, state)
        } else {
          state = analyzeStmt(ctx, diagnostics, expr, state)
        }
      }
    }
  } else if ast.type == NODE.Function {
    analyzeFunction(ctx, diagnostics, ast)
  }
}

// ========================================
// Public API
// ========================================

fn queryNilCheck(ctx) {
  if !ctx or !ctx.ast or !ctx.resolvedNames {
    return []
  }

  let diagnostics = []
  analyzeTopLevel(ctx, diagnostics, ctx.ast)
  diagnostics
}

queryNilCheck
