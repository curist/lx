// Typecheck Phase Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"

// Helper: parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{})
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    errors: typecheckResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

// Helper: Get type of expression in test block
fn getExprType(result, exprIndex) {
  // For tests like "{ expr1\nexpr2 }", ast.body[0] is the Block
  // and the expressions are in Block.expressions
  let ast = result.lowerResult.ast
  if !ast or !ast.body or len(ast.body) == 0 {
    return nil
  }

  let blockNode = ast.body[0]
  if !blockNode or blockNode.type != "Block" or !blockNode.expressions {
    return nil
  }

  if exprIndex >= len(blockNode.expressions) {
    return nil
  }

  let node = blockNode.expressions[exprIndex]

  // For Let nodes, get the type of the bound variable (from name.id)
  if node.type == "Let" {
    return result.types[node.name.id]
  }

  // Direct expression - return its type
  return result.types[node.id]
}

// Helper: Get the actual AST node at an index
fn getExprNode(result, exprIndex) {
  let ast = result.lowerResult.ast
  if len(ast.body) > 0 {
    let blockNode = ast.body[0]
    if blockNode.type == "Block" and exprIndex < len(blockNode.expressions) {
      return blockNode.expressions[exprIndex]
    }
  }
  nil
}

// ========================================
// Functions
// ========================================

test("typecheck - function definition", fn(assert) {
  let result = parseAndTypecheck("fn(x) { x }")
  assert.truthy(result.success, "Should typecheck function definition")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function call", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x }\nf(42) }")
  assert.truthy(result.success, "Should typecheck function call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function with multiple params", fn(assert) {
  let result = parseAndTypecheck("fn(x, y) { x + y }")
  assert.truthy(result.success, "Should typecheck multi-param function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function return type", fn(assert) {
  let result = parseAndTypecheck("fn(x) { return x + 1 }")
  assert.truthy(result.success, "Should typecheck function with return")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arity mismatch", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x, y) { x + y }\nf(42) }")
  assert.equal(result.success, false, "Should fail on arity mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - argument type error", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x + 1 }\nf(\"hello\") }")
  assert.equal(result.success, false, "Should fail on argument type error")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - closure", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nfn() { x } }")
  assert.truthy(result.success, "Should typecheck closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested functions", fn(assert) {
  let result = parseAndTypecheck("fn(x) { fn(y) { x + y } }")
  assert.truthy(result.success, "Should typecheck nested functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - return type mismatch", fn(assert) {
  let result = parseAndTypecheck("fn() { if true { return 1 } else { return \"hello\" } }")
  assert.equal(result.success, false, "Should fail on return type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - recursion", fn(assert) {
  let result = parseAndTypecheck("{ fn fact(n) { if n == 0 { 1 } else { n * fact(n - 1) } } fact(5) }")
  assert.truthy(result.success, "Should typecheck recursive function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - mutual recursion", fn(assert) {
  let result = parseAndTypecheck("{ fn a(n) { if n == 0 { 1 } else { b(n - 1) } } fn b(n) { a(n) } a(5) }")
  assert.truthy(result.success, "Should typecheck mutually recursive functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - recursion infers consistent type", fn(assert) {
  // This should fail because the recursive call expects Number but gets String
  let result = parseAndTypecheck("{ fn f(x) { if x == 0 { 1 } else { f(\"oops\") } } f(5) }")
  assert.equal(result.success, false, "Should fail when recursive call has wrong type")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Polymorphism Tests
// ========================================

test("typecheck - polymorphic identity function", fn(assert) {
  let result = parseAndTypecheck("{ let id = fn(x) { x }\nlet n = id(42)\nlet s = id(\"hello\")\nn + 1 }")
  assert.truthy(result.success, "Should allow polymorphic identity")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic function with constraints", fn(assert) {
  let result = parseAndTypecheck("{ let add1 = fn(x) { x + 1 }\nlet n1 = add1(10)\nlet n2 = add1(20)\nn1 + n2 }")
  assert.truthy(result.success, "Should allow multiple uses with same constraint")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic higher-order function", fn(assert) {
  let result = parseAndTypecheck("{ let apply = fn(f, x) { f(x) }\nlet inc = fn(n) { n + 1 }\napply(inc, 42) }")
  assert.truthy(result.success, "Should typecheck higher-order polymorphic function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - value restriction prevents generalization", fn(assert) {
  // Non-function values should not be generalized
  let result = parseAndTypecheck("{ let x = 42\nx = x + 1\nx }")
  assert.truthy(result.success, "Should allow assignment to monomorphic binding")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - cannot assign to polymorphic binding", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x }\nf = fn(y) { y + 1 }\nf }")
  assert.equal(result.success, false, "Should fail on assignment to poly binding")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - polymorphic function in array operations", fn(assert) {
  let result = parseAndTypecheck("{ let double = fn(x) { x + x }\nlet nums = [1, 2, 3]\nmap(nums, double) }")
  assert.truthy(result.success, "Should work with polymorphic map")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic pair selector", fn(assert) {
  let result = parseAndTypecheck("{ let fst = fn(a, b) { a }\nlet n = fst(1, \"x\")\nlet s = fst(\"hello\", 42)\nn + 1 }")
  assert.truthy(result.success, "Should generalize pair selectors")
  assert.equal(len(result.errors), 0, "Should have no errors")
})


suite.run()
