// ========================================================
// Type Constructors
// ========================================================
// Reusable type representations for any type system implementation.

fn typeAny()     { .{ kind: "Any" } }
fn typeNil()     { .{ kind: "Nil" } }
fn typeNumber()  { .{ kind: "Number" } }
fn typeBool()    { .{ kind: "Bool" } }
fn typeString()  { .{ kind: "String" } }
fn typeBottom()  { .{ kind: "Bottom" } }
fn typeEnum(fields) { .{ kind: "Enum", fields } }

fn typeVar(id) {
  .{
    kind: "TypeVar",
    id: id,
    lowerBounds: [],  // types this var must be a supertype of
    upperBounds: [],  // types this var must be a subtype of
  }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields }
}

fn typeMap(key, elem) {
  .{ kind: "Map", key, elem }
}

fn typeUnion(types) {
  let out = []
  let sawAny = false
  for t in (types or []) {
    if !t { continue }
    if t.kind == "Any" { sawAny = true }
    if t.kind == "Bottom" { continue }
    if t.kind == "Union" {
      for opt in (t.options or []) { push(out, opt) }
    } else {
      push(out, t)
    }
  }
  if sawAny { return typeAny() }
  if len(out) == 0 { return typeBottom() }
  if len(out) == 1 { return out[0] }
  .{ kind: "Union", options: out }
}

fn typeIntersect(types) {
  let out = []
  for t in (types or []) {
    if !t { continue }
    if t.kind == "Bottom" { return typeBottom() }
    if t.kind == "Any" { continue }
    if t.kind == "Intersect" {
      for part in (t.parts or []) { push(out, part) }
    } else {
      push(out, t)
    }
  }
  if len(out) == 0 { return typeAny() }
  if len(out) == 1 { return out[0] }
  .{ kind: "Intersect", parts: out }
}

fn typeNot(value) {
  .{ kind: "Not", value }
}

fn typeOption(value) {
  // Avoid Option[Option[T]]
  value and value.kind == "Option" and value or .{ kind: "Option", value }
}

fn typeIndexable(elem, key, nodeId) {
  .{
    kind: "Indexable",
    elem,
    key,
    nodeId,
    sawNumericIndex: false,
  }
}

fn typeTag(enumId, enumName, memberName, value) {
  .{
    kind: "Tag",
    enumId,
    enumName,
    memberName,
    value,
  }
}

// ========================================================
// Type Variable Management
// ========================================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = id + 1
  typeVar(id)
}

fn getTypeVarBinding(checker, id) {
  checker.typeVarBindings[id]
}

fn bindTypeVar(checker, id, type) {
  let old = checker.typeVarBindings[id]
  if !old {
    checker.typeVarBindings[id] = type
    if checker.changed != nil { checker.changed = true }
    return
  }

  // Avoid counting no-op rebindings as progress.
  if typeEquals(checker, old, type) {
    return
  }

  checker.typeVarBindings[id] = type
  if checker.changed != nil { checker.changed = true }
}

// ========================================================
// Type Utilities
// ========================================================

// Comparator for mixed string/number keys (used for deterministic key sorting)
// Defines total order: strings < numbers < other (stringified)
fn keyLess(a, b) {
  let ta = type(a)
  let tb = type(b)
  if ta != tb {
    if ta == "string" { return true }
    if tb == "string" { return false }
    if ta == "number" { return true }
    if tb == "number" { return false }
    return stringLess(str(ta), str(tb))
  }
  if ta == "string" { return stringLess(a, b) }
  if ta == "number" { return a < b }
  return stringLess(str(a), str(b))
}

// Follow type variable bindings until fixed point
fn deref(checker, type) {
  // Use epoch-based cycle detection to avoid allocating a map each call
  // Fallback to old approach if checker doesn't have epoch tracking (e.g., in tests)
  if checker.derefEpoch != nil {
    checker.derefEpoch = checker.derefEpoch + 1
    let epoch = checker.derefEpoch

    for type and type.kind == "TypeVar" {
      if checker.derefSeen[type.id] == epoch { return type }
      checker.derefSeen[type.id] = epoch
      let bound = getTypeVarBinding(checker, type.id)
      if !bound { break }
      type = bound
    }
    return type
  }

  // Fallback: allocate seen map (old behavior for minimal checker contexts)
  let seen = .{}
  for type and type.kind == "TypeVar" {
    if seen[type.id] { return type }
    seen[type.id] = true
    let bound = getTypeVarBinding(checker, type.id)
    if !bound { break }
    type = bound
  }
  type
}

// Dereference and return both root TypeVar (if any) and final type
fn derefWithRootVar(checker, t) {
  // Use epoch-based cycle detection to avoid allocating a map each call
  // Fallback to old approach if checker doesn't have epoch tracking
  if checker.derefEpoch != nil {
    checker.derefEpoch = checker.derefEpoch + 1
    let epoch = checker.derefEpoch

    let root = nil
    for t and t.kind == "TypeVar" {
      if checker.derefSeen[t.id] == epoch { break }
      checker.derefSeen[t.id] = epoch
      root = t
      let bound = getTypeVarBinding(checker, t.id)
      if !bound { break }
      t = bound
    }
    return .{ root: root, type: t }
  }

  // Fallback: allocate seen map (old behavior for minimal checker contexts)
  let root = nil
  let seen = .{}
  for t and t.kind == "TypeVar" {
    if seen[t.id] { break }
    seen[t.id] = true
    root = t
    let bound = getTypeVarBinding(checker, t.id)
    if !bound { break }
    t = bound
  }
  .{ root: root, type: t }
}

// Structural type equality
fn typeEquals(checker, a, b) {
  fn eq (x, y, depth) {
    if depth > 200 {
      // Defensive: if something went cyclic due to a bug, be conservative and
      // treat as not equal so we don't suppress progress.
      return false
    }
    x = x and deref(checker, x) or x
    y = y and deref(checker, y) or y

    if !x and !y { return true }
    if !x or !y { return false }

    // Fast paths
    if x.kind != y.kind { return false }
    if x.kind == "Any" or x.kind == "Bottom" or x.kind == "Nil" or
       x.kind == "Number" or x.kind == "Bool" or x.kind == "String" {
      return true
    }
    if x.kind == "TypeVar" { return x.id == y.id }

    if x.kind == "Tag" {
      if x.enumId != nil or y.enumId != nil {
        return x.enumId == y.enumId and x.memberName == y.memberName
      }
      return x.enumName == y.enumName and x.memberName == y.memberName
    }

    if x.kind == "Union" {
      let xk = collect t in (x.options or []) { typeKey(t) }
      let yk = collect t in (y.options or []) { typeKey(t) }
      if len(xk) != len(yk) { return false }
      xk = sort(xk, stringLess)
      yk = sort(yk, stringLess)
      for let i = 0; i < len(xk); i = i + 1 {
        if xk[i] != yk[i] { return false }
      }
      return true
    }

    if x.kind == "Intersect" {
      let xk = collect t in (x.parts or []) { typeKey(t) }
      let yk = collect t in (y.parts or []) { typeKey(t) }
      if len(xk) != len(yk) { return false }
      xk = sort(xk, stringLess)
      yk = sort(yk, stringLess)
      for let i = 0; i < len(xk); i = i + 1 {
        if xk[i] != yk[i] { return false }
      }
      return true
    }

    if x.kind == "Not" { return eq(x.value, y.value, depth + 1) }

    if x.kind == "Array" { return eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Map" { return eq(x.key, y.key, depth + 1) and eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Option" { return eq(x.value, y.value, depth + 1) }
    if x.kind == "Indexable" { return eq(x.key, y.key, depth + 1) and eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Function" {
      let xMin = (x.minArity != nil) and x.minArity or len(x.params)
      let yMin = (y.minArity != nil) and y.minArity or len(y.params)
      if xMin != yMin { return false }
      if len(x.params) != len(y.params) { return false }
      for xParam, i in x.params {
        if !eq(xParam, y.params[i], depth + 1) { return false }
      }
      return eq(x.return, y.return, depth + 1)
    }
    if x.kind == "Record" {
      let kx = keys(x.fields)
      let ky = keys(y.fields)
      if len(kx) != len(ky) { return false }
      for k in kx {
        if !y.fields[k] { return false }
        if !eq(x.fields[k], y.fields[k], depth + 1) { return false }
      }
      return true
    }
    if x.kind == "Enum" {
      // Compare enum field sets
      if !x.fields or !y.fields { return false }
      let kx = keys(x.fields)
      let ky = keys(y.fields)
      if len(kx) != len(ky) { return false }
      for k in kx {
        if y.fields[k] == nil { return false }
      }
      return true
    }

    // Fallback: treat as not equal.
    false
  }

  eq(a, b, 0)
}

// Occurs check: prevent infinite types
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for param in type.params {
      if occurs(checker, typeVarId, param) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Map" {
    return occurs(checker, typeVarId, type.key) or occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Option" {
    return occurs(checker, typeVarId, type.value)
  }

  if type.kind == "Union" {
    for t in (type.options or []) {
      if occurs(checker, typeVarId, t) { return true }
    }
  }

  if type.kind == "Intersect" {
    for t in (type.parts or []) {
      if occurs(checker, typeVarId, t) { return true }
    }
  }

  if type.kind == "Not" {
    return occurs(checker, typeVarId, type.value)
  }

  if type.kind == "Record" {
    for k in keys(type.fields) {
      if occurs(checker, typeVarId, type.fields[k]) {
        return true
      }
    }
  }

  false
}

// Recursively dereference all type variables in a type
fn derefAll(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Function" {
    let ps = []
    for param in t.params {
      push(ps, derefAll(checker, param))
    }
    return typeFunction(ps, derefAll(checker, t.return))
  }

  if t.kind == "Union" {
    let options = collect opt in (t.options or []) { derefAll(checker, opt) }
    return typeUnion(options)
  }

  if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { derefAll(checker, part) }
    return typeIntersect(parts)
  }

  if t.kind == "Not" {
    return typeNot(derefAll(checker, t.value))
  }

  if t.kind == "Array" {
    return typeArray(derefAll(checker, t.elem))
  }

  if t.kind == "Map" {
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Option" {
    let v = derefAll(checker, t.value)
    if v and v.kind == "Nil" {
      return typeNil()
    }
    return typeOption(v)
  }

  if t.kind == "Indexable" {
    let keyType = derefAll(checker, t.key)
    let elemType = derefAll(checker, t.elem)
    if keyType.kind == "Number" {
      return typeArray(elemType)
    }
    return typeMap(keyType, elemType)
  }

  if t.kind == "Record" {
    let fields = .{}
    for k in keys(t.fields) {
      fields[k] = derefAll(checker, t.fields[k])
    }
    return typeRecord(fields)
  }

  t
}

// ========================================================
// Boolean Algebra + Constraint Solving
// ========================================================

// Check if a type is a primitive (non-composite) type
fn isPrimitive(t) {
  t.kind == "Nil" or t.kind == "Number" or
  t.kind == "Bool" or t.kind == "String"
}

// Generate a unique key for a type (for caching)
fn typeKey(t) {
  if !t { return "nil" }
  if !t.kind { return "?" }  // Unknown type structure
  if t.kind == "TypeVar" { return "v" + str(t.id) }
  if t.kind == "Nil" or t.kind == "Number" or t.kind == "Bool" or t.kind == "String" or
     t.kind == "Any" or t.kind == "Bottom" {
    return t.kind
  }
  if t.kind == "Option" { return "O(" + typeKey(t.value) + ")" }
  if t.kind == "Union" {
    let keys = collect opt in (t.options or []) { typeKey(opt) }
    keys = sort(keys, stringLess)
    return "U(" + join(keys, ",") + ")"
  }
  if t.kind == "Intersect" {
    let keys = collect part in (t.parts or []) { typeKey(part) }
    keys = sort(keys, stringLess)
    return "I(" + join(keys, ",") + ")"
  }
  if t.kind == "Not" { return "N(" + typeKey(t.value) + ")" }
  if t.kind == "Tag" {
    let id = t.enumId != nil and ("#" + str(t.enumId)) or ""
    let nm = t.enumName != nil and t.enumName or "?"
    return "Tag(" + id + nm + "." + (t.memberName or "?") + ")"
  }
  if t.kind == "Array" { return "A(" + typeKey(t.elem) + ")" }
  if t.kind == "Map" { return "M(" + typeKey(t.key) + "," + typeKey(t.elem) + ")" }
  if t.kind == "Indexable" { return "Ix(" + typeKey(t.key) + "," + typeKey(t.elem) + ")" }
  if t.kind == "Function" {
    let paramKeys = collect p in (t.params or []) { typeKey(p) }
    return "F(" + join(paramKeys, ",") + ")->" + typeKey(t.return)
  }
  if t.kind == "Record" {
    let fields = t.fields
    // Defensive check - ensure fields is a hashmap
    if !fields or type(fields) != "map" {
      return "R{}"
    }
    // Sort keys for consistent caching - reduces cache misses for equivalent types
    // Use keyLess comparator to handle mixed string/number keys
    let fieldKeys = sort(keys(fields), keyLess)
    let fieldStrings = []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      push(fieldStrings, str(k) + ":" + typeKey(fields[k]))
    }
    return "R{" + join(fieldStrings, ",") + "}"
  }
  if t.kind == "Enum" {
    // Encode enum fields for proper caching - different enums have different fields
    // Sort keys for consistent caching
    let fields = t.fields
    if !fields or type(fields) != "map" {
      return "E{}"
    }
    let fieldKeys = sort(keys(fields), keyLess)
    let fieldStrings = []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      push(fieldStrings, str(k))
    }
    return "E{" + join(fieldStrings, ",") + "}"
  }
  t.kind
}

fn expandOption(t) {
  if t and t.kind == "Option" {
    return typeUnion([t.value, typeNil()])
  }
  t
}

fn literalKey(lit) {
  (lit.negated and "~" or "") + typeKey(lit.atom)
}

fn atomSubtype(checker, lhs, rhs) {
  lhs = deref(checker, lhs)
  rhs = deref(checker, rhs)
  if lhs == rhs { return true }

  if lhs.kind == "Any" or rhs.kind == "Any" { return true }
  if lhs.kind == "Bottom" { return true }
  if lhs.kind == "TypeVar" or rhs.kind == "TypeVar" { return false }

  if lhs.kind == "Option" or rhs.kind == "Option" {
    return isSubtype(checker, expandOption(lhs), expandOption(rhs))
  }

  if isPrimitive(lhs) and isPrimitive(rhs) {
    return lhs.kind == rhs.kind
  }

  if lhs.kind == "Tag" {
    if rhs.kind == "Number" { return true }
    if rhs.kind == "Tag" {
      if lhs.enumId != nil or rhs.enumId != nil {
        return lhs.enumId == rhs.enumId and lhs.memberName == rhs.memberName
      }
      return lhs.enumName == rhs.enumName and lhs.memberName == rhs.memberName
    }
    return false
  }

  if lhs.kind == "Function" and rhs.kind == "Function" {
    let lhsParams = lhs.params or []
    let rhsParams = rhs.params or []
    let lhsLen = len(lhsParams)
    let rhsLen = len(rhsParams)
    if lhsLen != rhsLen { return false }
    let lhsMin = lhs.minArity != nil and lhs.minArity or lhsLen
    let rhsMin = rhs.minArity != nil and rhs.minArity or rhsLen
    if lhsMin > rhsMin { return false }
    for let i = 0; i < lhsLen; i = i + 1 {
      if !isSubtype(checker, rhsParams[i], lhsParams[i]) { return false }
    }
    return isSubtype(checker, lhs.return, rhs.return)
  }

  if lhs.kind == "Record" and rhs.kind == "Record" {
    let lhsFields = lhs.fields or .{}
    let rhsFields = rhs.fields or .{}
    for k in keys(rhsFields) {
      let lhsField = lhsFields[k]
      if !lhsField { return false }
      if !isSubtype(checker, lhsField, rhsFields[k]) { return false }
    }
    return true
  }

  if lhs.kind == "Array" and rhs.kind == "Array" {
    return isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Map" and rhs.kind == "Map" {
    return isSubtype(checker, lhs.key, rhs.key) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Indexable" {
    return isSubtype(checker, lhs.key, rhs.key) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Array" and rhs.kind == "Indexable" {
    return isSubtype(checker, typeNumber(), rhs.key) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Map" and rhs.kind == "Indexable" {
    return isSubtype(checker, lhs.key, rhs.key) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Array" {
    return isSubtype(checker, lhs.key, typeNumber()) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Map" {
    return isSubtype(checker, lhs.key, rhs.key) and
           isSubtype(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Record" and rhs.kind == "Map" {
    let lhsFields = lhs.fields or .{}
    if len(keys(lhsFields)) == 0 {
      return true
    }
  }

  if lhs.kind == "Enum" and rhs.kind == "Enum" {
    let lhsFields = lhs.fields or .{}
    let rhsFields = rhs.fields or .{}
    for k in keys(rhsFields) {
      if lhsFields[k] == nil { return false }
    }
    return true
  }

  false
}

fn atomsDisjoint(checker, a, b) {
  a = deref(checker, a)
  b = deref(checker, b)

  if a.kind == "Bottom" or b.kind == "Bottom" { return true }
  if a.kind == "Any" or b.kind == "Any" { return false }
  if a.kind == "TypeVar" or b.kind == "TypeVar" { return false }

  if isPrimitive(a) and isPrimitive(b) and a.kind != b.kind { return true }

  if a.kind == "Tag" and b.kind == "Tag" {
    if a.enumId != nil or b.enumId != nil {
      return a.enumId != b.enumId or a.memberName != b.memberName
    }
    return a.enumName != b.enumName or a.memberName != b.memberName
  }
  if a.kind == "Tag" and b.kind != "Number" and b.kind != "Any" { return true }
  if b.kind == "Tag" and a.kind != "Number" and a.kind != "Any" { return true }

  if a.kind == "Array" and b.kind != "Array" and b.kind != "Indexable" { return true }
  if b.kind == "Array" and a.kind != "Array" and a.kind != "Indexable" { return true }

  if a.kind == "Function" and b.kind != "Function" { return true }
  if b.kind == "Function" and a.kind != "Function" { return true }

  if a.kind == "Enum" and b.kind != "Enum" { return true }
  if b.kind == "Enum" and a.kind != "Enum" { return true }

  if a.kind == "Record" and b.kind == "Record" {
    let af = a.fields or .{}
    let bf = b.fields or .{}
    for k in keys(af) {
      if bf[k] {
        let ad = deref(checker, af[k])
        let bd = deref(checker, bf[k])
        if isPrimitive(ad) and isPrimitive(bd) and ad.kind != bd.kind {
          return true
        }
        if ad.kind == "Tag" and bd.kind == "Tag" {
          if atomsDisjoint(checker, ad, bd) { return true }
        }
      }
    }
  }

  false
}

fn simplifyClause(checker, clause) {
  let positives = []
  let negatives = []
  let seen = .{}

  for lit in (clause or []) {
    let key = literalKey(lit)
    if seen[key] { continue }
    seen[key] = true
    if lit.negated {
      push(negatives, lit)
    } else {
      push(positives, lit)
    }
  }

  for p in positives {
    for n in negatives {
      if atomSubtype(checker, p.atom, n.atom) { return nil }
    }
  }

  for let i = 0; i < len(positives); i = i + 1 {
    for let j = i + 1; j < len(positives); j = j + 1 {
      if atomsDisjoint(checker, positives[i].atom, positives[j].atom) { return nil }
    }
  }

  let out = []
  for p in positives { push(out, .{ atom: p.atom, negated: false }) }
  for n in negatives { push(out, .{ atom: n.atom, negated: true }) }
  out
}

fn dnfUnion(a, b) {
  let out = []
  for c in (a or []) { push(out, c) }
  for c in (b or []) { push(out, c) }
  out
}

fn dnfIntersect(a, b) {
  let out = []
  if type(a) != "array" or type(b) != "array" {
    Lx.stderr.println("dnfIntersect non-array inputs:", type(a), type(b))
    return out
  }
  for ca in a {
    for cb in b {
      if type(ca) != "array" or type(cb) != "array" {
        Lx.stderr.println("dnfIntersect clause non-array:", type(ca), type(cb))
        continue
      }
      let clause = []
      for lit in ca { push(clause, lit) }
      for lit in cb { push(clause, lit) }
      push(out, clause)
    }
  }
  out
}

fn toDNF(checker, t) {
  t = expandOption(t)
  if !t { return [] }
  let tType = type(t)
  if tType != "map" {
    Lx.stderr.println("toDNF non-map:", tType, str(t))
    return [ [ .{ atom: typeAny(), negated: false } ] ]
  }
  let kind = t.kind
  if !kind {
    Lx.stderr.println("toDNF missing kind:", str(t))
    return [ [ .{ atom: typeAny(), negated: false } ] ]
  }
  Lx.stderr.println("toDNF kind:", kind)
  if kind == "Any" { return [ [] ] }
  if kind == "Bottom" { return [] }

  if kind != "Union" and kind != "Intersect" and kind != "Not" {
    return [ [ .{ atom: t, negated: false } ] ]
  }

  if kind == "Union" {
    let opts = t.options or []
    if type(opts) != "array" {
      Lx.stderr.println("toDNF Union options non-array:", type(opts), str(opts))
      return [ [ .{ atom: t, negated: false } ] ]
    }
    let out = []
    for opt in opts {
      out = dnfUnion(out, toDNF(checker, opt))
    }
    return out
  }

  if kind == "Intersect" {
    let parts = t.parts or []
    if type(parts) != "array" {
      Lx.stderr.println("toDNF Intersect parts non-array:", type(parts), str(parts))
      return [ [ .{ atom: t, negated: false } ] ]
    }
    let out = [ [] ]
    for part in parts {
      out = dnfIntersect(out, toDNF(checker, part))
    }
    return out
  }

  if kind == "Not" {
    let v = t.value
    if type(v) != "map" {
      Lx.stderr.println("toDNF Not non-map:", type(v), str(v))
      return [ [ .{ atom: typeAny(), negated: false } ] ]
    }
    if !v.kind {
      Lx.stderr.println("toDNF Not missing kind:", str(v))
      return [ [ .{ atom: typeAny(), negated: false } ] ]
    }
    return toDNFNot(checker, v)
  }

  [ [ .{ atom: t, negated: false } ] ]
}

fn toDNFNot(checker, t) {
  t = expandOption(t)
  if !t { return [] }
  let tType = type(t)
  if tType != "map" {
    Lx.stderr.println("toDNFNot non-map:", tType, str(t))
    return []
  }
  if !t.kind {
    Lx.stderr.println("toDNFNot missing kind:", str(t))
    return []
  }
  Lx.stderr.println("toDNFNot kind:", t.kind)
  if t.kind == "Any" { return [] }
  if t.kind == "Bottom" { return [ [] ] }

  if t.kind == "Not" { return toDNF(checker, t.value) }

  if t.kind == "Union" or t.kind == "Intersect" {
    return [ [ .{ atom: t, negated: true } ] ]
  }

  if t.kind == "Union" {
    let opts = t.options or []
    if type(opts) != "array" {
      Lx.stderr.println("toDNFNot Union options non-array:", type(opts), str(opts))
      return [ [ .{ atom: t, negated: true } ] ]
    }
    for opt in opts {
      let od = deref(checker, opt)
      if od and od.kind == "TypeVar" {
        return [ [ .{ atom: t, negated: true } ] ]
      }
    }
    let out = [ [] ]
    for opt in opts {
      Lx.stderr.println("toDNFNot Union opt type:", type(opt))
      out = dnfIntersect(out, toDNFNot(checker, opt))
    }
    return out
  }

  if t.kind == "Intersect" {
    let parts = t.parts
    Lx.stderr.println("toDNFNot Intersect parts type:", type(parts))
    if !parts { parts = [] }
    if type(parts) != "array" {
      Lx.stderr.println("toDNFNot Intersect parts non-array:", type(parts), str(parts))
      return [ [ .{ atom: t, negated: true } ] ]
    }
    let out = []
    for part in parts {
      out = dnfUnion(out, toDNFNot(checker, part))
    }
    return out
  }

  [ [ .{ atom: t, negated: true } ] ]
}

fn normalizeDNF(checker, dnf) {
  let out = []
  let seen = .{}
  for clause in (dnf or []) {
    let simplified = simplifyClause(checker, clause)
    if !simplified { continue }
    if len(simplified) == 0 {
      return [ [] ]
    }
    let keys = collect lit in simplified { literalKey(lit) }
    keys = sort(keys, stringLess)
    let key = join(keys, "&")
    if seen[key] { continue }
    seen[key] = true
    push(out, simplified)
  }
  out
}

fn dnfToType(dnf) {
  if !dnf or len(dnf) == 0 { return typeBottom() }
  for clause in dnf {
    if len(clause) == 0 { return typeAny() }
  }
  let clauses = []
  for clause in dnf {
    let parts = []
    for lit in clause {
      if lit.negated {
        push(parts, typeNot(lit.atom))
      } else {
        push(parts, lit.atom)
      }
    }
    push(clauses, typeIntersect(parts))
  }
  typeUnion(clauses)
}

fn normalizeType(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Option" {
    let v = normalizeType(checker, t.value)
    if v and v.kind == "Nil" { return typeNil() }
    return typeOption(v)
  }

  if t.kind == "Union" {
    let opts = collect opt in (t.options or []) { normalizeType(checker, opt) }
    return typeUnion(opts)
  }

  if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { normalizeType(checker, part) }
    return typeIntersect(parts)
  }

  if t.kind == "Not" {
    let v = normalizeType(checker, t.value)
    if v and v.kind == "Any" { return typeBottom() }
    if v and v.kind == "Bottom" { return typeAny() }
    return typeNot(v)
  }

  t
}

fn subtypeCacheKey(lhs, rhs) {
  typeKey(lhs) + "<=" + typeKey(rhs)
}

fn isSubtype(checker, lhs, rhs) {
  lhs = deref(checker, lhs)
  rhs = deref(checker, rhs)

  if lhs == rhs { return true }
  if lhs.kind == "Bottom" { return true }
  if rhs.kind == "Any" or lhs.kind == "Any" { return true }

  let cacheKey = subtypeCacheKey(lhs, rhs)
  checker.subtypeCache = checker.subtypeCache or .{}
  let cached = checker.subtypeCache[cacheKey]
  if cached != nil {
    if cached == "visiting" { return true }
    return cached
  }
  checker.subtypeCache[cacheKey] = "visiting"

  if lhs.kind == "Option" or rhs.kind == "Option" {
    let result = isSubtype(checker, expandOption(lhs), expandOption(rhs))
    checker.subtypeCache[cacheKey] = result
    return result
  }

  if rhs.kind == "Union" {
    for opt in (rhs.options or []) {
      if isSubtype(checker, lhs, opt) {
        checker.subtypeCache[cacheKey] = true
        return true
      }
    }
    checker.subtypeCache[cacheKey] = false
    return false
  }

  if lhs.kind == "Union" {
    for opt in (lhs.options or []) {
      if !isSubtype(checker, opt, rhs) {
        checker.subtypeCache[cacheKey] = false
        return false
      }
    }
    checker.subtypeCache[cacheKey] = true
    return true
  }

  if rhs.kind == "Intersect" {
    for part in (rhs.parts or []) {
      if !isSubtype(checker, lhs, part) {
        checker.subtypeCache[cacheKey] = false
        return false
      }
    }
    checker.subtypeCache[cacheKey] = true
    return true
  }

  if lhs.kind == "Intersect" {
    for part in (lhs.parts or []) {
      if !isSubtype(checker, part, rhs) {
        checker.subtypeCache[cacheKey] = false
        return false
      }
    }
    checker.subtypeCache[cacheKey] = true
    return true
  }

  if lhs.kind == "Not" {
    if rhs.kind == "Not" and typeEquals(lhs, rhs) {
      checker.subtypeCache[cacheKey] = true
      return true
    }
    checker.subtypeCache[cacheKey] = false
    return false
  }

  if rhs.kind == "Not" {
    let result = atomsDisjoint(checker, lhs, rhs.value)
    checker.subtypeCache[cacheKey] = result
    return result
  }

  let result = atomSubtype(checker, lhs, rhs)
  checker.subtypeCache[cacheKey] = result
  result
}

fn typeHasNilEvidence(checker, t) {
  t = deref(checker, t)
  if !t { return false }
  if t.kind == "Nil" { return true }
  if t.kind == "Option" { return true }
  if t.kind == "TypeVar" {
    let lbs = t.lowerBounds or []
    if len(lbs) == 0 { return false }
    for lb in lbs {
      if typeHasNilEvidence(checker, lb) { return true }
    }
    return false
  }
  if t.kind == "Union" {
    let opts = t.options or []
    if type(opts) != "array" { return false }
    for opt in opts {
      if typeHasNilEvidence(checker, opt) { return true }
    }
    return false
  }
  if t.kind == "Intersect" {
    let parts = t.parts or []
    if type(parts) != "array" { return false }
    for part in parts {
      if !typeHasNilEvidence(checker, part) { return false }
    }
    return true
  }
  if t.kind == "Not" {
    return false
  }
  false
}

fn typeMayAllowNil(checker, t) {
  t = deref(checker, t)
  if !t { return false }
  if typeHasNilEvidence(checker, t) { return true }
  if t.kind == "TypeVar" {
    let lbs = t.lowerBounds or []
    return len(lbs) == 0
  }
  if t.kind == "Union" {
    let opts = t.options or []
    if type(opts) != "array" { return false }
    for opt in opts {
      if typeMayAllowNil(checker, opt) { return true }
    }
    return false
  }
  if t.kind == "Intersect" {
    let parts = t.parts or []
    if type(parts) != "array" { return false }
    for part in parts {
      if !typeMayAllowNil(checker, part) { return false }
    }
    return true
  }
  false
}

// Generate a cache key for a constraint pair
// Cache all constraint pairs to prevent exponential re-checking
fn constraintCacheKey(lhs, rhs) {
  typeKey(lhs) + "<:" + typeKey(rhs)
}

// Core constraint function: enforce lhs <: rhs
// Returns true if constraint succeeded, false if it failed
fn constrain(checker, lhs, rhs) {
  lhs = deref(checker, lhs)
  rhs = deref(checker, rhs)

  if type(lhs) != "map" {
    Lx.stderr.println("constrain lhs non-map:", type(lhs), str(lhs))
    return false
  }
  if type(rhs) != "map" {
    Lx.stderr.println("constrain rhs non-map:", type(rhs), str(rhs))
    return false
  }

  if lhs == rhs { return true }
  if lhs.kind == "TypeVar" and rhs.kind == "TypeVar" and lhs.id == rhs.id {
    return true
  }

  let cacheKey = constraintCacheKey(lhs, rhs)
  if checker.constraintCache[cacheKey] { return true }
  checker.constraintCache[cacheKey] = true

  if lhs.kind == "Bottom" { return true }
  if lhs.kind == "Any" {
    if rhs.kind == "TypeVar" {
      push(rhs.lowerBounds, lhs)
      checker.constraintRevision = checker.constraintRevision + 1
    }
    return true
  }
  if rhs.kind == "Any" { return true }

  // Swapping: T <: U ∪ α  =>  T ∩ ¬U <: α
  if rhs.kind == "Union" {
    let rest = []
    let tv = nil
    for part in (rhs.options or []) {
      let pd = deref(checker, part)
      if !tv and pd.kind == "TypeVar" {
        tv = pd
      } else {
        push(rest, part)
      }
    }
    if tv {
      if len(rest) == 0 { return constrain(checker, lhs, tv) }
      let restUnion = typeUnion(rest)
      return constrain(checker, typeIntersect([lhs, typeNot(restUnion)]), tv)
    }
  }

  // Swapping: α ∩ T <: U  =>  α <: U ∪ ¬T
  if lhs.kind == "Intersect" {
    let rest = []
    let tv = nil
    for part in (lhs.parts or []) {
      let pd = deref(checker, part)
      if !tv and pd.kind == "TypeVar" {
        tv = pd
      } else {
        push(rest, part)
      }
    }
    if tv {
      if len(rest) == 0 { return constrain(checker, tv, rhs) }
      let restIntersect = typeIntersect(rest)
      return constrain(checker, tv, typeUnion([rhs, typeNot(restIntersect)]))
    }
  }

  if lhs.kind == "TypeVar" {
    if occurs(checker, lhs.id, rhs) { return false }
    let bound = normalizeType(checker, rhs)
    push(lhs.upperBounds, bound)
    checker.constraintRevision = checker.constraintRevision + 1
    for lb in lhs.lowerBounds {
      if !constrain(checker, lb, bound) { return false }
    }
    return true
  }

  if rhs.kind == "TypeVar" {
    if occurs(checker, rhs.id, lhs) { return false }
    let bound = normalizeType(checker, lhs)
    if rhs.fieldInvariant {
      for lb in (rhs.lowerBounds or []) {
        let dlb = deref(checker, lb)
        let dbound = deref(checker, bound)
        if dlb.kind == "Nil" or dbound.kind == "Nil" { continue }
        if isSubtype(checker, dbound, dlb) or isSubtype(checker, dlb, dbound) {
          continue
        }
        return false
      }
    }
    push(rhs.lowerBounds, bound)
    checker.constraintRevision = checker.constraintRevision + 1
    for ub in rhs.upperBounds {
      if !constrain(checker, bound, ub) { return false }
    }
    if rhs.narrowedTo and lhs.kind != "Nil" {
      for narrowedTV in rhs.narrowedTo {
        if !constrain(checker, bound, narrowedTV) { return false }
      }
    }
    return true
  }

  if lhs.kind == "Option" and rhs.kind == "Option" {
    return constrain(checker, lhs.value, rhs.value)
  }

  if lhs.kind == "Function" and rhs.kind == "Function" {
    let lhsParams = lhs.params or []
    let rhsParams = rhs.params or []
    let lhsLen = len(lhsParams)
    let rhsLen = len(rhsParams)
    if lhsLen != rhsLen { return false }
    let lhsMin = lhs.minArity != nil and lhs.minArity or lhsLen
    let rhsMin = rhs.minArity != nil and rhs.minArity or rhsLen
    if lhsMin > rhsMin { return false }
    for let i = 0; i < lhsLen; i = i + 1 {
      if !constrain(checker, rhsParams[i], lhsParams[i]) { return false }
    }
    return constrain(checker, lhs.return, rhs.return)
  }

  if lhs.kind == "Record" and rhs.kind == "Record" {
    let lhsFields = lhs.fields or .{}
    let rhsFields = rhs.fields or .{}
    for k in keys(rhsFields) {
      let lhsField = lhsFields[k]
      if !lhsField { return false }
      if !constrain(checker, lhsField, rhsFields[k]) { return false }
    }
    return true
  }

  if lhs.kind == "Array" and rhs.kind == "Array" {
    return constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Map" and rhs.kind == "Map" {
    return constrain(checker, lhs.key, rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Indexable" {
    return constrain(checker, lhs.key, rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Array" and rhs.kind == "Indexable" {
    return constrain(checker, typeNumber(), rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Map" and rhs.kind == "Indexable" {
    return constrain(checker, lhs.key, rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Array" {
    return constrain(checker, lhs.key, typeNumber()) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Indexable" and rhs.kind == "Map" {
    return constrain(checker, lhs.key, rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  if lhs.kind == "Record" and rhs.kind == "Map" {
    let lhsFields = lhs.fields or .{}
    if len(keys(lhsFields)) == 0 { return true }
  }

  isSubtype(checker, lhs, rhs)
}

// Coalesce a TypeVar's bounds into a final type
// If Nil appears alongside non-nil lower bounds, produce Option[T]
fn coalesceTypeVar(checker, tv) {
  if !tv or tv.kind != "TypeVar" { return tv }

  let lbs = tv.lowerBounds or []
  let ubs = tv.upperBounds or []

  let hasNil = false
  let nonNilBounds = []

  for lb in lbs {
    let dlb = deref(checker, lb)
    if dlb.kind == "TypeVar" {
      dlb = coalesceTypeVar(checker, dlb)
    }
    dlb = normalizeType(checker, dlb)

    if dlb.kind == "Nil" {
      hasNil = true
      continue
    }

    if dlb.kind == "Union" {
      let others = []
      for opt in (dlb.options or []) {
        let dopt = deref(checker, opt)
        if dopt.kind == "Nil" {
          hasNil = true
        } else {
          push(others, opt)
        }
      }
      if len(others) == 1 {
        push(nonNilBounds, others[0])
      } else if len(others) > 1 {
        push(nonNilBounds, typeUnion(others))
      }
      continue
    }

    if dlb and dlb.kind != "TypeVar" {
      push(nonNilBounds, dlb)
    }
  }

  if len(nonNilBounds) > 0 {
    if len(nonNilBounds) == 1 {
      let lbType = normalizeType(checker, nonNilBounds[0])
      if hasNil { return typeOption(lbType) }
      return lbType
    }
    // Keep as TypeVar when multiple non-nil bounds are present.
    if hasNil { return tv }
    return tv
  }

  if hasNil { return typeNil() }

  if len(ubs) > 0 {
    let ubTypes = collect ub in ubs { normalizeType(checker, ub) }
    return normalizeType(checker, typeIntersect(ubTypes))
  }

  tv
}

// Pretty-print a type for error messages
fn prettyTypeWithStack(checker, t, stack) {
  t = deref(checker, t)
  if !t { return "?" }

  if t.kind == "TypeVar" {
    if stack[t.id] { return "?" + str(t.id) }
    stack[t.id] = true
    let coalesced = coalesceTypeVar(checker, t)
    if coalesced.kind != "TypeVar" {
      let result = prettyTypeWithStack(checker, coalesced, stack)
      stack[t.id] = nil
      return result
    }
    stack[t.id] = nil
    return "?" + str(t.id)
  }

  if t.kind == "Bottom" { return "Bottom" }

  if t.kind == "Tag" {
    let enumName = t.enumName or "?"
    let member = t.memberName or "?"
    return "tag(" + enumName + "." + member + ")"
  }

  if t.kind == "Union" {
    let opts = t.options or []
    let nonNil = []
    let sawNil = false
    for opt in opts {
      let od = deref(checker, opt)
      if od.kind == "Nil" { sawNil = true }
      else { push(nonNil, opt) }
    }
    if sawNil and len(nonNil) == 1 {
      return prettyTypeWithStack(checker, nonNil[0], stack) + "?"
    }
    let parts = collect opt in opts { prettyTypeWithStack(checker, opt, stack) }
    return join(parts, " | ")
  }

  if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { prettyTypeWithStack(checker, part, stack) }
    return join(parts, " & ")
  }

  if t.kind == "Not" {
    return "~" + prettyTypeWithStack(checker, t.value, stack)
  }

  if t.kind == "Option" {
    return prettyTypeWithStack(checker, t.value, stack) + "?"
  }

  if t.kind == "Array" {
    return "Array[" + prettyTypeWithStack(checker, t.elem, stack) + "]"
  }

  if t.kind == "Map" {
    return "Map[" + prettyTypeWithStack(checker, t.key, stack) + ", " +
      prettyTypeWithStack(checker, t.elem, stack) + "]"
  }

  if t.kind == "Function" {
    let params = collect p in (t.params or []) { prettyTypeWithStack(checker, p, stack) }
    return "(" + join(params, ", ") + ") -> " +
      prettyTypeWithStack(checker, t.return, stack)
  }

  if t.kind == "Record" {
    // Sort keys for consistent output
    let sortedKeys = sort(keys(t.fields or .{}), stringLess)
    let fieldStrs = collect k in sortedKeys {
      str(k) + ": " + prettyTypeWithStack(checker, t.fields[k], stack)
    }
    return ".{ " + join(fieldStrs, ", ") + " }"
  }

  if t.kind == "Enum" {
    // Sort keys for consistent output
    let sortedKeys = sort(keys(t.fields or .{}), stringLess)
    let fieldStrs = collect k in sortedKeys { str(k) }
    return "enum { " + join(fieldStrs, ", ") + " }"
  }

  t.kind
}

fn prettyType(checker, t) {
  prettyTypeWithStack(checker, t, .{})
}

// Snapshot-safe pretty printer (checker-independent)
// Used for error messages after constraint failures to avoid printing
// partially-mutated types. Takes a snapshot from derefAll().
fn prettyTypeSnapshotWithStack(t, stack) {
  if !t { return "?" }
  if !t.kind { return "?" }

  if t.kind == "TypeVar" {
    // Cycle guard: don't coalesce, don't consult bounds
    if stack[t.id] { return "?" + str(t.id) }
    stack[t.id] = true
    let out = "?" + str(t.id)
    stack[t.id] = nil
    return out
  }

  if t.kind == "Any" or t.kind == "Nil" or t.kind == "Number" or
     t.kind == "Bool" or t.kind == "String" or t.kind == "Bottom" {
    return t.kind
  }

  if t.kind == "Tag" {
    let enumName = t.enumName or "?"
    let member = t.memberName or "?"
    return "tag(" + enumName + "." + member + ")"
  }

  if t.kind == "Union" {
    let opts = t.options or []
    let nonNil = []
    let sawNil = false
    for opt in opts {
      if opt.kind == "Nil" { sawNil = true }
      else { push(nonNil, opt) }
    }
    if sawNil and len(nonNil) == 1 {
      return prettyTypeSnapshotWithStack(nonNil[0], stack) + "?"
    }
    let parts = collect opt in opts { prettyTypeSnapshotWithStack(opt, stack) }
    return join(parts, " | ")
  }

  if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { prettyTypeSnapshotWithStack(part, stack) }
    return join(parts, " & ")
  }

  if t.kind == "Not" {
    return "~" + prettyTypeSnapshotWithStack(t.value, stack)
  }

  if t.kind == "Option" {
    return prettyTypeSnapshotWithStack(t.value, stack) + "?"
  }

  if t.kind == "Array" {
    return "Array[" + prettyTypeSnapshotWithStack(t.elem, stack) + "]"
  }

  if t.kind == "Map" {
    return "Map[" +
      prettyTypeSnapshotWithStack(t.key, stack) + ", " +
      prettyTypeSnapshotWithStack(t.elem, stack) + "]"
  }

  if t.kind == "Function" {
    let params = collect p in (t.params or []) { prettyTypeSnapshotWithStack(p, stack) }
    return "(" + join(params, ", ") + ") -> " +
      prettyTypeSnapshotWithStack(t.return, stack)
  }

  if t.kind == "Record" {
    // Sort keys for consistent output - use keyLess for mixed string/number keys
    let ks = sort(keys(t.fields or .{}), keyLess)
    let fieldStrs = collect k in ks {
      str(k) + ": " + prettyTypeSnapshotWithStack(t.fields[k], stack)
    }
    return ".{ " + join(fieldStrs, ", ") + " }"
  }

  if t.kind == "Enum" {
    let ks = sort(keys(t.fields or .{}), keyLess)
    let fieldStrs = collect k in ks { str(k) }
    return "enum { " + join(fieldStrs, ", ") + " }"
  }

  if t.kind == "Indexable" {
    let keyT = prettyTypeSnapshotWithStack(t.key, stack)
    let elemT = prettyTypeSnapshotWithStack(t.elem, stack)
    return "Indexable[" + keyT + ", " + elemT + "]"
  }

  // Fallback
  t.kind
}

fn prettyTypeSnapshot(t) {
  prettyTypeSnapshotWithStack(t, .{})
}

// ========================================================
// Builtin Type Signatures
// ========================================================
// Comprehensive catalog of stdlib function types.
// Note: Some builtins (push, pop, concat, reverse, slice, each, fold, take, drop, sort, _1, _2)
// use freshTypeVar and thus require a checker context with nextTypeVarId.

let BUILTIN_TYPES = .{
  // Basic I/O (variadic-ish): model as 0-arg fn returning Nil
  print: typeFunction([], typeNil()),
  println: typeFunction([], typeNil()),

  // String operations
  str: typeFunction([typeAny()], typeString()),
  join: typeFunction([typeArray(typeAny()), typeString()], typeString()),
  split: typeFunction([typeString(), typeString()], typeArray(typeString())),
  substr: typeFunction([typeString(), typeNumber()], typeString()),
  startsWith: typeFunction([typeString(), typeString()], typeBool()),
  endsWith: typeFunction([typeString(), typeString()], typeBool()),
  stringLess: typeFunction([typeOption(typeString()), typeOption(typeString())], typeBool()),
  contains: typeFunction([typeAny(), typeAny()], typeBool()),
  tolower: typeFunction([typeString()], typeString()),
  toupper: typeFunction([typeString()], typeString()),
  tonumber: typeFunction([typeString()], typeNumber()),
  chr: typeFunction([typeNumber()], typeString()),
  ord: typeFunction([typeString()], typeNumber()),

  // Reflection
  type: typeFunction([typeAny()], typeString()),
  nameOf: .{ kind: "Function", params: [typeAny(), typeAny()], return: typeOption(typeString()), builtinName: "nameOf" },

  // Collections (special handling at call sites)
  len: .{ kind: "Function", params: [typeAny()], return: typeNumber(), builtinName: "len" },
  range: .{ kind: "Function", params: [typeAny()], return: typeArray(typeAny()), builtinName: "range" },
  keys: .{ kind: "Function", params: [typeAny()], return: typeArray(typeAny()), builtinName: "keys" },

  // Namespaced builtins
  Math: typeRecord(.{
    floor: typeFunction([typeNumber()], typeNumber()),
    sqrt: typeFunction([typeNumber()], typeNumber()),
    random: typeFunction([], typeNumber()),
    max: typeFunction([], typeNumber()),  // variadic
    min: typeFunction([], typeNumber()),  // variadic
  }),

  Date: typeRecord(.{
    RFC3339: typeString(),
    now: typeFunction([], typeNumber()),
    nanotime: typeFunction([], typeNumber()),
    format: typeFunction([typeNumber()], typeString()),
    parse: typeFunction([typeString(), typeString()], typeNumber()),
  }),

  Fiber: typeRecord(.{
    create: typeFunction([typeAny()], typeAny()),  // fn -> fiber
    resume: typeFunction([typeAny()], typeRecord(.{
      tag: typeString(),
      value: typeAny(),
      error: typeAny(),
    })),
    yield: typeFunction([typeAny()], typeAny()),
    status: typeFunction([typeAny()], typeString()),
    current: typeFunction([], typeAny()),
  }),

  Lx: typeRecord(.{
    args: typeArray(typeString()),
    env: typeMap(typeString(), typeString()),
    version: typeString(),
    globals: typeFunction([], typeArray(typeAny())),
    doubleToUint8Array: typeFunction([typeNumber()], typeArray(typeNumber())),
    isLxObj: typeFunction([typeAny()], typeBool()),
    loadObj: typeFunction([typeAny()], typeAny()),
    pcall: typeFunction([typeAny()], typeRecord(.{
      ok: typeBool(),
      value: typeAny(),
      error: typeAny(),
    })),
    error: typeFunction([typeAny()], typeNil()),
    sleep: typeFunction([typeNumber()], typeNil()),
    fs: typeRecord(.{
      cwd: typeFunction([], typeString()),
      exists: typeFunction([typeString()], typeBool()),
      stat: typeFunction([typeString()], typeOption(typeAny())),
      realpath: typeFunction([typeString()], typeOption(typeString())),
      readFile: typeFunction([typeString()], typeString()),
      writeFile: typeFunction([typeString(), typeString()], typeBool()),
    }),
    path: typeRecord(.{
      join: typeFunction([], typeString()),
      dirname: typeFunction([typeString()], typeString()),
      basename: typeFunction([typeString()], typeString()),
    }),
    stdout: typeRecord(.{
      flush: typeFunction([], typeNil()),
      isTTY: typeFunction([], typeBool()),
      putc: typeFunction([], typeNil()),
    }),
    stderr: typeRecord(.{
      print: typeFunction([], typeNil()),
      println: typeFunction([], typeNil()),
      flush: typeFunction([], typeNil()),
      isTTY: typeFunction([], typeBool()),
    }),
    stdin: typeRecord(.{
      readAll: typeFunction([], typeString()),
      readLine: typeFunction([], typeOption(typeString())),
      readBytes: typeFunction([typeNumber()], typeOption(typeString())),
      readFd: typeFunction([typeNumber()], typeOption(typeString())),
      poll: typeFunction([typeNumber()], typeBool()),
      unbuffered: typeFunction([], typeNil()),
    }),
    term: typeRecord(.{
      getSize: typeFunction([], typeRecord(.{
        rows: typeNumber(),
        cols: typeNumber(),
      })),
      enterRawMode: typeFunction([], typeNil()),
      exitRawMode: typeFunction([], typeNil()),
    }),
    proc: typeRecord(.{
      system: typeFunction([typeString()], typeNumber()),
      exec: typeFunction([typeString()], typeRecord(.{
        code: typeNumber(),
        out: typeString(),
      })),
    }),
    zlib: typeRecord(.{
      deflate: typeFunction([typeArray(typeNumber())], typeArray(typeNumber())),
      inflate: typeFunction([typeArray(typeNumber())], typeArray(typeNumber())),
      crc32: typeFunction([typeAny()], typeNumber()),
    }),
    exit: typeFunction([], typeNil()),
  }),

  // Prelude builtins (from globals.lx)
  first: typeFunction([typeAny()], typeAny()),
  last: typeFunction([typeAny()], typeAny()),
}

let PARAMETRIC_BUILTIN_TYPES = .{
  // Array operations
  push: fn(checker) {
    let elem = freshTypeVar(checker)
    let arr = typeArray(elem)
    typeFunction([arr, elem], arr)
  },
  pop: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem)], typeOption(elem))
  },
  concat: fn(checker) {
    let elem = freshTypeVar(checker)
    let arr = typeArray(elem)
    typeFunction([arr, arr], arr)
  },
  reverse: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem)], typeArray(elem))
  },
  slice: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem), typeNumber()], typeArray(elem))
  },

  // Prelude collection helpers
  each: fn(checker) {
    let t = freshTypeVar(checker)
    let abort = typeFunction([], typeNil())
    let cb = typeFunction([t, typeNumber(), typeArray(t), abort], typeAny())
    typeFunction([typeArray(t), cb], typeNil())
  },
  fold: fn(checker) {
    let t = freshTypeVar(checker)
    let acc = freshTypeVar(checker)
    let abort = typeFunction([], typeNil())
    let cb = typeFunction([acc, t, typeNumber(), abort], acc)
    typeFunction([typeArray(t), acc, cb], acc)
  },
  take: fn(checker) {
    let t = freshTypeVar(checker)
    typeFunction([typeArray(t), typeNumber()], typeArray(t))
  },
  drop: fn(checker) {
    let t = freshTypeVar(checker)
    typeFunction([typeArray(t), typeNumber()], typeArray(t))
  },
  sort: fn(checker) {
    let t = freshTypeVar(checker)
    let cmp = typeFunction([t, t], typeBool())
    typeFunction([typeArray(t), cmp], typeArray(t))
  },
}

fn builtinTypeByName(checker, name) {
  // Check static table first (O(1) lookup)
  if let staticType = BUILTIN_TYPES[name] {
    return staticType
  }

  // Check parametric table (O(1) lookup + function call)
  if let parametricFn = PARAMETRIC_BUILTIN_TYPES[name] {
    return parametricFn(checker)
  }

  nil
}

// ========================================================
// Worklist Solver
// ========================================================
// Repeatedly scans `items`, removing the ones `trySolve(item)` can solve.
// Returns the remaining (unsolved) items once no progress is made.
fn solveWorklist(items, trySolve, opts = .{}) {
  let maxRounds = opts.maxRounds or 1000
  let progress = opts.progress
  let resetProgress = opts.resetProgress

  let round = 0 // number of completed rounds
  let remaining = items or []
  let hitMaxRounds = false

  for round < maxRounds {
    if len(remaining) == 0 { break }
    round = round + 1

    if resetProgress { resetProgress() }

    let work = remaining
    remaining = []
    let solved = 0

    for item in work {
      if trySolve(item) {
        solved = solved + 1
      } else {
        push(remaining, item)
      }
    }

    let didProgress = progress and progress() or solved > 0
    if !didProgress { break }
  }

  if round == maxRounds and len(remaining) > 0 {
    hitMaxRounds = true
    if opts.onMaxRounds {
      opts.onMaxRounds(.{ rounds: round, remaining: remaining })
    }
  }

  .{
    remaining: remaining,
    rounds: round,
    hitMaxRounds: hitMaxRounds,
  }
}

// ========================================================
// Range/Keys deferred refinement
// ========================================================

// Determine key type for a Record: String, Number, or Any if mixed
fn recordKeyType(record) {
  let fieldKeys = keys(record.fields or .{})
  if len(fieldKeys) == 0 { return typeAny() }

  let sawString = false
  let sawNumber = false
  for k in fieldKeys {
    if type(k) == "string" { sawString = true }
    else if type(k) == "number" { sawNumber = true }
    else { return typeAny() }
  }

  if sawString and !sawNumber { return typeString() }
  if sawNumber and !sawString { return typeNumber() }
  typeAny()
}

// Infer element type from a concrete argument type
fn inferFromConcrete(checker, arg, kind) {
  if arg.kind == "Union" {
    let inferred = []
    for opt in (arg.options or []) {
      let item = inferFromConcrete(checker, opt, kind)
      if !item { return nil }
      push(inferred, item)
    }
    return typeUnion(inferred)
  }
  if kind == "range" {
    if arg.kind == "Number" { return typeNumber() }
    if arg.kind == "Array" { return typeNumber() }
    if arg.kind == "String" { return typeString() }
    if arg.kind == "Map" { return arg.key }
    if arg.kind == "Record" { return recordKeyType(arg) }
    if arg.kind == "Indexable" { return arg.key }
    if arg.kind == "Enum" { return typeString() }
  }
  if kind == "keys" {
    if arg.kind == "Map" { return arg.key }
    if arg.kind == "Record" { return recordKeyType(arg) }
    if arg.kind == "Indexable" { return arg.key }
    if arg.kind == "Enum" { return typeString() }
  }
  nil
}

// Infer element type from TypeVar bounds
fn inferFromBounds(checker, tv, kind) {
  // Check upper bounds first (constraints from function body)
  let upperCandidates = tv.upperBounds or []
  for bound in upperCandidates {
    let inferred = inferFromConcrete(checker, deref(checker, bound), kind)
    if inferred { return inferred }
  }
  // Then check lower bounds (constraints from call sites)
  let lowerCandidates = tv.lowerBounds or []
  for bound in lowerCandidates {
    let inferred = inferFromConcrete(checker, deref(checker, bound), kind)
    if inferred { return inferred }
  }
  nil
}

// Solve a single range/keys constraint
fn solveRangeKeys(checker, item) {
  let arg = deref(checker, item.arg)
  let elem = item.elem
  let kind = item.kind


  // If arg is still unknown, try to infer from bounds
  if arg.kind == "TypeVar" {
    let inferred = inferFromBounds(checker, arg, kind)
    if !inferred { return false }
    return constrain(checker, inferred, elem)
  }

  let inferred = inferFromConcrete(checker, arg, kind)
  if !inferred { return false }
  return constrain(checker, inferred, elem)
}

// Solve all deferred builtin constraints
fn solveBuiltinConstraints(checker) {
  let constraints = checker.builtinConstraints or []
  solveWorklist(constraints, fn(item) {
    solveRangeKeys(checker, item)
  })
}

// ========================================================
// Exports
// ========================================================

.{
  // Type constructors
  typeAny,
  typeNil,
  typeNumber,
  typeBool,
  typeString,
  typeBottom,
  typeEnum,
  typeVar,
  typeFunction,
  typeArray,
  typeRecord,
  typeMap,
  typeUnion,
  typeIntersect,
  typeNot,
  typeOption,
  typeIndexable,
  typeTag,

  // Type variable management
  freshTypeVar,
  getTypeVarBinding,
  bindTypeVar,

  // Type utilities
  deref,
  derefWithRootVar,
  typeEquals,
  occurs,
  derefAll,

  // Simple-Sub constraint solving
  isPrimitive,
  isSubtype,
  constrain,
  coalesceTypeVar,
  prettyType,
  prettyTypeSnapshot,
  typeHasNilEvidence,
  typeMayAllowNil,

  // Builtin catalog
  builtinTypeByName,

  // Deferred refinement
  solveBuiltinConstraints,

  // Algorithms
  solveWorklist,
}
