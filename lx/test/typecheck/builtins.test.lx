// Typecheck: builtin functions
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref

  test("typecheck - numeric/string conversion builtins", fn(assert) {
    let result = parseAndTypecheck("{ int(123.456)\ntonumber(\"123.456\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - string builtins", fn(assert) {
    let result = parseAndTypecheck("{ tolower(\"A\")\ntoupper(\"a\")\nlines(\"a\\nb\")\nsplit(\"a,b\", \",\")\njoin([1, 2], \",\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
    let lt = deref(result, getExprType(result, 2))
    assert.equal(lt.kind, "Array")
    assert.equal(deref(result, lt.elem).kind, "String")
    let st = deref(result, getExprType(result, 3))
    assert.equal(st.kind, "Array")
    assert.equal(deref(result, st.elem).kind, "String")
    assert.equal(deref(result, getExprType(result, 4)).kind, "String")
  })

  test("typecheck - array builtins are polymorphic per use", fn(assert) {
    let result = parseAndTypecheck("{ let a = [1]\npush(a, 2)\npop(a)\nconcat([1], [2]) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "Array")
    let popt = deref(result, getExprType(result, 2))
    assert.equal(popt.kind, "Option")
    assert.equal(deref(result, popt.value).kind, "Number")
    let ct = deref(result, getExprType(result, 3))
    assert.equal(ct.kind, "Array")
    assert.equal(deref(result, ct.elem).kind, "Number")
  })

  test("typecheck - Date and Lx builtins typecheck via dot access", fn(assert) {
    let result = parseAndTypecheck("{ Date.RFC3339\nDate.time()\nLx.args\nLx.doubleToUint8Array(1) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    let at = deref(result, getExprType(result, 2))
    assert.equal(at.kind, "Array")
    assert.equal(deref(result, at.elem).kind, "String")
    let bt = deref(result, getExprType(result, 3))
    assert.equal(bt.kind, "Array")
    assert.equal(deref(result, bt.elem).kind, "Number")
  })

  test("typecheck - len works for array and string", fn(assert) {
    let result = parseAndTypecheck("{ len([1, 2])\nlen(\"ab\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - len rejects map", fn(assert) {
    let result = parseAndTypecheck("len(.{})")
    assert.truthy(!result.success)
    // This is a typecheck error even though runtime checks are dynamic.
    assert.truthy(helpers.hasError(result, "len() requires array or string"))
  })

  test("typecheck - len behavior preserved through alias", fn(assert) {
    let ok = parseAndTypecheck("{ let f = len\nf([1, 2]) }")
    assert.truthy(ok.success)
    if !ok.success { return }
    assert.equal(deref(ok, getExprType(ok, 1)).kind, "Number")

    let bad = parseAndTypecheck("{ let f = len\nf(.{}) }")
    assert.truthy(!bad.success)
    assert.truthy(helpers.hasError(bad, "len() requires array or string"))
  })

  test("typecheck - keys works for Map and preserves key type", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{}\nm[\"a\"] = 1\nkeys(m)[0] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 2)).kind, "String")
  })

  test("typecheck - keys works for Record", fn(assert) {
    let result = parseAndTypecheck("keys(.{ a: 1 })[0]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
  })

  test("typecheck - keys on mixed-key Record yields Any keys", fn(assert) {
    let result = parseAndTypecheck("keys(.{ a: 1, [2]: 3 })[0]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Any")
  })

  test("typecheck - keys behavior preserved through alias", fn(assert) {
    let ok = parseAndTypecheck("{ let k = keys\nk(.{ a: 1 })[0] }")
    assert.truthy(ok.success)
    if !ok.success { return }
    assert.equal(deref(ok, getExprType(ok, 1)).kind, "String")
  })

  test("typecheck - globals.lx prelude builtins", fn(assert) {
    let result = parseAndTypecheck("{\n" +
      "  map([1, 2], fn(x, i, arr) { x + i })\n" +
      "  fold([1, 2], 0, fn(acc, x, i, abort) { acc + x + i })\n" +
      "  _2(fn(a, b) { a + b })(1, 2)\n" +
      "  sort([3, 1, 2], fn(a, b) { a < b })\n" +
      "  startsWith(\"abc\", \"a\")\n" +
      "}\n")
    assert.truthy(result.success)
    if !result.success { return }

    let mt = deref(result, getExprType(result, 0))
    assert.equal(mt.kind, "Array")
    assert.equal(deref(result, mt.elem).kind, "Number")

    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")

    let st = deref(result, getExprType(result, 3))
    assert.equal(st.kind, "Array")
    assert.equal(deref(result, st.elem).kind, "Number")

    assert.equal(deref(result, getExprType(result, 4)).kind, "Bool")
  })

  test("typecheck - map preserves element types per use-site", fn(assert) {
    let result = parseAndTypecheck("{\n" +
      "  let n = map([1, 2, 3], fn(x) { x })[0]\n" +
      "  let s = map([\"a\", \"b\"], fn(x) { x })[0]\n" +
      "  n\n" +
      "  s\n" +
      "}\n")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
  })
}

.{ register: register }
