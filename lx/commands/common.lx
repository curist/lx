let driver = import "src/driver.lx"
let codegen = import "src/passes/emit/codegen.lx"
let fastcheck = import "src/passes/analysis/fastcheck.lx"
let peephole = (import "src/passes/opt/peephole-bytecode.lx").peephole
let verify = import "src/passes/verify/verify-bytecode.lx"
let objbuilder = import "src/objbuilder.lx"
let errors = import "src/errors.lx"
let ModuleResolution = import "src/module_resolution.lx"
let OP = (import "src/types.lx").OP

let DEBUG_BUILD = true

fn loadSource(path, sourceOverride, overridePath, resolver) {
  if sourceOverride and path == overridePath { return sourceOverride }
  resolver.slurp(path)
}

fn makeDriverWithSource(sourceOverride, overridePath, entryPath) {
  let resolver = ModuleResolution.forEntry(entryPath)
  driver.make(.{
    withTypecheck: false,
    loadSource: fn(p) { loadSource(p, sourceOverride, overridePath, resolver) },
  })
}

fn compileWithDriver(driverInstance, path) {
  // Compile a module to verified bytecode using the artifact API.
  // This replaces the manual orchestration of fastcheck → codegen → verify.

  // Compile the module (runs pass pipeline)
  let result = driverInstance.compileModule(path)
  if !result or result.status != "done" {
    errors.printErrors(errors.collectErrors(result or .{}), result)
    return nil
  }

  // Print warnings even if compilation succeeded (e.g., nilcheck warnings)
  let allErrors = errors.collectErrors(result)
  if allErrors and len(allErrors) > 0 {
    errors.printErrors(allErrors, result)
  }

  // Use artifact API to build verified bytecode
  // This triggers fastcheck → codegen → verify in dependency order
  let bytecode = driverInstance.buildModule(path, driver.ARTIFACT.BYTECODE_VERIFIED)
  if !bytecode {
    // buildModule returns nil on error; errors are already cached in result
    if result.codegenResult and !result.codegenResult.success {
      errors.printErrors(result.codegenResult.errors, result)
    }
    if result.verifyResult and !result.verifyResult.success {
      errors.printErrors(result.verifyResult.errors, result)
    }
    return nil
  }

  bytecode
}

fn compilePathToFunction(path, sourceOverride) {
  let resolver = ModuleResolution.forEntry(path)
  let d = makeDriverWithSource(sourceOverride, path, path)

  // Convert path to module specifier relative to project root
  let roots = resolver.roots()
  let moduleSpec = path
  if roots and roots.projectRoot {
    let absPath = path
    if len(absPath) > 0 and absPath[0] != "/" {
      absPath = Lx.path.join(Lx.fs.cwd(), absPath)
    }
    let prefix = roots.projectRoot + "/"
    if len(absPath) >= len(prefix) {
      let matches = true
      for let i = 0; i < len(prefix); i = i + 1 {
        if absPath[i] != prefix[i] {
          matches = false
          break
        }
      }
      if matches {
        moduleSpec = ""
        for let i = len(prefix); i < len(absPath); i = i + 1 {
          moduleSpec = moduleSpec + absPath[i]
        }
      }
    }
  }

  compileWithDriver(d, moduleSpec)
}

fn bytesToString(bytes) {
  collect byte in bytes { chr(byte) }->join("")
}

fn slurpUserPath(path, entryPath) {
  // Prefer reading literal filesystem paths when they exist relative to CWD
  // (e.g. `out/foo.lxobj`), otherwise fall back to module resolution (`cmd/...`).
  if Lx.fs.exists(path) {
    return Lx.fs.readFile(path)
  }
  let resolver = ModuleResolution.forEntry(entryPath or path)
  resolver.slurp(path)
}

fn printRuntimeError(err) {
  if !err {
    Lx.stderr.println("Runtime error.")
    return
  }
  if err.message {
    Lx.stderr.println(err.message)
  } else {
    Lx.stderr.println(err)
    return
  }

  let stack = err.stack
  if !stack { return }
  for let i = 0; i < len(stack); i = i + 1 {
    let f = stack[i] or .{}
    let file = f.file or "[unknown]"
    let line = Math.floor(f.line or 0)
    let name = f.name or "script"
    Lx.stderr.println("[" + file + " L" + str(line) + "] in " + name + "()")
  }
}

.{
  DEBUG_BUILD,
  OP,
  ModuleResolution,
  compilePathToFunction,
  compileWithDriver,
  makeDriverWithSource,
  bytesToString,
  slurpUserPath,
  objbuilder,
  printRuntimeError,
}
