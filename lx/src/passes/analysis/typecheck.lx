// Simple-Sub Type Checker for lx
//
// Implements Simple-Sub type inference with:
// - Subtyping constraints via constrain(lhs, rhs) enforcing lhs <: rhs
// - Type variables with mutable bounds (lowerBounds/upperBounds)
// - Functions + Records + Nil/Option support
// - Monomorphic let bindings

let helper = import "src/passes/analysis/typecheck/helpers.lx"
let factsModule = import "src/passes/analysis/typecheck/facts.lx"
let rulesModule = import "src/passes/analysis/typecheck/rules.lx"
let .{ NODE } = import "src/types.lx"

// Import utilities from facts module
let unwrapGroupings = factsModule.unwrapGroupings
let branchAlwaysReturns = factsModule.branchAlwaysReturns
let isNilGuard = factsModule.isNilGuard
let computeFacts = factsModule.computeFacts

// ========================================================
// Type Constructors and Utilities (from helper)
// ========================================================

let typeAny = helper.typeAny
let typeNil = helper.typeNil
let typeNumber = helper.typeNumber
let typeBool = helper.typeBool
let typeString = helper.typeString
let typeArray = helper.typeArray
let typeFunction = helper.typeFunction
let typeRecord = helper.typeRecord
let typeMap = helper.typeMap
let typeEnum = helper.typeEnum
let typeIndexable = helper.typeIndexable
let typeBottom = helper.typeBottom
let typeUnion = helper.typeUnion
let typeIntersect = helper.typeIntersect
let typeNot = helper.typeNot
let typeOption = helper.typeOption
let typeTag = helper.typeTag
let freshTypeVar = helper.freshTypeVar
let deref = helper.deref
let derefAll = helper.derefAll
let getTypeVarBinding = helper.getTypeVarBinding
let constrain = helper.constrain
let typeEquals = helper.typeEquals
let prettyType = helper.prettyType
let prettyTypeSnapshot = helper.prettyTypeSnapshot
let coalesceTypeVar = helper.coalesceTypeVar
let typeHasNilEvidence = helper.typeHasNilEvidence
let isSubtype = helper.isSubtype

// Check if a type is "optionalish" (has Nil evidence or might become optional)
// Narrowing should only happen when the type could be nil
//
// NOTE: We allow narrowing on empty-bounds TypeVars. At function-body time,
// parameters have no bounds yet; call-site evidence (e.g., f(nil)) arrives
// later. The narrowedTo back-link ensures any later non-Nil bounds propagate
// and keep the type sound. This is "might be optional" semantics rather than
// strict "is optional", but it's necessary for single-pass body synthesis.
fn isOptionalish(checker, t) {
  t = deref(checker, t)
  if !t { return false }
  typeHasNilEvidence(checker, t)
}

fn isTagFieldName(fieldName) {
  fieldName == "tag" or fieldName == "kind" or fieldName == "type"
}

fn extractTagTypeFromValue(checker, valueNode) {
  let unwrapped = unwrapGroupings(valueNode)
  if !unwrapped or unwrapped.type != NODE.Dot { return nil }

  let objType = checker.types[unwrapped.object.id]
  if !objType { objType = synthExpr(checker, unwrapped.object) }
  let objD = objType and deref(checker, objType)
  if !objD or objD.kind != "Enum" { return nil }

  let memberName = unwrapped.property.value or unwrapped.property.name
  if !memberName { return nil }
  let memberValue = objD.fields and objD.fields[memberName]
  if memberValue == nil { return nil }

  let enumName = unwrapped.object and unwrapped.object.name
  typeTag(objD.enumId, enumName, memberName, memberValue)
}

fn matchTagGuard(checker, condition) {
  let node = unwrapGroupings(condition)
  if !node or node.type != NODE.Binary { return nil }
  let op = node.operator and node.operator.lexeme or ""
  if op != "==" and op != "!=" { return nil }

  fn matchSide(tagExpr, valueExpr) {
    let tagNode = unwrapGroupings(tagExpr)
    if !tagNode or tagNode.type != NODE.Dot { return nil }

    let fieldName = tagNode.property and (tagNode.property.value or tagNode.property.name)
    if !fieldName or !isTagFieldName(fieldName) { return nil }

    let objNode = unwrapGroupings(tagNode.object)
    if !objNode or objNode.type != NODE.Identifier { return nil }

    let binding = checker.resolvedNames[objNode.id]
    if !binding or !binding.declaredAt { return nil }

    let tagType = extractTagTypeFromValue(checker, valueExpr)
    if !tagType { return nil }

    .{ declId: binding.declaredAt, tagType: tagType }
  }

  let match = matchSide(node.left, node.right)
  if !match { match = matchSide(node.right, node.left) }
  if !match { return nil }

  match.negated = op == "!="
  match
}

// Clone a type tree and freshen TypeVars to avoid cross-module ID collisions.
fn cloneType(checker, t, memo) {
  if !t { return t }

  if t.kind == "TypeVar" {
    let existing = memo[t.id]
    if existing { return existing }
    let fresh = freshTypeVar(checker)
    memo[t.id] = fresh
    let lbs = t.lowerBounds or []
    let ubs = t.upperBounds or []
    fresh.lowerBounds = collect lb in lbs { cloneType(checker, lb, memo) }
    fresh.upperBounds = collect ub in ubs { cloneType(checker, ub, memo) }
    fresh
  } else if t.kind == "Union" {
    let options = collect opt in (t.options or []) { cloneType(checker, opt, memo) }
    typeUnion(options)
  } else if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { cloneType(checker, part, memo) }
    typeIntersect(parts)
  } else if t.kind == "Not" {
    typeNot(cloneType(checker, t.value, memo))
  } else if t.kind == "Option" {
    typeOption(cloneType(checker, t.value, memo))
  } else if t.kind == "Array" {
    typeArray(cloneType(checker, t.elem, memo))
  } else if t.kind == "Map" {
    typeMap(cloneType(checker, t.key, memo), cloneType(checker, t.elem, memo))
  } else if t.kind == "Function" {
    let params = collect p in (t.params or []) { cloneType(checker, p, memo) }
    let ret = cloneType(checker, t.return, memo)
    let fnType = typeFunction(params, ret)
    if t.minArity != nil { fnType.minArity = t.minArity }
    if t.paramNames != nil { fnType.paramNames = t.paramNames }
    if t.builtinName != nil { fnType.builtinName = t.builtinName }
    fnType
  } else if t.kind == "Record" {
    let fields = .{}
    for k in keys(t.fields or .{}) {
      fields[k] = cloneType(checker, t.fields[k], memo)
    }
    typeRecord(fields)
  } else if t.kind == "Enum" {
    let fields = .{}
    for k in keys(t.fields or .{}) { fields[k] = t.fields[k] }
    let out = typeEnum(fields)
    if t.enumId != nil { out.enumId = t.enumId }
    if t.enumName != nil { out.enumName = t.enumName }
    out
  } else if t.kind == "Tag" {
    typeTag(t.enumId, t.enumName, t.memberName, t.value)
  } else if t.kind == "Indexable" {
    let out = typeIndexable(
      cloneType(checker, t.elem, memo),
      cloneType(checker, t.key, memo),
      t.nodeId
    )
    out.sawNumericIndex = t.sawNumericIndex
    out
  } else {
    t
  }
}

fn recordLiteralValues(node) {
  if !node or node.type != NODE.Hashmap { return nil }
  let pairs = node.pairs or []
  let values = .{}
  for pair in pairs {
    let keyNode = unwrapGroupings(pair.key)
    let valueNode = unwrapGroupings(pair.value)
    let key = nil
    if keyNode and keyNode.type == NODE.String {
      key = keyNode.value
    } else if keyNode and keyNode.type == NODE.Number {
      key = keyNode.value
    } else {
      return nil
    }
    if !valueNode { return nil }
    if valueNode.type == NODE.String {
      values[key] = valueNode.value
    } else if valueNode.type == NODE.Number {
      values[key] = valueNode.value
    } else {
      return nil
    }
  }
  values
}

fn recordFromKeysCall(checker, callNode) {
  if !callNode or callNode.type != NODE.Call { return nil }
  let callee = unwrapGroupings(callNode.callee)
  if !callee or callee.type != NODE.Identifier { return nil }
  let binding = checker.resolvedNames[callee.id]
  if !binding or binding.kind != "builtin" or binding.name != "keys" { return nil }
  let args = callNode.args or []
  if len(args) != 1 { return nil }
  let argNode = args[0]
  let argType = checker.types[argNode.id]
  if !argType { argType = synthExpr(checker, argNode) }
  let argD = deref(checker, argType)
  if argD.kind != "Record" { return nil }
  argType
}

fn internIndexElemVar(checker, tvId, keyTag) {
  checker.openIndexElems = checker.openIndexElems or .{}
  let elemMap = checker.openIndexElems[tvId]
  if !elemMap {
    elemMap = .{}
    checker.openIndexElems[tvId] = elemMap
  }
  let elemVar = elemMap[keyTag]
  if !elemVar {
    elemVar = freshTypeVar(checker)
    elemMap[keyTag] = elemVar
  }
  elemVar
}

// ========================================================
// Checker State
// ========================================================

fn makeChecker(resolveResult, opts = .{}) {
  .{
    // === Data from other passes ===
    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,  // Identifier -> binding info
    enumInfo: opts.enumInfo or .{},              // Node ID -> enum metadata
    program: opts.program,                       // Program-level context
    recordValueBindings: .{},                    // declId -> { fieldName: literalValue }
    keysSourceByDeclId: .{},                     // declId -> Record type for keys(...) results
    keyBindingRecord: .{},                       // loop binder declId -> Record type

    // === Result accumulation ===
    types: .{},                                  // Node ID -> inferred type
    errors: [],                                  // Collected errors
    hadError: false,

    // === Type inference state ===
    nextTypeVarId: 1,                            // For generating fresh type vars
    typeVarBindings: .{},                        // For backward compat with deref
    constraintCache: .{},                        // Prevent infinite recursion in constrain
    subtypeCache: .{},                           // Cache for subtype checks
    derefEpoch: 0,                               // Current epoch for deref cycle detection
    derefSeen: .{},                              // TypeVar ID -> epoch (reused across deref calls)
    constraintRevision: 0,                       // Incremented when bounds are added (for coalesce cache)

    // === Environment ===
    env: .{},                                    // declNodeId -> type (for locals/upvalues)
    currentReturn: nil,                          // Current function's return type var
    openRecordFields: .{},                       // TypeVar ID -> { fieldName: Type }
    openIndexElems: .{},                         // TypeVar ID -> { keyTag: Type }

    // === Fiber context (for incremental/cancellable typecheck) ===
    fiberCtx: opts.fiberCtx or nil,              // Optional fiber context for yielding
    nodesProcessed: 0,                           // Counter for progress tracking
    yieldInterval: 50,                           // Yield every N nodes (throttling)

    // facts: will be set after makeChecker() by typecheck()
  }
}

// ========================================================
// Error Reporting Pattern
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================================
// Fiber Support (Progress & Cancellation)
// ========================================================

// Check if we should yield for progress reporting / cancellation
// Returns true if cancelled (caller should abort)
fn maybeYield(checker) {
  if !checker.fiberCtx { return false }

  checker.nodesProcessed = checker.nodesProcessed + 1

  // Throttle yields - only yield every N nodes
  if checker.nodesProcessed % checker.yieldInterval != 0 { return false }

  // Yield progress event
  if checker.fiberCtx.yield {
    checker.fiberCtx.yield(.{
      kind: "PROGRESS",  // Will be mapped to Events.EventKind.PROGRESS
      pass: "typecheck",
      phase: "synthesizing",
      done: checker.nodesProcessed,
      total: nil,  // Unknown total (could estimate from AST size)
    })
  }

  // Check if cancelled
  if checker.fiberCtx.checkCancel and checker.fiberCtx.checkCancel() {
    return true  // Signal cancellation to caller
  }

  false
}

// ========================================================
// Constraint Consistency Checks
// ========================================================

fn collectTypeVarsFromType(checker, t, out, seen) {
  if !t or !t.kind { return }

  if t.kind == "TypeVar" {
    if !out[t.id] { out[t.id] = t }
    if seen[t.id] { return }
    seen[t.id] = true

    let bound = getTypeVarBinding(checker, t.id)
    if bound { collectTypeVarsFromType(checker, bound, out, seen) }

    for lb in (t.lowerBounds or []) { collectTypeVarsFromType(checker, lb, out, seen) }
    for ub in (t.upperBounds or []) { collectTypeVarsFromType(checker, ub, out, seen) }

    if t.narrowedFrom { collectTypeVarsFromType(checker, t.narrowedFrom, out, seen) }
    if t.narrowedTo {
      for ntv in t.narrowedTo { collectTypeVarsFromType(checker, ntv, out, seen) }
    }
    return
  }

  if t.kind == "Function" {
    for param in (t.params or []) { collectTypeVarsFromType(checker, param, out, seen) }
    collectTypeVarsFromType(checker, t.return, out, seen)
    return
  }
  if t.kind == "Array" {
    collectTypeVarsFromType(checker, t.elem, out, seen)
    return
  }
  if t.kind == "Map" or t.kind == "Indexable" {
    collectTypeVarsFromType(checker, t.key, out, seen)
    collectTypeVarsFromType(checker, t.elem, out, seen)
    return
  }
  if t.kind == "Record" {
    for k in keys(t.fields or .{}) { collectTypeVarsFromType(checker, t.fields[k], out, seen) }
    return
  }
  if t.kind == "Option" {
    collectTypeVarsFromType(checker, t.value, out, seen)
    return
  }
  if t.kind == "Union" {
    for opt in (t.options or []) { collectTypeVarsFromType(checker, opt, out, seen) }
    return
  }
  if t.kind == "Intersect" {
    for part in (t.parts or []) { collectTypeVarsFromType(checker, part, out, seen) }
    return
  }
  if t.kind == "Not" {
    collectTypeVarsFromType(checker, t.value, out, seen)
  }
}

fn collectAllTypeVars(checker) {
  let out = .{}
  let seen = .{}

  for nodeId in keys(checker.types or .{}) {
    collectTypeVarsFromType(checker, checker.types[nodeId], out, seen)
  }
  for declId in keys(checker.env or .{}) {
    collectTypeVarsFromType(checker, checker.env[declId], out, seen)
  }

  let openFields = checker.openRecordFields or .{}
  for objId in keys(openFields) {
    let fieldMap = openFields[objId] or .{}
    for fieldName in keys(fieldMap) {
      collectTypeVarsFromType(checker, fieldMap[fieldName], out, seen)
    }
  }

  let openElems = checker.openIndexElems or .{}
  for objId in keys(openElems) {
    let elemMap = openElems[objId] or .{}
    for keyTag in keys(elemMap) {
      collectTypeVarsFromType(checker, elemMap[keyTag], out, seen)
    }
  }

  let bindings = checker.typeVarBindings or .{}
  for id in keys(bindings) {
    collectTypeVarsFromType(checker, bindings[id], out, seen)
  }

  let constraints = checker.builtinConstraints or []
  for item in constraints {
    if item.arg { collectTypeVarsFromType(checker, item.arg, out, seen) }
    if item.elem { collectTypeVarsFromType(checker, item.elem, out, seen) }
  }

  out
}

fn typeContainsTypeVarId(checker, t, tvId, seen) {
  t = deref(checker, t)
  if !t { return false }
  if t.kind == "TypeVar" {
    if t.id == tvId { return true }
    if seen[t.id] { return false }
    seen[t.id] = true

    let bound = getTypeVarBinding(checker, t.id)
    if bound and typeContainsTypeVarId(checker, bound, tvId, seen) { return true }
    for lb in (t.lowerBounds or []) {
      if typeContainsTypeVarId(checker, lb, tvId, seen) { return true }
    }
    for ub in (t.upperBounds or []) {
      if typeContainsTypeVarId(checker, ub, tvId, seen) { return true }
    }
    return false
  }
  if t.kind == "Function" {
    for param in (t.params or []) {
      if typeContainsTypeVarId(checker, param, tvId, seen) { return true }
    }
    return typeContainsTypeVarId(checker, t.return, tvId, seen)
  }
  if t.kind == "Array" { return typeContainsTypeVarId(checker, t.elem, tvId, seen) }
  if t.kind == "Map" or t.kind == "Indexable" {
    return typeContainsTypeVarId(checker, t.key, tvId, seen) or
      typeContainsTypeVarId(checker, t.elem, tvId, seen)
  }
  if t.kind == "Record" {
    for k in keys(t.fields or .{}) {
      if typeContainsTypeVarId(checker, t.fields[k], tvId, seen) { return true }
    }
    return false
  }
  if t.kind == "Option" { return typeContainsTypeVarId(checker, t.value, tvId, seen) }
  if t.kind == "Union" {
    for opt in (t.options or []) {
      if typeContainsTypeVarId(checker, opt, tvId, seen) { return true }
    }
    return false
  }
  if t.kind == "Intersect" {
    for part in (t.parts or []) {
      if typeContainsTypeVarId(checker, part, tvId, seen) { return true }
    }
    return false
  }
  if t.kind == "Not" { return typeContainsTypeVarId(checker, t.value, tvId, seen) }
  false
}

fn containsTypeVar(checker, t) {
  t = deref(checker, t)
  if !t { return false }
  if t.kind == "TypeVar" { return true }
  if t.kind == "Function" {
    for param in (t.params or []) {
      if containsTypeVar(checker, param) { return true }
    }
    return containsTypeVar(checker, t.return)
  }
  if t.kind == "Array" { return containsTypeVar(checker, t.elem) }
  if t.kind == "Map" {
    return containsTypeVar(checker, t.key) or containsTypeVar(checker, t.elem)
  }
  if t.kind == "Indexable" {
    return containsTypeVar(checker, t.key) or containsTypeVar(checker, t.elem)
  }
  if t.kind == "Record" {
    for k in keys(t.fields or .{}) {
      if containsTypeVar(checker, t.fields[k]) { return true }
    }
    return false
  }
  if t.kind == "Option" { return containsTypeVar(checker, t.value) }
  if t.kind == "Union" {
    for opt in (t.options or []) {
      if containsTypeVar(checker, opt) { return true }
    }
    return false
  }
  if t.kind == "Intersect" {
    for part in (t.parts or []) {
      if containsTypeVar(checker, part) { return true }
    }
    return false
  }
  if t.kind == "Not" { return containsTypeVar(checker, t.value) }
  false
}

fn snapshotIfConcrete(checker, t) {
  let snap = derefAll(checker, t)
  if containsTypeVar(checker, snap) { return nil }
  snap
}

fn nodeLabel(node) {
  if !node { return "node" }
  let kind = nil
  if node.type != nil {
    kind = NODE->nameOf(node.type)
    if !kind { kind = str(node.type) }
  } else {
    kind = "node"
  }

  if node.type == NODE.Identifier {
    return kind + "(" + str(node.name) + ")"
  }
  if node.type == NODE.Let and node.name {
    return kind + "(" + str(node.name.name) + ")"
  }
  if node.type == NODE.Function and node.name {
    return kind + "(" + str(node.name.name) + ")"
  }
  if node.type == NODE.Dot and node.property {
    let prop = node.property.value or node.property.name
    if prop { return kind + "(" + str(prop) + ")" }
  }
  if node.type == NODE.Binary or node.type == NODE.Logical or node.type == NODE.Unary {
    let op = node.operator and node.operator.lexeme
    if op { return kind + "(" + op + ")" }
  }
  if node.type == NODE.Call {
    let callee = unwrapGroupings(node.callee)
    if callee and callee.type == NODE.Identifier {
      return kind + "(" + str(callee.name) + ")"
    }
    if callee and callee.type == NODE.Dot and callee.property {
      let prop = callee.property.value or callee.property.name
      if prop { return kind + "(." + str(prop) + ")" }
    }
  }

  kind
}

fn nodeSummary(checker, node, t) {
  let label = nodeLabel(node)
  let loc = nil
  if node and node.filename and node.line {
    loc = node.filename + ":" + str(node.line) + ":" + str(node.col or 0)
  } else if node and node.id {
    loc = "#" + str(node.id)
  } else {
    loc = "?"
  }

  let typeStr = t and prettyTypeSnapshot(derefAll(checker, t)) or "?"
  label + " at " + loc + " type " + typeStr
}

fn collectTypeVarWitnesses(checker, tvId, limit = 3) {
  let out = []
  let typeMap = checker.types or .{}
  let nodes = checker.resolveResult and checker.resolveResult.nodes or .{}

  for nodeId in keys(typeMap) {
    let t = typeMap[nodeId]
    if typeContainsTypeVarId(checker, t, tvId, .{}) {
      let node = nodes[nodeId] or .{ id: nodeId }
      push(out, .{
        nodeId: nodeId,
        summary: nodeSummary(checker, node, t),
      })
      if len(out) >= limit { break }
    }
  }

  out
}

fn witnessLines(witnesses) {
  if !witnesses or len(witnesses) == 0 { return "" }
  let lines = collect w in witnesses { "  witness: " + w.summary }
  "\n" + join(lines, "\n")
}

fn joinBoundSnapshots(checker, bounds) {
  if !bounds or len(bounds) == 0 { return "(none)" }
  let parts = collect b in bounds { prettyTypeSnapshot(derefAll(checker, b)) }
  join(parts, ", ")
}

fn reportInconsistentBounds(checker, tvId, tv, lbs, ubs, lbSnap, ubSnap) {
  let witnesses = collectTypeVarWitnesses(checker, tvId)
  let nodeId = witnesses and witnesses[0] and witnesses[0].nodeId or nil
  let coalesced = prettyTypeSnapshot(derefAll(checker, coalesceTypeVar(checker, tv)))
  let msg =
    "Internal typecheck error: inconsistent bounds for ?" + str(tvId) +
    "\n  coalesced: " + coalesced +
    "\n  lower: " + joinBoundSnapshots(checker, lbs) +
    "\n  upper: " + joinBoundSnapshots(checker, ubs) +
    "\n  violates: " + prettyTypeSnapshot(lbSnap) + " <: " + prettyTypeSnapshot(ubSnap) +
    witnessLines(witnesses)
  addError(checker, nodeId, msg)
}

fn reportFieldInvariantConflict(checker, tvId, aSnap, bSnap) {
  let witnesses = collectTypeVarWitnesses(checker, tvId)
  let nodeId = witnesses and witnesses[0] and witnesses[0].nodeId or nil
  let msg =
    "Internal typecheck error: incompatible field-invariant bounds for ?" + str(tvId) +
    "\n  bound A: " + prettyTypeSnapshot(aSnap) +
    "\n  bound B: " + prettyTypeSnapshot(bSnap) +
    witnessLines(witnesses)
  addError(checker, nodeId, msg)
}

fn reportOpenFieldMismatch(checker, tvId, fieldName, fieldType, cachedType) {
  let witnesses = collectTypeVarWitnesses(checker, tvId)
  let nodeId = witnesses and witnesses[0] and witnesses[0].nodeId or nil
  let msg =
    "Internal typecheck error: open field cache mismatch for ?" + str(tvId) +
    "\n  field: " + str(fieldName) +
    "\n  record: " + prettyTypeSnapshot(fieldType) +
    "\n  cached: " + prettyTypeSnapshot(cachedType) +
    witnessLines(witnesses)
  addError(checker, nodeId, msg)
}

fn reportOpenFieldMissing(checker, tvId, fieldName, recordType) {
  let witnesses = collectTypeVarWitnesses(checker, tvId)
  let nodeId = witnesses and witnesses[0] and witnesses[0].nodeId or nil
  let msg =
    "Internal typecheck error: open field cache missing on record for ?" + str(tvId) +
    "\n  field: " + str(fieldName) +
    "\n  record: " + prettyTypeSnapshot(recordType) +
    witnessLines(witnesses)
  addError(checker, nodeId, msg)
}

fn reportOpenIndexMismatch(checker, tvId, keyTag, objType, elemType, cachedType) {
  let witnesses = collectTypeVarWitnesses(checker, tvId)
  let nodeId = witnesses and witnesses[0] and witnesses[0].nodeId or nil
  let msg =
    "Internal typecheck error: open index cache mismatch for ?" + str(tvId) +
    "\n  key: " + str(keyTag) +
    "\n  object: " + prettyTypeSnapshot(objType) +
    "\n  elem: " + prettyTypeSnapshot(elemType) +
    "\n  cached: " + prettyTypeSnapshot(cachedType) +
    witnessLines(witnesses)
  addError(checker, nodeId, msg)
}

fn checkConstraintConsistency(checker) {
  let typeVars = collectAllTypeVars(checker)

  for tvId in keys(typeVars) {
    let tv = typeVars[tvId]
    let lbs = tv.lowerBounds or []
    let ubs = tv.upperBounds or []

    let violated = false
    for lb in lbs {
      if violated { break }
      for ub in ubs {
        let lbSnap = snapshotIfConcrete(checker, lb)
        let ubSnap = snapshotIfConcrete(checker, ub)
        if !lbSnap or !ubSnap { continue }
        if !isSubtype(checker, lbSnap, ubSnap) {
          reportInconsistentBounds(checker, tvId, tv, lbs, ubs, lbSnap, ubSnap)
          violated = true
          break
        }
      }
    }

    if tv.fieldInvariant and !violated {
      for let i = 0; i < len(lbs); i = i + 1 {
        if violated { break }
        for let j = i + 1; j < len(lbs); j = j + 1 {
          let aSnap = snapshotIfConcrete(checker, lbs[i])
          let bSnap = snapshotIfConcrete(checker, lbs[j])
          if !aSnap or !bSnap { continue }
          if aSnap.kind == "Nil" or bSnap.kind == "Nil" { continue }
          if !isSubtype(checker, aSnap, bSnap) and !isSubtype(checker, bSnap, aSnap) {
            reportFieldInvariantConflict(checker, tvId, aSnap, bSnap)
            violated = true
            break
          }
        }
      }
    }
  }

  let openFields = checker.openRecordFields or .{}
  for objId in keys(openFields) {
    let objTv = typeVars[objId]
    if !objTv { continue }
    let objCo = coalesceTypeVar(checker, objTv)
    if !objCo or objCo.kind != "Record" { continue }

    let fieldMap = openFields[objId] or .{}
    for fieldName in keys(fieldMap) {
      let cachedField = fieldMap[fieldName]
      let recordField = objCo.fields and objCo.fields[fieldName]
      if !recordField {
        reportOpenFieldMissing(checker, objId, fieldName, derefAll(checker, objCo))
        continue
      }
      let recordSnap = snapshotIfConcrete(checker, recordField)
      let cachedSnap = snapshotIfConcrete(checker, cachedField)
      if !recordSnap or !cachedSnap { continue }
      if !isSubtype(checker, recordSnap, cachedSnap) {
        reportOpenFieldMismatch(checker, objId, fieldName, recordSnap, cachedSnap)
      }
    }
  }

  let openElems = checker.openIndexElems or .{}
  for objId in keys(openElems) {
    let objTv = typeVars[objId]
    if !objTv { continue }
    let objCo = coalesceTypeVar(checker, objTv)
    if !objCo or objCo.kind == "TypeVar" { continue }

    let elemMap = openElems[objId] or .{}
    for keyTag in keys(elemMap) {
      if keyTag == "any" { continue }
      let expectedKey =
        keyTag == "string" and typeString() or
        keyTag == "number" and typeNumber() or
        nil
      if !expectedKey { continue }

      let cachedElem = elemMap[keyTag]
      let cachedSnap = snapshotIfConcrete(checker, cachedElem)
      if !cachedSnap { continue }

      if objCo.kind == "Array" {
        if keyTag != "number" { reportOpenIndexMismatch(checker, objId, keyTag, objCo, objCo.elem, cachedSnap) }
        let elemSnap = snapshotIfConcrete(checker, objCo.elem)
        if elemSnap and !isSubtype(checker, elemSnap, cachedSnap) {
          reportOpenIndexMismatch(checker, objId, keyTag, objCo, elemSnap, cachedSnap)
        }
        continue
      }

      if objCo.kind == "Map" or objCo.kind == "Indexable" {
        let keySnap = snapshotIfConcrete(checker, objCo.key)
        if keySnap and !isSubtype(checker, keySnap, expectedKey) {
          reportOpenIndexMismatch(checker, objId, keyTag, objCo, objCo.elem, cachedSnap)
        }
        let elemSnap = snapshotIfConcrete(checker, objCo.elem)
        if elemSnap and !isSubtype(checker, elemSnap, cachedSnap) {
          reportOpenIndexMismatch(checker, objId, keyTag, objCo, elemSnap, cachedSnap)
        }
      }
    }
  }
}

// ========================================================
// Environment Helpers
// ========================================================

fn envLookup(checker, declNodeId) {
  checker.env[declNodeId]
}

fn envBind(checker, declNodeId, t) {
  checker.env[declNodeId] = t
}

// ========================================================
// Type Synthesis Functions
// ========================================================

// ExprStmt wrapper - common in lowered AST
fn synthExprStmt(checker, node) {
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

// Literal nodes
fn synthLiteral(checker, node) {
  let t =
    node.type == NODE.Number and typeNumber() or
    node.type == NODE.String and typeString() or
    node.type == NODE.Bool   and typeBool()   or
    typeNil()

  checker.types[node.id] = t
  t
}

// Identifier nodes - lookup in env or create fresh TypeVar
fn synthIdentifier(checker, node) {
  let binding = checker.resolvedNames[node.id]

  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Handle builtins
  if binding.kind == "builtin" {
    let bt = helper.builtinTypeByName(checker, binding.name)
    if !bt { bt = typeAny() }
    checker.types[node.id] = bt
    return bt
  }

  // Local or upvalue - look up in environment by declaredAt
  let declId = binding.declaredAt
  let t = envLookup(checker, declId)

  if !t {
    // Not yet bound - create fresh type var
    t = freshTypeVar(checker)
    envBind(checker, declId, t)
  }

  checker.types[node.id] = t
  t
}

// Let binding
fn synthLet(checker, node) {
  let declId = node.name and node.name.id

  if node.init {
    let initType = synthExpr(checker, node.init)
    let initD = deref(checker, initType)

    // Special handling for nil init: create a TypeVar with Nil as lower bound
    // This allows the variable to evolve to Option[T] when assigned non-nil later
    if initD.kind == "Nil" {
      let t = freshTypeVar(checker)
      constrain(checker, initType, t)  // Nil <: TypeVar
      if declId {
        envBind(checker, declId, t)
        checker.types[node.name.id] = t
      }
      checker.types[node.id] = t
      return t
    }

    if declId {
      envBind(checker, declId, initType)
      checker.types[node.name.id] = initType
      let keysRecord = recordFromKeysCall(checker, node.init)
      if keysRecord { checker.keysSourceByDeclId[declId] = keysRecord }
      if node.init.type == NODE.Index {
        let objNode = unwrapGroupings(node.init.object)
        if objNode and objNode.type == NODE.Identifier {
          let binding = checker.resolvedNames[objNode.id]
          if binding and binding.declaredAt {
            let recordType = checker.keysSourceByDeclId[binding.declaredAt]
            if recordType { checker.keyBindingRecord[declId] = recordType }
          }
        }
      }
      let literalMap = recordLiteralValues(node.init)
      if literalMap {
        checker.recordValueBindings[declId] = literalMap
      } else if node.init.type == NODE.Identifier {
        let binding = checker.resolvedNames[node.init.id]
        if binding and binding.declaredAt {
          let bound = checker.recordValueBindings[binding.declaredAt]
          if bound { checker.recordValueBindings[declId] = bound }
          let keysRecord = checker.keysSourceByDeclId[binding.declaredAt]
          if keysRecord { checker.keysSourceByDeclId[declId] = keysRecord }
        }
      }
    }
    checker.types[node.id] = initType
    return initType
  } else {
    // Uninitialized - fresh type var (runtime value is nil)
    let t = freshTypeVar(checker)
    t.uninitializedLocal = true  // Mark for field access checking
    if declId {
      envBind(checker, declId, t)
      checker.types[node.name.id] = t
    }
    checker.types[node.id] = t
    return t
  }
}

// Function definition
fn synthFunction(checker, node) {
  let params = node.params or []
  let defaults = node.defaults or []

  // Compute minArity from trailing defaults (only trailing defaults can be omitted)
  let minArity = len(params)
  if len(defaults) == len(params) and len(defaults) > 0 {
    for let i = len(defaults) - 1; i >= 0; i = i - 1 {
      if defaults[i] != nil {
        minArity = i
      } else {
        break
      }
    }
  }

  // Create fresh type vars for parameters and bind them
  let paramTypes = []
  for param in params {
    let pt = freshTypeVar(checker)
    envBind(checker, param.id, pt)
    checker.types[param.id] = pt
    push(paramTypes, pt)
  }
  let paramNames = collect p in params { p.name }

  // Fresh type var for return
  let retType = freshTypeVar(checker)
  let savedReturn = checker.currentReturn
  checker.currentReturn = retType

  // Create the function type before synthesizing body
  // (allows recursive functions to look up their own type)
  let fnType = typeFunction(paramTypes, retType)
  fnType.minArity = minArity
  fnType.paramNames = paramNames
  checker.types[node.id] = fnType

  // For named functions, bind the function to the environment
  // The resolver's declaredAt points to node.id for named functions
  if node.name and node.name.id {
    envBind(checker, node.id, fnType)
    envBind(checker, node.name.id, fnType)
    checker.types[node.name.id] = fnType
  }

  // Synthesize body
  let bodyType = typeNil()
  if node.body {
    bodyType = synthExpr(checker, node.body)
    // Body type constrains return type
    constrain(checker, bodyType, retType)
  }

  checker.currentReturn = savedReturn
  fnType
}

// Function call
fn synthCall(checker, node) {
  let calleeType = synthExpr(checker, node.callee)
  let args = node.args or []

  // Synthesize argument types (arguments are always used)
  let argTypes = collect arg in args { synthExpr(checker, arg) }

  // Fresh result type
  let resultType = freshTypeVar(checker)

  // Build expected function type from args
  let expectedFnType = typeFunction(argTypes, resultType)

  // Constrain: calleeType <: (args) -> result
  let calleeD = deref(checker, calleeType)
  let calleeName =
    node.callee and node.callee.type == NODE.Identifier and node.callee.name or
    calleeD and calleeD.kind == "Function" and calleeD.builtinName or
    nil

  // Try builtin synthesize rules first (for special builtins like range/keys)
  if calleeD.kind == "Function" and calleeD.builtinName {
    let builtinResult = rulesModule.applyBuiltinRules(
      checker, node, calleeD.builtinName, argTypes, args, addError, envBind, unwrapGroupings, "synthesize"
    )
    if builtinResult and builtinResult.handled {
      checker.types[node.id] = builtinResult.type
      return builtinResult.type
    }
  }

  if calleeD.kind == "Function" {
    // Check arity
    let calleeParams = calleeD.params or []
    let minArity = calleeD.minArity
    if minArity == nil { minArity = len(calleeParams) }

    if len(argTypes) < minArity {
      addError(checker, node.id,
        "Too few arguments: expected at least " + str(minArity) +
        ", got " + str(len(argTypes)))
    } else {
      // Apply builtin validation rules (for len, nameOf, etc.)
      if calleeD.builtinName {
        rulesModule.applyBuiltinRules(
          checker, node, calleeD.builtinName, argTypes, args, addError, envBind, unwrapGroupings, "validate"
        )
      }

      // Constrain argument types (contravariant)
      let numParams = len(calleeParams)
      for let i = 0; i < len(argTypes) and i < numParams; i = i + 1 {
        // Snapshot types BEFORE constraint (derefAll creates immutable copies)
        // Coalesce first to resolve TypeVars to their bounds, then snapshot
        let expectedCoalesced = coalesceTypeVar(checker, deref(checker, calleeParams[i]))
        let actualCoalesced = coalesceTypeVar(checker, deref(checker, argTypes[i]))
        let expectedSnap = derefAll(checker, expectedCoalesced)
        let actualSnap = derefAll(checker, actualCoalesced)

        if !constrain(checker, argTypes[i], calleeParams[i]) {
          // Use snapshot-safe printer to avoid "expected String, got String" errors
          // (constrain() mutates TypeVars, so post-constraint pretty-printing is incorrect)
          let expected = prettyTypeSnapshot(expectedSnap)
          let actual = prettyTypeSnapshot(actualSnap)

          let paramName = calleeD.paramNames and calleeD.paramNames[i]
          let label = "Argument " + str(i + 1)
          if paramName { label = label + " (" + paramName + ")" }
          if calleeName {
            label = label + " mismatch in call to " + calleeName
          } else {
            label = label + " mismatch"
          }
          addError(checker, node.id, label + ": expected " + expected + ", got " + actual)
        }
      }
      // Constrain return type (covariant)
      constrain(checker, calleeD.return, resultType)
    }
  } else if calleeD.kind == "TypeVar" {
    // Unknown callee - constrain it to be a function
    if !constrain(checker, calleeType, expectedFnType) {
      addError(checker, node.id, "Cannot call value")
    }
  } else if calleeD.kind != "Any" {
    addError(checker, node.id,
      "Cannot call value of type " + prettyType(checker, calleeType))
  }

  checker.types[node.id] = resultType
  resultType
}

// Record/Hashmap literal
fn synthHashmap(checker, node) {
  let pairs = node.pairs or []

  // Check if this hashmap is an enum definition (via enumInfo)
  let enumInfo = checker.enumInfo[node.id]
  if enumInfo and enumInfo.members {
    // Create an Enum type with member values
    let enumFields = .{}
    for member in enumInfo.members {
      enumFields[member.name] = member.value
    }
    let t = helper.typeEnum(enumFields)
    t.enumId = node.id
    // Store enum info for later use when accessing members
    checker.enumDefs = checker.enumDefs or .{}
    checker.enumDefs[node.id] = enumInfo
    checker.types[node.id] = t
    return t
  }

  if len(pairs) == 0 {
    let elemType = freshTypeVar(checker)
    let keyType = freshTypeVar(checker)
    let t = typeIndexable(elemType, keyType, node.id)
    checker.types[node.id] = t
    return t
  }

  let fields = .{}
  let hasError = false
  let enumKeyOrigins = []
  let tagInfo = nil

  for pair in pairs {
    let keyNode = pair.key
    let valueNode = pair.value

    // Determine field key (preserve original type for numbers)
    let fieldKey = nil
    let isLiteralKey = false

    // Unwrap groupings to find the actual key expression
    let unwrappedKey = unwrapGroupings(keyNode)
    if !unwrappedKey { unwrappedKey = keyNode }

    if unwrappedKey.type == NODE.String {
      fieldKey = unwrappedKey.value
      isLiteralKey = true
      synthExpr(checker, keyNode)
    } else if unwrappedKey.type == NODE.Number {
      fieldKey = unwrappedKey.value  // Keep as number
      isLiteralKey = true
      synthExpr(checker, keyNode)
    } else if unwrappedKey.type == NODE.Dot {
      // Could be enum member access - try to resolve it
      synthExpr(checker, keyNode)
      // Try to get enum member value from the type system
      let objType = checker.types[unwrappedKey.object.id]
      let objD = objType and deref(checker, objType)
      if objD and objD.kind == "Enum" and objD.fields {
        let memberName = unwrappedKey.property.value or unwrappedKey.property.name
        let memberValue = objD.fields[memberName]
        if memberValue != nil {
          fieldKey = memberValue  // Use the enum member's numeric value
          isLiteralKey = true
          // Track enum key origin
          push(enumKeyOrigins, .{
            member: memberName,
            enumName: unwrappedKey.object.name,
          })
        }
      }
      // Also allow computed key from a record literal with string/number values
      if !isLiteralKey {
        let baseObj = unwrapGroupings(unwrappedKey.object)
        if baseObj and baseObj.type == NODE.Identifier {
          let binding = checker.resolvedNames[baseObj.id]
          if binding and binding.declaredAt {
            let recordValues = checker.recordValueBindings[binding.declaredAt]
            if recordValues {
              let memberName = unwrappedKey.property.value or unwrappedKey.property.name
              if memberName and recordValues[memberName] != nil {
                fieldKey = recordValues[memberName]
                isLiteralKey = true
              }
            }
          }
        }
      }
      // If not an enum member access, reject it
      if !isLiteralKey {
        addError(checker, keyNode.id, "Record literal computed key must be a literal string, number, or enum member.")
        hasError = true
      }
    } else {
      // Non-literal computed key (e.g., a variable)
      synthExpr(checker, keyNode)
      addError(checker, keyNode.id, "Record literal computed key must be a literal string, number, or enum member.")
      hasError = true
    }

    let valueType = synthExpr(checker, valueNode)
    let fieldType = valueType
    let unwrappedValue = unwrapGroupings(valueNode)
    if unwrappedValue and unwrappedValue.type == NODE.Nil {
      let tv = freshTypeVar(checker)
      fieldType = typeOption(tv)
    }
    if isLiteralKey and type(fieldKey) == "string" and
       (fieldKey == "tag" or fieldKey == "kind" or fieldKey == "type") {
      let tagType = extractTagTypeFromValue(checker, valueNode)
      if tagType {
        if tagInfo {
          addError(checker, valueNode.id, "Multiple tag fields are not allowed.")
        } else {
          tagInfo = .{ tagType: tagType }
        }
      }
    }
    if fieldKey != nil {
      fields[fieldKey] = fieldType
    }
  }

  // Store enum key origins if any
  if len(enumKeyOrigins) > 0 {
    checker.recordEnumKeyOrigins = checker.recordEnumKeyOrigins or .{}
    checker.recordEnumKeyOrigins[node.id] = enumKeyOrigins
  }

  let recordType = typeRecord(fields)
  let t = recordType
  if tagInfo and tagInfo.tagType {
    t = typeIntersect([recordType, tagInfo.tagType])
  }
  checker.types[node.id] = t
  t
}

// Field access (dot)
// Delegates to rule-based dispatch in rules.lx
fn synthDot(checker, node) {
  let objType = synthExpr(checker, node.object)
  let propNode = node.property
  let fieldName = propNode.value or propNode.name or propNode

  // Apply dot rules to determine result type
  let resultType = rulesModule.applyDotRules(checker, node, objType, fieldName, addError)

  checker.types[node.id] = resultType
  resultType
}

// If expression
fn synthIf(checker, node) {
  // Check condition (lx uses truthiness, not strict Bool)
  synthExpr(checker, node.condition)

  // Branch-scoped overlay for truthy guard narrowing
  let overlay = nil
  let guard = checker.facts and checker.facts.truthyGuardThen and checker.facts.truthyGuardThen[node.id]
  if guard and guard.declId {
    overlay = applyNarrowingOverlay(checker, guard.declId)
    if overlay {
      envBind(checker, guard.declId, overlay.narrowed)
    }
  }

  let tagGuard = matchTagGuard(checker, node.condition)
  let tagOverlayThen = nil
  if tagGuard and tagGuard.declId and tagGuard.tagType {
    let constraint = tagGuard.negated and typeNot(tagGuard.tagType) or tagGuard.tagType
    tagOverlayThen = applyTagNarrowingOverlay(checker, tagGuard.declId, constraint)
    if tagOverlayThen {
      envBind(checker, tagGuard.declId, tagOverlayThen.narrowed)
    }
  }

  // Synthesize then branch (sees narrowed env)
  let thenType = synthExpr(checker, node.then)

  // Restore before else branch
  if tagOverlayThen {
    envBind(checker, tagGuard.declId, tagOverlayThen.original)
  }
  if overlay {
    envBind(checker, guard.declId, overlay.original)
  }

  if node.else {
    let tagOverlayElse = nil
    if tagGuard and tagGuard.declId and tagGuard.tagType {
      let constraint = tagGuard.negated and tagGuard.tagType or typeNot(tagGuard.tagType)
      tagOverlayElse = applyTagNarrowingOverlay(checker, tagGuard.declId, constraint)
      if tagOverlayElse {
        envBind(checker, tagGuard.declId, tagOverlayElse.narrowed)
      }
    }

    // With else: join both branches
    let elseType = synthExpr(checker, node.else)

    if tagOverlayElse {
      envBind(checker, tagGuard.declId, tagOverlayElse.original)
    }

    let thenD = deref(checker, thenType)
    let elseD = deref(checker, elseType)

    // Check for branch mismatch (incompatible concrete types)
    // Skip if in statement position - result is discarded anyway
    let inStmtPos = checker.facts and checker.facts.stmtPosition[node.id]
    if !inStmtPos {
      if thenD.kind != "TypeVar" and elseD.kind != "TypeVar" and
         thenD.kind != "Any" and elseD.kind != "Any" and
         thenD.kind != "Nil" and elseD.kind != "Nil" {
        // Both are concrete non-nil types - check compatibility
        if thenD.kind != elseD.kind {
          addError(checker, node.id, "Branch mismatch")
          checker.types[node.id] = typeAny()
          return typeAny()
        }
      }
    }

    // Fresh result type, constrain both branches
    let resultType = freshTypeVar(checker)
    constrain(checker, thenType, resultType)
    constrain(checker, elseType, resultType)

    checker.types[node.id] = resultType
    return resultType
  } else {
    // No else branch - result is Option[thenType]
    let thenD = deref(checker, thenType)
    if thenD.kind == "Nil" {
      checker.types[node.id] = typeNil()
      return typeNil()
    }
    if typeHasNilEvidence(checker, thenType) {
      checker.types[node.id] = thenType
      return thenType
    }
    let optType = typeOption(thenType)
    checker.types[node.id] = optType
    return optType
  }
}

// Array literal
fn synthArray(checker, node) {
  let elems = node.elements or []

  if len(elems) == 0 {
    // Empty array - element type is fresh
    let elemType = freshTypeVar(checker)
    let t = typeArray(elemType)
    checker.types[node.id] = t
    return t
  }

  // Non-empty: unify all elements
  let elemType = freshTypeVar(checker)
  for elem in elems {
    let et = synthExpr(checker, elem)
    constrain(checker, et, elemType)
  }

  let t = typeArray(elemType)
  checker.types[node.id] = t
  t
}

// Binary operations
fn synthBinary(checker, node) {
  let op = node.operator and node.operator.lexeme or ""
  let leftType = synthExpr(checker, node.left)
  let rightType = synthExpr(checker, node.right)

  // Arithmetic: both must be Number, result is Number
  if op == "+" or op == "-" or op == "*" or op == "/" or op == "%" {
    if op == "+" {
      // String concatenation check
      // Use coalesceTypeVar to resolve TypeVars with String bounds
      let leftD = deref(checker, leftType)
      let rightD = deref(checker, rightType)
      if leftD.kind == "TypeVar" {
        leftD = coalesceTypeVar(checker, leftD)
      }
      if rightD.kind == "TypeVar" {
        rightD = coalesceTypeVar(checker, rightD)
      }
      if leftD.kind == "String" or rightD.kind == "String" {
        constrain(checker, leftType, typeString())
        constrain(checker, rightType, typeString())
        checker.types[node.id] = typeString()
        return typeString()
      }
    }

    if !constrain(checker, leftType, typeNumber()) {
      addError(checker, node.left.id,
        "Expected Number for left operand of '" + op + "', got " + prettyType(checker, leftType))
    }
    if !constrain(checker, rightType, typeNumber()) {
      addError(checker, node.right.id,
        "Expected Number for right operand of '" + op + "', got " + prettyType(checker, rightType))
    }

    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  // Comparison: result is Bool
  if op == "==" or op == "!=" or op == "<" or op == ">" or
     op == "<=" or op == ">=" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  // Bitwise: both Number, result Number
  if op == "&" or op == "|" or op == "^" or op == "<<" or op == ">>" {
    constrain(checker, leftType, typeNumber())
    constrain(checker, rightType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  checker.types[node.id] = typeAny()
  typeAny()
}

// Unary operations
fn synthUnary(checker, node) {
  let op = node.operator and node.operator.lexeme or ""
  let operandType = synthExpr(checker, node.operand)

  if op == "-" {
    constrain(checker, operandType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  if op == "!" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  if op == "~" {
    constrain(checker, operandType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  checker.types[node.id] = typeAny()
  typeAny()
}

fn stripNilEvidence(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Nil" { return typeBottom() }
  if t.kind == "Option" { return t.value }

  if t.kind == "Union" {
    let nonNil = []
    for opt in (t.options or []) {
      let stripped = stripNilEvidence(checker, opt)
      if stripped and stripped.kind != "Bottom" { push(nonNil, stripped) }
    }
    if len(nonNil) == 0 { return typeBottom() }
    if len(nonNil) == 1 { return nonNil[0] }
    return typeUnion(nonNil)
  }

  if t.kind == "TypeVar" {
    let lbs = t.lowerBounds or []
    if len(lbs) == 0 {
      let coalesced = coalesceTypeVar(checker, t)
      if coalesced and coalesced.kind != "TypeVar" {
        return stripNilEvidence(checker, coalesced)
      }
      return t
    }

    let nonNilBounds = []
    for lb in lbs {
      let stripped = stripNilEvidence(checker, lb)
      if stripped and stripped.kind != "Bottom" { push(nonNilBounds, stripped) }
    }
    if len(nonNilBounds) == 0 { return typeBottom() }
    if len(nonNilBounds) == 1 { return nonNilBounds[0] }
    return typeUnion(nonNilBounds)
  }

  t
}

// Logical operations (and/or)
// In lx: `a and b` returns b if a is truthy, else a
//        `a or b` returns a if a is truthy, else b
fn synthLogical(checker, node) {
  let op = node.operator and node.operator.lexeme or ""

  // --------------------------------------------------------
  // Special-case: (cond and X) or Y  ==>  join(X, Y)
  //
  // This matches the common "ternary-ish" idiom and prevents
  // `cond` from leaking into the result type.
  //
  // Semantically: the final value is always either X or Y:
  //   - if cond is falsy: left becomes falsy, so `or` returns Y
  //   - if cond is truthy: left becomes X, so `or` returns X (if truthy) else Y
  // Either way, the final value is in {X, Y}, never cond.
  // --------------------------------------------------------
  if op == "or" {
    let leftNode = unwrapGroupings(node.left)
    let leftOp = leftNode and leftNode.operator and leftNode.operator.lexeme or ""
    if leftNode and leftNode.type == NODE.Logical and leftOp == "and" {
      // Synthesize subparts
      // Note: cond is still synthesized for completeness/side effects,
      // but its type does not contribute to the overall expression type.
      synthExpr(checker, leftNode.left)          // cond
      let xType = synthExpr(checker, leftNode.right)  // X
      let yType = synthExpr(checker, node.right)      // Y

      let yNode = unwrapGroupings(node.right)
      let yD = deref(checker, yType)
      let yLiteralTruthy = yNode and yNode.type == NODE.Bool and yNode.value
      let yTruthy = yLiteralTruthy or
        (!typeHasNilEvidence(checker, yType) and yD.kind != "Bool" and yD.kind != "TypeVar" and yD.kind != "Nil")

      let resultType = freshTypeVar(checker)
      if yTruthy and typeHasNilEvidence(checker, xType) {
        let nonNilX = stripNilEvidence(checker, xType)
        if nonNilX and nonNilX.kind != "Bottom" {
          constrain(checker, nonNilX, resultType)
        }
        constrain(checker, yType, resultType)
      } else {
        // Result is a join of X and Y
        constrain(checker, xType, resultType)
        constrain(checker, yType, resultType)
      }

      checker.types[node.id] = resultType
      return resultType
    }
  }

  // -----------------------
  // Existing general logic
  // -----------------------
  let leftNode = unwrapGroupings(node.left)
  let rightNode = unwrapGroupings(node.right)
  let leftLiteralTruthy = false
  let leftLiteralFalsy = false
  if leftNode and leftNode.type == NODE.Nil {
    leftLiteralFalsy = true
  } else if leftNode and leftNode.type == NODE.Bool {
    if leftNode.value { leftLiteralTruthy = true }
    else { leftLiteralFalsy = true }
  }

  let leftType = synthExpr(checker, node.left)
  let rightType = synthExpr(checker, node.right)

  let leftD = deref(checker, leftType)
  let rightD = deref(checker, rightType)

  // Check if left is definitely falsy (Nil or literal false)
  let leftFalsy = leftLiteralFalsy or leftD.kind == "Nil"

  // Check if left is definitely truthy (literal true or non-nil, non-bool, not TypeVar)
  // In lx, only nil and false are falsy
  let leftTruthy = !leftFalsy and
    (leftLiteralTruthy or
     (!typeHasNilEvidence(checker, leftType) and leftD.kind != "Bool" and leftD.kind != "TypeVar"))

  let rightLiteralTruthy = false
  if rightNode and rightNode.type == NODE.Bool and rightNode.value { rightLiteralTruthy = true }
  let rightTruthy = rightLiteralTruthy or
    (!typeHasNilEvidence(checker, rightType) and rightD.kind != "Bool" and rightD.kind != "TypeVar" and rightD.kind != "Nil")

  if op == "and" {
    // `a and b`: if a is falsy, return a; if a is truthy, return b
    if leftFalsy {
      checker.types[node.id] = leftType
      return leftType
    }
    if leftTruthy {
      checker.types[node.id] = rightType
      return rightType
    }
    // Unknown - join both types
    let resultType = freshTypeVar(checker)
    constrain(checker, leftType, resultType)
    constrain(checker, rightType, resultType)
    checker.types[node.id] = resultType
    return resultType
  }

  if op == "or" {
    // `a or b`: if a is truthy, return a; if a is falsy, return b
    if leftTruthy {
      checker.types[node.id] = leftType
      return leftType
    }
    if leftFalsy {
      checker.types[node.id] = rightType
      return rightType
    }
    if rightTruthy and typeHasNilEvidence(checker, leftType) {
      let nonNilLeft = stripNilEvidence(checker, leftType)
      if nonNilLeft and nonNilLeft.kind == "Bottom" {
        checker.types[node.id] = rightType
        return rightType
      }
      let resultType = freshTypeVar(checker)
      if nonNilLeft { constrain(checker, nonNilLeft, resultType) }
      constrain(checker, rightType, resultType)
      checker.types[node.id] = resultType
      return resultType
    }
    // Unknown - join both types
    let resultType = freshTypeVar(checker)
    constrain(checker, leftType, resultType)
    constrain(checker, rightType, resultType)
    checker.types[node.id] = resultType
    return resultType
  }

  // Default
  checker.types[node.id] = leftType
  leftType
}

// Helper: Apply narrowing overlay for a declaration
// Returns { original, narrowed } if narrowing was applied, nil otherwise
fn applyNarrowingOverlay(checker, declId) {
  let currentType = envLookup(checker, declId)
  if !currentType { return nil }

  if !isOptionalish(checker, currentType) { return nil }

  // Create narrowed type var
  let narrowedTV = freshTypeVar(checker)
  constrain(checker, narrowedTV, currentType)

  let currentD = deref(checker, currentType)
  if currentD.kind == "TypeVar" {
    narrowedTV.narrowedFrom = currentType
    currentType.narrowedTo = currentType.narrowedTo or []
    push(currentType.narrowedTo, narrowedTV)
  }

  // Return overlay record so caller can restore
  .{ original: currentType, narrowed: narrowedTV }
}

fn applyTagNarrowingOverlay(checker, declId, constraintType) {
  let currentType = envLookup(checker, declId)
  if !currentType { return nil }

  let narrowedTV = freshTypeVar(checker)
  constrain(checker, narrowedTV, currentType)
  if constraintType { constrain(checker, narrowedTV, constraintType) }

  .{ original: currentType, narrowed: narrowedTV }
}

// Block expression
// Uses refinement overlay for nil-guard narrowing:
// - refinements: declId -> { original, narrowed } mapping
// - Closures see original env (not narrowed)
// - Other expressions see narrowed env
// - Refinements don't leak out of block scope
fn synthBlock(checker, node) {
  let exprs = node.expressions or []
  let lastType = typeNil()

  // Refinement overlay: declId -> { original: Type, narrowed: Type }
  let refinements = .{}
  let refinementKeys = []  // Track keys in order for iteration

  for let i = 0; i < len(exprs); i = i + 1 {
    let expr = exprs[i]

    // For closures, temporarily restore original bindings (closures should not see narrowed types)
    let unwrappedExpr = unwrapGroupings(expr)
    let isClosure = unwrappedExpr.type == NODE.Function
    if isClosure and len(refinementKeys) > 0 {
      for declId in refinementKeys {
        envBind(checker, declId, refinements[declId].original)
      }
    }

    // Synthesize current expression
    lastType = synthExpr(checker, expr)

    // Re-apply narrowing after closure synthesis (restore same narrowed TypeVar to preserve constraints)
    if isClosure and len(refinementKeys) > 0 {
      for declId in refinementKeys {
        envBind(checker, declId, refinements[declId].narrowed)
      }
    }

    // Apply refinement from pre-computed facts (not inline detection)
    let guard = checker.facts and checker.facts.nilGuardReturn[expr.id]
    if guard and i < len(exprs) - 1 {
      let declId = guard.declId
      if !refinements[declId] {
        let overlay = applyNarrowingOverlay(checker, declId)
        if overlay {
          // Store in refinement overlay
          refinements[declId] = overlay
          push(refinementKeys, declId)

          // Use narrowed type for subsequent lookups
          envBind(checker, declId, overlay.narrowed)
        }
      }
    }

    let guardNode = unwrapGroupings(expr)
    if guardNode and guardNode.type == NODE.ExprStmt {
      guardNode = unwrapGroupings(guardNode.expr)
    }
    if guardNode and guardNode.type == NODE.If and !guardNode.else and i < len(exprs) - 1 {
      if branchAlwaysReturns(guardNode.then) {
        let tagGuard = matchTagGuard(checker, guardNode.condition)
        if tagGuard and tagGuard.declId and tagGuard.tagType {
          let constraint = tagGuard.negated and tagGuard.tagType or typeNot(tagGuard.tagType)
          let overlay = refinements[tagGuard.declId]
          if overlay {
            constrain(checker, overlay.narrowed, constraint)
          } else {
            overlay = applyTagNarrowingOverlay(checker, tagGuard.declId, constraint)
            if overlay {
              refinements[tagGuard.declId] = overlay
              push(refinementKeys, tagGuard.declId)
              envBind(checker, tagGuard.declId, overlay.narrowed)
            }
          }
        }
      }
    }

    // Yield point: after processing each expression in block
    // (state is consistent - expression fully typed, env updated)
    if maybeYield(checker) {
      // Cancelled - return early with partial results
      checker.types[node.id] = typeAny()
      return typeAny()
    }
  }

  // Restore original env (don't leak narrowing out of block)
  for declId in refinementKeys {
    envBind(checker, declId, refinements[declId].original)
  }

  checker.types[node.id] = lastType
  lastType
}

// For loop (C-style)
fn synthFor(checker, node) {
  if node.init { synthExpr(checker, node.init) }
  if node.condition { synthExpr(checker, node.condition) }
  if node.update { synthExpr(checker, node.update) }
  if node.body { synthExpr(checker, node.body) }

  // For loops return nil
  let t = typeNil()
  checker.types[node.id] = t
  t
}

// For-in loop
fn synthForIn(checker, node) {
  let iterableType = synthExpr(checker, node.iterable)

  // Bind the value binder
  if node.valueBinder {
    // Create a fresh type var for the element
    let elemType = freshTypeVar(checker)

    // Constrain iterable to Array[elemType]
    constrain(checker, iterableType, typeArray(elemType))

    // Find the binding for valueBinder and bind it
    // The resolver should have created a local for it
    let binding = checker.resolvedNames[node.id]
    if binding and binding.valueBinderDeclId {
      envBind(checker, binding.valueBinderDeclId, elemType)
      let recordType = recordFromKeysCall(checker, node.iterable)
      if !recordType and node.iterable and node.iterable.type == NODE.Identifier {
        let iterBinding = checker.resolvedNames[node.iterable.id]
        if iterBinding and iterBinding.declaredAt {
          recordType = checker.keysSourceByDeclId[iterBinding.declaredAt]
        }
      }
      if recordType { checker.keyBindingRecord[binding.valueBinderDeclId] = recordType }
    }
  }

  if node.body { synthExpr(checker, node.body) }

  let t = typeNil()
  checker.types[node.id] = t
  t
}

// Collect expression (C-style)
fn synthCollect(checker, node) {
  if node.init { synthExpr(checker, node.init) }
  if node.condition { synthExpr(checker, node.condition) }
  if node.update { synthExpr(checker, node.update) }

  let bodyType = typeAny()
  if node.body {
    bodyType = synthExpr(checker, node.body)
  }

  let t = typeArray(bodyType)
  checker.types[node.id] = t
  t
}

// Collect-in expression
fn synthCollectIn(checker, node) {
  let iterableType = synthExpr(checker, node.iterable)

  // Bind the value binder
  if node.valueBinder {
    let elemType = freshTypeVar(checker)
    constrain(checker, iterableType, typeArray(elemType))

    let binding = checker.resolvedNames[node.id]
    if binding and binding.valueBinderDeclId {
      envBind(checker, binding.valueBinderDeclId, elemType)
      let recordType = recordFromKeysCall(checker, node.iterable)
      if !recordType and node.iterable and node.iterable.type == NODE.Identifier {
        let iterBinding = checker.resolvedNames[node.iterable.id]
        if iterBinding and iterBinding.declaredAt {
          recordType = checker.keysSourceByDeclId[iterBinding.declaredAt]
        }
      }
      if recordType { checker.keyBindingRecord[binding.valueBinderDeclId] = recordType }
    }
  }

  let bodyType = typeAny()
  if node.body {
    bodyType = synthExpr(checker, node.body)
  }

  let t = typeArray(bodyType)
  checker.types[node.id] = t
  t
}

// Return statement
fn synthReturn(checker, node) {
  let valueType = typeNil()
  if node.value {
    valueType = synthExpr(checker, node.value)
  }

  // Constrain to current function's return type
  if checker.currentReturn {
    constrain(checker, valueType, checker.currentReturn)
  }

  checker.types[node.id] = valueType
  valueType
}

// Assignment
fn synthAssignment(checker, node) {
  let valueType = synthExpr(checker, node.value)

  // Special handling for dot assignment (closed record model)
  if node.target.type == NODE.Dot {
    let dotNode = node.target
    let objType = synthExpr(checker, dotNode.object)
    let objD = deref(checker, objType)
    let propNode = dotNode.property
    let fieldName = propNode.value or propNode.name or propNode

    // Cannot assign to field on optional value
    if objD.kind != "TypeVar" and typeHasNilEvidence(checker, objType) {
      addError(checker, node.id, "Cannot assign to field on optional value")
      checker.types[node.id] = valueType
      return valueType
    }

    // For TypeVar, add constraint that it must have this field
    // But error if it's an uninitialized local (nil at runtime)
    if objD.kind == "TypeVar" {
      if objD.uninitializedLocal {
        addError(checker, dotNode.id, "Cannot access field on nil value")
        checker.types[node.id] = valueType
        return valueType
      }
      let requiredRecord = typeRecord(.{ [fieldName]: valueType })
      if !constrain(checker, objType, requiredRecord) {
        addError(checker, dotNode.id, "Cannot access field '" + fieldName + "' on type " + prettyType(checker, objType))
      }
      checker.types[dotNode.id] = valueType
      checker.types[node.id] = valueType
      return valueType
    }

    // For Record, check field exists
    if objD.kind == "Record" {
      let fieldType = objD.fields and objD.fields[fieldName]
      if !fieldType {
        addError(checker, dotNode.id, "Missing field: " + fieldName)
        checker.types[node.id] = valueType
        return valueType
      }
      if fieldType.kind == "TypeVar" {
        let existingBounds = fieldType.lowerBounds or []
        let dv = deref(checker, valueType)
        if dv.kind == "TypeVar" { dv = coalesceTypeVar(checker, dv) }
        for lb in existingBounds {
          let dlb = deref(checker, lb)
          if dlb.kind == "TypeVar" { dlb = coalesceTypeVar(checker, dlb) }
          if dlb.kind == "TypeVar" or dv.kind == "TypeVar" { continue }
          if dlb.kind == "Nil" or dv.kind == "Nil" { continue }
          if isSubtype(checker, dv, dlb) or isSubtype(checker, dlb, dv) {
            continue
          }
          addError(checker, node.id, "Assignment mismatch")
          checker.types[dotNode.id] = fieldType
          checker.types[node.id] = valueType
          return valueType
        }
      }
      // Constrain value to field type
      if !constrain(checker, valueType, fieldType) {
        addError(checker, node.id, "Assignment mismatch")
      }
      checker.types[dotNode.id] = fieldType
      checker.types[node.id] = valueType
      return valueType
    }

    // Non-record type
    if objD.kind != "Any" {
      addError(checker, dotNode.id, "Cannot access field on type " + prettyType(checker, objType))
    }
    checker.types[node.id] = valueType
    return valueType
  }

  // Special handling for index assignment
  if node.target.type == NODE.Index {
    let indexNode = node.target
    let objType = synthExpr(checker, indexNode.object)
    let indexType = synthExpr(checker, indexNode.index)
    let objD = deref(checker, objType)
    let indexTypeD = deref(checker, indexType)

    // Determine if key is numeric or string
    let keyIsNumeric = indexTypeD.kind == "Number"
    let keyIsString = indexTypeD.kind == "String"
    let keyIsTypeVar = indexTypeD.kind == "TypeVar"

    // For hashmap/map key type validation
    if objD.kind == "Record" or objD.kind == "Map" or objD.kind == "TypeVar" or objD.kind == "Indexable" {
      if !keyIsNumeric and !keyIsString and !keyIsTypeVar {
        addError(checker, node.id, "Hashmap key type must be number or string.")
        checker.types[node.id] = valueType
        return valueType
      }
    }

    // Try to get the constant key value
    // First check pre-computed facts for simple literals
    let keyValue = checker.facts and checker.facts.literalKeyValue[indexNode.id]

    // If not found in facts, try enum member access (needs type info)
    if keyValue == nil {
      let unwrappedIndex = unwrapGroupings(indexNode.index)
      if unwrappedIndex.type == NODE.Dot {
        // Check if it's an enum member access
        let objIndexType = checker.types[unwrappedIndex.object.id]
        let objIndexD = objIndexType and deref(checker, objIndexType)
        if objIndexD and objIndexD.kind == "Enum" and objIndexD.fields {
          let memberName = unwrappedIndex.property.value or unwrappedIndex.property.name
          let memberValue = objIndexD.fields[memberName]
          if memberValue != nil {
            keyValue = memberValue
          }
        }
      }
    }

    if objD.kind == "Indexable" {
      constrain(checker, indexType, objD.key)
      constrain(checker, valueType, objD.elem)
      if keyIsNumeric { objD.sawNumericIndex = true }
      checker.types[indexNode.id] = objD.elem
      checker.types[node.id] = valueType
      return valueType
    }

    if objD.kind == "Record" {
      if keyValue != nil {
        // Check if field exists
        let fieldType = objD.fields and objD.fields[keyValue]
        if !fieldType {
          addError(checker, indexNode.id, "Missing field: " + str(keyValue))
          checker.types[node.id] = valueType
          return valueType
        }
        // Constrain value to field type
        if !constrain(checker, valueType, fieldType) {
          addError(checker, node.id, "Assignment mismatch")
        }
        checker.types[indexNode.id] = fieldType
        checker.types[node.id] = valueType
        return valueType
      }
      // Variable key - can't determine field at compile time
      // Return optional based on field types
      let fieldKeys = keys(objD.fields)
      let commonType = freshTypeVar(checker)
      for fk in fieldKeys {
        constrain(checker, objD.fields[fk], commonType)
      }
      constrain(checker, valueType, commonType)
      checker.types[indexNode.id] = commonType
      checker.types[node.id] = valueType
      return valueType
    }

    if objD.kind == "TypeVar" {
      // Unknown object - infer based on key type
      if keyIsNumeric {
        // Numeric key - infer Array
        let elemVar = internIndexElemVar(checker, objD.id, "number")
        let arrType = typeArray(elemVar)
        constrain(checker, objType, arrType)
        let objBinding = checker.resolvedNames[indexNode.object.id]
        if objBinding and objBinding.declaredAt {
          envBind(checker, objBinding.declaredAt, arrType)
        }
        if !constrain(checker, valueType, elemVar) {
          addError(checker, node.id, "Assignment mismatch")
        }
        checker.types[indexNode.id] = elemVar
        checker.types[node.id] = valueType
        return valueType
      } else if keyIsString {
        // String key - infer Map
        let elemVar = internIndexElemVar(checker, objD.id, "string")
        let mapType = helper.typeMap(indexType, elemVar)
        constrain(checker, objType, mapType)
        let objBinding = checker.resolvedNames[indexNode.object.id]
        if objBinding and objBinding.declaredAt {
          envBind(checker, objBinding.declaredAt, mapType)
        }
        if !constrain(checker, valueType, elemVar) {
          addError(checker, node.id, "Assignment mismatch")
        }
        checker.types[indexNode.id] = elemVar
        checker.types[node.id] = valueType
        return valueType
      }
      // TypeVar key - keep element type stable without narrowing to Nil
      let elemVar = internIndexElemVar(checker, objD.id, "any")
      if !constrain(checker, valueType, elemVar) {
        addError(checker, node.id, "Assignment mismatch")
      }
      checker.types[indexNode.id] = elemVar
      checker.types[node.id] = valueType
      return valueType
    }
  }

  // Regular assignment
  let targetType = synthExpr(checker, node.target)

  // Constrain: valueType <: targetType
  if !constrain(checker, valueType, targetType) {
    addError(checker, node.id, "Assignment mismatch: cannot assign " +
      prettyType(checker, valueType) + " to " + prettyType(checker, targetType))
  }

  checker.types[node.id] = valueType
  valueType
}

// Index access
fn synthIndex(checker, node) {
  let objType = synthExpr(checker, node.object)
  let indexType = synthExpr(checker, node.index)

  // Fresh result type
  let resultType = freshTypeVar(checker)

  let objD = deref(checker, objType)
  let indexTypeD = deref(checker, indexType)

  if objD.kind == "Array" {
    // Array indexing - index must be Number, return element type directly
    if indexTypeD.kind != "Number" and indexTypeD.kind != "TypeVar" {
      addError(checker, node.id, "Array index must be a number")
      checker.types[node.id] = resultType
      return resultType
    }
    constrain(checker, indexType, typeNumber())
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "Map" {
    // Map indexing - return element type directly
    constrain(checker, indexType, objD.key)
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "Record" {
    // Record indexing with constant key
    // Use pre-computed facts for literal keys
    let keyValue = checker.facts and checker.facts.literalKeyValue[node.id]

    if keyValue != nil and objD.fields {
      let fieldType = objD.fields[keyValue]
      if fieldType {
        checker.types[node.id] = fieldType
        return fieldType
      }
    }

    // If index key is from keys(record), treat as non-optional
    let indexNode = unwrapGroupings(node.index)
    if indexNode and indexNode.type == NODE.Identifier {
      let binding = checker.resolvedNames[indexNode.id]
      if binding and binding.declaredAt {
        let keyRecord = checker.keyBindingRecord[binding.declaredAt]
        if keyRecord and typeEquals(checker, objType, keyRecord) {
          if objD.fields and len(keys(objD.fields)) > 0 {
            let fieldKeys = keys(objD.fields)
            let commonType = freshTypeVar(checker)
            for fk in fieldKeys {
              constrain(checker, objD.fields[fk], commonType)
            }
            checker.types[node.id] = commonType
            return commonType
          }
        }
      }
    }

    // Variable key on Record - return Option[fieldType]
    // The key might not exist at runtime, so result is optional
    if objD.fields and len(keys(objD.fields)) > 0 {
      // Get the common type of all fields
      let fieldKeys = keys(objD.fields)
      let commonType = freshTypeVar(checker)
      for fk in fieldKeys {
        constrain(checker, objD.fields[fk], commonType)
      }
      let optType = typeOption(commonType)
      checker.types[node.id] = optType
      return optType
    }
    // Empty record - return fresh Option
  } else if objD.kind == "String" {
    // String indexing - index must be Number
    if indexTypeD.kind != "Number" and indexTypeD.kind != "TypeVar" {
      addError(checker, node.id, "String index must be a number")
      checker.types[node.id] = typeString()
      return typeString()
    }
    constrain(checker, indexType, typeNumber())
    checker.types[node.id] = typeString()
    return typeString()
  } else if objD.kind == "Indexable" {
    constrain(checker, indexType, objD.key)
    if indexTypeD.kind == "Number" { objD.sawNumericIndex = true }
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "TypeVar" {
    // Unknown object - check if index type has bounds that tell us Array vs Map
    // Look at index TypeVar's lower bounds to see if it's constrained to String or Number
    if indexTypeD.kind == "TypeVar" {
      let indexBounds = indexTypeD.lowerBounds or []
      for lb in indexBounds {
        let dlb = deref(checker, lb)
        if dlb.kind == "String" {
          // Index is constrained to String - infer Map
          let elemVar = internIndexElemVar(checker, objD.id, "string")
          let mapType = helper.typeMap(typeString(), elemVar)
          constrain(checker, objType, mapType)
          checker.types[node.id] = elemVar
          return elemVar
        } else if dlb.kind == "Number" {
          // Index is constrained to Number - infer Array
          let elemVar = internIndexElemVar(checker, objD.id, "number")
          let arrType = typeArray(elemVar)
          constrain(checker, objType, arrType)
          checker.types[node.id] = elemVar
          return elemVar
        }
      }
      let elemVar = internIndexElemVar(checker, objD.id, "any")
      checker.types[node.id] = elemVar
      return elemVar
    } else if indexTypeD.kind == "String" {
      // Concrete String index - infer Map
      let elemVar = internIndexElemVar(checker, objD.id, "string")
      let mapType = helper.typeMap(typeString(), elemVar)
      constrain(checker, objType, mapType)
      checker.types[node.id] = elemVar
      return elemVar
    } else if indexTypeD.kind == "Number" {
      // Concrete Number index - infer Array
      let elemVar = internIndexElemVar(checker, objD.id, "number")
      let arrType = typeArray(elemVar)
      constrain(checker, objType, arrType)
      checker.types[node.id] = elemVar
      return elemVar
    }
    let elemVar = internIndexElemVar(checker, objD.id, "any")
    checker.types[node.id] = elemVar
    return elemVar
  }

  checker.types[node.id] = resultType
  resultType
}

// Import
fn synthImport(checker, node) {
  // Imports return the exported value
  let importInfo = checker.resolveResult and checker.resolveResult.importInfoByNodeId or .{}
  let info = importInfo[node.id]
  let t = info and info.importType
  if !t and checker.program and checker.program.exports {
    let importPath = info and info.importResult and info.importResult.path or nil
    if !importPath and node.path and node.path.type == NODE.String {
      importPath = node.path.value
    }
    if importPath { t = checker.program.exports[importPath] }
  }
  if t {
    let cloned = cloneType(checker, t, .{})
    checker.types[node.id] = cloned
    return cloned
  }
  t = typeAny()
  checker.types[node.id] = t
  t
}

// Arrow operator (pipeline)
fn synthArrow(checker, node) {
  // x->f(a) is like f(x, a)
  // The right side should be a Call node
  if node.right.type == NODE.Call {
    // Synthesize x
    synthExpr(checker, node.left)
    // Synthesize the call (which includes x as implicit first arg)
    return synthExpr(checker, node.right)
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Intrinsic call
fn synthIntrinsicCall(checker, node) {
  let args = node.args or []

  // Handle specific intrinsics
  if node.intrinsic == "array_new" {
    // array_new() creates an empty array with fresh element type
    let elemType = freshTypeVar(checker)
    let t = typeArray(elemType)
    checker.types[node.id] = t
    return t
  }

  if node.intrinsic == "array_push" or node.intrinsic == "array_append" {
    // array_push/array_append(arr, elem) - constrain elem to array's element type
    if len(args) >= 2 {
      let arrType = synthExpr(checker, args[0])
      let elemType = synthExpr(checker, args[1])
      let arrD = deref(checker, arrType)
      if arrD.kind == "Array" {
        constrain(checker, elemType, arrD.elem)
      } else if arrD.kind == "TypeVar" {
        // Constrain arrType to be Array[elemType]
        constrain(checker, arrType, typeArray(elemType))
      }
      let t = typeNil()  // push/append returns nil
      checker.types[node.id] = t
      return t
    }
  }

  // Default: synthesize args and return Any
  for arg in args {
    synthExpr(checker, arg)
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Main expression synthesizer - dispatches by node type
fn synthExpr(checker, node) {
  if !node { return typeNil() }

  if node.type == NODE.ExprStmt { return synthExprStmt(checker, node) }
  if node.type == NODE.Number or node.type == NODE.String or
     node.type == NODE.Bool or node.type == NODE.Nil {
    return synthLiteral(checker, node)
  }
  if node.type == NODE.Identifier { return synthIdentifier(checker, node) }
  if node.type == NODE.Let { return synthLet(checker, node) }
  if node.type == NODE.Function { return synthFunction(checker, node) }
  if node.type == NODE.Call { return synthCall(checker, node) }
  if node.type == NODE.Hashmap { return synthHashmap(checker, node) }
  if node.type == NODE.Dot { return synthDot(checker, node) }
  if node.type == NODE.If { return synthIf(checker, node) }
  if node.type == NODE.Array { return synthArray(checker, node) }
  if node.type == NODE.Binary { return synthBinary(checker, node) }
  if node.type == NODE.Unary { return synthUnary(checker, node) }
  if node.type == NODE.Logical { return synthLogical(checker, node) }
  if node.type == NODE.Block { return synthBlock(checker, node) }
  if node.type == NODE.Grouping {
    let inner = synthExpr(checker, node.expression)
    checker.types[node.id] = inner
    return inner
  }
  if node.type == NODE.For { return synthFor(checker, node) }
  if node.type == NODE.ForIn { return synthForIn(checker, node) }
  if node.type == NODE.Collect { return synthCollect(checker, node) }
  if node.type == NODE.CollectIn { return synthCollectIn(checker, node) }
  if node.type == NODE.Return { return synthReturn(checker, node) }
  if node.type == NODE.Assignment { return synthAssignment(checker, node) }
  if node.type == NODE.Index { return synthIndex(checker, node) }
  if node.type == NODE.Import { return synthImport(checker, node) }
  if node.type == NODE.Arrow { return synthArrow(checker, node) }
  if node.type == NODE.IntrinsicCall { return synthIntrinsicCall(checker, node) }
  if node.type == NODE.Break or node.type == NODE.Continue {
    checker.types[node.id] = typeNil()
    return typeNil()
  }

  // For unhandled nodes, assign Any
  let t = typeAny()
  if node.id {
    checker.types[node.id] = t
  }
  t
}

// ========================================================
// Public API
// ========================================================

fn typecheck(ast, resolveResult, opts) {
  // Check preconditions
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  if !ast {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Missing AST", severity: "error" }],
    }
  }

  // Phase 1: Compute facts (pre-computed static properties)
  let facts = computeFacts(ast, resolveResult)

  // Create checker with data from other passes
  let checker = makeChecker(resolveResult, opts)
  checker.facts = facts  // Store facts in checker for access during synthesis

  // Traverse the AST
  synthExpr(checker, ast)

  // Solve deferred range/keys constraints
  helper.solveBuiltinConstraints(checker)

  // Post-pass consistency check for bounds and open caches (opt-in)
  if opts and opts.checkConsistency {
    checkConstraintConsistency(checker)
  }

  // Return results
  .{
    success: !checker.hadError,
    types: checker.types,           // Node ID -> type
    errors: checker.errors,         // List of error objects
    recordEnumKeyOrigins: checker.recordEnumKeyOrigins,  // Track enum keys in records
  }
}

typecheck
