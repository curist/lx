// Typecheck: builtin functions
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref

  test("typecheck - numeric/string conversion builtins", fn(assert) {
    let result = parseAndTypecheck("{ Math.floor(123.456)\ntonumber(\"123.456\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - string builtins", fn(assert) {
    let result = parseAndTypecheck("{ tolower(\"A\")\ntoupper(\"a\")\nsplit(\"a,b\", \",\")\njoin([1, 2], \",\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
    let lt = deref(result, getExprType(result, 2))
    assert.equal(lt.kind, "Array")
    assert.equal(deref(result, lt.elem).kind, "String")
    assert.equal(deref(result, getExprType(result, 3)).kind, "String")
  })

  test("typecheck - array builtins are polymorphic per use", fn(assert) {
    let result = parseAndTypecheck("{ let a = [1]\npush(a, 2)\npop(a)\nconcat([1], [2]) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "Array")
    let popt = deref(result, getExprType(result, 2))
    assert.equal(popt.kind, "Option")
    assert.equal(deref(result, popt.value).kind, "Number")
    let ct = deref(result, getExprType(result, 3))
    assert.equal(ct.kind, "Array")
    assert.equal(deref(result, ct.elem).kind, "Number")
  })

  test("typecheck - Date and Lx builtins typecheck via dot access", fn(assert) {
    let result = parseAndTypecheck("{ Date.RFC3339\nDate.now()\nLx.args\nLx.doubleToUint8Array(1) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    let at = deref(result, getExprType(result, 2))
    assert.equal(at.kind, "Array")
    assert.equal(deref(result, at.elem).kind, "String")
    let bt = deref(result, getExprType(result, 3))
    assert.equal(bt.kind, "Array")
    assert.equal(deref(result, bt.elem).kind, "Number")
  })

  test("typecheck - len works for array and string", fn(assert) {
    let result = parseAndTypecheck("{ len([1, 2])\nlen(\"ab\") }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - len rejects map", fn(assert) {
    let result = parseAndTypecheck("len(.{})")
    assert.truthy(!result.success)
    // This is a typecheck error even though runtime checks are dynamic.
    assert.truthy(helpers.hasError(result, "len() requires array or string"))
  })

  test("typecheck - len behavior preserved through alias", fn(assert) {
    let ok = parseAndTypecheck("{ let f = len\nf([1, 2]) }")
    assert.truthy(ok.success)
    if !ok.success { return }
    assert.equal(deref(ok, getExprType(ok, 1)).kind, "Number")

    let bad = parseAndTypecheck("{ let f = len\nf(.{}) }")
    assert.truthy(!bad.success)
    assert.truthy(helpers.hasError(bad, "len() requires array or string"))
  })

  test("typecheck - range works for array/number/string", fn(assert) {
    let result = parseAndTypecheck("{
      range([1, 2])[0]
      range(3)[0]
      range(\"ab\")[0]
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 2)).kind, "String")
  })

  test("typecheck - range works for Map and preserves key type", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{}\nm[\"a\"] = 1\nrange(m)[0] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 2)).kind, "String")
  })

  test("typecheck - range works for Record", fn(assert) {
    let result = parseAndTypecheck("range(.{ a: 1 })[0]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
  })

  test("typecheck - range behavior preserved through alias", fn(assert) {
    let ok = parseAndTypecheck("{ let r = range\nr(3)[0] }")
    assert.truthy(ok.success)
    if !ok.success { return }
    assert.equal(deref(ok, getExprType(ok, 1)).kind, "Number")
  })

  test("typecheck - range refines after later evidence", fn(assert) {
    let result = parseAndTypecheck("{
      fn f(p) {
        let k = range(p)[0]
        p[\"a\"] = 1
        k
      }
      f(.{})
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
  })

  test("typecheck - keys works for Map and preserves key type", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{}\nm[\"a\"] = 1\nkeys(m)[0] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 2)).kind, "String")
  })

  test("typecheck - keys works for Record", fn(assert) {
    let result = parseAndTypecheck("keys(.{ a: 1 })[0]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
  })

  test("typecheck - keys on mixed-key Record yields Any keys", fn(assert) {
    let result = parseAndTypecheck("keys(.{ a: 1, [2]: 3 })[0]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Any")
  })

  test("typecheck - keys behavior preserved through alias", fn(assert) {
    let ok = parseAndTypecheck("{ let k = keys\nk(.{ a: 1 })[0] }")
    assert.truthy(ok.success)
    if !ok.success { return }
    assert.equal(deref(ok, getExprType(ok, 1)).kind, "String")
  })

  test("typecheck - keys refines after later evidence", fn(assert) {
    // Regression test: if keys(p) is treated as "solved" while p is still unknown,
    // it will freeze the result to Array[Any] and lose the ability to refine once
    // p becomes a Map via index assignment.
    let result = parseAndTypecheck("{
      fn f(p) {
        let k = keys(p)[0]
        p[\"a\"] = 1
        k
      }
      f(.{})
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
  })

  test("typecheck - nameOf works for enum", fn(assert) {
    let result = parseAndTypecheck("{ let Color = enum { Red, Green = 3, Blue }\nnameOf(Color, Color.Red) }")
    assert.truthy(result.success)
    if !result.success { return }
    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "String")
  })

  test("typecheck - nameOf rejects non-enum", fn(assert) {
    let result = parseAndTypecheck("nameOf([1, 2], 1)")
    assert.truthy(!result.success)
    assert.truthy(helpers.hasError(result, "nameOf() requires enum"))
  })

  test("typecheck - nameOf rejects map/record", fn(assert) {
    let result = parseAndTypecheck("nameOf(.{ a: 1 }, 1)")
    assert.truthy(!result.success)
    assert.truthy(helpers.hasError(result, "nameOf() requires enum"))
  })

  test("typecheck - nameOf constrains value type for enum", fn(assert) {
    let result = parseAndTypecheck("{ let Color = enum { Red, Blue }\nnameOf(Color, \"x\") }")
    assert.truthy(!result.success)
    assert.truthy(helpers.hasError(result, "nameOf() value mismatch"))
  })

  test("typecheck - globals.lx prelude builtins", fn(assert) {
    let result = parseAndTypecheck("{
      collect x, i in [1, 2] { x + i }
      fold([1, 2], 0, fn(acc, x, i, abort) { acc + x + i })
      _2(fn(a, b) { a + b })(1, 2)
      sort([3, 1, 2], fn(a, b) { a < b })
      startsWith(\"abc\", \"a\")
    }")
    assert.truthy(result.success)
    if !result.success { return }

    let mt = deref(result, getExprType(result, 0))
    assert.equal(mt.kind, "Array")
    assert.equal(deref(result, mt.elem).kind, "Number")

    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")

    let st = deref(result, getExprType(result, 3))
    assert.equal(st.kind, "Array")
    assert.equal(deref(result, st.elem).kind, "Number")

    assert.equal(deref(result, getExprType(result, 4)).kind, "Bool")
  })

  test("typecheck - collect preserves element types per use-site", fn(assert) {
    let result = parseAndTypecheck("{
      let n = (collect x in [1, 2, 3] { x })[0]
      let s = (collect x in [\"a\", \"b\"] { x })[0]
      n
      s
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
  })
}

.{ register }
