// Resolve Phase - Name resolution and semantic validation
// Responsibility: Binding analysis and contextual legality enforcement
//   - Name resolution (locals, upvalues, globals)
//   - Function hoisting for mutual recursion
//   - Semantic validation (return/break/continue placement, etc.)
//   - Build side tables for codegen
//
// IMPORTANT: Resolve MUST NOT mutate the AST.
// All information stored in side tables keyed by node ID.

let .{ OP, NODE } = import "src/types.lx"

// ========================================
// Data Structures
// ========================================

// Scope - represents a lexical scope
fn Scope(enclosing, type) {
  // Blocks and loops should continue the function's slot counter, not start from 0
  // Only functions start fresh at slot 0
  let initialSlot = 0
  if (type == "block" or type == "loop") and enclosing {
    initialSlot = enclosing.nextSlot
  }

  .{
    enclosing: enclosing,
    type: type,  // "function" | "block" | "loop"
    depth: enclosing and enclosing.depth + 1 or 0,

    localsByName: .{},       // name → Local
    localsArray: [],         // [Local] - preserve declaration order!
    hoistedFns: .{},         // name → HoistedFunction
    lastHoistedFunctionIndex: -1,
    upvalues: [],            // [Upvalue]
    upvalueIndexByKey: .{},  // "L:<captured>" | "U:<captured>" -> index (perf: avoid O(n) scans)
    baseSlot: initialSlot,   // NEW: restore point for block/loop scopes
    nextSlot: initialSlot,   // Start from function's current slot for blocks/loops
  }
}

// Local - represents a local variable
fn Local(name, depth, kind, slot, nodeId) {
  .{
    name: name,
    depth: depth,        // -1 = uninitialized, depth when initialized
    kind: kind,          // "var" | "fn" | "param"
    slot: slot,          // Stable slot ID
    nodeId: nodeId,      // Declaration node ID
    isCaptured: false,   // Set to true if captured by closure
  }
}

// Upvalue - represents a captured variable
// For isLocal=true: captured is the nodeId of the captured local declaration
// For isLocal=false: captured is the upvalue index being captured from parent
fn Upvalue(index, isLocal, captured, slot) {
  .{
    index: index,
    isLocal: isLocal,
    captured: captured,  // nodeId for local captures, upvalue index for indirect captures
    slot: slot,  // Actual slot number for local captures, nil for indirect captures
  }
}

// HoistedFunction - metadata for hoisted functions
fn HoistedFunction(declNodeId, declIndex, slot) {
  .{
    declNodeId: declNodeId,   // AST node ID of function declaration
    declIndex: declIndex,     // Position in block.expressions
    slot: slot,               // Slot assigned
  }
}

// Resolver - main resolution state
fn makeResolver(opts) {
  .{
    // Side tables (output)
    resolvedNames: .{},    // nodeId → BindingInfo
    scopeInfo: .{},        // nodeId → ScopeInfo
    assignmentInfo: .{},   // nodeId → AssignmentInfo (for Assignment nodes)
    importInfoByNodeId: .{}, // nodeId → { importResult, importType, importBindings }
    nodes: .{},            // nodeId → AST node (built during traversal)
    errors: [],            // [{ nodeId, message, severity }]
    hadError: false,

    // State
    currentScope: nil,     // Current scope object

    // Options
    importCache: opts.importCache or .{},
    compileModule: opts.compileModule,  // Callback: fn(path) → result
  }
}

// ========================================
// Error Handling
// ========================================

fn addError(resolver, nodeId, message) {
  // we only have error severity for now.
  // other severities are info & warning
  resolver.hadError = true
  push(resolver.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Scope Management
// ========================================

fn beginScope(resolver, type) {
  let newScope = Scope(resolver.currentScope, type)
  resolver.currentScope = newScope
  newScope
}

fn endScope(resolver, nodeId) {
  let scope = resolver.currentScope
  if !scope {
    return  // Compiler bug guard
  }

  // Record scope info in side table
  resolver.scopeInfo[nodeId] = .{
    scopeType: scope.type,
    depth: scope.depth,
    locals: scope.localsArray,
    upvalues: scope.upvalues,
    hoistedFns: scope.hoistedFns,  // Full map: name → { declNodeId, declIndex, slot }
    lastHoistedFunctionIndex: scope.lastHoistedFunctionIndex,
    nextSlot: scope.nextSlot,
  }

  // CRITICAL FIX: Restore parent's nextSlot for block/loop scopes
  // This makes slots reusable (stack-based model), matching codegen's POP behavior
  // Previously we propagated nextSlot upward (monotonic model), but that doesn't match
  // the value stack which shrinks when scopes end
  if (scope.type == "block" or scope.type == "loop") and scope.enclosing {
    scope.enclosing.nextSlot = scope.baseSlot
  }

  // Pop to enclosing scope
  resolver.currentScope = scope.enclosing
}

// ========================================
// Local Declaration
// ========================================

fn declareLocal(resolver, name, kind, nodeId) {
  let scope = resolver.currentScope
  if !scope {
    return nil  // Global scope - no local
  }

  // Special case: '_' is a discard variable - allow multiple declarations
  if name == "_" {
    // Allocate a new slot each time
    let slot = scope.nextSlot
    scope.nextSlot = scope.nextSlot + 1

    // Create local (uninitialized: depth = -1)
    let local = Local(name, -1, kind, slot, nodeId)

    // Don't add to localsByName (so next '_' won't conflict)
    // But add to localsArray for scope cleanup
    push(scope.localsArray, local)

    return local
  }

  // Check for duplicate in current scope
  if scope.localsByName[name] {
    addError(resolver, nodeId, "Variable '" + name + "' already declared in this scope")
    return nil
  }

  // Allocate slot
  let slot = scope.nextSlot
  scope.nextSlot = scope.nextSlot + 1


  // Create local (uninitialized: depth = -1)
  let local = Local(name, -1, kind, slot, nodeId)

  // Add to scope
  scope.localsByName[name] = local
  push(scope.localsArray, local)

  local
}

fn markInitialized(resolver, local) {
  if local {
    let scope = resolver.currentScope
    local.depth = scope.depth
  }
}

// ========================================
// Upvalue Handling
// ========================================

fn addUpvalue(resolver, scope, isLocal, captured, slot) {
  // For isLocal captures: captured is nodeId, for indirect: captured is upvalue index
  let key = (isLocal and "L:" or "U:") + str(captured)
  let existing = scope.upvalueIndexByKey[key]
  if existing != nil {
    return existing
  }

  // Add new upvalue
  let index = len(scope.upvalues)
  push(scope.upvalues, Upvalue(index, isLocal, captured, slot))
  scope.upvalueIndexByKey[key] = index
  index
}

fn markCaptured(local) {
  if local {
    local.isCaptured = true
  }
}

fn resolveUpvalue(resolver, scope, name, nodeId) {
  if !scope or !scope.enclosing { return }  // At root scope

  // Walk scopes iteratively to avoid deep recursion.
  // Track only function scopes (blocks/loops don't carry upvalues at runtime).
  let functionScopes = []  // innermost -> outermost (closest to definition at end)
  let functionCount = 0

  let current = scope
  for current and current.enclosing {
    if current.type == "function" {
      push(functionScopes, current)
      functionCount = functionCount + 1
    }

    let enclosing = current.enclosing
    let local = enclosing.localsByName[name]
    if local {
      if local.depth == -1 {
        addError(resolver, nodeId, "Can't read local variable '" + name + "' in its own initializer")
        return nil
      }
      markCaptured(local)

      // If there is no intervening function scope, this is a local reference.
      if len(functionScopes) == 0 {
        return nil
      }

      // The outermost function scope in the chain captures the local directly.
      // CRITICAL FIX: Pass nodeId instead of slot for robust slot mapping in codegen
      let index = addUpvalue(resolver, functionScopes[len(functionScopes) - 1], true, local.nodeId, local.slot)

      // Inner function scopes capture indirectly via their parent's upvalue index.
      for let i = len(functionScopes) - 2; i >= 0; i = i - 1 {
        index = addUpvalue(resolver, functionScopes[i], false, index, index)
      }

      return .{
        index: index,
        isLocal: functionCount == 1,
      }
    }

    current = enclosing
  }

  nil
}

// ========================================
// Name Resolution
// ========================================

fn resolveName(resolver, name, nodeId) {
  // Special case: '_' is write-only, can't be read
  if name == "_" {
    addError(resolver, nodeId, "Cannot read from discard variable '_'")
    return
  }

  let scope = resolver.currentScope

  // Walk up scope chain
  let current = scope
  for current {
    // Check locals
    let local = current.localsByName[name]
    if local {
      // Check read-before-init
      if local.depth == -1 {
        addError(resolver, nodeId, "Can't read local variable '" + name + "' in its own initializer")
        return
      }

      // Local found
      if current == scope {
        // Same scope - direct local access
        resolver.resolvedNames[nodeId] = .{
          kind: "local",
          getOp: OP.GET_LOCAL,
          setOp: OP.SET_LOCAL,
          slot: local.slot,
          declaredAt: local.nodeId,
          depth: current.depth,
          // Note: isCaptured is NOT stored here - codegen should read it from scopeInfo.locals
        }
      } else {
        // Different scope - check if we cross a function boundary
        // Only create upvalues if crossing function boundary
        let crossesFunctionBoundary = false
        let s = scope
        for s and s != current {
          if s.type == "function" {
            crossesFunctionBoundary = true
            break
          }
          s = s.enclosing
        }

        if crossesFunctionBoundary {
          // Need upvalue
          let upvalue = resolveUpvalue(resolver, scope, name, nodeId)
          if upvalue {
            resolver.resolvedNames[nodeId] = .{
              kind: "upvalue",
              getOp: OP.GET_UPVALUE,
              setOp: OP.SET_UPVALUE,
              upvalueIndex: upvalue.index,
              declaredAt: local.nodeId,
              depth: current.depth,
            }
          }
        } else {
          // Same function, different block - still direct local access
          resolver.resolvedNames[nodeId] = .{
            kind: "local",
            getOp: OP.GET_LOCAL,
            setOp: OP.SET_LOCAL,
            slot: local.slot,
            declaredAt: local.nodeId,
            depth: current.depth,
          }
        }
      }
      return
    }

    current = current.enclosing
  }

  // Not found in any local scope - assume builtin/external
  resolver.resolvedNames[nodeId] = .{
    kind: "builtin",
    getOp: OP.GET_GLOBAL,
    setOp: OP.SET_GLOBAL,
    name: name,
  }
}

fn resolveIdentifier(resolver, node, context) {
  let name = node.name
  let scope = resolver.currentScope

  // Check if this is a hoisted function in current block scope
  if scope and scope.hoistedFns[name] {
    let hoisted = scope.hoistedFns[name]

    // Block-level calls require exprIndex >= function's own declIndex
    // This allows calling a function after its declaration, even if later functions exist
    // (Permits mutual recursion while preventing use-before-declaration)
    if context and !context.inFunctionBody {
      if context.exprIndex < hoisted.declIndex {
        addError(resolver, node.id,
          "Cannot use hoisted function '" + name + "' before it is declared")
        return
      }
    }

    // Valid hoisted function reference
    resolver.resolvedNames[node.id] = .{
      kind: "local",
      getOp: OP.GET_LOCAL,
      setOp: OP.SET_LOCAL,
      slot: hoisted.slot,
      declaredAt: hoisted.declNodeId,
      depth: scope.depth,
    }
    return
  }

  // Regular name resolution
  resolveName(resolver, name, node.id)
}

// ========================================
// Semantic Validation Helpers
// ========================================

fn isInLoop(scope) {
  let current = scope
  for current {
    if current.type == "loop" { return true }
    current = current.enclosing
  }
  false
}

fn isInFunction(scope) {
  let current = scope
  for current {
    if current.type == "function" { return true }
    current = current.enclosing
  }
  false
}

// ========================================
  // Import Handling
  // ========================================

  fn resolveImport(resolver, node) {
  // Add path node to nodes map if it exists
  if node.path and node.path.id {
    resolver.nodes[node.path.id] = node.path
  }

  // Import path must be a string literal
  if !node.path or node.path.type != NODE.String {
    addError(resolver, node.id, "Import path must be a string literal")
    return nil
  }

  let path = node.path.value

  // Helper to extract import type from compilation result
  fn extractImportType(result) {
    if !result or result.status != "done" or
       !result.passes.typecheck or !result.passes.typecheck.success {
      return nil
    }

    // Use the same AST that was typechecked (prefer post-resolve transforms)
    let modAst = (result.passes["lower-intrinsics"] and result.passes["lower-intrinsics"].ast) or
                 (result.passes["anf-inline"] and result.passes["anf-inline"].ast) or
                 (result.passes.anf and result.passes.anf.ast) or
                 (result.passes.lower and result.passes.lower.ast)
    let modTypes = result.passes.typecheck.types
    let modBindings = result.passes.typecheck.typeVarBindings

    if modAst and modAst.expressions and len(modAst.expressions) > 0 and modTypes {
      let lastExpr = modAst.expressions[len(modAst.expressions) - 1]
      return .{
        importType: modTypes[lastExpr.id],
        importBindings: modBindings,
      }
    }

    nil
  }

  // Check cache if available
    if resolver.importCache {
      let cached = resolver.importCache[path]
      if cached {
        // Check for circular import (status is neither done nor failed)
        if cached.status != "done" and cached.status != "failed" {
          addError(resolver, node.id, "Circular import detected: " + path)
          return nil
        }

        // Check if cached import compilation failed
        if cached.status == "failed" {
          let errMsg = "Failed to import module: " + path
          if cached.passes and cached.passes.parse and cached.passes.parse.errors and len(cached.passes.parse.errors) > 0 {
            errMsg = errMsg + " (" + cached.passes.parse.errors[0] + ")"
          }
          addError(resolver, node.id, errMsg)
        }

        // Store import metadata in side table (consistent with non-cached path)
        let importInfo = .{ importResult: cached }
        let typeInfo = extractImportType(cached)
        if typeInfo {
          importInfo.importType = typeInfo.importType
          importInfo.importBindings = typeInfo.importBindings
        }
        resolver.importInfoByNodeId[node.id] = importInfo

      // Already compiled successfully or failed - return cached result
      return cached
    }
  }

    // Compile module via callback if provided
    if resolver.compileModule {
      let result = resolver.compileModule(path)

      // Check if import compilation failed
      if result and result.status == "failed" {
        let errMsg = "Failed to import module: " + path
        if result.passes and result.passes.parse and result.passes.parse.errors and len(result.passes.parse.errors) > 0 {
          errMsg = errMsg + " (" + result.passes.parse.errors[0] + ")"
        }
        addError(resolver, node.id, errMsg)
      }

      // Store import metadata in side table
      let importInfo = .{ importResult: result }
      let typeInfo = extractImportType(result)
      if typeInfo {
        importInfo.importType = typeInfo.importType
        importInfo.importBindings = typeInfo.importBindings
      }

      resolver.importInfoByNodeId[node.id] = importInfo
      return result
    }

  // No callback - import will be handled at runtime
  nil
}

// ========================================
// Function and Block Resolution
// ========================================


fn resolveFunction(resolver, node, context) {
  // Create function scope
  beginScope(resolver, "function")

  // Named function expressions bind their name inside their own body
  // (enables recursion without introducing an outer-scope binding).
  if node.name and node.name.type == NODE.Identifier {
    let local = declareLocal(resolver, node.name.name, "fn", node.id)
    // Mark initialized immediately so the name is usable within the body.
    markInitialized(resolver, local)
  }

  // Declare parameters as locals
  for let i = 0; i < len(node.params); i = i + 1 {
    let param = node.params[i]
    let local = declareLocal(resolver, param.name, "param", param.id)
    markInitialized(resolver, local)
  }

  // Resolve function body (with inFunctionBody = true)
  let bodyContext = .{
    exprIndex: 0,
    inFunctionBody: true,  // Disable hoisting ordering check in function bodies
  }
  resolveExpr(resolver, node.body, bodyContext)

  endScope(resolver, node.id)
}

fn resolveBlockWithHoisting(resolver, node, context) {
  // Two-phase block resolution for hoisting
  let scope = resolver.currentScope
  let isRootBlock = context and context.atTopLevel and !context.parentBlock

  // PHASE 1: Prescan for hoisted functions
  let lastHoistedIndex = -1
  for let i = 0; i < len(node.expressions); i = i + 1 {
    let expr = node.expressions[i]
    if expr.type == NODE.Function and expr.name {
      // Named function declaration - hoist it
      let fnName = expr.name.name
      // Declare at function node id, not name node id - the function type belongs to the function
      let local = declareLocal(resolver, fnName, "fn", expr.id)

      // Mark as initialized immediately (hoisting!)
      // This allows mutual recursion in function bodies
      markInitialized(resolver, local)

      // Store hoisting metadata
      scope.hoistedFns[fnName] = HoistedFunction(
        expr.id,     // declNodeId
        i,           // declIndex
        local.slot   // slot
      )

      lastHoistedIndex = i
    }
  }

  scope.lastHoistedFunctionIndex = lastHoistedIndex

  // PHASE 2: Resolve all expressions
  let exprCount = len(node.expressions)
  for let i = 0; i < exprCount; i = i + 1 {
    let expr = node.expressions[i]
    let blockContext = .{
      exprIndex: i,
      inFunctionBody: context and context.inFunctionBody or false,
      atTopLevel: isRootBlock,
      isLastExpr: i == exprCount - 1,  // Track if this is the last expression
      parentBlock: node,
    }

    resolveExpr(resolver, expr, blockContext)
  }
}

// ========================================
// Expression Resolution
// ========================================

let resolveExprHandlers = .{
  [NODE.Identifier]: fn(resolver, node, context) {
    resolveIdentifier(resolver, node, context)
  },
  [NODE.Number]: fn(resolver, node, context) { nil },
  [NODE.String]: fn(resolver, node, context) { nil },
  [NODE.Bool]: fn(resolver, node, context) { nil },
  [NODE.Nil]: fn(resolver, node, context) { nil },
  [NODE.Binary]: fn(resolver, node, context) {
    resolveExpr(resolver, node.left, context)
    resolveExpr(resolver, node.right, context)
  },
  [NODE.Logical]: fn(resolver, node, context) {
    resolveExpr(resolver, node.left, context)
    resolveExpr(resolver, node.right, context)
  },
  [NODE.Unary]: fn(resolver, node, context) {
    resolveExpr(resolver, node.operand, context)
  },
  [NODE.Grouping]: fn(resolver, node, context) {
    resolveExpr(resolver, node.expression, context)
  },
  [NODE.Let]: fn(resolver, node, context) {
    // Add name node to nodes map so diagnostics can find it
    if node.name and node.name.id {
      resolver.nodes[node.name.id] = node.name
    }
    let name = node.name.name
    let local = declareLocal(resolver, name, "var", node.name.id)
    if node.init {
      resolveExpr(resolver, node.init, context)
    }
    markInitialized(resolver, local)
  },
  [NODE.Block]: fn(resolver, node, context) {
    beginScope(resolver, "block")
    resolveBlockWithHoisting(resolver, node, context)
    endScope(resolver, node.id)
  },
  [NODE.Call]: fn(resolver, node, context) {
    resolveExpr(resolver, node.callee, context)
    for let i = 0; i < len(node.args); i = i + 1 {
      resolveExpr(resolver, node.args[i], context)
    }
  },
  [NODE.Arrow]: fn(resolver, node, context) {
    resolveExpr(resolver, node.left, context)
    if node.right and node.right.type == NODE.Call {
      resolveExpr(resolver, node.right, context)
    } else {
      addError(resolver, node.id, "Arrow operator requires function call on right side")
      resolveExpr(resolver, node.right, context)
    }
  },
  [NODE.IntrinsicCall]: fn(resolver, node, context) {
    for let i = 0; i < len(node.args or []); i = i + 1 {
      resolveExpr(resolver, node.args[i], context)
    }
  },
  [NODE.If]: fn(resolver, node, context) {
    resolveExpr(resolver, node.condition, context)
    resolveExpr(resolver, node.then, context)
    if node.else {
      resolveExpr(resolver, node.else, context)
    }
  },
  [NODE.Assignment]: fn(resolver, node, context) {
    let target = node.target
    if target.type == NODE.Identifier {
      resolveExpr(resolver, target, context)
      let binding = resolver.resolvedNames[target.id]
      if binding and binding.setOp {
        if binding.kind == "local" {
          resolver.assignmentInfo[node.id] = .{ kind: "local", slot: binding.slot }
        } else if binding.kind == "upvalue" {
          resolver.assignmentInfo[node.id] = .{ kind: "upvalue", upvalueIndex: binding.upvalueIndex }
        } else if binding.kind == "builtin" {
          addError(resolver, node.id, "Cannot assign to undeclared name '" + binding.name + "'")
        }
      } else {
        addError(resolver, node.id, "Cannot assign to identifier (no setOp)")
      }
    } else if target.type == NODE.Index {
      resolveExpr(resolver, target.object, context)
      resolveExpr(resolver, target.index, context)
      resolver.assignmentInfo[node.id] = .{ kind: "index" }
    } else if target.type == NODE.Dot {
      resolveExpr(resolver, target.object, context)
      resolver.assignmentInfo[node.id] = .{ kind: "dot" }
    } else {
      addError(resolver, node.id, "Invalid assignment target")
    }
    resolveExpr(resolver, node.value, context)
  },
  [NODE.Array]: fn(resolver, node, context) {
    for let i = 0; i < len(node.elements); i = i + 1 {
      resolveExpr(resolver, node.elements[i], context)
    }
  },
  [NODE.Hashmap]: fn(resolver, node, context) {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      resolveExpr(resolver, node.pairs[i].key, context)
      resolveExpr(resolver, node.pairs[i].value, context)
    }
  },
  [NODE.Index]: fn(resolver, node, context) {
    resolveExpr(resolver, node.object, context)
    resolveExpr(resolver, node.index, context)
  },
  [NODE.Dot]: fn(resolver, node, context) {
    resolveExpr(resolver, node.object, context)
  },
  [NODE.Function]: fn(resolver, node, context) {
    resolveFunction(resolver, node, context)
  },
  [NODE.For]: fn(resolver, node, context) {
    beginScope(resolver, "loop")
    if node.init { resolveExpr(resolver, node.init, context) }
    if node.condition { resolveExpr(resolver, node.condition, context) }
    if node.update { resolveExpr(resolver, node.update, context) }
    resolveExpr(resolver, node.body, context)
    endScope(resolver, node.id)
  },
  [NODE.ForIn]: fn(resolver, node, context) {
    beginScope(resolver, "loop")
    resolveExpr(resolver, node.iterable, context)
    if node.valueBinder and node.valueBinder != "_" {
      let local = declareLocal(resolver, node.valueBinder, "var", node.id)
      markInitialized(resolver, local)
    }
    if node.indexBinder and node.indexBinder != "_" {
      let local = declareLocal(resolver, node.indexBinder, "var", node.id)
      markInitialized(resolver, local)
    }
    resolveExpr(resolver, node.body, context)
    endScope(resolver, node.id)
  },
  [NODE.CollectIn]: fn(resolver, node, context) {
    beginScope(resolver, "loop")
    resolveExpr(resolver, node.iterable, context)
    if node.valueBinder and node.valueBinder != "_" {
      let local = declareLocal(resolver, node.valueBinder, "var", node.id)
      markInitialized(resolver, local)
    }
    if node.indexBinder and node.indexBinder != "_" {
      let local = declareLocal(resolver, node.indexBinder, "var", node.id)
      markInitialized(resolver, local)
    }
    resolveExpr(resolver, node.body, context)
    endScope(resolver, node.id)
  },
  [NODE.Collect]: fn(resolver, node, context) {
    beginScope(resolver, "loop")
    if node.init { resolveExpr(resolver, node.init, context) }
    if node.condition { resolveExpr(resolver, node.condition, context) }
    if node.update { resolveExpr(resolver, node.update, context) }
    resolveExpr(resolver, node.body, context)
    endScope(resolver, node.id)
  },
  [NODE.Return]: fn(resolver, node, context) {
    let scope = resolver.currentScope
    if !isInFunction(scope) {
      if !context or !context.atTopLevel {
        addError(resolver, node.id, "Return is only allowed in functions or at top level")
      } else if !context.isLastExpr {
        addError(resolver, node.id, "Can only return at end of file when not in function")
      }
    } else {
      if context and !context.isLastExpr {
        addError(resolver, node.id, "Return must be at end of block")
      }
    }
    if node.value {
      resolveExpr(resolver, node.value, context)
    }
  },
  [NODE.Break]: fn(resolver, node, context) {
    if !isInLoop(resolver.currentScope) {
      addError(resolver, node.id, "Can only break inside a loop")
    }
    if context and !context.isLastExpr {
      addError(resolver, node.id, "Break must be at end of block")
    }
  },
  [NODE.Continue]: fn(resolver, node, context) {
    if !isInLoop(resolver.currentScope) {
      addError(resolver, node.id, "Can only continue inside a loop")
    }
    if context and !context.isLastExpr {
      addError(resolver, node.id, "Continue must be at end of block")
    }
  },
  [NODE.Import]: fn(resolver, node, context) {
    resolveImport(resolver, node)
  },
}

fn resolveExpr(resolver, node, context) {
  if !node { return }

  if node.id {
    resolver.nodes[node.id] = node
  }

  if let handler = resolveExprHandlers[node.type] {
    handler(resolver, node, context)
  } else {
    addError(resolver, node.id, "Resolution not yet implemented for: " + (nameOf(NODE, node.type) or str(node.type)))
  }
}

// ========================================
// Main API
// ========================================

fn resolve(ast, opts) {
  let resolver = makeResolver(opts or .{})

  // Root is an implicit block (same semantics as a Block node).
  resolveExpr(resolver, ast, .{
    exprIndex: 0,
    inFunctionBody: false,
    atTopLevel: true,
    isLastExpr: true,
    parentBlock: nil,
  })

  .{
    success: !resolver.hadError,
    ast: ast,
    nodes: resolver.nodes,
    resolvedNames: resolver.resolvedNames,
    scopeInfo: resolver.scopeInfo,
    assignmentInfo: resolver.assignmentInfo,
    importInfoByNodeId: resolver.importInfoByNodeId,
    errors: resolver.errors,
  }
}

resolve
