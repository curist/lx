// Snake game
// Use arrow keys or WASD to move, press 'q' to quit

if !Lx.stdout.isTTY() {
  println("Error: This example requires a TTY (terminal).")
  Lx.exit(1)
}

// ANSI helpers
fn moveTo(row, col) {
  print(join(["\e[", str(row), ";", str(col), "H"], ""))
}

fn clearScreen() {
  print("\e[2J")
}

fn hideCursor() {
  print("\e[?25l")
}

fn showCursor() {
  print("\e[?25h")
}

fn setColor(r, g, b) {
  print(join(["\e[38;2;", str(r), ";", str(g), ";", str(b), "m"], ""))
}

fn setBgColor(r, g, b) {
  print(join(["\e[48;2;", str(r), ";", str(g), ";", str(b), "m"], ""))
}

fn resetColor() {
  print("\e[0m")
}

// Get terminal size
let size = Lx.term.getSize()
let rows = size.rows - 2  // Leave room for status bar
let cols = size.cols

// Use only even columns to make grid more square (terminal chars are ~2x taller than wide)
let gridCols = Math.floor(cols / 2)

// Direction constants
let DIR = enum { UP, DOWN, LEFT, RIGHT }

// Convert grid coordinates to terminal coordinates
let toTermCol = fn(gridCol) { gridCol * 2 }

// Game state
let snake = [.{row: Math.floor(rows / 2), col: Math.floor(gridCols / 2)}]
let snakePos = .{}  // Hashmap for O(1) position lookups
let direction = DIR.RIGHT
let nextDirection = DIR.RIGHT
let food = .{row: 0, col: 0}
let bonusFood = .{row: 0, col: 0, active: false, spawnTime: 0}
let bonusTimeout = 10000  // Bonus disappears after 10 seconds
let score = 0
let gameOver = false
let speed = 100  // ms per game tick (snake movement speed)
let fps = 120  // Target frames per second for rendering
let nextBonusLength = 5  // Spawn bonus at length 5, 10, 15, etc.

// Helper to make position key
let posKey = fn(row, col) {
  join([str(row), ",", str(col)], "")
}

// Initialize snake with length 3
push(snake, .{row: snake[0].row, col: snake[0].col - 1})
push(snake, .{row: snake[0].row, col: snake[0].col - 2})

// Build initial position map
for segment in snake {
  snakePos[posKey(segment.row, segment.col)] = true
}

// Spawn food at random position
fn spawnFood() {
  for true {
    food.row = Math.floor(Math.random() * rows) + 1
    food.col = Math.floor(Math.random() * gridCols) + 1

    // Make sure food doesn't spawn on snake or bonus food (O(1) hashmap lookup)
    let foodKey = posKey(food.row, food.col)
    let onSnake = snakePos[foodKey]
    let onBonus = bonusFood.active and food.row == bonusFood.row and food.col == bonusFood.col
    if !onSnake and !onBonus {
      break
    }
  }
}

// Spawn bonus food at random position
fn spawnBonusFood() {
  for true {
    bonusFood.row = Math.floor(Math.random() * rows) + 1
    bonusFood.col = Math.floor(Math.random() * gridCols) + 1

    // Make sure bonus doesn't spawn on snake or regular food (O(1) hashmap lookup)
    let bonusKey = posKey(bonusFood.row, bonusFood.col)
    let onSnake = snakePos[bonusKey]
    let onFood = bonusFood.row == food.row and bonusFood.col == food.col
    if !onSnake and !onFood {
      bonusFood.active = true
      bonusFood.spawnTime = Date.now()
      break
    }
  }
}

// Draw border
fn drawBorder() {
  setColor(80, 80, 80)
  for col in range(1, cols + 1) {
    moveTo(1, col)
    print("─")
    moveTo(rows + 1, col)
    print("─")
  }
  for row in range(1, rows + 2) {
    moveTo(row, 1)
    print("│")
    moveTo(row, cols)
    print("│")
  }
  moveTo(1, 1)
  print("┌")
  moveTo(1, cols)
  print("┐")
  moveTo(rows + 1, 1)
  print("└")
  moveTo(rows + 1, cols)
  print("┘")
  resetColor()
}

// Draw status bar
fn drawStatus() {
  moveTo(rows + 2, 1)
  setColor(200, 200, 200)
  let bonusMsg = ""
  if bonusFood.active {
    bonusMsg = " | "
    print(join([" Score: ", str(score), " | Length: ", str(len(snake)), " | Grid: ", str(gridCols), "x", str(rows)], ""))
    setColor(255, 215, 0)
    print(" | ★ BONUS!")
    setColor(200, 200, 200)
    print(" | Arrow keys/WASD: move | q: quit ")
  } else {
    let untilBonus = nextBonusLength - len(snake)
    print(join([" Score: ", str(score), " | Length: ", str(len(snake)), " | Next bonus: ", str(untilBonus), " | Grid: ", str(gridCols), "x", str(rows), " | Arrow keys/WASD: move | q: quit "], ""))
  }
  resetColor()
}

// Draw snake
fn drawSnake() {
  // Draw head
  let head = snake[0]
  moveTo(head.row, toTermCol(head.col))
  setColor(100, 255, 100)
  print("●")

  // Draw body
  setColor(50, 200, 50)
  for i in range(1, len(snake)) {
    let segment = snake[i]
    moveTo(segment.row, toTermCol(segment.col))
    print("○")
  }
  resetColor()
}

// Draw food
fn drawFood() {
  moveTo(food.row, toTermCol(food.col))
  setColor(255, 100, 100)
  print("◆")
  resetColor()
}

// Draw bonus food
fn drawBonusFood() {
  if bonusFood.active {
    moveTo(bonusFood.row, toTermCol(bonusFood.col))
    setColor(255, 215, 0)  // Gold color
    print("★")
    resetColor()
  }
}

// Clear position
fn clearPos(row, col) {
  moveTo(row, toTermCol(col))
  print(" ")
}

// Update game state
fn update() {
  // Check if bonus food has expired
  if bonusFood.active and Date.now() - bonusFood.spawnTime > bonusTimeout {
    bonusFood.active = false
    clearPos(bonusFood.row, bonusFood.col)
  }

  // Apply next direction (prevents reversing into self)
  direction = nextDirection

  // Calculate new head position
  let head = snake[0]
  let newHead = .{row: head.row, col: head.col}

  if direction == DIR.UP { newHead.row = newHead.row - 1 }
  if direction == DIR.DOWN { newHead.row = newHead.row + 1 }
  if direction == DIR.LEFT { newHead.col = newHead.col - 1 }
  if direction == DIR.RIGHT { newHead.col = newHead.col + 1 }

  // Wrap around edges
  if newHead.row < 1 { newHead.row = rows }
  if newHead.row > rows { newHead.row = 1 }
  if newHead.col < 1 { newHead.col = gridCols }
  if newHead.col > gridCols { newHead.col = 1 }

  // Check food collision first to know if we're growing
  let ateFood = newHead.row == food.row and newHead.col == food.col
  let ateBonus = bonusFood.active and newHead.row == bonusFood.row and newHead.col == bonusFood.col

  let growAmount = 0
  if ateFood {
    score = score + 10
    growAmount = 1
    spawnFood()
  }

  if ateBonus {
    score = score + 50
    growAmount = growAmount + 3  // Bonus gives 3 extra segments
    bonusFood.active = false
    clearPos(bonusFood.row, bonusFood.col)
  }

  // Check self collision using hashmap (O(1) instead of O(n))
  // If not growing, the tail position will be freed up
  let newHeadKey = posKey(newHead.row, newHead.col)
  let tailKey = ""
  if growAmount == 0 {
    let tail = snake[len(snake) - 1]
    tailKey = posKey(tail.row, tail.col)
  }

  if snakePos[newHeadKey] and newHeadKey != tailKey {
    gameOver = true
    return
  }

  // Add new head (need to build new array with head first)
  let newSnake = [newHead]
  for segment in snake {
    push(newSnake, segment)
  }

  // Add extra segments for growth at tail position
  if growAmount > 1 {
    let tail = snake[len(snake) - 1]
    for i in range(growAmount - 1) {
      push(newSnake, tail)
      snakePos[posKey(tail.row, tail.col)] = true
    }
  }

  // Update position hashmap: add new head
  snakePos[newHeadKey] = true

  // Remove tail unless growing
  if growAmount == 0 {
    let tail = newSnake[len(newSnake) - 1]
    clearPos(tail.row, tail.col)
    snakePos[tailKey] = nil  // Remove from hashmap
    pop(newSnake)
  }

  snake = newSnake

  // Check if we should spawn bonus food
  if len(snake) >= nextBonusLength and !bonusFood.active {
    spawnBonusFood()
    nextBonusLength = nextBonusLength + 5
  }
}

// Handle input
fn handleInput(key) {
  if key == "q" {
    gameOver = true
    return
  }

  // Arrow keys and WASD - can't reverse direction
  // Check against current direction to prevent reversal
  if (key == "\e[A" or key == "w") and direction != DIR.DOWN {
    nextDirection = DIR.UP
  }
  if (key == "\e[B" or key == "s") and direction != DIR.UP {
    nextDirection = DIR.DOWN
  }
  if (key == "\e[D" or key == "a") and direction != DIR.RIGHT {
    nextDirection = DIR.LEFT
  }
  if (key == "\e[C" or key == "d") and direction != DIR.LEFT {
    nextDirection = DIR.RIGHT
  }
}

// Draw game over screen
fn drawGameOver() {
  let msgRow = Math.floor(rows / 2)
  let msg1 = "GAME OVER"
  let msg2 = join(["Final Score: ", str(score)], "")
  let msg3 = join(["Final Length: ", str(len(snake))], "")

  moveTo(msgRow, toTermCol(Math.floor((gridCols - len(msg1)) / 2)))
  setColor(255, 100, 100)
  print(msg1)

  moveTo(msgRow + 2, toTermCol(Math.floor((gridCols - len(msg2)) / 2)))
  setColor(200, 200, 200)
  print(msg2)

  moveTo(msgRow + 3, toTermCol(Math.floor((gridCols - len(msg3)) / 2)))
  print(msg3)

  resetColor()
  Lx.stdout.flush()
}

// Input fiber - yields keyboard events
let inputFiber = Fiber.create(fn() {
  for true {
    if Lx.stdin.poll(0) {
      let key = Lx.stdin.readFd(16)
      if key {
        Fiber.yield(key)
      }
    } else {
      Fiber.yield(nil)
    }
  }
})

// Game logic fiber - yields true when it's time to update game state
let gameLogicFiber = Fiber.create(fn() {
  let lastUpdate = Date.now()
  for true {
    let now = Date.now()
    if now - lastUpdate >= speed {
      lastUpdate = now
      Fiber.yield(true)
    } else {
      Fiber.yield(false)
    }
  }
})

// Render fiber - yields true when it's time to render a frame
let renderFiber = Fiber.create(fn() {
  let frameTime = 1000 / fps  // ms per frame
  let lastRender = Date.now()
  for true {
    let now = Date.now()
    if now - lastRender >= frameTime {
      lastRender = now
      Fiber.yield(true)
    } else {
      Fiber.yield(false)
    }
  }
})

// Render function - handles all drawing
fn render() {
  drawSnake()
  drawFood()
  drawBonusFood()
  drawStatus()
  Lx.stdout.flush()
}

// Initialize
Lx.term.enterRawMode()
clearScreen()
hideCursor()

drawBorder()
spawnFood()
drawFood()
drawSnake()
drawStatus()
Lx.stdout.flush()

// Game loop coordinating fibers
for !gameOver {
  // Poll input fiber - handle keyboard input
  let inputResult = Fiber.resume(inputFiber)
  if inputResult.tag == "yield" and inputResult.value {
    handleInput(inputResult.value)
  }

  // Poll game logic fiber - update game state when ready
  let logicResult = Fiber.resume(gameLogicFiber)
  if logicResult.tag == "yield" and logicResult.value {
    update()
  }

  // Poll render fiber - render frame when ready
  let renderResult = Fiber.resume(renderFiber)
  if renderResult.tag == "yield" and renderResult.value and !gameOver {
    render()
  }

  // Small sleep to avoid busy loop (1ms)
  Lx.sleep(0.001)
}

// Game over
drawGameOver()

// Wait for key press to exit
for true {
  if Lx.stdin.poll(100) {
    let key = Lx.stdin.readFd(16)
    if key {
      break
    }
  }
}

// Cleanup
clearScreen()
showCursor()
Lx.term.exitRawMode()
println()
println("Thanks for playing!")
println(join(["Final Score: ", str(score)], ""))
println(join(["Final Length: ", str(len(snake))], ""))
