// Typecheck: functions and calls
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - function definition only remains unknown", fn(assert) {
    let result = parseAndTypecheck("fn f(x) { x }")
    let fnT = deref(result, getExprType(result, 0))
    assert.equal(fnT.kind, "Function")
    let pKind = deref(result, fnT.params[0]).kind
    let rKind = deref(result, fnT.return).kind
    assert.truthy(pKind == "TypeVar" or pKind == "Any")
    assert.truthy(rKind == "TypeVar" or rKind == "Any")
  })

  test("typecheck - function constrained by call", fn(assert) {
    let result = parseAndTypecheck("{ fn add(a, b) { a + b }\nadd(1, 2) }")
    let fnT = deref(result, getExprType(result, 0))
    let callT = deref(result, getExprType(result, 1))
    assert.equal(fnT.kind, "Function")
    assert.equal(deref(result, fnT.params[0]).kind, "Number")
    assert.equal(deref(result, fnT.params[1]).kind, "Number")
    assert.equal(deref(result, fnT.return).kind, "Number")
    assert.equal(callT.kind, "Number")
  })

  test("typecheck - wrong argument type surfaces error", fn(assert) {
    let result = parseAndTypecheck("{ fn add(a, b) { a + b }\nadd(1, \"x\") }")
    assert.truthy(hasError(result,
      "Argument 2 (b) mismatch in call to add: expected Number, got String"))
  })

  test("typecheck - mismatch on anonymous call includes param name", fn(assert) {
    let result = parseAndTypecheck("{ (fn(a, b) { a + b })(1, \"x\") }")
    assert.truthy(hasError(result,
      "Argument 2 (b) mismatch: expected Number, got String"))
  })

  test("typecheck - call allows extra args", fn(assert) {
    let result = parseAndTypecheck("{ fn f(x) { x }\nf(1, 2) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - call rejects too few args", fn(assert) {
    let result = parseAndTypecheck("{ fn f(x, y) { x }\nf(1) }")
    assert.truthy(len(result.errors) > 0)
    // Error message includes counts.
    assert.truthy(hasError(result, "Too few arguments: expected at least 2, got 1"))
    assert.truthy(!hasError(result, "Unresolved call"))
  })

  test("typecheck - trailing defaults lower min arity", fn(assert) {
    let result = parseAndTypecheck("{ fn f(a, b = 2) { a }\nf(1) }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Too few arguments"))
  })

  test("typecheck - all defaults allow zero args", fn(assert) {
    let result = parseAndTypecheck("{ fn f(a = 1, b = 2) { a + b }\nf() }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Too few arguments"))
  })

  test("typecheck - non-trailing default does not lower min arity", fn(assert) {
    let result = parseAndTypecheck("{ fn f(a = 1, b) { b }\nf(1) }")
    assert.truthy(len(result.errors) > 0)
    assert.truthy(hasError(result, "Too few arguments: expected at least 2, got 1"))
  })

  test("typecheck - default record arg allows omitted optional param", fn(assert) {
    let result = parseAndTypecheck("{
      fn callme(a, opt = .{}) {
        println(a)
        if let hello = opt.hello {
          println(\"hello\", hello)
        } else {
          println(\"hello stranger\")
        }
      }
      callme(1)
      callme(1, .{ hello: \"world\" })
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Too few arguments"))
  })

  test("typecheck - unknown callee can grow tracked arity", fn(assert) {
    let result = parseAndTypecheck("{
      fn g(f) {
        f(1)
        f(1, 2)
      }
      g(fn(a, b) { a })
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Too few arguments: expected at least 2, got 1"))

    let gt = deref(result, getExprType(result, 0))
    assert.equal(gt.kind, "Function")
    let ft = deref(result, gt.params[0])
    assert.equal(ft.kind, "Function")
    assert.equal(len(ft.params), 2)
  })

  test("typecheck - recursive function does not hang", fn(assert) {
    let result = parseAndTypecheck("fn f(x) { f(x) }")
    let fnT = getExprType(result, 0)
    assert.truthy(fnT)
  })

  test("typecheck - occurs check on self application", fn(assert) {
    let result = parseAndTypecheck("fn f(x) { x(x) }")
    assert.truthy(len(result.errors) > 0)
  })

  // Minimal repro for resolve.lx issue:
  // Record type from makeX() should flow to helper function parameter
  test("typecheck - record type flows through function parameter", fn(assert) {
    let result = parseAndTypecheck("{
      fn makeState() {
        .{ count: 0, done: false }
      }
      fn update(state) {
        state.done = true
      }
      let s = makeState()
      update(s)
    }")
    assert.truthy(result.success)
    assert.truthy(!hasError(result, "Missing field"))
  })

  // Check what happens when reading from uninitialized (nil)
  test("typecheck - dot read on nil-initialized should fail", fn(assert) {
    let result = parseAndTypecheck("{ let x\nx.a }")
    // `let x` means x is nil, can't read field on nil
    assert.truthy(!result.success)
  })

  // Test string concatenation with logical expression
  test("typecheck - string concat with TypeVar and str()", fn(assert) {
    // str(1) returns String, so this should be string concatenation
    let result = parseAndTypecheck("{
      fn test(x) {
        x + str(1)
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - string concat with logical and/or expression", fn(assert) {
    // (flag and "A" or "B") + str(val) should be string concatenation
    let result = parseAndTypecheck("{
      fn test(flag, val) {
        (flag and \"A\" or \"B\") + str(val)
      }
    }")
    assert.truthy(result.success)
  })
}

.{ register }
