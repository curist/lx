// Generated by scripts/gen-builtin-docs.lx. Do not edit by hand.

let DOCS = .{
  ["Date"]: .{
    name: "Date",
    signature: "Date",
    description: "runtime date/time namespace.",
    markdown: "`Date`\nruntime date/time namespace.",
    source: "API.md",
  },
  ["Date.RFC3339"]: .{
    name: "Date.RFC3339",
    signature: "Date.RFC3339: string",
    description: "Default RFC3339 format string.",
    markdown: "`Date.RFC3339: string`\nDefault RFC3339 format string.",
    source: "API.md",
  },
  ["Date.format"]: .{
    name: "Date.format",
    signature: "Date.format(unix: number, format?: string) -> string",
    description: "Format unix timestamp (milliseconds).",
    markdown: "`Date.format(unix: number, format?: string) -> string`\nFormat unix timestamp (milliseconds).",
    source: "API.md",
  },
  ["Date.nanotime"]: .{
    name: "Date.nanotime",
    signature: "Date.nanotime() -> number",
    description: "Current unix timestamp (nanoseconds).",
    markdown: "`Date.nanotime() -> number`\nCurrent unix timestamp (nanoseconds).",
    source: "API.md",
  },
  ["Date.now"]: .{
    name: "Date.now",
    signature: "Date.now() -> number",
    description: "Current unix timestamp (milliseconds).",
    markdown: "`Date.now() -> number`\nCurrent unix timestamp (milliseconds).",
    source: "API.md",
  },
  ["Date.parse"]: .{
    name: "Date.parse",
    signature: "Date.parse(s: string, format: string) -> number",
    description: "Parse a date string, returns unix timestamp (milliseconds).",
    markdown: "`Date.parse(s: string, format: string) -> number`\nParse a date string, returns unix timestamp (milliseconds).",
    source: "API.md",
  },
  ["Lx"]: .{
    name: "Lx",
    signature: "Lx",
    description: "runtime namespace.",
    markdown: "`Lx`\nruntime namespace.",
    source: "API.md",
  },
  ["Lx.args"]: .{
    name: "Lx.args",
    signature: "Lx.args: array[string]",
    description: "CLI args.",
    markdown: "`Lx.args: array[string]`\nCLI args.",
    source: "API.md",
  },
  ["Lx.doubleToUint8Array"]: .{
    name: "Lx.doubleToUint8Array",
    signature: "Lx.doubleToUint8Array(x: number) -> array[number]",
    description: "Convert a float64 to 8 bytes (little-endian).",
    markdown: "`Lx.doubleToUint8Array(x: number) -> array[number]`\nConvert a float64 to 8 bytes (little-endian).",
    source: "API.md",
  },
  ["Lx.env"]: .{
    name: "Lx.env",
    signature: "Lx.env: map[string]string",
    description: "environment variables.",
    markdown: "`Lx.env: map[string]string`\nenvironment variables.",
    source: "API.md",
  },
  ["Lx.error"]: .{
    name: "Lx.error",
    signature: "Lx.error(message: string) -> never",
    description: "raises a runtime error (caught by `Lx.pcall`).",
    markdown: "`Lx.error(message: string) -> never`\nraises a runtime error (caught by `Lx.pcall`).",
    source: "API.md",
  },
  ["Lx.exit"]: .{
    name: "Lx.exit",
    signature: "Lx.exit(code?: number) -> never",
    description: "Exit the process.",
    markdown: "`Lx.exit(code?: number) -> never`\nExit the process.",
    source: "API.md",
  },
  ["Lx.fs"]: .{
    name: "Lx.fs",
    signature: "Lx.fs",
    description: "filesystem helpers namespace.",
    markdown: "`Lx.fs`\nfilesystem helpers namespace.",
    source: "API.md",
  },
  ["Lx.fs.cwd"]: .{
    name: "Lx.fs.cwd",
    signature: "Lx.fs.cwd() -> string",
    description: "Current working directory.",
    markdown: "`Lx.fs.cwd() -> string`\nCurrent working directory.",
    source: "API.md",
  },
  ["Lx.fs.exists"]: .{
    name: "Lx.fs.exists",
    signature: "Lx.fs.exists(path: string) -> bool",
    description: "Whether a path exists.",
    markdown: "`Lx.fs.exists(path: string) -> bool`\nWhether a path exists.",
    source: "API.md",
  },
  ["Lx.fs.readFile"]: .{
    name: "Lx.fs.readFile",
    signature: "Lx.fs.readFile(path: string) -> string",
    description: "Read a file.",
    markdown: "`Lx.fs.readFile(path: string) -> string`\nRead a file.",
    source: "API.md",
  },
  ["Lx.fs.realpath"]: .{
    name: "Lx.fs.realpath",
    signature: "Lx.fs.realpath(path: string) -> string | nil",
    description: "Resolve symlinks, or `nil` on failure.",
    markdown: "`Lx.fs.realpath(path: string) -> string | nil`\nResolve symlinks, or `nil` on failure.",
    source: "API.md",
  },
  ["Lx.fs.stat"]: .{
    name: "Lx.fs.stat",
    signature: "Lx.fs.stat(path: string) -> map | nil",
    description: "File metadata (e.g. `.{type,size,mtime,mode}`).",
    markdown: "`Lx.fs.stat(path: string) -> map | nil`\nFile metadata (e.g. `.{type,size,mtime,mode}`).",
    source: "API.md",
  },
  ["Lx.fs.writeFile"]: .{
    name: "Lx.fs.writeFile",
    signature: "Lx.fs.writeFile(path: string, content: string) -> true",
    description: "Write a file.",
    markdown: "`Lx.fs.writeFile(path: string, content: string) -> true`\nWrite a file.",
    source: "API.md",
  },
  ["Lx.globals"]: .{
    name: "Lx.globals",
    signature: "Lx.globals() -> array[string | number]",
    description: "List current global keys.",
    markdown: "`Lx.globals() -> array[string | number]`\nList current global keys.",
    source: "API.md",
  },
  ["Lx.isLxObj"]: .{
    name: "Lx.isLxObj",
    signature: "Lx.isLxObj(bytes: string | array[number]) -> bool",
    description: "checks whether a byte buffer looks like an lxobj.",
    markdown: "`Lx.isLxObj(bytes: string | array[number]) -> bool`\nchecks whether a byte buffer looks like an lxobj.",
    source: "API.md",
  },
  ["Lx.loadObj"]: .{
    name: "Lx.loadObj",
    signature: "Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn",
    description: "loads an lxobj and returns a callable closure.",
    markdown: "`Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn`\nloads an lxobj and returns a callable closure.",
    source: "API.md",
  },
  ["Lx.path"]: .{
    name: "Lx.path",
    signature: "Lx.path",
    description: "path helpers namespace.",
    markdown: "`Lx.path`\npath helpers namespace.",
    source: "API.md",
  },
  ["Lx.path.basename"]: .{
    name: "Lx.path.basename",
    signature: "Lx.path.basename(path: string) -> string",
    description: "Filename component (last segment after final `/`).",
    markdown: "`Lx.path.basename(path: string) -> string`\nFilename component (last segment after final `/`).",
    source: "API.md",
  },
  ["Lx.path.dirname"]: .{
    name: "Lx.path.dirname",
    signature: "Lx.path.dirname(path: string) -> string",
    description: "Parent directory.",
    markdown: "`Lx.path.dirname(path: string) -> string`\nParent directory.",
    source: "API.md",
  },
  ["Lx.path.join"]: .{
    name: "Lx.path.join",
    signature: "Lx.path.join(...segments: string) -> string",
    description: "Join path segments.",
    markdown: "`Lx.path.join(...segments: string) -> string`\nJoin path segments.",
    source: "API.md",
  },
  ["Lx.pcall"]: .{
    name: "Lx.pcall",
    signature: "Lx.pcall(fn: fn, ...args) -> {ok,value,error}",
    description: "calls a function and captures runtime errors instead of aborting.",
    markdown: "`Lx.pcall(fn: fn, ...args) -> {ok,value,error}`\ncalls a function and captures runtime errors instead of aborting.",
    source: "API.md",
  },
  ["Lx.proc"]: .{
    name: "Lx.proc",
    signature: "Lx.proc",
    description: "process helpers namespace.",
    markdown: "`Lx.proc`\nprocess helpers namespace.",
    source: "API.md",
  },
  ["Lx.proc.exec"]: .{
    name: "Lx.proc.exec",
    signature: "Lx.proc.exec(cmd: string) -> {code,out}",
    description: "Run a shell command and capture stdout.",
    markdown: "`Lx.proc.exec(cmd: string) -> {code,out}`\nRun a shell command and capture stdout.",
    source: "API.md",
  },
  ["Lx.proc.system"]: .{
    name: "Lx.proc.system",
    signature: "Lx.proc.system(cmd: string) -> number",
    description: "Run a shell command (inherits stdio), returning exit code.",
    markdown: "`Lx.proc.system(cmd: string) -> number`\nRun a shell command (inherits stdio), returning exit code.",
    source: "API.md",
  },
  ["Lx.stderr"]: .{
    name: "Lx.stderr",
    signature: "Lx.stderr",
    description: "stderr helpers namespace.",
    markdown: "`Lx.stderr`\nstderr helpers namespace.",
    source: "API.md",
  },
  ["Lx.stderr.flush"]: .{
    name: "Lx.stderr.flush",
    signature: "Lx.stderr.flush() -> nil",
    description: "Flush stderr.",
    markdown: "`Lx.stderr.flush() -> nil`\nFlush stderr.",
    source: "API.md",
  },
  ["Lx.stderr.isTTY"]: .{
    name: "Lx.stderr.isTTY",
    signature: "Lx.stderr.isTTY() -> bool",
    description: "Return true when stderr is a TTY.",
    markdown: "`Lx.stderr.isTTY() -> bool`\nReturn true when stderr is a TTY.",
    source: "API.md",
  },
  ["Lx.stderr.print"]: .{
    name: "Lx.stderr.print",
    signature: "Lx.stderr.print(...values) -> nil",
    description: "Print values to stderr separated by spaces.",
    markdown: "`Lx.stderr.print(...values) -> nil`\nPrint values to stderr separated by spaces.",
    source: "API.md",
  },
  ["Lx.stderr.println"]: .{
    name: "Lx.stderr.println",
    signature: "Lx.stderr.println(...values) -> nil",
    description: "Print values to stderr separated by spaces and a trailing newline.",
    markdown: "`Lx.stderr.println(...values) -> nil`\nPrint values to stderr separated by spaces and a trailing newline.",
    source: "API.md",
  },
  ["Lx.stdin"]: .{
    name: "Lx.stdin",
    signature: "Lx.stdin",
    description: "stdin helpers namespace.",
    markdown: "`Lx.stdin`\nstdin helpers namespace.",
    source: "API.md",
  },
  ["Lx.stdin.poll"]: .{
    name: "Lx.stdin.poll",
    signature: "Lx.stdin.poll(timeoutMs: number) -> bool",
    description: "Whether stdin is readable within `timeoutMs` (ms). Use `0` to poll and `-1` to wait forever.",
    markdown: "`Lx.stdin.poll(timeoutMs: number) -> bool`\nWhether stdin is readable within `timeoutMs` (ms). Use `0` to poll and `-1` to wait forever.",
    source: "API.md",
  },
  ["Lx.stdin.readAll"]: .{
    name: "Lx.stdin.readAll",
    signature: "Lx.stdin.readAll() -> string",
    description: "Read all stdin.",
    markdown: "`Lx.stdin.readAll() -> string`\nRead all stdin.",
    source: "API.md",
  },
  ["Lx.stdin.readBytes"]: .{
    name: "Lx.stdin.readBytes",
    signature: "Lx.stdin.readBytes(n: number) -> string | nil",
    description: "Read up to `n` bytes from stdin.",
    markdown: "`Lx.stdin.readBytes(n: number) -> string | nil`\nRead up to `n` bytes from stdin.",
    source: "API.md",
  },
  ["Lx.stdin.readFd"]: .{
    name: "Lx.stdin.readFd",
    signature: "Lx.stdin.readFd(n: number) -> string | nil",
    description: "Read up to `n` bytes from stdin using fd I/O (works with `poll`).",
    markdown: "`Lx.stdin.readFd(n: number) -> string | nil`\nRead up to `n` bytes from stdin using fd I/O (works with `poll`).",
    source: "API.md",
  },
  ["Lx.stdin.readLine"]: .{
    name: "Lx.stdin.readLine",
    signature: "Lx.stdin.readLine(prompt?: string) -> string | nil",
    description: "Read one line from stdin (without trailing `\\n`), or `nil` on EOF.",
    markdown: "`Lx.stdin.readLine(prompt?: string) -> string | nil`\nRead one line from stdin (without trailing `\\n`), or `nil` on EOF.",
    source: "API.md",
  },
  ["Lx.stdin.unbuffered"]: .{
    name: "Lx.stdin.unbuffered",
    signature: "Lx.stdin.unbuffered() -> nil",
    description: "Disable stdin stdio buffering (recommended if mixing `poll` with `readLine`/`readBytes`).",
    markdown: "`Lx.stdin.unbuffered() -> nil`\nDisable stdin stdio buffering (recommended if mixing `poll` with `readLine`/`readBytes`).",
    source: "API.md",
  },
  ["Lx.stdout"]: .{
    name: "Lx.stdout",
    signature: "Lx.stdout",
    description: "stdout helpers namespace.",
    markdown: "`Lx.stdout`\nstdout helpers namespace.",
    source: "API.md",
  },
  ["Lx.stdout.flush"]: .{
    name: "Lx.stdout.flush",
    signature: "Lx.stdout.flush() -> nil",
    description: "Flush stdout.",
    markdown: "`Lx.stdout.flush() -> nil`\nFlush stdout.",
    source: "API.md",
  },
  ["Lx.stdout.isTTY"]: .{
    name: "Lx.stdout.isTTY",
    signature: "Lx.stdout.isTTY() -> bool",
    description: "Return true when stdout is a TTY.",
    markdown: "`Lx.stdout.isTTY() -> bool`\nReturn true when stdout is a TTY.",
    source: "API.md",
  },
  ["Lx.stdout.putc"]: .{
    name: "Lx.stdout.putc",
    signature: "Lx.stdout.putc(...codes: number) -> nil",
    description: "Write bytes/chars to stdout.",
    markdown: "`Lx.stdout.putc(...codes: number) -> nil`\nWrite bytes/chars to stdout.",
    source: "API.md",
  },
  ["Lx.version"]: .{
    name: "Lx.version",
    signature: "Lx.version: string",
    description: "runtime version string.",
    markdown: "`Lx.version: string`\nruntime version string.",
    source: "API.md",
  },
  ["Lx.zlib"]: .{
    name: "Lx.zlib",
    signature: "Lx.zlib",
    description: "compression helpers namespace.",
    markdown: "`Lx.zlib`\ncompression helpers namespace.",
    source: "API.md",
  },
  ["Lx.zlib.crc32"]: .{
    name: "Lx.zlib.crc32",
    signature: "Lx.zlib.crc32(data: string | array[number]) -> number",
    description: "Calculate CRC32 checksum of a string or byte array (unsigned 32-bit integer).",
    markdown: "`Lx.zlib.crc32(data: string | array[number]) -> number`\nCalculate CRC32 checksum of a string or byte array (unsigned 32-bit integer).",
    source: "API.md",
  },
  ["Lx.zlib.deflate"]: .{
    name: "Lx.zlib.deflate",
    signature: "Lx.zlib.deflate(data: array[number]) -> array[number]",
    description: "Compress a byte array using zlib deflate (compatible with gzip).",
    markdown: "`Lx.zlib.deflate(data: array[number]) -> array[number]`\nCompress a byte array using zlib deflate (compatible with gzip).",
    source: "API.md",
  },
  ["Lx.zlib.inflate"]: .{
    name: "Lx.zlib.inflate",
    signature: "Lx.zlib.inflate(data: array[number]) -> array[number]",
    description: "Decompress a zlib-compressed byte array.",
    markdown: "`Lx.zlib.inflate(data: array[number]) -> array[number]`\nDecompress a zlib-compressed byte array.",
    source: "API.md",
  },
  ["Math"]: .{
    name: "Math",
    signature: "Math",
    description: "runtime math namespace.",
    markdown: "`Math`\nruntime math namespace.",
    source: "API.md",
  },
  ["Math.floor"]: .{
    name: "Math.floor",
    signature: "Math.floor(n: number) -> number",
    description: "Floor (round down) to an integer.",
    markdown: "`Math.floor(n: number) -> number`\nFloor (round down) to an integer.",
    source: "API.md",
  },
  ["Math.max"]: .{
    name: "Math.max",
    signature: "Math.max(...values: number) -> number",
    description: "Returns the maximum value from the arguments.",
    markdown: "`Math.max(...values: number) -> number`\nReturns the maximum value from the arguments.",
    source: "API.md",
  },
  ["Math.min"]: .{
    name: "Math.min",
    signature: "Math.min(...values: number) -> number",
    description: "Returns the minimum value from the arguments.",
    markdown: "`Math.min(...values: number) -> number`\nReturns the minimum value from the arguments.",
    source: "API.md",
  },
  ["Math.random"]: .{
    name: "Math.random",
    signature: "Math.random() -> number",
    description: "Random float in `[0, 1)`.",
    markdown: "`Math.random() -> number`\nRandom float in `[0, 1)`.",
    source: "API.md",
  },
  ["Math.sqrt"]: .{
    name: "Math.sqrt",
    signature: "Math.sqrt(n: number) -> number",
    description: "Square root.",
    markdown: "`Math.sqrt(n: number) -> number`\nSquare root.",
    source: "API.md",
  },
  ["chr"]: .{
    name: "chr",
    signature: "chr(code: number) -> string",
    description: "Convert a byte (0–255) to a 1-byte string.",
    markdown: "`chr(code: number) -> string`\nConvert a byte (0–255) to a 1-byte string.",
    source: "API.md",
  },
  ["concat"]: .{
    name: "concat",
    signature: "concat(a: array, b: array) -> array",
    description: "New array with elements of `a` followed by `b`.",
    markdown: "`concat(a: array, b: array) -> array`\nNew array with elements of `a` followed by `b`.",
    source: "API.md",
  },
  ["contains"]: .{
    name: "contains",
    signature: "contains(haystack: array | string, needle) -> bool",
    description: "Membership test for arrays/strings.",
    markdown: "`contains(haystack: array | string, needle) -> bool`\nMembership test for arrays/strings.",
    source: "API.md",
  },
  ["endsWith"]: .{
    name: "endsWith",
    signature: "endsWith(s: string, suffix: string) -> bool",
    description: "String suffix test.",
    markdown: "`endsWith(s: string, suffix: string) -> bool`\nString suffix test.",
    source: "API.md",
  },
  ["join"]: .{
    name: "join",
    signature: "join(values: array, sep: string) -> string",
    description: "Join stringified values with a separator.",
    markdown: "`join(values: array, sep: string) -> string`\nJoin stringified values with a separator.",
    source: "API.md",
  },
  ["keys"]: .{
    name: "keys",
    signature: "keys(x: map | enum) -> array[string]",
    description: "Keys/names.",
    markdown: "`keys(x: map | enum) -> array[string]`\nKeys/names.",
    source: "API.md",
  },
  ["len"]: .{
    name: "len",
    signature: "len(x: string | array) -> number",
    description: "Length of a string/array.",
    markdown: "`len(x: string | array) -> number`\nLength of a string/array.",
    source: "API.md",
  },
  ["nameOf"]: .{
    name: "nameOf",
    signature: "nameOf(enum: enum, value: number | string) -> string | nil",
    description: "Reverse lookup (value → name).",
    markdown: "`nameOf(enum: enum, value: number | string) -> string | nil`\nReverse lookup (value → name).",
    source: "API.md",
  },
  ["ord"]: .{
    name: "ord",
    signature: "ord(ch: string) -> number",
    description: "Convert a 1-character string to its byte value.",
    markdown: "`ord(ch: string) -> number`\nConvert a 1-character string to its byte value.",
    source: "API.md",
  },
  ["pop"]: .{
    name: "pop",
    signature: "pop(arr: array) -> value | nil",
    description: "Mutates `arr` by removing and returning the last element.",
    markdown: "`pop(arr: array) -> value | nil`\nMutates `arr` by removing and returning the last element.",
    source: "API.md",
  },
  ["print"]: .{
    name: "print",
    signature: "print(...values) -> nil",
    description: "Print values to stdout separated by spaces.",
    markdown: "`print(...values) -> nil`\nPrint values to stdout separated by spaces.",
    source: "API.md",
  },
  ["println"]: .{
    name: "println",
    signature: "println(...values) -> nil",
    description: "Print values to stdout separated by spaces and a trailing newline.",
    markdown: "`println(...values) -> nil`\nPrint values to stdout separated by spaces and a trailing newline.",
    source: "API.md",
  },
  ["push"]: .{
    name: "push",
    signature: "push(arr: array, value) -> array",
    description: "Mutates `arr` by appending `value`.",
    markdown: "`push(arr: array, value) -> array`\nMutates `arr` by appending `value`.",
    source: "API.md",
  },
  ["range"]: .{
    name: "range",
    signature: "range(x: number | string | array | map | enum) -> array",
    description: "For number: `[0..n-1]`; for string: chars; for map/enum: keys.",
    markdown: "`range(x: number | string | array | map | enum) -> array`\nFor number: `[0..n-1]`; for string: chars; for map/enum: keys.",
    source: "API.md",
  },
  ["reverse"]: .{
    name: "reverse",
    signature: "reverse(arr: array) -> array",
    description: "Returns a new array with elements in reverse order (non-mutating).",
    markdown: "`reverse(arr: array) -> array`\nReturns a new array with elements in reverse order (non-mutating).",
    source: "API.md",
  },
  ["slice"]: .{
    name: "slice",
    signature: "slice(arr: array, start: number, end?: number) -> array",
    description: "Array slice from start to end (exclusive). Supports negative indices (count from end). If end omitted, goes to end of array.",
    markdown: "`slice(arr: array, start: number, end?: number) -> array`\nArray slice from start to end (exclusive). Supports negative indices (count from end). If end omitted, goes to end of array.",
    source: "API.md",
  },
  ["split"]: .{
    name: "split",
    signature: "split(s: string, sep: string) -> array[string]",
    description: "Split by substring; when `sep == \"\"`, splits into chars.",
    markdown: "`split(s: string, sep: string) -> array[string]`\nSplit by substring; when `sep == \"\"`, splits into chars.",
    source: "API.md",
  },
  ["startsWith"]: .{
    name: "startsWith",
    signature: "startsWith(s: string, prefix: string) -> bool",
    description: "String prefix test.",
    markdown: "`startsWith(s: string, prefix: string) -> bool`\nString prefix test.",
    source: "API.md",
  },
  ["str"]: .{
    name: "str",
    signature: "str(value) -> string",
    description: "Convert a value to a string (uses runtime formatting).",
    markdown: "`str(value) -> string`\nConvert a value to a string (uses runtime formatting).",
    source: "API.md",
  },
  ["substr"]: .{
    name: "substr",
    signature: "substr(s: string, start: number, end?: number) -> string",
    description: "Substring from start to end (exclusive). Supports negative indices (count from end). If end omitted, goes to end of string.",
    markdown: "`substr(s: string, start: number, end?: number) -> string`\nSubstring from start to end (exclusive). Supports negative indices (count from end). If end omitted, goes to end of string.",
    source: "API.md",
  },
  ["tolower"]: .{
    name: "tolower",
    signature: "tolower(s: string) -> string",
    description: "Lowercase ASCII.",
    markdown: "`tolower(s: string) -> string`\nLowercase ASCII.",
    source: "API.md",
  },
  ["tonumber"]: .{
    name: "tonumber",
    signature: "tonumber(s: string) -> number",
    description: "Parse a string to a number (float).",
    markdown: "`tonumber(s: string) -> number`\nParse a string to a number (float).",
    source: "API.md",
  },
  ["toupper"]: .{
    name: "toupper",
    signature: "toupper(s: string) -> string",
    description: "Uppercase ASCII.",
    markdown: "`toupper(s: string) -> string`\nUppercase ASCII.",
    source: "API.md",
  },
  ["type"]: .{
    name: "type",
    signature: "type(x) -> string",
    description: "One of `nil|boolean|number|fn|string|enum|map|array`.",
    markdown: "`type(x) -> string`\nOne of `nil|boolean|number|fn|string|enum|map|array`.",
    source: "API.md",
  },
}

let NATIVE_NAMES = .{
  ["Date"]: true,
  ["Date.RFC3339"]: true,
  ["Date.format"]: true,
  ["Date.nanotime"]: true,
  ["Date.now"]: true,
  ["Date.parse"]: true,
  ["Lx"]: true,
  ["Lx.args"]: true,
  ["Lx.doubleToUint8Array"]: true,
  ["Lx.env"]: true,
  ["Lx.error"]: true,
  ["Lx.exit"]: true,
  ["Lx.fs"]: true,
  ["Lx.fs.cwd"]: true,
  ["Lx.fs.exists"]: true,
  ["Lx.fs.readFile"]: true,
  ["Lx.fs.realpath"]: true,
  ["Lx.fs.stat"]: true,
  ["Lx.fs.writeFile"]: true,
  ["Lx.globals"]: true,
  ["Lx.isLxObj"]: true,
  ["Lx.loadObj"]: true,
  ["Lx.path"]: true,
  ["Lx.path.basename"]: true,
  ["Lx.path.dirname"]: true,
  ["Lx.path.join"]: true,
  ["Lx.pcall"]: true,
  ["Lx.proc"]: true,
  ["Lx.proc.crc32"]: true,
  ["Lx.proc.deflate"]: true,
  ["Lx.proc.exec"]: true,
  ["Lx.proc.inflate"]: true,
  ["Lx.proc.system"]: true,
  ["Lx.stderr"]: true,
  ["Lx.stderr.flush"]: true,
  ["Lx.stderr.isTTY"]: true,
  ["Lx.stderr.print"]: true,
  ["Lx.stderr.println"]: true,
  ["Lx.stdin"]: true,
  ["Lx.stdin.poll"]: true,
  ["Lx.stdin.readAll"]: true,
  ["Lx.stdin.readBytes"]: true,
  ["Lx.stdin.readFd"]: true,
  ["Lx.stdin.readLine"]: true,
  ["Lx.stdin.unbuffered"]: true,
  ["Lx.stdout"]: true,
  ["Lx.stdout.flush"]: true,
  ["Lx.stdout.isTTY"]: true,
  ["Lx.stdout.putc"]: true,
  ["Lx.version"]: true,
  ["Lx.zlib"]: true,
  ["Lx.zlib.crc32"]: true,
  ["Lx.zlib.deflate"]: true,
  ["Lx.zlib.inflate"]: true,
  ["Math"]: true,
  ["Math.floor"]: true,
  ["Math.max"]: true,
  ["Math.min"]: true,
  ["Math.random"]: true,
  ["Math.sqrt"]: true,
  ["chr"]: true,
  ["concat"]: true,
  ["contains"]: true,
  ["endsWith"]: true,
  ["join"]: true,
  ["keys"]: true,
  ["len"]: true,
  ["nameOf"]: true,
  ["ord"]: true,
  ["pop"]: true,
  ["print"]: true,
  ["println"]: true,
  ["push"]: true,
  ["range"]: true,
  ["reverse"]: true,
  ["slice"]: true,
  ["split"]: true,
  ["startsWith"]: true,
  ["str"]: true,
  ["substr"]: true,
  ["tolower"]: true,
  ["tonumber"]: true,
  ["toupper"]: true,
  ["type"]: true,
}

let PRELUDE_NAMES = .{
  ["each"]: true,
  ["first"]: true,
  ["fold"]: true,
  ["last"]: true,
  ["sort"]: true,
}

.{
  DOCS,
  NATIVE_NAMES,
  PRELUDE_NAMES,
}
