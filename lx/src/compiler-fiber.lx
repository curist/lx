// Fiber-based compiler API
//
// Provides a fiber-driven compilation interface that yields events
// for streaming diagnostics and progress.

let Events = import "src/events.lx"
let parse = import "src/passes/parse/parser.lx"
let lower = import "src/passes/transform/lower.lx"
let anf = import "src/passes/transform/anf.lx"
let resolve = import "src/passes/analysis/resolve.lx"
let anfInline = import "src/passes/transform/anf-inline.lx"
let lowerIntrinsics = import "src/passes/transform/lower-intrinsics.lx"
let codegen = import "src/passes/emit/codegen.lx"

// Parse error message format: [file:line:col] context: message
// Returns: .{ line, col } or nil if parsing fails
fn parseErrorLocation(errorMsg) {
  // Find the bracket and colon positions
  // Format: [file:line:col] ...
  let openBracket = nil
  let closeBracket = nil
  let colons = []

  for let i = 0; i < len(errorMsg); i = i + 1 {
    let ch = errorMsg[i]
    if ch == "[" and !openBracket {
      openBracket = i
    } else if ch == ":" and openBracket and !closeBracket {
      push(colons, i)
    } else if ch == "]" and !closeBracket {
      closeBracket = i
      break
    }
  }

  // Need at least 2 colons (file:line:col)
  if !openBracket or !closeBracket or len(colons) < 2 {
    return nil
  }

  // Line is between second-to-last and last colon
  // Col is between last colon and ]
  let lineColonIdx = colons[len(colons) - 2]
  let colColonIdx = colons[len(colons) - 1]

  // Extract line number
  let line = collect let i = lineColonIdx + 1; i < colColonIdx; i = i + 1 {
    errorMsg[i]
  }->join("")->tonumber()

  // Extract column number
  let col = collect let i = colColonIdx + 1; i < closeBracket; i = i + 1 {
    errorMsg[i]
  }->join("")->tonumber()

  .{ line, col }
}

// Internal: Create the compilation fiber with optional cancellation support
// - cancelled: nil (no cancellation) or .{ value: bool } for cancellation state
fn createCompilerFiber(source, filename, cancelled) {
  Fiber.create(fn() {
    // Helper to check cancellation - returns true if cancelled
    fn checkCancel() {
      cancelled and cancelled.value
    }

    // Parse phase
    Fiber.yield(Events.progress("parse", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }

    let parseResult = parse(source, filename)

    // Yield diagnostics for parse errors
    for errorMsg in parseResult.errors {
      let loc = parseErrorLocation(errorMsg)
      let range = if loc {
        .{ start: .{ line: loc.line, col: loc.col }, end: .{ line: loc.line, col: loc.col + 1 } }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("parse", filename, range, Events.Severity.ERROR, errorMsg, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("parse", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Stop if parse failed
    if !parseResult.success {
      return Events.done(.{ success: false, errors: parseResult.errors })
    }

    // Lower phase
    Fiber.yield(Events.progress("lower", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let lowerResult = lower(parseResult.ast, .{ nextNodeId: parseResult.nextNodeId })
    Fiber.yield(Events.progress("lower", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    if !lowerResult.success {
      return Events.done(.{ success: false, errors: lowerResult.errors })
    }

    // ANF phase
    Fiber.yield(Events.progress("anf", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let anfResult = anf(lowerResult.ast, .{ nextNodeId: lowerResult.nextNodeId })
    Fiber.yield(Events.progress("anf", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    if !anfResult.success {
      return Events.done(.{ success: false, errors: anfResult.errors })
    }

    // Resolve phase
    Fiber.yield(Events.progress("resolve", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let resolveResult = resolve(anfResult.ast, .{})

    // Yield diagnostics for resolve errors
    for err in resolveResult.errors {
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      let severity = if err.severity == "error" {
        Events.Severity.ERROR
      } else if err.severity == "warning" {
        Events.Severity.WARNING
      } else {
        Events.Severity.ERROR
      }
      Fiber.yield(Events.diag("resolve", filename, range, severity, err.message, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("resolve", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Stop if resolve failed
    if !resolveResult.success {
      return Events.done(.{ success: false, errors: resolveResult.errors })
    }

    // ANF-inline phase
    Fiber.yield(Events.progress("anf-inline", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    anfInline(anfResult.ast, resolveResult)
    Fiber.yield(Events.progress("anf-inline", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Lower-intrinsics phase
    Fiber.yield(Events.progress("lower-intrinsics", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    lowerIntrinsics(anfResult.ast, resolveResult, nil)
    Fiber.yield(Events.progress("lower-intrinsics", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Codegen phase
    Fiber.yield(Events.progress("codegen", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let codegenResult = codegen(anfResult.ast, resolveResult, .{
      enumInfo: parseResult.enumInfo
    })

    // Yield diagnostics for codegen errors
    for err in codegenResult.errors {
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("codegen", filename, range, Events.Severity.ERROR, err.message, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("codegen", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Return done event with all results
    Events.done(.{
      success: codegenResult.success,
      ast: anfResult.ast,
      function: codegenResult.function,
      parseResult,
      lowerResult,
      anfResult,
      resolveResult,
      codegenResult
    })
  })
}

// Start a compilation fiber.
// - source: source code string to compile
// - opts: compilation options (.{ filename, ... })
// Returns: .{ fiber, cancel } where cancel() requests cancellation
fn start(source, opts) {
  let filename = opts.filename or "unknown"
  let cancelled = .{ value: false }

  let fiber = createCompilerFiber(source, filename, cancelled)

  let cancel = fn() {
    cancelled.value = true
  }

  .{ fiber, cancel }
}

// Poll a compilation fiber for events.
// - fiber: the compilation fiber from start()
// - budget: .{ maxEvents } - how many events to collect before returning
// Returns: .{ events, done?, result?, error? }
fn poll(fiber, budget) {
  let events = []
  let maxEvents = budget.maxEvents

  for len(events) < maxEvents {
    let resumeResult = Fiber.resume(fiber)

    if resumeResult.tag == "yield" {
      push(events, resumeResult.value)
    } else if resumeResult.tag == "return" {
      return .{ events, done: true, result: resumeResult.value }
    } else if resumeResult.tag == "error" {
      return .{ events, done: true, error: resumeResult.error }
    }
  }

  .{ events, done: false }
}

.{ start, poll }
