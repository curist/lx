// Driver - Orchestrates compilation pipeline (passes): parse → lower → anf → resolve → anf-inline → typecheck
//
// Responsibilities:
// - Coordinate pass execution
// - Manage import cache for multi-file compilation
// - Handle circular import detection
// - Provide compilation artifacts for query service and codegen
// - ANF runs after lower (optional, default on)
// - ANF inline runs post-resolve (optional, default on)

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let anf = import "src/anf.lx"
let anfInline = import "src/anf-inline.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"
let pipeline = import "src/passes/pipeline.lx"

// ========================================
// Build Pass List
// ========================================

fn buildPassList(ctx) {
  // Build the list of passes with their adapters
  // ctx contains: importCache, compileModule, opts (withAnf, withAnfInline, withTypecheck)

  [
    // PASS 1: Parse
    .{
      name: "parse",
      mutatesAst: false,
      run: fn(ctx, state) {
        parse(state.source, state.path)
      },
    },

    // PASS 2: Lower
    .{
      name: "lower",
      mutatesAst: false,
      run: fn(ctx, state) {
        lower(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },

    // PASS 3: ANF (optional, default on)
    .{
      name: "anf",
      mutatesAst: false,
      enabled: fn(ctx, state) {
        // Explicit boolean: default to true if opts missing
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        true
      },
      run: fn(ctx, state) {
        anf(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },

    // PASS 4: Resolve
    .{
      name: "resolve",
      mutatesAst: true,  // Currently mutates import nodes (to be fixed in Phase 2)
      run: fn(ctx, state) {
        let opts = .{
          importCache: ctx.importCache,
          compileModule: ctx.compileModule,
        }
        resolve(state.ast, opts)
      },
    },

    // PASS 5: ANF Inline Optimization (optional, default on, post-resolve)
    .{
      name: "anf-inline",
      mutatesAst: true,  // Explicitly mutates AST in-place
      enabled: fn(ctx, state) {
        // Only run if both ANF and ANF-inline are enabled
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        if ctx.opts.withAnfInline == false { return false }
        true
      },
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        anfInline(state.ast, resolveResult)
      },
    },

    // PASS 6: Typecheck (optional, non-fatal)
    .{
      name: "typecheck",
      mutatesAst: false,
      fatal: false,  // Non-fatal: don't stop pipeline on typecheck errors
      enabled: fn(ctx, state) {
        // Explicit boolean: default to true if opts missing
        if !ctx.opts { return true }
        if ctx.opts.withTypecheck == false { return false }
        true
      },
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        let result = typecheck(state.ast, resolveResult, .{})

        // Defensive: handle nil return (shouldn't happen, but be safe)
        if !result {
          return .{
            success: false,
            errors: [.{
              pass: "typecheck",
              message: "typecheck returned nil",
              severity: "error",
            }],
          }
        }

        result
      },
    },
  ]
}

// ========================================
// Driver Factory
// ========================================

fn make(opts) {
  let driver = .{}
  driver.cache = .{}
  driver.compiledModules = []  // Track compilation order
  driver.loadSource = opts and opts.loadSource or nil
  driver.withTypecheck = !(opts and opts.withTypecheck == false)  // Default: true
  driver.withAnf = !(opts and opts.withAnf == false)  // Default: true
  driver.withAnfInline = !(opts and opts.withAnfInline == false)  // Default: true

  driver.compileModule = fn(path) {
    // Check cache first
    let cached = driver.cache[path]
    if cached {
      return cached
    }

    // Track compilation (first time only)
    push(driver.compiledModules, path)

    // Mark as compiling (for circular import detection)
    driver.cache[path] = .{
      status: "compiling",
      path: path,
    }

    // Load source via callback
    let source = nil
    if driver.loadSource {
      source = driver.loadSource(path)
    }

    if !source {
      // Source loading failed - return legacy format for compatibility
      let result = .{
        status: "failed",
        path: path,
        parseResult: .{ success: false, errors: ["Failed to load source: " + path] },
      }
      driver.cache[path] = result
      return result
    }

    // ========================================
    // Run Pipeline
    // ========================================

    // Build context for passes
    let ctx = .{
      importCache: driver.cache,
      compileModule: driver.compileModule,
      opts: .{
        withAnf: driver.withAnf,
        withAnfInline: driver.withAnfInline,
        withTypecheck: driver.withTypecheck,
      },
    }

    // Build initial state
    let state = .{
      path: path,
      source: source,
      ast: nil,
      nextNodeId: 1,
      passes: .{},
    }

    // Execute passes
    let passList = buildPassList(ctx)
    let pipelineResult = pipeline.runPasses(passList, ctx, state)

    // ========================================
    // Legacy Projection Layer (backward compatibility)
    // ========================================

    // Extract individual pass results
    let parseResult = pipelineResult.passes.parse
    let lowerResult = pipelineResult.passes.lower
    let anfResult = pipelineResult.passes.anf
    let resolveResult = pipelineResult.passes.resolve
    let anfInlineResult = pipelineResult.passes["anf-inline"]
    let typecheckResult = pipelineResult.passes.typecheck

    // Special handling: anf-inline updates anfResult.ast (preserve existing behavior)
    if anfResult and anfInlineResult and anfInlineResult.ast {
      anfResult.ast = anfInlineResult.ast
    }

    // Build result with both new and legacy fields
    let result = .{
      // Core fields
      status: pipelineResult.status,
      success: pipelineResult.success,
      path: path,
      failedPass: pipelineResult.failedPass,

      // New pipeline fields
      passOrder: pipelineResult.passOrder,
      passes: pipelineResult.passes,

      // Legacy projection fields (for existing tests/tooling)
      parseResult: parseResult,
      lowerResult: lowerResult,
      anfResult: anfResult,
      anfInlineResult: anfInlineResult,
      resolveResult: resolveResult,
      typecheckResult: typecheckResult,

      // Legacy error fields (backward compat)
      // Only set when pass actually failed, to preserve phase-detection logic
      parseErrors: parseResult and !parseResult.success and parseResult.errors,
      lowerErrors: lowerResult and !lowerResult.success and lowerResult.errors,
    }

    driver.cache[path] = result
    return result
  }

  driver
}

// ========================================
// Module Exports
// ========================================

.{
  make: make
}
