// ANF Inline Optimization (Post-Resolve, Binder-Aware)
//
// Goal:
// - Inline single-use ANF temps ($anf.N) using binding metadata (declaredAt)
// - Remove their `let` bindings when inlined
//
// Key facts / invariants:
// - Node shapes:
//   - Let: { type:"Let", id, name: Identifier{id,name}, init: expr }
//   - declaredAt == Let.name.id (binder identifier id)
//   - Block: { type:"Block", id, expressions:[...] }
// - This pass mutates the AST in-place (performance-critical).
// - Later phases (typecheck, codegen, etc.) are read-only.
//
// Performance design:
// - One traversal builds:
//   - letByDeclId: declId -> { letNode, blockId, indexInBlock }
//   - useCount: declId -> count
//   - useSite: declId -> { parent, field, index } (kept only if single-use)
//   - blockById: blockId -> blockNode (for compaction)
// - Apply edits:
//   - Replace the unique Identifier use-site with RHS (structural sharing)
//   - Mark Let indices for removal per block, then compact each affected block once
//
// Validation:
// - Cheap binder-aware validation:
//   - Every removed let had uses == 1
//   - Every removed let had a remembered single-use site
//   - Replacement succeeded

let .{ NODE } = import "src/types.lx"

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

let SAFE_LITERAL_TYPES = .{
  [NODE.Number]: true,
  [NODE.String]: true,
  [NODE.Bool]: true,
  [NODE.Nil]: true,
}

fn debugLog(enabled, msg) {
  if !enabled { return }
  Lx.stderr.println(msg)
}

fn isAnfTempName(name) {
  if !name or type(name) != "string" { return false }
  name->startsWith("$anf.")
}

// ------------------------------------------------------------
// Inline-safety predicate
// ------------------------------------------------------------

fn isInlineSafeExpr(node) {
  isInlineSafeExprImpl(node, 0)
}

fn isInlineSafeExprImpl(node, depth) {
  // Depth limit to prevent infinite recursion
  if depth > 50 { return false }

  if !node { return true }
  if type(node) != "map" { return true }

  let t = node.type

  // Conservative whitelist
  if t == NODE.Nil or t == NODE.Bool or t == NODE.Number or t == NODE.String or t == NODE.Identifier {
    return true
  }

  let d = depth + 1

  if t == NODE.Binary {
    return isInlineSafeExprImpl(node.left, d) and isInlineSafeExprImpl(node.right, d)
  }

  if t == NODE.Unary {
    return isInlineSafeExprImpl(node.operand, d)
  }

  if t == NODE.Logical {
    return isInlineSafeExprImpl(node.left, d) and isInlineSafeExprImpl(node.right, d)
  }

  if t == NODE.Dot {
    return isInlineSafeExprImpl(node.object, d) and node.property and node.property.type == NODE.String
  }

  if t == NODE.Index {
    return isInlineSafeExprImpl(node.object, d) and isInlineSafeExprImpl(node.index, d)
  }

  if t == NODE.IntrinsicCall {
    let args = node.args or []
    for arg in args {
      if !isInlineSafeExprImpl(arg, d) { return false }
    }
    return true
  }

  // Synthetic blocks with single safe expression
  if t == NODE.Block and node.anfSynthetic {
    let exprs = node.expressions or []
    if len(exprs) == 1 {
      return isInlineSafeExprImpl(exprs[0], d)
    }
  }

  false
}

// ------------------------------------------------------------
// Walker (single traversal)
// ------------------------------------------------------------

fn walk(node, resolvedNames, state, parent, parentField, parentIndex) {
  if !node { return }
  let t = type(node)

  if t == "array" {
    for item, i in node {
      // Parent is this array; field name is nil; index is i
      walk(item, resolvedNames, state, node, nil, i)
    }
    return
  }

  if t != "map" { return }

  // Remember blocks by id for later compaction
  if node.type == NODE.Block and node.id != nil {
    state.blockById[node.id] = node
    // Traverse expressions with precise parent info
    let exprs = node.expressions or []
    for expr, i in exprs {
      walk(expr, resolvedNames, state, node, "expressions", i)
    }
    return
  }

  // Track ANF temp lets and their position in Block.expressions
  if node.type == NODE.Let and node.name and isAnfTempName(node.name.name) and node.name.id {
    let declId = node.name.id
    // Record where the let lives (only deletable when it's a direct element of Block.expressions)
    if parent and parent.type == NODE.Block and parentField == "expressions" and parentIndex != nil and parent.id != nil {
      state.letByDeclId[declId] = .{
        letNode: node,
        blockId: parent.id,
        index: parentIndex,
      }
    } else {
      // Still record the let node for completeness (but cannot delete unless in a block expr list)
      state.letByDeclId[declId] = .{
        letNode: node,
        blockId: nil,
        index: nil,
      }
    }

    // Traverse init only (skip binder name)
    walk(node.init, resolvedNames, state, node, "init", nil)
    return
  }

  // Count identifier uses by binding identity + remember unique use-site
  if node.type == NODE.Identifier and node.id {
    let resolved = resolvedNames[node.id]
    if resolved and resolved.declaredAt {
      let declId = resolved.declaredAt
      let c = state.useCount[declId] or 0
      c = c + 1
      state.useCount[declId] = c

      if c == 1 {
        state.useSite[declId] = .{
          parent: parent,
          field: parentField,
          index: parentIndex,
        }
      } else if c == 2 {
        // No longer single-use
        state.useSite[declId] = nil
      }
    }
  }

  // Specialized traversal for Let (non-temp or non-ANF let): init only
  if node.type == NODE.Let {
    walk(node.init, resolvedNames, state, node, "init", nil)
    return
  }

  // Specialized traversal for common node types (avoid expensive keys() calls)
  // Only specialize node types where we're certain of the field structure
  let nt = node.type

  if nt == NODE.Binary or nt == NODE.Logical {
    walk(node.left, resolvedNames, state, node, "left", nil)
    walk(node.right, resolvedNames, state, node, "right", nil)
    return
  }

  if nt == NODE.Unary {
    walk(node.operand, resolvedNames, state, node, "operand", nil)
    return
  }

  if nt == NODE.Dot {
    walk(node.object, resolvedNames, state, node, "object", nil)
    walk(node.property, resolvedNames, state, node, "property", nil)
    return
  }

  if nt == NODE.Index {
    walk(node.object, resolvedNames, state, node, "object", nil)
    walk(node.index, resolvedNames, state, node, "index", nil)
    return
  }

  // Literals and other leaf nodes - no traversal needed
  if nt == NODE.Nil or nt == NODE.Bool or nt == NODE.Number or nt == NODE.String or nt == NODE.Import {
    return
  }

  // Fallback traversal (should be rare now):
  // We avoid copying; we only walk map/array children.
  for k in keys(node) {
    let v = node[k]
    let vt = type(v)
    if vt == "map" or vt == "array" {
      walk(v, resolvedNames, state, node, k, nil)
    }
  }
}

fn replaceInParent(site, newNode) {
  let p = site and site.parent
  if !p { return false }

  let f = site.field
  let idx = site.index

  // parent is an array itself (field == nil)
  if f == nil and idx != nil {
    p[idx] = newNode
    return true
  }

  // parent[f] is an array
  if idx != nil {
    p[f][idx] = newNode
    return true
  }

  // parent field assignment
  if f != nil {
    p[f] = newNode
    return true
  }

  false
}

fn markRemoval(removedByBlockId, blockId, index) {
  let flags = removedByBlockId[blockId]
  if !flags {
    flags = .{}
    removedByBlockId[blockId] = flags
  }
  flags[index] = true
}

fn compactBlock(block, flags) {
  if !flags { return }
  let exprs = block.expressions or []
  let out = []
  for expr, i in exprs {
    if flags[i] { continue }
    push(out, expr)
  }
  block.expressions = out
}

fn buildState(ast, resolvedNames) {
  let state = .{
    // declId -> { letNode, blockId, index }
    letByDeclId: .{},
    // declId -> count
    useCount: .{},
    // declId -> site (only kept when count == 1)
    useSite: .{},
    // blockId -> block node
    blockById: .{},
  }

  walk(ast, resolvedNames, state, nil, nil, nil)
  state
}

fn compactRemoved(state, removedByBlockId) {
  for bid in keys(removedByBlockId) {
    let block = state.blockById[bid]
    if !block {
      return .{
        success: false,
        error: "ANF-inline: missing block for id " + str(bid),
        blockId: bid,
      }
    }
    compactBlock(block, removedByBlockId[bid])
  }

  .{ success: true }
}

// ------------------------------------------------------------
// Grouped temp inlining (batch pattern for consecutive temps)
// ------------------------------------------------------------

fn isTempLetOfCall(letNode) {
  if !letNode or letNode.type != NODE.Let { return false }
  let tempName = letNode.name and letNode.name.name
  if !isAnfTempName(tempName) { return false }
  if !letNode.init { return false }

  // Check if init is a Call directly
  if letNode.init.type == NODE.Call { return true }

  // Check for a synthetic block with a call tree in the last expression.
  if letNode.init.type == NODE.Block {
    if !letNode.init.anfSynthetic { return false }
    if blockHasLet(letNode.init) { return false }
    let exprs = letNode.init.expressions or []
    if len(exprs) == 0 { return false }
    let last = exprs[len(exprs) - 1]
    if isCallTree(last) { return true }
  }

  false
}

fn extractCallExpr(letNode) {
  // Extract the init expression to inline (Call or synthetic Block with call tree last expr).
  if !letNode or !letNode.init { return nil }

  if letNode.init.type == NODE.Call {
    return letNode.init
  }

  if letNode.init.type == NODE.Block {
    if !letNode.init.anfSynthetic { return nil }
    if blockHasLet(letNode.init) { return nil }
    let exprs = letNode.init.expressions or []
    if len(exprs) > 0 and isCallTree(exprs[len(exprs) - 1]) {
      return letNode.init
    }
  }

  nil
}

fn isSafeLiteral(node) {
  if !node { return false }
  if node.type == NODE.Grouping {
    return isSafeLiteral(node.expression)
  }
  SAFE_LITERAL_TYPES[node.type] == true
}

fn blockHasLet(block) {
  if !block or block.type != NODE.Block { return false }
  let exprs = block.expressions or []
  for expr in exprs {
    if expr and expr.type == NODE.Let { return true }
  }
  false
}

fn isCallTree(node) {
  if !node { return false }
  if node.type == NODE.Call { return true }
  if isSafeLiteral(node) { return true }
  if node.type == NODE.Binary {
    return isCallTree(node.left) and isCallTree(node.right)
  }
  false
}

fn isSingleUseInSameBlock(state, declId, blockId) {
  let uses = state.useCount[declId] or 0
  if uses != 1 { return false }

  let site = state.useSite[declId]
  if !site { return false }

  // The let must be in this block (we'll verify use-site location in the main loop)
  let info = state.letByDeclId[declId]
  if !info or info.blockId != blockId { return false }

  true
}

fn collectBinaryIdentDecls(node, resolvedNames, out) {
  if !node { return false }

  if node.type == NODE.Identifier and node.id {
    let resolved = resolvedNames[node.id]
    if !resolved or !resolved.declaredAt { return false }
    push(out, resolved.declaredAt)
    return true
  }

  if isSafeLiteral(node) {
    return true
  }

  if node.type == NODE.Grouping {
    return collectBinaryIdentDecls(node.expression, resolvedNames, out)
  }

  if node.type == NODE.Binary {
    if !collectBinaryIdentDecls(node.left, resolvedNames, out) { return false }
    if !collectBinaryIdentDecls(node.right, resolvedNames, out) { return false }
    return true
  }

  false
}

fn inlineGroupedTempsInBlock(block, state, resolvedNames, removedByBlockId) {
  let exprs = block.expressions or []
  let i = 0
  let debug = Lx.env["LX_DEBUG_ANF_INLINE"]

  for i < len(exprs) {
    let fileLabel = block.filename or "<no-file>"
    debugLog(debug, "anf-inline: block " + str(block.id) + " run start at " + str(i) + " file " + fileLabel)
    // 1) Collect a run of consecutive temp lets of Call
    let start = i
    let run = []  // each item: { letNode, declId, index }

    for i < len(exprs) {
      if !isTempLetOfCall(exprs[i]) {
        debugLog(debug, "anf-inline: stop run at " + str(i) + " expr " +
          (exprs[i] and nameOf(NODE, exprs[i].type) or "nil"))
        break
      }

      let letNode = exprs[i]
      let declId = letNode.name.id

      // Only consider single-use temps in this block
      if !isSingleUseInSameBlock(state, declId, block.id) {
        debugLog(debug, "anf-inline: stop run at " + str(i) + " declId " +
          str(declId) + " not single-use in block")
        break
      }

      push(run, .{ letNode: letNode, declId: declId, index: i })
      i = i + 1
    }

    if len(run) == 0 {
      i = i + 1
      continue
    }

    // 2) Next expr is the candidate user
    if i >= len(exprs) { break }
    let useExpr = exprs[i]
    debugLog(debug, "anf-inline: block " + str(block.id) + " run size " +
      str(len(run)) + " next expr " + (useExpr and nameOf(NODE, useExpr.type) or "nil"))

    // 3) Guard: binary chain of identifiers in evaluation order
    if useExpr.type != NODE.Binary {
      debugLog(debug, "anf-inline: reject non-binary")
      i = i + 1
      continue
    }

    if len(run) == 2 {
      let left = useExpr.left
      let right = useExpr.right
      if !left or !right or left.type != NODE.Identifier or right.type != NODE.Identifier {
        debugLog(debug, "anf-inline: non-identifier operands")
        i = i + 1
        continue
      }

      let leftDecl = resolvedNames[left.id] and resolvedNames[left.id].declaredAt
      let rightDecl = resolvedNames[right.id] and resolvedNames[right.id].declaredAt
      if leftDecl != run[0].declId or rightDecl != run[1].declId {
        debugLog(debug, "anf-inline: left/right decl mismatch")
        i = i + 1
        continue
      }
    } else {
      let useDecls = []
      if !collectBinaryIdentDecls(useExpr, resolvedNames, useDecls) {
        debugLog(debug, "anf-inline: reject non-ident binary tree")
        i = i + 1
        continue
      }

      if len(useDecls) != len(run) {
        debugLog(debug, "anf-inline: reject decl count mismatch")
        i = i + 1
        continue
      }

      let orderMatches = true
      for let j = 0; j < len(run); j = j + 1 {
        if useDecls[j] != run[j].declId {
          orderMatches = false
          break
        }
      }
      if !orderMatches {
        debugLog(debug, "anf-inline: reject decl order mismatch")
        i = i + 1
        continue
      }
    }

    // 5) Perform replacements: replace identifiers with init expressions
    if len(run) == 2 {
      let leftInit = extractCallExpr(run[0].letNode)
      let rightInit = extractCallExpr(run[1].letNode)
      if !leftInit or !rightInit {
        debugLog(debug, "anf-inline: missing init expr")
        i = i + 1
        continue
      }
      useExpr.left = leftInit
      useExpr.right = rightInit
      markRemoval(removedByBlockId, block.id, run[0].index)
      markRemoval(removedByBlockId, block.id, run[1].index)
      debugLog(debug, "anf-inline: inlined run at block " + str(block.id))
    } else {
      for item in run {
        let declId = item.declId
        let site = state.useSite[declId]
        if !site {
          debugLog(debug, "anf-inline: missing useSite for decl " + str(declId))
          continue
        }
        let initExpr = extractCallExpr(item.letNode)
        if !initExpr {
          debugLog(debug, "anf-inline: missing init expr")
          continue
        }
        if !replaceInParent(site, initExpr) {
          debugLog(debug, "anf-inline: replace failed")
          continue
        }
        markRemoval(removedByBlockId, block.id, item.index)
      }
    }

    // 6) Move past the user expr
    i = i + 1
  }

  true
}

// ------------------------------------------------------------
// Entrypoint
// ------------------------------------------------------------

fn anfInline(ast, resolveResult) {
  let resolvedNames = (resolveResult and resolveResult.resolvedNames) or .{}

  let state = buildState(ast, resolvedNames)

  // Apply edits
  let removedByBlockId = .{} // blockId -> { index:true }
  let inlined = 0

  for declId in keys(state.letByDeclId) {
    let info = state.letByDeclId[declId]
    let letNode = info and info.letNode
    if !letNode { continue }

    // Only delete lets that are directly in a block expressions list
    // (info.blockId/index present) and are truly single-use.
    let uses = state.useCount[declId] or 0
    if uses != 1 { continue }

    let site = state.useSite[declId]
    if !site { continue }

    if !isInlineSafeExpr(letNode.init) { continue }

    // Replace the unique use-site with RHS (structural sharing).
    if !replaceInParent(site, letNode.init) {
      return .{
        success: false,
        error: "ANF-inline: failed to replace single-use site for declId " + str(declId),
        declId: declId,
        ast: ast,
      }
    }

    // Remove the let from its block (deferred)
    if info.blockId != nil and info.index != nil {
      markRemoval(removedByBlockId, info.blockId, info.index)
    }

    inlined = inlined + 1
  }

  // Compact lets removed by safe inlining before grouped passes.
  let compactResult = compactRemoved(state, removedByBlockId)
  if !compactResult.success {
    return .{
      success: false,
      error: compactResult.error,
      blockId: compactResult.blockId,
      ast: ast,
    }
  }

  // Apply grouped temp inlining (consecutive temps into Binary).
  // Run a few passes to allow inner blocks to be simplified before outer ones.
  for let pass = 0; pass < 3; pass = pass + 1 {
    let groupedState = buildState(ast, resolvedNames)
    let groupedRemoved = .{}

    for bid in keys(groupedState.blockById) {
      let block = groupedState.blockById[bid]
      if !block { continue }
      inlineGroupedTempsInBlock(block, groupedState, resolvedNames, groupedRemoved)
    }

    if len(keys(groupedRemoved)) == 0 { break }
    let groupedCompact = compactRemoved(groupedState, groupedRemoved)
    if !groupedCompact.success {
      return .{
        success: false,
        error: groupedCompact.error,
        blockId: groupedCompact.blockId,
        ast: ast,
      }
    }
  }

  // Cheap validation (binder-aware):
  // For every removed let, ensure uses==1 and useSite existed (by construction).
  // Also ensure the removed Let node is not still present in its original block
  // at the same index prior to compaction (not checkable now), so we rely on
  // compaction correctness. For extra safety, enable a full debug validator
  // behind an option later (not default).

  .{
    success: true,
    ast: ast,          // mutated in place
    inlined: inlined,  // Note: grouped inlining removals are included in the compaction
  }
}

anfInline
