// Typecheck Phase - Static type inference and checking
//
// Responsibility: Best-effort monomorphic type inference
//   - Type inference for expressions
//   - Unification-based constraint solving
//   - Type error detection and reporting
//
// IMPORTANT: Typecheck MUST NOT mutate the AST.
// All information stored in side tables keyed by node ID.
//
// Core Subset (Phase 1):
//   - Basic types: Unknown, Any, Nil, Number, Bool, String, TypeVar
//   - Monomorphic inference (no Poly/Scheme)
//   - Function, Array, Record types
//   - Eager unification
//
// Deferred to Future Phases:
//   - Polymorphic types (Poly/Scheme, generalization)
//   - Local narrowing (type guards)
//   - Tagged records (discriminated unions)

// ========================================
// Type Constructors
// ========================================

fn typeUnknown() {
  .{ kind: "Unknown" }
}

fn typeAny() {
  .{ kind: "Any" }
}

fn typeNil() {
  .{ kind: "Nil" }
}

fn typeNumber() {
  .{ kind: "Number" }
}

fn typeBool() {
  .{ kind: "Bool" }
}

fn typeString() {
  .{ kind: "String" }
}

fn typeVar(id) {
  .{ kind: "TypeVar", id: id }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params: params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem: elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields: fields }
}

fn typeScheme(typeVars, type) {
  .{ kind: "Scheme", typeVars: typeVars, type: type }
}

fn typeTagged(tagField, cases) {
  .{ kind: "Tagged", tagField: tagField, cases: cases }
}

fn typeRecordTop() {
  .{ kind: "RecordTop" }
}

fn typeLenableTop() {
  .{ kind: "LenableTop" }
}

// ========================================
// Type Bindings (Mono/Poly)
// ========================================

fn bindingMono(typeVar) {
  .{ kind: "Mono", typeVar: typeVar }
}

fn bindingPoly(scheme) {
  .{ kind: "Poly", scheme: scheme }
}

// ========================================
// Type Variable Management
// ========================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = checker.nextTypeVarId + 1
  typeVar(id)
}

fn bindTypeVar(checker, typeVarId, type) {
  checker.typeVarBindings[typeVarId] = type
}

fn getTypeVarBinding(checker, typeVarId) {
  checker.typeVarBindings[typeVarId]
}

// Dereference TypeVars to their bound types
fn deref(checker, type) {
  if type.kind == "TypeVar" {
    let bound = getTypeVarBinding(checker, type.id)
    if bound {
      return deref(checker, bound)
    }
  }
  type
}

// Occurs check: does typeVarId occur in type?
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for let i = 0; i < len(type.params); i = i + 1 {
      if occurs(checker, typeVarId, type.params[i]) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Record" {
    let fieldKeys = keys(type.fields)
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let key = fieldKeys[i]
      if occurs(checker, typeVarId, type.fields[key]) {
        return true
      }
    }
    return false
  }

  if type.kind == "Tagged" {
    let caseKeys = keys(type.cases)
    for let i = 0; i < len(caseKeys); i = i + 1 {
      let tagValue = caseKeys[i]
      if occurs(checker, typeVarId, type.cases[tagValue]) {
        return true
      }
    }
    return false
  }

  // For other types (primitives, Unknown, Any, etc.), no occurrence
  false
}

// ========================================
// Type Equality
// ========================================

fn sameType(t1, t2) {
  if t1.kind != t2.kind {
    return false
  }

  if t1.kind == "TypeVar" {
    return t1.id == t2.id
  } else if t1.kind == "Function" {
    if len(t1.params) != len(t2.params) {
      return false
    }
    for let i = 0; i < len(t1.params); i = i + 1 {
      if !sameType(t1.params[i], t2.params[i]) {
        return false
      }
    }
    return sameType(t1.return, t2.return)
  } else if t1.kind == "Array" {
    return sameType(t1.elem, t2.elem)
  } else if t1.kind == "Record" {
    let keys1 = keys(t1.fields)
    let keys2 = keys(t2.fields)
    if len(keys1) != len(keys2) {
      return false
    }
    for let i = 0; i < len(keys1); i = i + 1 {
      let k = keys1[i]
      if !t2.fields[k] {
        return false
      }
      if !sameType(t1.fields[k], t2.fields[k]) {
        return false
      }
    }
    return true
  }

  // Tagged types
  if t1.kind == "Tagged" and t2.kind == "Tagged" {
    if t1.tagField != t2.tagField {
      return false
    }
    let keys1 = keys(t1.cases)
    let keys2 = keys(t2.cases)
    if len(keys1) != len(keys2) {
      return false
    }
    for let i = 0; i < len(keys1); i = i + 1 {
      let k = keys1[i]
      if !t2.cases[k] {
        return false
      }
      if !sameType(t1.cases[k], t2.cases[k]) {
        return false
      }
    }
    return true
  }

  // Primitive types (Unknown, Any, Nil, Number, Bool, String)
  true
}

// ========================================
// Forward Declarations
// ========================================

let lookupDecl = nil
let addError = nil
let checkExpr = nil

// ========================================
// Type Environment
// ========================================

fn TypeEnv(parent) {
  .{
    parent: parent,
    bindings: .{},  // declNodeId → TypeVar
  }
}

fn cloneEnv(env) {
  // Shallow clone environment for type narrowing
  // Clone bindings map to allow shadowing
  if !env { return nil }

  let newBindings = .{}
  let bindingKeys = keys(env.bindings)
  for let i = 0; i < len(bindingKeys); i = i + 1 {
    let key = bindingKeys[i]
    newBindings[key] = env.bindings[key]
  }

  return .{
    parent: env.parent,  // Share parent chain
    bindings: newBindings,
  }
}

// ========================================
// Type Narrowing - Refinement
// ========================================

fn refineForNilCheck(checker, env, guard, truthy) {
  // guard.isNilCheck: true if checking == nil, false if checking != nil
  let checkingIsNil = guard.isNilCheck
  let shouldBeNil = (truthy == checkingIsNil)

  if shouldBeNil {
    // Variable is Nil - create new binding
    let freshVar = freshTypeVar(checker)
    let nilType = typeNil()
    bindTypeVar(checker, freshVar.id, nilType)
    let newBinding = bindingMono(freshVar)
    env.bindings[guard.declNodeId] = newBinding
  } else {
    // Variable is non-nil
    // Best-effort: we don't create a NonNil type form
    // Just leave the binding as-is for now
    // This is sufficient to mark that we've validated non-nil
  }
}

fn refineForTypeTest(checker, env, guard, truthy) {
  if !truthy { return }  // Only refine in truthy branch

  // Replace binding with refined type
  let freshVar = freshTypeVar(checker)
  let refinedType = guard.expectedType
  bindTypeVar(checker, freshVar.id, refinedType)
  let newBinding = bindingMono(freshVar)
  env.bindings[guard.declNodeId] = newBinding
}

fn refineForTagCheck(checker, env, guard, truthy) {
  if !truthy { return }

  // Get variable's current type
  let originalBinding = lookupDecl(checker, guard.declNodeId)
  if !originalBinding or originalBinding.kind == "Poly" {
    return
  }

  let varType = deref(checker, originalBinding.typeVar)
  if !varType or varType.kind != "Tagged" {
    return
  }

  // Verify tag field and value match
  if varType.tagField != guard.tagField {
    return
  }
  if !varType.cases[guard.tagValue] {
    return
  }

  // Store known tag
  checker.knownTags[guard.declNodeId] = guard.tagValue
}

fn refineEnv(checker, env, guard, truthy) {
  // Create a refined environment based on guard
  if !guard { return env }

  // Check if guard variable is polymorphic (can't refine)
  let originalBinding = lookupDecl(checker, guard.declNodeId)
  if originalBinding and originalBinding.kind == "Poly" {
    return env  // Don't refine polymorphic bindings
  }

  let refinedEnv = cloneEnv(env)

  if guard.kind == "nil-check" {
    refineForNilCheck(checker, refinedEnv, guard, truthy)
  } else if guard.kind == "type-test" {
    refineForTypeTest(checker, refinedEnv, guard, truthy)
  } else if guard.kind == "tag-check" {
    refineForTagCheck(checker, refinedEnv, guard, truthy)
  }

  return refinedEnv
}

fn enterScope(checker) {
  let newEnv = TypeEnv(checker.currentEnv)
  checker.currentEnv = newEnv
  newEnv
}

fn exitScope(checker) {
  if checker.currentEnv {
    checker.currentEnv = checker.currentEnv.parent
  }
}

fn bindDeclMono(checker, declNodeId) {
  // Create a monomorphic binding
  if !declNodeId {
    return bindingMono(freshTypeVar(checker))
  }
  let tv = freshTypeVar(checker)
  let binding = bindingMono(tv)
  checker.currentEnv.bindings[declNodeId] = binding
  binding
}

fn bindDeclPoly(checker, declNodeId, scheme) {
  // Create a polymorphic binding
  if !declNodeId {
    return bindingPoly(scheme)
  }
  let binding = bindingPoly(scheme)
  checker.currentEnv.bindings[declNodeId] = binding
  binding
}

lookupDecl = fn(checker, declNodeId) {
  // Returns Mono/Poly binding or nil
  if !declNodeId {
    return nil
  }
  let env = checker.currentEnv
  for env {
    let binding = env.bindings[declNodeId]
    if binding {
      return binding
    }
    env = env.parent
  }
  return nil
}

// ========================================
// Unification Algorithm
// ========================================

fn unify(checker, t1, t2) {
  // Dereference both types
  t1 = deref(checker, t1)
  t2 = deref(checker, t2)

  // Same type - success
  if sameType(t1, t2) {
    return true
  }

  // Unknown unifies with anything (stays Unknown for now in core subset)
  if t1.kind == "Unknown" or t2.kind == "Unknown" {
    return true
  }

  // Any accepts everything
  if t1.kind == "Any" or t2.kind == "Any" {
    return true
  }

  // TypeVar unification
  if t1.kind == "TypeVar" {
    // Occurs check: prevent infinite types
    if occurs(checker, t1.id, t2) {
      return false
    }
    bindTypeVar(checker, t1.id, t2)
    return true
  }
  if t2.kind == "TypeVar" {
    // Occurs check: prevent infinite types
    if occurs(checker, t2.id, t1) {
      return false
    }
    bindTypeVar(checker, t2.id, t1)
    return true
  }

  // Structural unification - Function
  if t1.kind == "Function" and t2.kind == "Function" {
    if len(t1.params) != len(t2.params) {
      return false
    }
    for let i = 0; i < len(t1.params); i = i + 1 {
      if !unify(checker, t1.params[i], t2.params[i]) {
        return false
      }
    }
    return unify(checker, t1.return, t2.return)
  }

  // Structural unification - Array
  if t1.kind == "Array" and t2.kind == "Array" {
    return unify(checker, t1.elem, t2.elem)
  }

  // Structural unification - Record
  if t1.kind == "Record" and t2.kind == "Record" {
    let keys1 = keys(t1.fields)
    let keys2 = keys(t2.fields)

    // Check all keys from t1 exist in t2
    for let i = 0; i < len(keys1); i = i + 1 {
      let k = keys1[i]
      if !t2.fields[k] {
        return false
      }
      if !unify(checker, t1.fields[k], t2.fields[k]) {
        return false
      }
    }

    // Check all keys from t2 exist in t1
    for let i = 0; i < len(keys2); i = i + 1 {
      let k = keys2[i]
      if !t1.fields[k] {
        return false
      }
    }

    return true
  }

  // Structural unification - Tagged
  if t1.kind == "Tagged" and t2.kind == "Tagged" {
    // Tag field must match
    if t1.tagField != t2.tagField {
      return false
    }

    // Unify overlapping cases and merge cases from t2 into t1
    let keys2 = keys(t2.cases)
    for let i = 0; i < len(keys2); i = i + 1 {
      let k = keys2[i]
      let case1 = t1.cases[k]
      let case2 = t2.cases[k]

      if case1 {
        // Overlapping case - unify
        if !unify(checker, case1, case2) {
          return false
        }
      } else {
        // New case from t2 - merge it into t1
        t1.cases[k] = case2
      }
    }

    return true
  }

  // Tagged with Record: strict mode - incompatible
  if (t1.kind == "Tagged" and t2.kind == "Record") or
     (t1.kind == "Record" and t2.kind == "Tagged") {
    return false
  }

  // RecordTop unifies with any Record
  if t1.kind == "RecordTop" and t2.kind == "Record" {
    return true
  }
  if t1.kind == "Record" and t2.kind == "RecordTop" {
    return true
  }

  // LenableTop unifies with String and Array
  if t1.kind == "LenableTop" and (t2.kind == "String" or t2.kind == "Array") {
    return true
  }
  if (t1.kind == "String" or t1.kind == "Array") and t2.kind == "LenableTop" {
    return true
  }

  // Incompatible types
  false
}

fn constrain(checker, t1, t2, nodeId, errorMsg) {
  if !unify(checker, t1, t2) {
    addError(checker, nodeId, errorMsg)
    return typeAny()
  }
  t1
}

// ========================================
// Polymorphism: Schemes, Generalization, Instantiation
// ========================================

fn ftv(type) {
  // Compute free type variables in a type
  if type.kind == "TypeVar" {
    return [type.id]
  }

  if type.kind == "Function" {
    let vars = []
    for let i = 0; i < len(type.params); i = i + 1 {
      let paramVars = ftv(type.params[i])
      for let j = 0; j < len(paramVars); j = j + 1 {
        push(vars, paramVars[j])
      }
    }
    let retVars = ftv(type.return)
    for let j = 0; j < len(retVars); j = j + 1 {
      push(vars, retVars[j])
    }
    return vars
  }

  if type.kind == "Array" {
    return ftv(type.elem)
  }

  if type.kind == "Record" {
    let vars = []
    let fieldKeys = keys(type.fields)
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let fieldVars = ftv(type.fields[fieldKeys[i]])
      for let j = 0; j < len(fieldVars); j = j + 1 {
        push(vars, fieldVars[j])
      }
    }
    return vars
  }

  if type.kind == "Tagged" {
    let vars = []
    let caseKeys = keys(type.cases)
    for let i = 0; i < len(caseKeys); i = i + 1 {
      let caseVars = ftv(type.cases[caseKeys[i]])
      for let j = 0; j < len(caseVars); j = j + 1 {
        push(vars, caseVars[j])
      }
    }
    return vars
  }

  // Unknown, Any, Nil, Number, Bool, String have no free vars
  return []
}

fn ftvEnv(checker, env) {
  // Compute free type variables in environment
  let vars = []
  for env {
    let bindingKeys = keys(env.bindings)
    for let i = 0; i < len(bindingKeys); i = i + 1 {
      let binding = env.bindings[bindingKeys[i]]
      if binding.kind == "Mono" {
        let bindingVars = ftv(binding.typeVar)
        for let j = 0; j < len(bindingVars); j = j + 1 {
          push(vars, bindingVars[j])
        }
      }
      // Poly bindings don't contribute free vars (they're bound by Scheme)
    }
    env = env.parent
  }
  return vars
}

fn setDifference(set1, set2) {
  // Return elements in set1 that are not in set2
  let result = []
  for let i = 0; i < len(set1); i = i + 1 {
    let found = false
    for let j = 0; j < len(set2); j = j + 1 {
      if set1[i] == set2[j] {
        found = true
      }
    }
    if !found {
      push(result, set1[i])
    }
  }
  return result
}

fn derefAll(checker, type) {
  // Recursively dereference all TypeVars in a type
  type = deref(checker, type)

  if type.kind == "Function" {
    let newParams = []
    for let i = 0; i < len(type.params); i = i + 1 {
      push(newParams, derefAll(checker, type.params[i]))
    }
    let newReturn = derefAll(checker, type.return)
    return typeFunction(newParams, newReturn)
  }

  if type.kind == "Array" {
    return typeArray(derefAll(checker, type.elem))
  }

  if type.kind == "Record" {
    let newFields = .{}
    let fieldKeys = keys(type.fields)
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let key = fieldKeys[i]
      newFields[key] = derefAll(checker, type.fields[key])
    }
    return typeRecord(newFields)
  }

  if type.kind == "Tagged" {
    let newCases = .{}
    let caseKeys = keys(type.cases)
    for let i = 0; i < len(caseKeys); i = i + 1 {
      let tagValue = caseKeys[i]
      newCases[tagValue] = derefAll(checker, type.cases[tagValue])
    }
    return typeTagged(type.tagField, newCases)
  }

  // TypeVar, Unknown, Any, Nil, Number, Bool, String - already deref'd
  return type
}

fn generalize(checker, env, type) {
  // First, fully dereference the type to follow all bindings
  type = derefAll(checker, type)

  // generalize(env, type) = Forall(ftv(type) - ftv(env), type)
  let typeFreeVars = ftv(type)
  let envFreeVars = ftvEnv(checker, env)
  let quantifiedVars = setDifference(typeFreeVars, envFreeVars)

  if len(quantifiedVars) == 0 {
    // No free vars to quantify - return monomorphic binding
    return nil
  }

  typeScheme(quantifiedVars, type)
}

fn substitute(type, subst) {
  // Substitute TypeVars according to subst map
  if type.kind == "TypeVar" {
    let replacement = subst[type.id]
    if replacement {
      return replacement
    }
    return type
  }

  if type.kind == "Function" {
    let newParams = []
    for let i = 0; i < len(type.params); i = i + 1 {
      push(newParams, substitute(type.params[i], subst))
    }
    let newReturn = substitute(type.return, subst)
    return typeFunction(newParams, newReturn)
  }

  if type.kind == "Array" {
    return typeArray(substitute(type.elem, subst))
  }

  if type.kind == "Record" {
    let newFields = .{}
    let fieldKeys = keys(type.fields)
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let key = fieldKeys[i]
      newFields[key] = substitute(type.fields[key], subst)
    }
    return typeRecord(newFields)
  }

  if type.kind == "Tagged" {
    let newCases = .{}
    let caseKeys = keys(type.cases)
    for let i = 0; i < len(caseKeys); i = i + 1 {
      let tagValue = caseKeys[i]
      newCases[tagValue] = substitute(type.cases[tagValue], subst)
    }
    return typeTagged(type.tagField, newCases)
  }

  // Unknown, Any, Nil, Number, Bool, String unchanged
  return type
}

fn instantiate(checker, scheme) {
  // instantiate(Forall([t1..tn], T)) = substitute(T, { t1 → fresh, ... })
  let subst = .{}
  for let i = 0; i < len(scheme.typeVars); i = i + 1 {
    let oldId = scheme.typeVars[i]
    let newVar = freshTypeVar(checker)
    subst[oldId] = newVar
  }
  substitute(scheme.type, subst)
}

// ========================================
// Error Handling
// ========================================

addError = fn(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Expression Type Checking
// ========================================

fn checkLiteral(checker, node) {
  let resultType = nil

  if node.type == "Number" {
    resultType = typeNumber()
  } else if node.type == "String" {
    resultType = typeString()
  } else if node.type == "Bool" {
    resultType = typeBool()
  } else if node.type == "Nil" {
    resultType = typeNil()
  }

  if node.id {
    checker.types[node.id] = resultType
  }

  resultType
}

fn getBuiltinType(checker, name) {
  // Returns type for known builtins, nil otherwise
  // Using TypeVars to approximate polymorphism

  if name == "len" {
    // len: LenableTop -> Number (accepts String or Array)
    return typeFunction([typeLenableTop()], typeNumber())
  }

  if name == "push" {
    // push: (Array(T), T) -> Nil
    let tv = freshTypeVar(checker)
    return typeFunction([typeArray(tv), tv], typeNil())
  }

  if name == "println" or name == "print" {
    // println/print: (...Any) -> Nil (variadic, approximate with Any)
    return typeFunction([typeAny()], typeNil())
  }

  if name == "type" {
    // type: Any -> String
    return typeFunction([typeAny()], typeString())
  }

  if name == "str" {
    // str: Any -> String
    return typeFunction([typeAny()], typeString())
  }

  if name == "int" {
    // int: Any -> Number
    return typeFunction([typeAny()], typeNumber())
  }

  if name == "range" {
    // range: Number -> Array(Number)
    return typeFunction([typeNumber()], typeArray(typeNumber()))
  }

  if name == "map" {
    // map: (Array(T), Function(T -> U)) -> Array(U)
    let tvar = freshTypeVar(checker)
    let uvar = freshTypeVar(checker)
    let fnType = typeFunction([tvar], uvar)
    return typeFunction([typeArray(tvar), fnType], typeArray(uvar))
  }

  if name == "fold" {
    // fold: (Array(T), U, Function(U, T -> U)) -> U
    let tvar = freshTypeVar(checker)
    let uvar = freshTypeVar(checker)
    let fnType = typeFunction([uvar, tvar], uvar)
    return typeFunction([typeArray(tvar), uvar, fnType], uvar)
  }

  if name == "each" {
    // each: (Array(T), Function(T -> Any)) -> Nil
    let tvar = freshTypeVar(checker)
    let fnType = typeFunction([tvar], typeAny())
    return typeFunction([typeArray(tvar), fnType], typeNil())
  }

  if name == "keys" {
    // keys: RecordTop -> Array(String) (accepts any Record)
    return typeFunction([typeRecordTop()], typeArray(typeString()))
  }

  if name == "join" {
    // join: (Array(String), String) -> String
    return typeFunction([typeArray(typeString()), typeString()], typeString())
  }

  nil
}

fn checkIdentifier(checker, node) {
  // Look up in resolvedNames (from resolve phase)
  let binding = checker.resolvedNames[node.id]

  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Get the declaration's type binding
  let declNodeId = binding.declaredAt
  let declBinding = lookupDecl(checker, declNodeId)

  let declType = nil

  if declBinding {
    // Found in local environment - extract type based on Mono/Poly
    if declBinding.kind == "Mono" {
      declType = declBinding.typeVar
    } else if declBinding.kind == "Poly" {
      // Instantiate polymorphic binding with fresh TypeVars
      declType = instantiate(checker, declBinding.scheme)
    }
  } else {
    // Not in local environment - check if it's a builtin
    let builtinType = getBuiltinType(checker, node.name)
    if builtinType {
      declType = builtinType
      // Cache builtin type for this declaration (as Mono binding)
      if declNodeId {
        checker.globalTypeCache[declNodeId] = bindingMono(builtinType)
      }
    } else if declNodeId {
      // Check global cache
      let cachedBinding = checker.globalTypeCache[declNodeId]
      if cachedBinding {
        if cachedBinding.kind == "Mono" {
          declType = cachedBinding.typeVar
        } else if cachedBinding.kind == "Poly" {
          declType = instantiate(checker, cachedBinding.scheme)
        }
      } else {
        // First time seeing this global - create and cache it
        declType = freshTypeVar(checker)
        checker.globalTypeCache[declNodeId] = bindingMono(declType)
      }
    } else {
      // No declNodeId - create fresh TypeVar
      declType = freshTypeVar(checker)
    }
  }

  checker.types[node.id] = declType
  declType
}

fn checkBinary(checker, node) {
  let leftType = checkExpr(checker, node.left)
  let rightType = checkExpr(checker, node.right)

  let resultType = nil
  let op = node.operator.lexeme

  // Arithmetic: +, -, *, /, %
  if op == "+" or op == "-" or op == "*" or op == "/" or op == "%" {
    constrain(checker, leftType, typeNumber(), node.left.id,
      "Arithmetic operation requires number")
    constrain(checker, rightType, typeNumber(), node.right.id,
      "Arithmetic operation requires number")
    resultType = typeNumber()
  }
  // Comparison: <, >, <=, >=
  else if op == "<" or op == ">" or op == "<=" or op == ">=" {
    constrain(checker, leftType, typeNumber(), node.left.id,
      "Comparison requires number")
    constrain(checker, rightType, typeNumber(), node.right.id,
      "Comparison requires number")
    resultType = typeBool()
  }
  // Equality: ==, !=
  else if op == "==" or op == "!=" {
    // No constraints - any types can be compared
    resultType = typeBool()
  }
  // Bitwise: &, |, ^, <<, >>
  else if op == "&" or op == "|" or op == "^" or op == "<<" or op == ">>" {
    constrain(checker, leftType, typeNumber(), node.left.id,
      "Bitwise operation requires number")
    constrain(checker, rightType, typeNumber(), node.right.id,
      "Bitwise operation requires number")
    resultType = typeNumber()
  }
  else {
    addError(checker, node.id, "Unknown binary operator: " + op)
    resultType = typeAny()
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkUnary(checker, node) {
  let operandType = checkExpr(checker, node.operand)

  let resultType = nil
  let op = node.operator.lexeme

  if op == "-" {
    constrain(checker, operandType, typeNumber(), node.operand.id,
      "Unary negation requires number")
    resultType = typeNumber()
  } else if op == "!" {
    // No constraint - any type can be negated
    resultType = typeBool()
  } else {
    addError(checker, node.id, "Unknown unary operator: " + op)
    resultType = typeAny()
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkLogical(checker, node) {
  let leftType = checkExpr(checker, node.left)
  let rightType = checkExpr(checker, node.right)

  // Logical operators with short-circuit semantics can return either operand
  // If both types are compatible (unify), use that type; otherwise use Any
  leftType = deref(checker, leftType)
  rightType = deref(checker, rightType)

  let resultType = typeAny()
  if unify(checker, leftType, rightType) {
    resultType = leftType
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkArray(checker, node) {
  // Infer element type from first element, unify with rest
  let elemType = freshTypeVar(checker)

  if len(node.elements) > 0 {
    elemType = checkExpr(checker, node.elements[0])

    for let i = 1; i < len(node.elements); i = i + 1 {
      let eltType = checkExpr(checker, node.elements[i])
      constrain(checker, elemType, eltType, node.elements[i].id,
        "Array elements must have compatible types")
    }
  }

  let resultType = typeArray(elemType)
  checker.types[node.id] = resultType
  resultType
}

fn checkIndex(checker, node) {
  let objType = checkExpr(checker, node.object)
  let indexType = checkExpr(checker, node.index)

  objType = deref(checker, objType)

  let resultType = nil

  if objType.kind == "Array" {
    // Index should be number (optional check)
    constrain(checker, indexType, typeNumber(), node.index.id,
      "Array index must be number")
    resultType = objType.elem
  } else if objType.kind == "Unknown" or objType.kind == "TypeVar" {
    // Refine to Array(TypeVar) - this binds the Unknown/TypeVar
    let elemType = freshTypeVar(checker)
    let arrayType = typeArray(elemType)
    constrain(checker, objType, arrayType, node.object.id,
      "Index access requires array")
    resultType = elemType
  } else {
    addError(checker, node.id, "Index access requires array, got: " + objType.kind)
    resultType = typeAny()
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkHashmap(checker, node) {
  // Get tag field names from opts (default: ["kind", "type", "tag"])
  let tagFieldNames = ["kind", "type", "tag"]
  if checker.opts.tagFieldNames {
    tagFieldNames = checker.opts.tagFieldNames
  }

  // First pass: check for tag field with literal value
  let tagFieldName = nil
  let tagValue = nil
  let tagPairIndex = -1

  for let i = 0; i < len(node.pairs); i = i + 1 {
    let pair = node.pairs[i]
    if pair.key.type == "String" {
      let keyName = pair.key.value

      // Check if this is a tag field
      for let j = 0; j < len(tagFieldNames); j = j + 1 {
        if keyName == tagFieldNames[j] {
          // Found potential tag field - check if value is literal
          if pair.value.type == "String" {
            tagFieldName = keyName
            tagValue = pair.value.value
            tagPairIndex = i
          }
        }
      }
    }
  }

  // Second pass: build type
  if tagFieldName {
    // Build Tagged type - exclude tag field from case fields
    let caseFields = .{}

    for let i = 0; i < len(node.pairs); i = i + 1 {
      if i == tagPairIndex {
        // Skip tag field - it's not part of the case Record
        let dummy = 0
      } else {
        let pair = node.pairs[i]
        let valueType = checkExpr(checker, pair.value)

        if pair.key.type == "String" {
          let keyName = pair.key.value
          caseFields[keyName] = valueType
        } else {
          addError(checker, pair.key.id, "Record keys must be string literals")
        }
      }
    }

    // Create single-case Tagged
    let cases = .{}
    cases[tagValue] = typeRecord(caseFields)

    let resultType = typeTagged(tagFieldName, cases)
    checker.types[node.id] = resultType
    return resultType
  } else {
    // Build regular Record (existing logic)
    let fields = .{}

    for let i = 0; i < len(node.pairs); i = i + 1 {
      let pair = node.pairs[i]
      let keyType = checkExpr(checker, pair.key)
      let valueType = checkExpr(checker, pair.value)

      if pair.key.type == "String" {
        let keyName = pair.key.value
        fields[keyName] = valueType
      } else {
        addError(checker, pair.key.id, "Record keys must be string literals")
      }
    }

    let resultType = typeRecord(fields)
    checker.types[node.id] = resultType
    return resultType
  }
}

fn checkFieldInAllCases(checker, cases, fieldName, nodeId) {
  // Check if field exists in all cases with same type
  let caseKeys = keys(cases)

  if len(caseKeys) == 0 {
    addError(checker, nodeId, "Cannot access field on empty tagged union")
    return typeAny()
  }

  let firstCase = cases[caseKeys[0]]
  let commonFieldType = firstCase.fields[fieldName]

  if !commonFieldType {
    addError(checker, nodeId, "Field '" + fieldName + "' not present in all cases")
    return typeAny()
  }

  // Check all other cases have this field with same type
  for let i = 1; i < len(caseKeys); i = i + 1 {
    let caseRecord = cases[caseKeys[i]]
    let fieldType = caseRecord.fields[fieldName]

    if !fieldType {
      addError(checker, nodeId, "Field '" + fieldName + "' not present in all cases")
      return typeAny()
    }

    if !sameType(commonFieldType, fieldType) {
      addError(checker, nodeId, "Field '" + fieldName + "' has incompatible types across cases")
      return typeAny()
    }
  }

  return commonFieldType
}

fn getKnownTag(checker, objNode) {
  // Get known tag for an identifier from narrowing context
  if objNode.type != "Identifier" {
    return nil
  }

  let binding = checker.resolvedNames[objNode.id]
  if !binding {
    return nil
  }

  return checker.knownTags[binding.declaredAt]
}

fn checkDot(checker, node) {
  let objType = checkExpr(checker, node.object)
  objType = deref(checker, objType)

  // Property must be a string literal (from parser)
  let propName = node.property.value

  let resultType = nil

  if objType.kind == "Tagged" {
    // Accessing tag field itself
    if propName == objType.tagField {
      resultType = typeString()
    } else {
      // Accessing non-tag field
      let knownTag = getKnownTag(checker, node.object)

      if knownTag {
        // Tag is known via narrowing - lookup in specific case
        let caseRecord = objType.cases[knownTag]
        if !caseRecord {
          addError(checker, node.id, "Unknown tag value '" + knownTag + "'")
          resultType = typeAny()
        } else {
          let fieldType = caseRecord.fields[propName]
          if !fieldType {
            addError(checker, node.id, "Field '" + propName + "' not in case '" + knownTag + "'")
            resultType = typeAny()
          } else {
            resultType = fieldType
          }
        }
      } else {
        // Tag unknown - field must exist in all cases
        resultType = checkFieldInAllCases(checker, objType.cases, propName, node.id)
      }
    }
  } else if objType.kind == "Record" {
    let fieldType = objType.fields[propName]
    if !fieldType {
      addError(checker, node.id, "Property '" + propName + "' not found in record")
      resultType = typeAny()
    } else {
      resultType = fieldType
    }
  } else if objType.kind == "Unknown" or objType.kind == "TypeVar" {
    // Refine to Record with this field - this binds the Unknown/TypeVar
    let fieldType = freshTypeVar(checker)
    let recordFields = .{}
    recordFields[propName] = fieldType
    let recordType = typeRecord(recordFields)
    constrain(checker, objType, recordType, node.object.id,
      "Dot access requires record")
    resultType = fieldType
  } else {
    addError(checker, node.id, "Dot access requires record, got: " + objType.kind)
    resultType = typeAny()
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkFunction(checker, node) {
  // If this is a named function, pre-bind its declaration ID to allow recursion
  // The resolve phase declares named functions at the function node ID (not the name identifier ID)
  let functionBinding = nil
  if node.name {
    functionBinding = bindDeclMono(checker, node.id)
  }

  // Enter new scope for function
  enterScope(checker)

  // Create type variables for parameters
  let paramTypes = []
  for let i = 0; i < len(node.params); i = i + 1 {
    let param = node.params[i]
    let binding = bindDeclMono(checker, param.id)
    let paramType = binding.typeVar

    push(paramTypes, paramType)
    checker.types[param.id] = paramType
  }

  // Track return type for this function
  let returnType = freshTypeVar(checker)
  let prevReturnType = checker.currentReturnType
  checker.currentReturnType = returnType

  // Check body
  let bodyType = checkExpr(checker, node.body)

  // Body type unifies with return type (implicit return)
  // But only if the body doesn't end with an explicit return (which evaluates to Nil)
  bodyType = deref(checker, bodyType)
  if bodyType.kind != "Nil" {
    constrain(checker, bodyType, returnType, node.body.id,
      "Function body type incompatible with return type")
  }

  // Restore previous return type
  checker.currentReturnType = prevReturnType

  exitScope(checker)

  // Create function type
  let resultType = typeFunction(paramTypes, returnType)
  checker.types[node.id] = resultType

  // Bind the function declaration to its inferred type
  if functionBinding {
    constrain(checker, functionBinding.typeVar, resultType, node.id,
      "Function type inconsistent")
  }

  resultType
}

fn checkCall(checker, node) {
  let calleeType = checkExpr(checker, node.callee)

  // Check arguments
  let argTypes = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(argTypes, checkExpr(checker, node.args[i]))
  }

  calleeType = deref(checker, calleeType)

  let resultType = nil

  if calleeType.kind == "Function" {
    // Arity widening: allow extra arguments (ignore them), error on missing
    let paramCount = len(calleeType.params)
    let argCount = len(argTypes)

    if argCount < paramCount {
      addError(checker, node.id,
        "Function expects " + str(paramCount) + " arguments, got " + str(argCount))
    } else {
      // Unify provided arguments with parameters (ignore extras)
      for let i = 0; i < paramCount; i = i + 1 {
        constrain(checker, argTypes[i], calleeType.params[i],
          node.args[i].id, "Argument type mismatch")
      }
    }

    resultType = calleeType.return
  } else if calleeType.kind == "Unknown" or calleeType.kind == "TypeVar" {
    // Refine to Function type
    let paramTypes = []
    for let i = 0; i < len(argTypes); i = i + 1 {
      push(paramTypes, argTypes[i])
    }
    let retType = freshTypeVar(checker)
    let fnType = typeFunction(paramTypes, retType)
    constrain(checker, calleeType, fnType, node.callee.id,
      "Call requires function")
    resultType = retType
  } else if calleeType.kind == "Any" {
    // Any can be called - result is Any
    resultType = typeAny()
  } else {
    addError(checker, node.id, "Cannot call non-function type: " + calleeType.kind)
    resultType = typeAny()
  }

  checker.types[node.id] = resultType
  resultType
}

// ========================================
// Statement Type Checking
// ========================================

fn checkLet(checker, node) {
  // For Let declarations, the declNodeId is the name identifier's id
  let declNodeId = node.name.id

  let varType = nil
  let binding = nil

  // Check initializer if present
  if node.init {
    let initType = checkExpr(checker, node.init)

    // Value restriction: only generalize function literals
    if node.init.type == "Function" {
      // Try to generalize
      let scheme = generalize(checker, checker.currentEnv, initType)
      if scheme {
        // Successfully generalized - create Poly binding
        binding = bindDeclPoly(checker, declNodeId, scheme)
        varType = initType  // Store the ungeneralized type for checker.types
      } else {
        // No free vars to generalize - create Mono binding
        binding = bindDeclMono(checker, declNodeId)
        varType = binding.typeVar
        constrain(checker, varType, initType, node.init.id,
          "Initializer type incompatible with variable type")
      }
    } else {
      // Not a function literal - create Mono binding
      binding = bindDeclMono(checker, declNodeId)
      varType = binding.typeVar
      constrain(checker, varType, initType, node.init.id,
        "Initializer type incompatible with variable type")
    }
  } else {
    // No initializer - create Mono binding
    binding = bindDeclMono(checker, declNodeId)
    varType = binding.typeVar
  }

  // Record type for the name identifier
  checker.types[node.name.id] = varType

  // Let statements return nil
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkAssignment(checker, node) {
  // Check value first
  let valueType = checkExpr(checker, node.value)

  // Check target
  let targetType = nil

  if node.target.type == "Identifier" {
    // Check if target is a polymorphic binding (not assignable)
    let binding = checker.resolvedNames[node.target.id]
    if binding {
      let declNodeId = binding.declaredAt
      let declBinding = lookupDecl(checker, declNodeId)
      if declBinding and declBinding.kind == "Poly" {
        addError(checker, node.target.id,
          "Cannot assign to polymorphic binding: " + node.target.name)
        targetType = typeAny()
        checker.types[node.id] = valueType
        return valueType
      }
    }

    targetType = checkExpr(checker, node.target)
    // Unify target with value
    constrain(checker, targetType, valueType, node.value.id,
      "Assignment type mismatch")
  } else if node.target.type == "Index" {
    // arr[i] = value
    let objType = checkExpr(checker, node.target.object)
    let indexType = checkExpr(checker, node.target.index)

    objType = deref(checker, objType)

    if objType.kind == "Array" {
      constrain(checker, objType.elem, valueType, node.value.id,
        "Array element assignment type mismatch")
      targetType = valueType
    } else if objType.kind == "Unknown" or objType.kind == "TypeVar" {
      // Refine unknown/typevar to Array(valueType)
      let elemType = freshTypeVar(checker)
      let arrayType = typeArray(elemType)
      constrain(checker, objType, arrayType, node.target.object.id,
        "Index assignment requires array")
      constrain(checker, elemType, valueType, node.value.id,
        "Array element assignment type mismatch")
      targetType = valueType
    } else if objType.kind == "Any" {
      // Allow assignment to Any (dynamic escape hatch)
      targetType = valueType
    } else {
      addError(checker, node.target.object.id,
        "Index assignment requires array, got: " + objType.kind)
      targetType = typeAny()
    }
  } else if node.target.type == "Dot" {
    // obj.field = value
    let objType = checkExpr(checker, node.target.object)
    objType = deref(checker, objType)

    if objType.kind == "Record" {
      let propName = node.target.property.value
      let fieldType = objType.fields[propName]

      if fieldType {
        constrain(checker, fieldType, valueType, node.value.id,
          "Record field assignment type mismatch")
        targetType = valueType
      } else {
        addError(checker, node.target.id,
          "Field '" + propName + "' does not exist on record")
        targetType = typeAny()
      }
    } else if objType.kind == "Unknown" or objType.kind == "TypeVar" {
      // Refine unknown/typevar to Record with this field
      let propName = node.target.property.value
      let fieldType = freshTypeVar(checker)
      let fields = .{}
      fields[propName] = fieldType
      let recordType = typeRecord(fields)
      constrain(checker, objType, recordType, node.target.object.id,
        "Dot assignment requires record")
      constrain(checker, fieldType, valueType, node.value.id,
        "Record field assignment type mismatch")
      targetType = valueType
    } else if objType.kind == "Any" {
      // Allow assignment to Any (dynamic escape hatch)
      targetType = valueType
    } else {
      addError(checker, node.target.object.id,
        "Dot assignment requires record, got: " + objType.kind)
      targetType = typeAny()
    }
  }

  // Assignment evaluates to the assigned value
  checker.types[node.id] = valueType
  valueType
}

// ========================================
// Type Narrowing - Guard Detection
// ========================================

fn tryExtractNilCheck(checker, node, op) {
  // Pattern: x != nil, x == nil, nil != x, nil == x
  let left = node.left
  let right = node.right

  let identifier = nil
  let isCheckingForNil = (op == "==")

  if left.type == "Identifier" and right.type == "Nil" {
    identifier = left
  } else if left.type == "Nil" and right.type == "Identifier" {
    identifier = right
  } else {
    return nil
  }

  let binding = checker.resolvedNames[identifier.id]
  if !binding { return nil }

  return .{
    kind: "nil-check",
    identifier: identifier,
    declNodeId: binding.declaredAt,
    isNilCheck: isCheckingForNil,
  }
}

fn tryExtractTypeTest(checker, node, op) {
  // Pattern: type(x) == "string"
  if op != "==" { return nil }

  let left = node.left
  let right = node.right

  // Check if left is type(x)
  if left.type != "Call" { return nil }
  if left.callee.type != "Identifier" { return nil }
  if left.callee.name != "type" { return nil }
  if len(left.args) != 1 { return nil }

  let arg = left.args[0]
  if arg.type != "Identifier" { return nil }

  // Check if right is a string literal
  if right.type != "String" { return nil }
  let typeName = right.value

  // Map type name to Type constructor
  let expectedType = nil
  if typeName == "string" {
    expectedType = typeString()
  } else if typeName == "number" {
    expectedType = typeNumber()
  } else if typeName == "bool" {
    expectedType = typeBool()
  } else if typeName == "nil" {
    expectedType = typeNil()
  } else if typeName == "array" {
    expectedType = typeArray(freshTypeVar(checker))
  } else if typeName == "map" {
    expectedType = typeRecord(.{})
  } else if typeName == "function" {
    let retVar = freshTypeVar(checker)
    expectedType = typeFunction([], retVar)
  } else {
    return nil  // Unknown type string
  }

  let binding = checker.resolvedNames[arg.id]
  if !binding { return nil }

  return .{
    kind: "type-test",
    identifier: arg,
    declNodeId: binding.declaredAt,
    expectedType: expectedType,
  }
}

fn tryExtractTagCheck(checker, node, op) {
  // Pattern: x.kind == "Foo"
  if op != "==" { return nil }

  let left = node.left
  let right = node.right

  // Left must be x.field
  if left.type != "Dot" { return nil }
  if left.object.type != "Identifier" { return nil }

  // Right must be string literal
  if right.type != "String" { return nil }

  let identifier = left.object
  let tagField = left.property.value  // property is a String node
  let tagValue = right.value

  let binding = checker.resolvedNames[identifier.id]
  if !binding { return nil }

  return .{
    kind: "tag-check",
    identifier: identifier,
    declNodeId: binding.declaredAt,
    tagField: tagField,
    tagValue: tagValue,
  }
}

fn extractGuard(checker, condNode) {
  // Returns GuardInfo or nil
  if !condNode { return nil }

  if condNode.type == "Binary" {
    let op = condNode.operator.lexeme

    // Only handle equality/inequality
    if op == "!=" or op == "==" {
      let guard = tryExtractNilCheck(checker, condNode, op)
      if guard { return guard }

      let typeGuard = tryExtractTypeTest(checker, condNode, op)
      if typeGuard { return typeGuard }

      let tagGuard = tryExtractTagCheck(checker, condNode, op)
      if tagGuard { return tagGuard }
    }
  }

  return nil
}

fn mergeEnvs(checker, originalEnv, thenEnv, elseEnv, guard) {
  // After if/else, reconcile refined bindings
  // Unify both branches back to the original binding
  if !guard { return }

  let declNodeId = guard.declNodeId

  let thenBinding = thenEnv.bindings[declNodeId]
  let elseBinding = elseEnv.bindings[declNodeId]
  let originalBinding = originalEnv.bindings[declNodeId]

  if !originalBinding { return }

  // If both branches refined the type, unify them back
  if thenBinding and elseBinding and originalBinding.kind == "Mono" {
    if thenBinding.kind == "Mono" and elseBinding.kind == "Mono" {
      // Unify refined types back to original
      // This ensures the original binding reflects constraints from both branches
      unify(checker, thenBinding.typeVar, originalBinding.typeVar)
      unify(checker, elseBinding.typeVar, originalBinding.typeVar)
    }
  }

  // Clear tag narrowing after merge
  if guard and guard.kind == "tag-check" {
    checker.knownTags[guard.declNodeId] = nil
  }
}

fn checkIf(checker, node) {
  // Check condition
  let condType = checkExpr(checker, node.condition)

  // Extract guard information
  let guard = extractGuard(checker, node.condition)

  // Save current environment
  let originalEnv = checker.currentEnv

  // Create refined environment for then branch
  let thenEnv = refineEnv(checker, originalEnv, guard, true)
  checker.currentEnv = thenEnv
  let thenType = checkExpr(checker, node.then)

  let resultType = nil

  if node.else {
    // Create refined environment for else branch
    let elseEnv = refineEnv(checker, originalEnv, guard, false)
    checker.currentEnv = elseEnv
    let elseType = checkExpr(checker, node.else)

    // Restore original environment
    checker.currentEnv = originalEnv

    // Merge: unify refined bindings back to original
    mergeEnvs(checker, originalEnv, thenEnv, elseEnv, guard)

    // Unify branch types
    constrain(checker, thenType, elseType, node.else.id,
      "If branches have incompatible types")

    resultType = thenType
  } else {
    // Restore original environment
    checker.currentEnv = originalEnv

    // No else branch - return then-branch type
    // Note: This is unsound (result could be Nil at runtime), but without union types
    // we cannot properly represent "ThenType | Nil"
    resultType = thenType
  }

  checker.types[node.id] = resultType
  resultType
}

fn checkFor(checker, node) {
  // Enter loop scope
  enterScope(checker)

  // Check init
  if node.init {
    checkExpr(checker, node.init)
  }

  // Check condition
  if node.condition {
    checkExpr(checker, node.condition)
  }

  // Check update
  if node.update {
    checkExpr(checker, node.update)
  }

  // Check body
  checkExpr(checker, node.body)

  exitScope(checker)

  // For loops return nil
  let resultType = typeNil()
  checker.types[node.id] = resultType
  resultType
}

fn checkReturn(checker, node) {
  let valueType = nil

  if node.value {
    valueType = checkExpr(checker, node.value)
  } else {
    valueType = typeNil()
  }

  // Constrain with current function's return type
  if checker.currentReturnType {
    constrain(checker, valueType, checker.currentReturnType,
      node.id, "Return type mismatch")
  }

  // Return statements have no value (never reached)
  let resultType = typeNil()
  checker.types[node.id] = resultType
  resultType
}

fn checkBreak(checker, node) {
  let valueType = nil

  if node.value {
    valueType = checkExpr(checker, node.value)
  } else {
    valueType = typeNil()
  }

  // Break value typing is complex - skip for core subset
  let resultType = typeNil()
  checker.types[node.id] = resultType
  resultType
}

fn checkContinue(checker, node) {
  let resultType = typeNil()
  checker.types[node.id] = resultType
  resultType
}

fn checkBlock(checker, node) {
  // Blocks create new scope
  enterScope(checker)

  let resultType = typeNil()

  for let i = 0; i < len(node.expressions); i = i + 1 {
    resultType = checkExpr(checker, node.expressions[i])
  }

  // Block evaluates to last expression
  exitScope(checker)

  checker.types[node.id] = resultType
  resultType
}

// ========================================
// Main Expression Dispatcher
// ========================================

checkExpr = fn(checker, node) {
  if !node {
    return typeNil()
  }

  // Dispatch based on node type
  if node.type == "Number" or node.type == "String" or
     node.type == "Bool" or node.type == "Nil" {
    return checkLiteral(checker, node)
  } else if node.type == "Identifier" {
    return checkIdentifier(checker, node)
  } else if node.type == "Binary" {
    return checkBinary(checker, node)
  } else if node.type == "Unary" {
    return checkUnary(checker, node)
  } else if node.type == "Logical" {
    return checkLogical(checker, node)
  } else if node.type == "Grouping" {
    return checkExpr(checker, node.expression)
  } else if node.type == "Array" {
    return checkArray(checker, node)
  } else if node.type == "Index" {
    return checkIndex(checker, node)
  } else if node.type == "Hashmap" {
    return checkHashmap(checker, node)
  } else if node.type == "Dot" {
    return checkDot(checker, node)
  } else if node.type == "Function" {
    return checkFunction(checker, node)
  } else if node.type == "Call" {
    return checkCall(checker, node)
  } else if node.type == "Let" {
    return checkLet(checker, node)
  } else if node.type == "Assignment" {
    return checkAssignment(checker, node)
  } else if node.type == "If" {
    return checkIf(checker, node)
  } else if node.type == "For" {
    return checkFor(checker, node)
  } else if node.type == "Return" {
    return checkReturn(checker, node)
  } else if node.type == "Break" {
    return checkBreak(checker, node)
  } else if node.type == "Continue" {
    return checkContinue(checker, node)
  } else if node.type == "Block" {
    return checkBlock(checker, node)
  } else if node.type == "Import" {
    // Import: treat as Any for now
    let t = typeAny()
    checker.types[node.id] = t
    return t
  } else if node.type == "Program" {
    // Program node - check body
    let resultType = typeNil()
    for let i = 0; i < len(node.body); i = i + 1 {
      resultType = checkExpr(checker, node.body[i])
    }
    return resultType
  } else {
    addError(checker, node.id, "Type checking not implemented for: " + node.type)
    return typeAny()
  }
}

// ========================================
// Main API
// ========================================

fn makeChecker(resolveResult, opts) {
  .{
    // Output tables
    types: .{},
    errors: [],
    hadError: false,

    // Inputs
    resolveResult: resolveResult,
    nodes: resolveResult.nodes,
    resolvedNames: resolveResult.resolvedNames,

    // Type variable state
    nextTypeVarId: 1,
    typeVarBindings: .{},
    globalTypeCache: .{},  // declNodeId -> TypeVar for globals/imports

    // Environment
    currentEnv: nil,

    // Type narrowing
    knownTags: .{},  // declNodeId → tagValue for tag narrowing

    // Function tracking
    currentReturnType: nil,

    // Options
    opts: opts or .{},
  }
}

fn typecheck(ast, resolveResult, opts) {
  if !resolveResult.success {
    // Resolve failed - cannot typecheck
    return .{
      success: false,
      types: .{},
      errors: [.{ nodeId: nil, message: "Resolve phase failed", severity: "error" }],
    }
  }

  let checker = makeChecker(resolveResult, opts)

  // Initialize global environment
  checker.currentEnv = TypeEnv(nil)

  // Check program body
  for let i = 0; i < len(ast.body); i = i + 1 {
    checkExpr(checker, ast.body[i])
  }

  // Post-process: dereference all stored types for cleaner output
  let derefedTypes = .{}
  let typeKeys = keys(checker.types)
  for let i = 0; i < len(typeKeys); i = i + 1 {
    let nodeId = typeKeys[i]
    derefedTypes[nodeId] = derefAll(checker, checker.types[nodeId])
  }

  .{
    success: !checker.hadError,
    types: derefedTypes,
    errors: checker.errors,
  }
}

// Export the main function
typecheck
