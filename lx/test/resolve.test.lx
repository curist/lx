// Resolve Phase Tests
// Tests for semantic validation (resolve.lx)

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let resolve = import "src/resolve.lx"

// Helper to parse from fixture file
fn parseFixture(path) {
  let src = slurp(path)
  parse(src, path)
}

// Helper to parse and resolve
fn parseAndResolve(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseErrors: parseResult.errors }
  }
  resolve(parseResult.ast, .{})
}

// ========================================
// Basic Expressions and Declarations
// ========================================

test("resolve - binary expression", fn(assert) {
  let result = parseAndResolve("1 + 2")
  assert.truthy(result.success, "Should resolve binary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - logical expression", fn(assert) {
  let result = parseAndResolve("true and false")
  assert.truthy(result.success, "Should resolve logical expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - unary expression", fn(assert) {
  let result = parseAndResolve("-42")
  assert.truthy(result.success, "Should resolve unary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - grouping expression", fn(assert) {
  let result = parseAndResolve("(1 + 2)")
  assert.truthy(result.success, "Should resolve grouping expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested binary expressions", fn(assert) {
  let result = parseAndResolve("1 + 2 * 3 - 4")
  assert.truthy(result.success, "Should resolve nested binary expressions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration without initializer", fn(assert) {
  let result = parseAndResolve("{ let x }")
  assert.truthy(result.success, "Should resolve let declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration with initializer", fn(assert) {
  let result = parseAndResolve("{ let x = 42 }")
  assert.truthy(result.success, "Should resolve let with initializer")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - using declared variable", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx }")
  assert.truthy(result.success, "Should resolve variable reference")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - duplicate declaration error", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet x = 2 }")
  assert.equal(result.success, false, "Should fail on duplicate declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - read before initialization error", fn(assert) {
  let result = parseAndResolve("{ let x = x }")
  assert.equal(result.success, false, "Should fail on read-before-init")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Expression Types
// ========================================

test("resolve - function call", fn(assert) {
  let result = parseAndResolve("{ let f = fn() { 1 }\nf() }")
  assert.truthy(result.success, "Should resolve function call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if expression", fn(assert) {
  let result = parseAndResolve("if true { 1 } else { 2 }")
  assert.truthy(result.success, "Should resolve if expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if with variable reference", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nif x { 2 } else { 3 } }")
  assert.truthy(result.success, "Should resolve if with variable")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to local", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx = 2 }")
  assert.truthy(result.success, "Should resolve assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to index (valid)", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] = 3 }")
  assert.truthy(result.success, "Should allow assignment to index")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to dot (valid)", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x = 2 }")
  assert.truthy(result.success, "Should allow assignment to dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to literal rejected by parser", fn(assert) {
  let result = parse("42 = 1", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to binary expression rejected by parser", fn(assert) {
  let result = parse("(x + 1) = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call rejected by parser", fn(assert) {
  let result = parse("f() = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - assignment to literal from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-literal.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to expression from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-expression.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-call.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - valid assignment targets from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/assignment-targets.lx")
  assert.truthy(result.success, "Parser should accept valid assignment targets")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolver should accept valid assignments")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - array literal", fn(assert) {
  let result = parseAndResolve("[1, 2, 3]")
  assert.truthy(result.success, "Should resolve array literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - array with variables", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet arr = [x, 2] }")
  assert.truthy(result.success, "Should resolve array with variables")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - hashmap literal", fn(assert) {
  let result = parseAndResolve(".{ a: 1, b: 2 }")
  assert.truthy(result.success, "Should resolve hashmap literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - index access", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] }")
  assert.truthy(result.success, "Should resolve index access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - dot access", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x }")
  assert.truthy(result.success, "Should resolve dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - for loop", fn(assert) {
  let result = parseAndResolve("for let i = 0; i < 10; i = i + 1 { i }")
  assert.truthy(result.success, "Should resolve for loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Functions and Hoisting
// ========================================

test("resolve - anonymous function", fn(assert) {
  let result = parseAndResolve("fn() { 1 }")
  assert.truthy(result.success, "Should resolve anonymous function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - named function declaration", fn(assert) {
  let result = parseAndResolve("{ fn foo() { 1 } }")
  assert.truthy(result.success, "Should resolve named function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - function with parameters", fn(assert) {
  let result = parseAndResolve("fn(x, y) { x + y }")
  assert.truthy(result.success, "Should resolve function with params")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested functions", fn(assert) {
  let result = parseAndResolve("fn outer() { fn inner() { 1 } }")
  assert.truthy(result.success, "Should resolve nested functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - mutual recursion in function bodies", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
  }")
  assert.truthy(result.success, "Should allow mutual recursion in function bodies")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after all hoisted functions declared", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
    a()
  }")
  assert.truthy(result.success, "Should allow call after all declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after first hoisted function (allowed)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    a()
    fn b() { a() }
  }")
  // With per-function declIndex check, a() is allowed after fn a()
  assert.truthy(result.success, "Should allow call after function's declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - forward reference in function body (ok)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { 1 }
  }")
  assert.truthy(result.success, "Should allow forward reference in function body")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level mutual recursion", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }")
  assert.truthy(result.success, "Should allow mutual recursion at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { 1 }")
  assert.truthy(result.success, "Should allow forward reference at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level call after hoisted functions", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }\na()")
  assert.truthy(result.success, "Should allow call after all top-level declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// Test for hoisted-function ordering rule (issue #4)
test("resolve - call hoisted function after its declaration", fn(assert) {
  let result = parseAndResolve("{
    fn a() { }
    a()
    fn b() { }
  }")
  // Should allow calling a() after fn a() even if fn b() comes later
  assert.truthy(result.success, "Should allow call after function's own declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call hoisted function before its declaration (should error)", fn(assert) {
  let result = parseAndResolve("{
    a()
    fn a() { }
  }")
  assert.equal(result.success, false, "Should error when calling before declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - top-level mutual recursion from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-mutual-recursion.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level mutual recursion")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-forward-reference.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level forward reference")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Closures and Capture
// ========================================

test("resolve - simple closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f() { x }
  }")
  assert.truthy(result.success, "Should resolve simple closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn outer() {
      fn inner() { x }
    }
  }")
  assert.truthy(result.success, "Should resolve nested closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - parameter shadowing", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f(x) { x }
  }")
  assert.truthy(result.success, "Should allow parameter shadowing")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple captures of same variable", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn a() { x }
    fn b() { x }
  }")
  assert.truthy(result.success, "Should resolve multiple captures")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - capture variable in own initializer (invalid)", fn(assert) {
  let result = parseAndResolve("let x = fn() { x }")
  assert.equal(result.success, false, "Should reject capturing var in own initializer")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Return Validation
// ========================================

test("resolve - return at end of function (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1 }")
  assert.truthy(result.success, "Should allow return at end of function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1\n2 }")
  assert.equal(result.success, false, "Should reject return not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return at top level end (valid)", fn(assert) {
  let result = parseAndResolve("1 + 2\nreturn 3")
  assert.truthy(result.success, "Should allow return at end of file")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in middle of file (invalid)", fn(assert) {
  let result = parseAndResolve("return 1\n2")
  assert.equal(result.success, false, "Should reject return in middle of file")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - multiple returns in branches (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { if true { return 1 } return 2 }")
  assert.truthy(result.success, "Should allow returns in different branches")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in nested block at end (invalid)", fn(assert) {
  let result = parseAndResolve("{ { return 1 } }")
  assert.equal(result.success, false, "Should reject return in nested block")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in if block outside function (invalid)", fn(assert) {
  let result = parseAndResolve("if true { return 1 }")
  assert.equal(result.success, false, "Should reject return in if block at top level")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in nested block from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-nested-block.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in nested block")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return in if outside function from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-if-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in if at top level")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return outside function from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Break Validation
// ========================================

test("resolve - break inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { break }")
  assert.truthy(result.success, "Should allow break inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break inside loop with value (valid)", fn(assert) {
  let result = parseAndResolve("for true { break 1 }")
  assert.truthy(result.success, "Should allow break with value inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ break }")
  assert.equal(result.success, false, "Should reject break outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - break in nested loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { for true { break } }")
  assert.truthy(result.success, "Should allow break in nested loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - break not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Continue Validation
// ========================================

test("resolve - continue inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { continue }")
  assert.truthy(result.success, "Should allow continue inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - continue outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ continue }")
  assert.equal(result.success, false, "Should reject continue outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("for true { continue\n1 }")
  assert.equal(result.success, false, "Should reject continue not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/continue-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Valid Control Flow Cases
// ========================================

test("resolve - valid control flow from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/control-flow.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - valid loop control from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/loop-control.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Import Resolution
// ========================================

test("resolve - simple import", fn(assert) {
  let result = parseAndResolve("let x = import \"test/makeTestSuite.lx\"")
  assert.truthy(result.success, "Should resolve valid import")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import used in expression", fn(assert) {
  let result = parseAndResolve("let suite = (import \"test/makeTestSuite.lx\")()")
  assert.truthy(result.success, "Should resolve import in call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple imports", fn(assert) {
  let source = "let parse = import \"src/parser.lx\"\nlet resolve = import \"src/resolve.lx\""
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve multiple imports")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in block", fn(assert) {
  let source = "{ let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in block")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in function", fn(assert) {
  let source = "fn f() { let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import node in nodes map", fn(assert) {
  let parseResult = parse("let x = import \"test/makeTestSuite.lx\"", "test.lx")
  let result = resolve(parseResult.ast, .{})

  let importNode = parseResult.ast.body[0].init
  assert.equal(importNode.type, "Import", "Should be Import node")

  let nodeInfo = result.nodes[importNode.id]
  assert.truthy(nodeInfo, "Import node should be in nodes map")
  assert.equal(nodeInfo.type, "Import", "Should track node type")
})

suite.run()
