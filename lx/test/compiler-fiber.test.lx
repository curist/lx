// TDD tests for the fiber-based Compiler API
//
// API contract:
//   Compiler.start(entry, opts) -> fiber
//   Compiler.poll(fiber, budget) -> .{ events, done?, result?, error? }

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

// We'll import this once we create it
let Compiler = import "src/compiler-fiber.lx"
let Events = import "src/events.lx"
let Driver = import "src/driver.lx"

// --- Test 1 - Compiler.start returns handle with fiber and cancel ---

test("Compiler.start returns handle with fiber and cancel", fn(assert) {
  let source = "42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  assert.equal(type(handle), "map", "start should return a map")
  assert.equal(type(handle.fiber), "fiber", "handle should have a fiber")
  assert.equal(type(handle.cancel), "fn", "handle should have a cancel function")
})

// --- Test 2 - Compiler.poll returns expected shape ---

test("Compiler.poll returns object with events array", fn(assert) {
  let source = "42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 10 })

  assert.equal(type(result), "map", "poll should return a map")
  assert.equal(type(result.events), "array", "result should have events array")
})

// --- Test 3 - Polling to completion sets done flag ---

test("Compiler.poll sets done flag when compilation completes", fn(assert) {
  let source = "42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.done, "done should be true when compilation completes")
})

// --- Test 4 - Completed compilation returns DONE event as result ---

test("Compiler.poll returns DONE event as result", fn(assert) {
  let source = "42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.result, "result should exist")
  assert.equal(result.result.kind, Events.EventKind.DONE, "result should be DONE event")
})

// --- Test 5 - Compilation yields progress events ---

test("Compiler yields PROGRESS event for parse phase", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Find a progress event for the parse phase
  let parseProgress = nil
  for evt in result.events {
    if evt.kind == Events.EventKind.PROGRESS and evt.pass == "parse" {
      parseProgress = evt
      break
    }
  }

  assert.truthy(parseProgress, "should have a PROGRESS event for parse")
  assert.equal(parseProgress.pass, "parse", "progress event should be for parse pass")
})

// --- Test 6 - Compilation yields DIAG events for parse errors ---

test("Compiler yields DIAG events for parse errors", fn(assert) {
  let source = "let x ="  // Missing value - syntax error
  let handle = Compiler.start(source, .{ filename: "bad.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Find a diagnostic event for the parse phase
  let diagEvent = nil
  for evt in result.events {
    if evt.kind == Events.EventKind.DIAG and evt.pass == "parse" {
      diagEvent = evt
      break
    }
  }

  assert.truthy(diagEvent, "should have a DIAG event for parse error")
  assert.equal(diagEvent.pass, "parse", "diag event should be for parse pass")
  assert.equal(diagEvent.file, "bad.lx", "diag event should have correct filename")
  assert.equal(diagEvent.severity, Events.Severity.ERROR, "diag should be ERROR severity")
})

// --- Test 7 - Budget limiting works ---

test("Compiler.poll respects maxEvents budget", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  // Poll with budget of 1 - should only get 1 event
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 1 })

  assert.equal(len(result.events), 1, "should only return 1 event")
  assert.truthy(!result.done, "should not be done yet")

  // Poll again to get remaining events
  let result2 = Compiler.poll(handle.fiber, .{ maxEvents: 100 })
  assert.truthy(result2.done, "should be done after second poll")
})

// --- Test 8 - Compilation yields progress for multiple passes ---

test("Compiler yields PROGRESS events for lower, anf, resolve passes", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Collect all progress events by pass
  let passesSeen = .{}
  for evt in result.events {
    if evt.kind == Events.EventKind.PROGRESS {
      passesSeen[evt.pass] = true
    }
  }

  assert.truthy(passesSeen["parse"], "should have parse progress")
  assert.truthy(passesSeen["lower"], "should have lower progress")
  assert.truthy(passesSeen["anf"], "should have anf progress")
  assert.truthy(passesSeen["resolve"], "should have resolve progress")
})

// --- Test 9 - Compilation yields DIAG events for resolve errors ---

test("Compiler yields DIAG events for resolve errors", fn(assert) {
  let source = "let x = x"  // Can't read local variable in its own initializer
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Find a diagnostic event for the resolve phase
  let diagEvent = nil
  for evt in result.events {
    if evt.kind == Events.EventKind.DIAG and evt.pass == "resolve" {
      diagEvent = evt
      break
    }
  }

  assert.truthy(diagEvent, "should have a DIAG event for resolve error")
  assert.equal(diagEvent.pass, "resolve", "diag event should be for resolve pass")
  assert.equal(diagEvent.severity, Events.Severity.ERROR, "diag should be ERROR severity")
})

// --- Test 10 - Compilation yields progress for optimization passes ---

test("Compiler yields PROGRESS events for anf-inline and lower-intrinsics", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Collect all progress events by pass
  let passesSeen = .{}
  for evt in result.events {
    if evt.kind == Events.EventKind.PROGRESS {
      passesSeen[evt.pass] = true
    }
  }

  assert.truthy(passesSeen["anf-inline"], "should have anf-inline progress")
  assert.truthy(passesSeen["lower-intrinsics"], "should have lower-intrinsics progress")
})

// --- Test 11 - Compilation yields progress for codegen ---

test("Compiler yields PROGRESS events for codegen", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Collect all progress events by pass
  let passesSeen = .{}
  for evt in result.events {
    if evt.kind == Events.EventKind.PROGRESS {
      passesSeen[evt.pass] = true
    }
  }

  assert.truthy(passesSeen["codegen"], "should have codegen progress")
})

// --- Test 12 - Full compilation produces bytecode function ---

test("Full compilation produces bytecode function", fn(assert) {
  let source = "let x = 42\nx"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.done, "compilation should complete")
  assert.truthy(result.result.result.success, "compilation should succeed")
  assert.truthy(result.result.result.function, "result should include bytecode function")
})

// --- Test 13 - DIAG events have proper line info for parse errors ---

test("DIAG events have proper line info for parse errors", fn(assert) {
  // Error on line 2
  let source = "let x = 1\nlet y ="
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Find a diagnostic event for parse
  let diagEvent = nil
  for evt in result.events {
    if evt.kind == Events.EventKind.DIAG and evt.pass == "parse" {
      diagEvent = evt
      break
    }
  }

  assert.truthy(diagEvent, "should have a DIAG event")
  assert.equal(diagEvent.range.start.line, 2, "error should be on line 2")
})

// --- Test 14 - DIAG events have proper line info for resolve errors ---

test("DIAG events have proper line info for resolve errors", fn(assert) {
  // Error on line 2 - reading x in its own initializer
  let source = "let a = 1\nlet x = x"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  // Find a diagnostic event for resolve
  let diagEvent = nil
  for evt in result.events {
    if evt.kind == Events.EventKind.DIAG and evt.pass == "resolve" {
      diagEvent = evt
      break
    }
  }

  assert.truthy(diagEvent, "should have a DIAG event")
  assert.equal(diagEvent.range.start.line, 2, "error should be on line 2")
})

// =============================================================================
// Cancellation Tests
// =============================================================================

// --- Test 15 - Cancellation stops compilation early ---

test("Cancellation stops compilation and returns ERROR event", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  // Poll once to start compilation (gets first event)
  let result1 = Compiler.poll(handle.fiber, .{ maxEvents: 1 })
  assert.truthy(!result1.done, "should not be done after first poll")

  // Cancel the compilation
  handle.cancel()

  // Poll again - should complete with cancellation
  let result2 = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result2.done, "should be done after cancel")
  assert.truthy(result2.result, "should have a result")
  assert.equal(result2.result.kind, Events.EventKind.ERROR, "result should be ERROR event")
  assert.truthy(result2.result.error, "ERROR event should have error message")
})

// --- Test 16 - Cancellation error message says "Cancelled" ---

test("Cancellation error message says Cancelled", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  // Poll once then cancel
  Compiler.poll(handle.fiber, .{ maxEvents: 1 })
  handle.cancel()

  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.equal(result.result.error, "Cancelled", "error message should be 'Cancelled'")
})

// --- Test 17 - Cancellation before any polling ---

test("Cancellation before polling returns ERROR on first poll", fn(assert) {
  let source = "let x = 42"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  // Cancel before polling
  handle.cancel()

  // First poll should see cancellation
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.done, "should be done")
  assert.equal(result.result.kind, Events.EventKind.ERROR, "should be ERROR event")
  assert.equal(result.result.error, "Cancelled", "error should be Cancelled")
})

// --- Test 18 - Cancellation mid-pipeline stops at next yield point ---

test("Cancellation mid-pipeline stops at next yield point", fn(assert) {
  let source = "let x = 42\nx"
  let handle = Compiler.start(source, .{ filename: "test.lx" })

  // Poll for several events to get past parse phase
  let result1 = Compiler.poll(handle.fiber, .{ maxEvents: 5 })
  assert.truthy(!result1.done, "should not be done after 5 events")

  // Verify we've seen some progress
  let parseStartSeen = false
  for evt in result1.events {
    if evt.kind == Events.EventKind.PROGRESS and evt.pass == "parse" and evt.phase == "start" {
      parseStartSeen = true
    }
  }
  assert.truthy(parseStartSeen, "should have seen parse start")

  // Cancel mid-compilation
  handle.cancel()

  // Poll to completion - should get ERROR
  let result2 = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result2.done, "should be done after cancel")
  assert.equal(result2.result.kind, Events.EventKind.ERROR, "should be ERROR event")
  assert.equal(result2.result.error, "Cancelled", "error should be Cancelled")
})

// =============================================================================
// Driver Integration Tests
// =============================================================================

// --- Test 19 - Compiler.startModule returns handle with fiber and cancel ---

test("Compiler.startModule returns handle with fiber and cancel", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "test.lx" { "42" }
    }
  })

  let handle = Compiler.startModule(driver, "test.lx", .{})

  assert.equal(type(handle), "map", "startModule should return a map")
  assert.equal(type(handle.fiber), "fiber", "handle should have a fiber")
  assert.equal(type(handle.cancel), "fn", "handle should have a cancel function")
})

// --- Test 20 - startModule compiles to bytecode function ---

test("startModule compiles to bytecode function", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "test.lx" { "let x = 42\nx" }
    }
  })

  let handle = Compiler.startModule(driver, "test.lx", .{})
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.done, "compilation should complete")
  assert.truthy(result.result, "should have result")
  assert.equal(result.result.kind, Events.EventKind.DONE, "should be DONE event")
  assert.truthy(result.result.result.success, "compilation should succeed")
  assert.truthy(result.result.result.function, "should have bytecode function")
})

// --- Test 21 - startModule handles imports ---

test("startModule handles imports", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "main.lx" {
        "let lib = import \"lib.lx\"\nlib.value"
      } else if path == "lib.lx" {
        ".{ value: 42 }"
      }
    }
  })

  let handle = Compiler.startModule(driver, "main.lx", .{})
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 200 })

  assert.truthy(result.done, "compilation should complete")
  assert.truthy(result.result.result.success, "compilation should succeed with imports")
  assert.truthy(result.result.result.function, "should have bytecode function")
})

// --- Test 22 - startModule yields DEPS events for imports ---

test("startModule yields DEPS events for imports", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "main.lx" {
        "let lib = import \"lib.lx\"\nlib.value"
      } else if path == "lib.lx" {
        ".{ value: 42 }"
      }
    }
  })

  let handle = Compiler.startModule(driver, "main.lx", .{})
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 200 })

  // Find DEPS events
  let depsEvents = collect evt in result.events {
    if evt.kind == Events.EventKind.DEPS { evt } else { continue }
  }

  assert.truthy(len(depsEvents) > 0, "should have at least one DEPS event")

  // Find DEPS event for main.lx
  let mainDeps = nil
  for evt in depsEvents {
    if evt.file == "main.lx" {
      mainDeps = evt
      break
    }
  }

  assert.truthy(mainDeps, "should have DEPS event for main.lx")
  assert.truthy(len(mainDeps.deps) > 0, "main.lx should have dependencies")
})

// --- Test 23 - startModule handles missing source error ---

test("startModule handles missing source error", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      // Return nil for missing files
      nil
    }
  })

  let handle = Compiler.startModule(driver, "missing.lx", .{})
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 100 })

  assert.truthy(result.done, "should complete")
  assert.equal(result.result.kind, Events.EventKind.ERROR, "should be ERROR event")
})

// --- Test 24 - startModule handles import failure ---

test("startModule handles import failure", fn(assert) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "main.lx" {
        "let lib = import \"missing.lx\"\nlib.value"
      }
      // missing.lx returns nil
    }
  })

  let handle = Compiler.startModule(driver, "main.lx", .{})
  let result = Compiler.poll(handle.fiber, .{ maxEvents: 200 })

  assert.truthy(result.done, "should complete")
  // Should fail because import is missing
  assert.truthy(!result.result.result.success, "compilation should fail for missing import")
})

suite.run()
