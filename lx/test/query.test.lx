// Query Service Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let Driver = import "src/driver.lx"
let query = import "services/query.lx"
let types = import "src/types.lx"

let NODE = types.NODE

// Helper: compile source through full pipeline and create query context
// Tests use lower-level APIs for flexibility (inline source, not filesystem)
fn compileAndQuery(source, filename) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == filename { return source }
      return slurp(path)
    },
    withTypecheck: true,
    withAnf: false,  // Query tests need non-ANF AST (imports not hoisted, etc.)
  })

  let result = driver.compileModule(filename)

  if result.status != "done" {
    let phase = "unknown"
    let errors = []
    let passes = result.passes or .{}

    if passes.parse and passes.parse.errors {
      phase = "parse"
      errors = passes.parse.errors
    } else if passes.lower and passes.lower.errors {
      phase = "lower"
      errors = passes.lower.errors
    } else if passes.resolve and !passes.resolve.success {
      phase = "resolve"
      errors = passes.resolve.errors
    }

    return .{ success: false, phase: phase, errors: errors }
  }

  let initResult = query.queryInit(
    result.passes.lower.ast,
    result.passes.resolve,
    result.passes.typecheck,
    .{ buildIndex: true }
  )

  .{
    success: initResult.success,
    ctx: initResult.ctx,
    parseResult: result.passes.parse,
    lowerResult: result.passes.lower,
    resolveResult: result.passes.resolve,
    typecheckResult: result.passes.typecheck,
  }
}

// ========================================
// Core Tests (5 minimum)
// ========================================

test("query - hover on number literal", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
})

test("query - hover on variable shows inferred type", fn(assert) {
  let result = compileAndQuery("let x = 42\nx", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'x' usage (line 2, col 1)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 2, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
  assert.truthy(hoverResult.contents.symbol, "Should include symbol info")
  assert.equal(hoverResult.contents.symbol.name, "x", "Should include symbol name")
  assert.equal(hoverResult.contents.symbol.kind, "local", "Should classify symbol kind")
  assert.truthy(hoverResult.details, "Should have details")
  assert.equal(hoverResult.details.nodeType, "Identifier", "Should identify as Identifier node")
})

test("query - hover resolves bound type variables via bindings", fn(assert) {
  // Manual context with a bound type variable to ensure hover formats binding
  let node = .{
    id: 1,
    type: NODE.Identifier,
    filename: "test.lx",
    line: 1, col: 0,
    endLine: 1, endCol: 1,
  }

  let ctx = .{
    nodes: .{[1]: node},
    resolvedNames: .{},
    types: .{[1]: .{ kind: "TypeVar", id: 123 }},
    typeVarBindings: .{[123]: .{ kind: "Number" }},
    fileNodeIds: .{ ["test.lx"]: [1] },
  }

  let hoverResult = query.queryHover(ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should format bound TypeVar as its binding type")
})

test("query - hover on record key shows field value type", fn(assert) {
  let source = ".{ DEBUG: false }"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'DEBUG' key (line 1, col 3)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 3)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Bool", "Should show field value type when hovering key")
})

test("query - goto local variable", fn(assert) {
  let result = compileAndQuery("let x = 1\nx + 1", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'x' usage (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.filename, "test.lx", "Should target same file")
  assert.equal(gotoResult.target.line, 1, "Should target declaration line")
})

test("query - goto function parameter", fn(assert) {
  let result = compileAndQuery("fn f(a) { a + 1 }", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'a' in body (line 1, col 10)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 10)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target parameter declaration")
})

test("query - goto named function normalized to name", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'foo' call (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target function declaration line")
  // The target should be the function name, not the entire function
  // We can verify it's normalized by checking the span is small
  let spanSize = (gotoResult.target.endLine - gotoResult.target.line) * 1000 +
                 (gotoResult.target.endCol - gotoResult.target.col)
  assert.truthy(spanSize < 100, "Should target function name, not entire function body")
})

test("query - goto builtin has no definition", fn(assert) {
  let result = compileAndQuery("println(42)", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'println' (line 1, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail for builtin")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
})

// ========================================
// Edge Case Tests (2 additional)
// ========================================

test("query - hover on empty position returns no node", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Position far beyond code
  let hoverResult = query.queryHover(result.ctx, "test.lx", 100, 100)

  assert.equal(hoverResult.success, false, "Hover should fail")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.message, "No node at position: test.lx:100:100", "Hover should include location")
})

test("query - goto on non-identifier fails gracefully", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on number literal
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail on non-identifier")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.equal(gotoResult.message, "Not an identifier at test.lx:1:0", "Goto should include location")
})

// ========================================
// Multi-Module Import Tests
// ========================================

test("query - hover on imported symbol shows type", fn(assert) {
  // Use proper fixture file - showcases real API usage
  let result = query.compile("test/fixtures/imports/test-hover.lx")

  if !result.success {
    println("Hover test compilation failed!")
    println("Phase:", result.phase)
    if result.errors { println("Errors:", result.errors) }
  }

  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'config.version' (line 5, col 20 - dot expression)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 20)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show imported field type")
})

test("query - hover on imported binding identifier shows type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on local binding 'version' (line 5, col 5)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 5)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show type propagated from import")
})

test("query - hover on imported function value shows function type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover-fn.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on imported function binding 'greet' (line 1, col 4)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover-fn.lx", 1, 4)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "fn(String) -> String", "Should surface imported function type")
})

test("query - goto definition to imported module", fn(assert) {
  // Use proper fixture file
  let result = query.compile("test/fixtures/imports/test-goto.lx")

  if !result.success {
    println("Compilation failed:", result.phase)
    println("Errors:", result.errors)
  }

  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'config' usage (line 7, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-goto.lx", 7, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target location")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-goto.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 2, "Should point to line 2 (let config = ...)")
})

test("query - query works across diamond import structure", fn(assert) {
  // Use proper fixture file with diamond pattern
  let result = query.compile("test/fixtures/imports/test-diamond.lx")

  assert.truthy(result.success, "Should compile with diamond imports")

  // Hover on 'app.start' (line 8, col 4 - the 'start' part)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 4)

  assert.truthy(hoverResult.success, "Hover should work across imports")
  assert.truthy(hoverResult.contents, "Should have type information")

  // Goto on 'app' usage (line 8, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 0)

  assert.truthy(gotoResult.success, "Goto should work across imports")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-diamond.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 4, "Should point to line 4 (let app = ...)")

  // Hover inside an imported module file should work via query context
  let appHover = query.queryHover(result.ctx, "test/fixtures/imports/app.lx", 6, 2)
  assert.truthy(appHover.success, "Hover should work in imported module file")
  assert.truthy(appHover.contents, "Imported module hover should include contents")

  // Goto inside an imported module file should resolve locally
  let appGoto = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/app.lx", 7, 4)
  assert.truthy(appGoto.success, "Goto should work in imported module file")
  assert.equal(appGoto.target.filename, "test/fixtures/imports/app.lx", "Goto should stay in module file")
  assert.equal(appGoto.target.line, 3, "Goto should land on logger binding")
})

test("query - hover in imported module shows constant types", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-diamond.lx")
  assert.truthy(result.success, "Should compile with diamond imports")

  let versionHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 3, 2)
  assert.truthy(versionHover.success, "Hover should work in constants module")
  assert.equal(versionHover.contents.type, "String", "VERSION should be String")

  let sizeHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 4, 2)
  assert.truthy(sizeHover.success, "Hover should work in constants module")
  assert.equal(sizeHover.contents.type, "Number", "MAX_SIZE should be Number")

  let debugHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 5, 2)
  assert.truthy(debugHover.success, "Hover should work in constants module")
  assert.equal(debugHover.contents.type, "Bool", "DEBUG should be Bool")
})

test("query - goto in imported module resolves local import binding", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-diamond.lx")
  assert.truthy(result.success, "Should compile with diamond imports")

  // Goto on 'constants' usage inside config module (line 5, col 11)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/config.lx", 5, 11)
  assert.truthy(gotoResult.success, "Goto should work inside imported module")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/config.lx", "Goto should stay in config module")
  assert.equal(gotoResult.target.line, 2, "Goto should land on constants binding")
})

test("query - goto dot property resolves record field in imported module", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  // Goto on 'value' property (line 5, col 6)
  let gotoValue = query.queryGotoDefinition(result.ctx, "test/fixtures/query/use.lx", 5, 6)
  assert.truthy(gotoValue.success, "Goto should resolve dot property")
  assert.equal(gotoValue.target.filename, "test/fixtures/query/module.lx", "Goto should land in module file")
  assert.equal(gotoValue.target.line, 3, "Goto should land on value key")
})

test("query - hover dot property shows function type", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  // Hover on 'greet' property (line 6, col 6)
  let hoverGreet = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverGreet.success, "Hover should resolve dot property")
  assert.equal(hoverGreet.contents.type, "fn() -> String", "Should show function type")
  assert.truthy(hoverGreet.contents.property, "Hover should include property definition")
  assert.equal(hoverGreet.contents.property.definedAt.filename, "test/fixtures/query/module.lx", "Definition should point to module")
  assert.equal(hoverGreet.contents.property.definedAt.line, 4, "Definition should point to greet key")
})

test("query - goto dot property resolves enum-like record field", fn(assert) {
  let result = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result.success, "Should compile enum fixture")

  // Goto on 'CONSTANT' in OP.CONSTANT (line 3, col 6)
  let gotoConst = query.queryGotoDefinition(result.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(gotoConst.success, "Goto should resolve OP.CONSTANT")
  assert.equal(gotoConst.target.filename, "test/fixtures/query/enum-module.lx", "Goto should land in module file")
  assert.equal(gotoConst.target.line, 2, "Goto should land on CONSTANT key")
})

test("query - goto dot property resolves alias from imported module", fn(assert) {
  let result = query.compile("test/fixtures/query/alias-use.lx")
  assert.truthy(result.success, "Should compile alias fixture")

  // Goto on 'CONSTANT' in OP.CONSTANT (line 4, col 3)
  let gotoConst = query.queryGotoDefinition(result.ctx, "test/fixtures/query/alias-use.lx", 4, 3)
  assert.truthy(gotoConst.success, "Goto should resolve OP.CONSTANT")
  assert.equal(gotoConst.target.filename, "test/fixtures/query/alias-module.lx", "Goto should land in module file")
  assert.equal(gotoConst.target.line, 3, "Goto should land on CONSTANT key")
})

test("query - diagnostics parse error includes location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-parse.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report parse diagnostics")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-parse.lx", "Diagnostic filename should match")
  assert.truthy(diags[0].line > 0, "Diagnostic line should be positive")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "Expect")) > 1, "Parse message should include expected token")
})

test("query - diagnostics resolve error includes node location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-resolve.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report resolve diagnostics")
  assert.equal(diags[0].phase, "resolve", "Diagnostic phase should be resolve")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-resolve.lx", "Diagnostic filename should match")
  assert.equal(diags[0].line, 1, "Diagnostic line should match")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "undeclared")) > 1, "Resolve message should include undeclared")
})

test("query - diagnostics typecheck error includes node location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-typecheck.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report typecheck diagnostics")
  assert.equal(diags[0].phase, "typecheck", "Diagnostic phase should be typecheck")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-typecheck.lx", "Diagnostic filename should match")
  assert.equal(diags[0].line, 1, "Diagnostic line should match")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "len()")) > 1, "Typecheck message should mention len()")
})

test("query - hover reports candidates on ambiguous span", fn(assert) {
  let nodeA = .{ id: 1, type: NODE.Identifier, filename: "test.lx", line: 1, col: 0, endLine: 1, endCol: 1, name: "a" }
  let nodeB = .{ id: 2, type: NODE.Number, filename: "test.lx", line: 1, col: 0, endLine: 1, endCol: 1, value: 1 }

  let ctx = .{
    nodes: .{ [1]: nodeA, [2]: nodeB },
    resolvedNames: .{},
    types: .{ [1]: .{ kind: "Number" }, [2]: .{ kind: "Number" } },
    typeVarBindings: .{},
    fileNodeIds: .{ ["test.lx"]: [1, 2] },
  }

  let hoverResult = query.queryHover(ctx, "test.lx", 1, 0)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.truthy(hoverResult.candidates, "Hover should include candidates")
  assert.equal(len(hoverResult.candidates), 1, "Should include one alternate candidate")
  assert.equal(hoverResult.candidates[0].nodeId, 1, "Candidate should include the non-selected node")
})

test("query - hover on function name returns function type", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 3)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "fn() -> Number", "Should show function type")
})

test("query - ctx validation warns once on missing nodes", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  result.ctx.resolvedNames["999999"] = .{ kind: "local", declaredAt: 999999 }
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.truthy(result.ctx.warnings and len(result.ctx.warnings) > 0, "Should warn on missing nodes")

  let count = len(result.ctx.warnings)
  let hoverResult2 = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverResult2.success, "Hover should still succeed")
  assert.equal(len(result.ctx.warnings), count, "Warnings should not repeat")
})

test("query - compile twice yields stable goto targets", fn(assert) {
  let result1 = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result1.success, "First compile should succeed")
  let goto1 = query.queryGotoDefinition(result1.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(goto1.success, "First goto should succeed")

  let result2 = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result2.success, "Second compile should succeed")
  let goto2 = query.queryGotoDefinition(result2.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(goto2.success, "Second goto should succeed")

  assert.equal(goto1.target.filename, goto2.target.filename, "Goto filename should match")
  assert.equal(goto1.target.line, goto2.target.line, "Goto line should match")
  assert.equal(goto1.target.col, goto2.target.col, "Goto col should match")
})

suite.run()
