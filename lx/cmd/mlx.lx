let driver = import "src/driver.lx"
let codegen = import "src/passes/backend/codegen.lx"
let verify = import "src/passes/backend/verify-bytecode.lx"
let objbuilder = import "src/objbuilder.lx"
let errors = import "src/errors.lx"
let ModuleResolution = import "src/module_resolution.lx"
let OP = (import "src/types.lx").OP

let DEBUG_BUILD = true

fn loadSource(path, sourceOverride, overridePath) {
  if sourceOverride and path == overridePath { return sourceOverride }
  ModuleResolution.slurpPath(path)
}

fn makeDriverWithSource(sourceOverride, overridePath) {
  driver.make(.{
    withTypecheck: false,
    loadSource: fn(p) { loadSource(p, sourceOverride, overridePath) },
  })
}

fn compileWithDriver(driverInstance, path) {
  let moduleCache = .{}

  fn codegenModule(modulePath) {
    let cached = moduleCache[modulePath]
    if cached { return cached }

    let result = driverInstance.compileModule(modulePath)
    if !result or result.status != "done" {
      errors.printErrors(errors.collectErrors(result or .{}), result)
      return nil
    }

    let passes = result.passes or .{}
    let ast = (passes["anf-inline"] and passes["anf-inline"].ast) or
              (passes.anf and passes.anf.ast) or
              (passes.lower and passes.lower.ast)
    let enumInfo =
      (passes.anf and passes.anf.enumInfo) or
      (passes.lower and passes.lower.enumInfo) or
      (passes.parse and passes.parse.enumInfo) or
      .{}
    let cg = codegen(ast, result.passes.resolve, .{
      codegenModule: codegenModule,
      enumInfo: enumInfo,
    })
    result.codegenResult = cg
    if !cg.success {
      errors.printErrors(cg.errors, result)
      return nil
    }

    let verifyResult = verify.verifyFunction(cg.function)
    result.verifyResult = verifyResult
    if !verifyResult.success {
      errors.printErrors(verifyResult.errors, result)
      return nil
    }

    moduleCache[modulePath] = cg.function
    cg.function
  }

  codegenModule(path)
}

fn printHelp() {
  groanln("Usage:")
  groanln("")
  groanln("  " + Lx.args[0] + " <command> [arguments]")
  groanln("")
  groanln("Commands:")
  groanln("  run      Run source or lxobj")
  groanln("  eval     Evaluate expression (arg or stdin)")
  groanln("  repl     Start REPL (use :q to quit)")
  groanln("  compile  Compile source to lxobj (-o/--output <output>)")
  groanln("  disasm   Disassemble lxobj or lx source")
  groanln("  version  Print version")
  groanln("  help     Print this helpful page")
}

fn normalizeCommand(cmd) {
  if !cmd or cmd == "" { return "help" }
  if cmd == "-h" or cmd == "--help" or cmd == "h" { return "help" }
  if cmd == "r" { return "run" }
  if cmd == "c" { return "compile" }
  if cmd == "d" { return "disasm" }
  cmd
}

fn compilePathToFunction(path, sourceOverride) {
  let d = makeDriverWithSource(sourceOverride, path)
  compileWithDriver(d, path)
}

fn bytesToString(bytes) {
  let byteString = ""
  for let i = 0; i < len(bytes); i = i + 1 {
    byteString = byteString + chr(bytes[i])
  }
  byteString
}

fn slurpUserPath(path) {
  // Prefer reading literal filesystem paths when they exist relative to CWD
  // (e.g. `out/foo.lxobj`), otherwise fall back to module resolution (`cmd/...`).
  if Lx and Lx.fs and Lx.fs.exists and Lx.fs.exists(path) {
    return slurp(path)
  }
  ModuleResolution.slurpPath(path)
}

fn printRuntimeError(err) {
  if !err {
    groanln("Runtime error.")
    return
  }
  if err.message {
    groanln(err.message)
  } else {
    groanln(err)
    return
  }

  let stack = err.stack
  if !stack { return }
  for let i = 0; i < len(stack); i = i + 1 {
    let f = stack[i] or .{}
    let file = f.file or "[unknown]"
    let line = int(f.line or 0)
    let name = f.name or "script"
    groanln("[" + file + " L" + str(line) + "] in " + name + "()")
  }
}

let handlers = .{
  help: fn() { printHelp() },

  version: fn() {
    println("lx version " + (Lx and Lx.version or "?"))
  },

  compile: fn() {
    let argsLength = len(Lx.args)
    let usageMessage = join(["Usage:", Lx.args[0], "compile <path> [-o|--output <output>]"], " ")
    if argsLength < 3 {
      groanln(usageMessage)
      Lx.exit(28)
    }

    let path = nil
    let outputPath = nil
    let i = 2
    for i < argsLength {
      let arg = Lx.args[i]
      if arg == "-o" or arg == "--output" {
        if i + 1 >= argsLength {
          groanln(usageMessage)
          Lx.exit(28)
        }
        outputPath = Lx.args[i + 1]
        i = i + 2
        continue
      }
      if !path { path = arg }
      i = i + 1
    }
    if !path {
      groanln(usageMessage)
      Lx.exit(28)
    }

    let func = compilePathToFunction(path, nil)
    if !func { Lx.exit(65) }

    if outputPath {
      let bytes = objbuilder(func, DEBUG_BUILD).bytes()
      let ok = spit(outputPath, bytesToString(bytes))
      if ok != true {
        groanln(ok or "Failed to write output.")
        Lx.exit(74)
      }
    } else {
      objbuilder(func, DEBUG_BUILD).dump()
    }
  },

  run: fn() {
    if len(Lx.args) < 3 {
      groanln("Usage: " + Lx.args[0] + " run <lxfile|lxobj>")
      Lx.exit(28)
    }

    let path = Lx.args[2]
    let data = slurpUserPath(path)

    if Lx and Lx.isLxObj and Lx.isLxObj(data) {
      let program = Lx.loadObj(data, false)
      return program()
    }

    let func = compilePathToFunction(path, data)
    if !func { Lx.exit(65) }

    let bytes = objbuilder(func, DEBUG_BUILD).bytes()
    let program = Lx.loadObj(bytes, false)
    program()
  },

  disasm: fn() {
    if len(Lx.args) < 3 {
      groanln("Usage: " + Lx.args[0] + " disasm <lxobj|lxfile>")
      Lx.exit(28)
    }

    let path = Lx.args[2]
    let data = slurpUserPath(path)
    if Lx and Lx.isLxObj and Lx.isLxObj(data) {
      Lx.loadObj(data, true)
      return nil
    }

    let func = compilePathToFunction(path, data)
    if !func { Lx.exit(65) }
    let bytes = objbuilder(func, DEBUG_BUILD).bytes()
    Lx.loadObj(bytes, true)
  },

  eval: fn() {
    let src = nil
    if len(Lx.args) >= 3 {
      src = Lx.args[2]
    } else if Lx and Lx.stdin and Lx.stdin.readAll {
      src = Lx.stdin.readAll()
    }

    if !src or src == "" {
      groanln("Usage: " + Lx.args[0] + " eval <expression>")
      groanln("  or pipe input via stdin: echo 'println(42)' | " + Lx.args[0] + " eval")
      Lx.exit(64)
    }

    let path = "[LX EVAL]"
    let d = makeDriverWithSource(src, path)
    let func = compileWithDriver(d, path)
    if !func { Lx.exit(65) }

    let bytes = objbuilder(func, false).bytes()
    let program = Lx.loadObj(bytes, false)
    let result = program()
    println(result)
  },

  repl: fn() {
    if !Lx or !Lx.stdin or !Lx.stdin.readLine or !Lx.pcall or !Lx.loadObj {
      groanln("repl: missing required runtime APIs (Lx.stdin.readLine, Lx.pcall, Lx.loadObj)")
      Lx.exit(70)
    }

    let iter = 0
    for true {
      let line = Lx.stdin.readLine("> ")
      if !line { break }
      if line == "\n" or line == "" { continue }
      if line == ":q\n" or line == ":q" or line == ":quit\n" or line == ":quit" { break }

      iter = iter + 1
      let path = "[LX REPL " + str(iter) + "]"

      let d = makeDriverWithSource(line, path)
      let func = compileWithDriver(d, path)
      if !func {
        continue
      }

      if len(func.chunk.bytecode) == 1 {
        func.chunk.bytecode = [OP.NIL, OP.RETURN]
      }

      let bytes = objbuilder(func, false).bytes()
      let program = Lx.loadObj(bytes, false)

      let r = Lx.pcall(program)
      if r.ok {
        print("=> ")
        println(r.value)
      } else {
        printRuntimeError(r.error)
      }
    }
  },
}

fn handleUnknownCommand() {
  let cmd = Lx.args[1]
  if cmd {
    groanln(Lx.args[0] + " " + cmd + ": unknown command")
  }
  groanln("Run '" + Lx.args[0] + " help' for usage.")
  Lx.exit(28)
}

let cmd = normalizeCommand(Lx.args[1])
if len(Lx.args) < 2 {
  printHelp()
  Lx.exit(28)
}
{handlers[cmd] or handleUnknownCommand}()
