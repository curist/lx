// Multi-phase compiler entrypoint (mlx)
let __lx_result__

  fn() {
  let driver = import "src/driver.lx"
  let parse = import "src/parser.lx"
  let lower = import "src/lower.lx"
  let anf = import "src/anf.lx"
  let codegen = import "src/codegen.lx"
  let objbuilder = import "src/objbuilder.lx"
  let tohex = (import "src/lib.lx").tohex
  let OP = (import "src/types.lx").OP

  fn resolvePath(path) {
    if path and path[0] == "@" {
      let s = "~/lx/"
      let length = len(path)
      for let i = 1; i < length; i = i + 1 {
        s = s + path[i]
      }
      return s
    }
    path
  }

  fn loadSource(path, sourceOverride, overridePath) {
    if sourceOverride and path == overridePath {
      return sourceOverride
    }
    let realPath = resolvePath(path)
    slurp(realPath)
  }

  fn printErrors(errors) {
    if !errors or len(errors) == 0 { return }
    for let i = 0; i < len(errors); i = i + 1 {
      let err = errors[i]
      if err.pos {
        let file = err.pos.filename or err.filename
        let prefix = file and join([file, ":", err.pos.line, ":", err.pos.col or 0], "") or
          join([err.pos.line, ":", err.pos.col or 0], "")
        groanln(join(["[", prefix, "] ", err.message], ""))
      } else if err.line {
        groanln(join(["[L", err.line, "] ", err.message], ""))
      } else {
        groanln(err.message)
      }
    }
  }

  fn collectErrors(result) {
    let errors = []
    if result.parseErrors { errors = concat(errors, result.parseErrors) }
    if result.lowerErrors { errors = concat(errors, result.lowerErrors) }
    if result.parseResult and result.parseResult.errors {
      errors = concat(errors, result.parseResult.errors)
    }
    if result.lowerResult and result.lowerResult.errors {
      errors = concat(errors, result.lowerResult.errors)
    }
    if result.resolveResult and result.resolveResult.errors {
      errors = concat(errors, result.resolveResult.errors)
    }
    if result.codegenResult and result.codegenResult.errors {
      errors = concat(errors, result.codegenResult.errors)
    }
    errors
  }

  fn pad(n) {
    let s = ""
    for let i = 0; i < n; i = i + 1 { s = s + " " }
    s
  }

  fn dumpScalar(value, indent) {
    let t = type(value)
    if t == "string" {
      println(pad(indent) + "\"" + value + "\"")
    } else {
      println(pad(indent) + str(value))
    }
  }

  fn dumpNode(node, indent) {
    if node == nil {
      println(pad(indent) + "nil")
      return
    }

    let t = type(node)
    if t == "array" {
      println(pad(indent) + "[")
      for let i = 0; i < len(node); i = i + 1 {
        dumpNode(node[i], indent + 2)
      }
      println(pad(indent) + "]")
      return
    }
    if t != "map" {
      dumpScalar(node, indent)
      return
    }

    if !node.type {
      println(pad(indent) + "<map>")
      return
    }

    let header = pad(indent) + node.type
    if node.id != nil { header = header + " #" + str(node.id) }
    if node.line != nil { header = header + " (L" + str(node.line) + ")" }
    if node.anfSynthetic { header = header + " [synthetic]" }
    println(header)

    if node.type == "Identifier" {
      println(pad(indent + 2) + "name: " + node.name)
      return
    }

    if node.value != nil {
      println(pad(indent + 2) + "value:")
      dumpNode(node.value, indent + 4)
    }

    if node.name {
      println(pad(indent + 2) + "name:")
      dumpNode(node.name, indent + 4)
    }
    if node.params {
      println(pad(indent + 2) + "params:")
      dumpNode(node.params, indent + 4)
    }
    if node.body {
      println(pad(indent + 2) + "body:")
      dumpNode(node.body, indent + 4)
    }
    if node.expressions {
      println(pad(indent + 2) + "expressions:")
      dumpNode(node.expressions, indent + 4)
    }
    if node.left {
      println(pad(indent + 2) + "left:")
      dumpNode(node.left, indent + 4)
    }
    if node.right {
      println(pad(indent + 2) + "right:")
      dumpNode(node.right, indent + 4)
    }
    if node.operand {
      println(pad(indent + 2) + "operand:")
      dumpNode(node.operand, indent + 4)
    }
    if node.condition {
      println(pad(indent + 2) + "condition:")
      dumpNode(node.condition, indent + 4)
    }
    if node.then {
      println(pad(indent + 2) + "then:")
      dumpNode(node.then, indent + 4)
    }
    if node.else {
      println(pad(indent + 2) + "else:")
      dumpNode(node.else, indent + 4)
    }
    if node.init {
      println(pad(indent + 2) + "init:")
      dumpNode(node.init, indent + 4)
    }
    if node.update {
      println(pad(indent + 2) + "update:")
      dumpNode(node.update, indent + 4)
    }
    if node.callee {
      println(pad(indent + 2) + "callee:")
      dumpNode(node.callee, indent + 4)
    }
    if node.args {
      println(pad(indent + 2) + "args:")
      dumpNode(node.args, indent + 4)
    }
    if node.object {
      println(pad(indent + 2) + "object:")
      dumpNode(node.object, indent + 4)
    }
    if node.index {
      println(pad(indent + 2) + "index:")
      dumpNode(node.index, indent + 4)
    }
    if node.property {
      println(pad(indent + 2) + "property:")
      dumpNode(node.property, indent + 4)
    }
    if node.target {
      println(pad(indent + 2) + "target:")
      dumpNode(node.target, indent + 4)
    }
    if node.elements {
      println(pad(indent + 2) + "elements:")
      dumpNode(node.elements, indent + 4)
    }
    if node.pairs {
      println(pad(indent + 2) + "pairs:")
      dumpNode(node.pairs, indent + 4)
    }
    if node.path {
      println(pad(indent + 2) + "path:")
      dumpNode(node.path, indent + 4)
    }
  }

  fn makeDriverWithSource(source, path) {
    driver.make(.{
      withAnf: true,
      withTypecheck: false,
      loadSource: fn(p) { loadSource(p, source, path) },
    })
  }

  fn compileWithDriver(driverInstance, path) {
    let moduleCache = .{}

    fn codegenModule(modulePath) {
      let cached = moduleCache[modulePath]
      if cached { return cached }

      let result = driverInstance.compileModule(modulePath)
      if !result or result.status != "done" {
        printErrors(collectErrors(result or .{}))
        return nil
      }

      let ast = result.anfResult and result.anfResult.ast or result.lowerResult.ast
      let cg = codegen(ast, result.resolveResult, .{
        codegenModule: codegenModule,
      })
      result.codegenResult = cg
      if !cg.success {
        printErrors(cg.errors)
        return nil
      }
      moduleCache[modulePath] = cg.function
      cg.function
    }

    codegenModule(path)
  }

  fn handleBuildFunction(cb) {
    let argsLength = len(Lx.args)
    let DEBUG_BUILD = true
    let usageMessage = join(["Usage:", Lx.args[0], "compile <path> [-o|--output <output>]"], " ")
    if argsLength < 3 {
      groanln(usageMessage)
      Lx.exit(28)
    }
    let path = nil
    let outputPath = nil
    let i = 2
    for i < argsLength {
      let arg = Lx.args[i]
      if arg == "-o" or arg == "--output" {
        if i + 1 >= argsLength {
          groanln(usageMessage)
          Lx.exit(28)
        }
        outputPath = Lx.args[i + 1]
        i = i + 2
        continue
      }
      if !path {
        path = arg
      }
      i = i + 1
    }
    if !path {
      groanln(usageMessage)
      Lx.exit(28)
    }
    let source = loadSource(path, nil, nil)
    if !source {
      groanln("Failed to open", path)
      Lx.exit(2)
    }

    let driverInstance = makeDriverWithSource(nil, nil)
    let func = compileWithDriver(driverInstance, path)
    if !func {
      Lx.exit(65)
    }
    cb(func, DEBUG_BUILD, outputPath)
  }

  let handlers = .{
    compile: fn() {
      handleBuildFunction(fn(func, DEBUG_BUILD, outputPath) {
        if outputPath {
          let bytes = objbuilder(func, DEBUG_BUILD).bytes()
          let ok = spit(outputPath, bytes)
          if ok != true {
            groanln(ok or "Failed to write output.")
            Lx.exit(74)
          }
        } else {
          objbuilder(func, DEBUG_BUILD).dump()
        }
      })
    },
    run: fn() {
      handleBuildFunction(fn(func, DEBUG_BUILD) {
        __lx_result__ = objbuilder(func, DEBUG_BUILD).bytes()
      })
    },
    eval: fn() {
      if !__lx_input__ {
        __lx_result__ = "Empty input."
        return
      }
      let path = "[LX EVAL]"
      let driverInstance = makeDriverWithSource(__lx_input__, path)
      let func = compileWithDriver(driverInstance, path)
      if !func {
        __lx_result__ = "Compile failed."
        return
      }
      __lx_result__ = objbuilder(func, false).bytes()
    },
    repl: fn() {
      if !__lx_input__ {
        __lx_result__ = "Empty input."
        return
      }
      let path = "[LX REPL]"
      let driverInstance = makeDriverWithSource(__lx_input__, path)
      let func = compileWithDriver(driverInstance, path)
      if !func {
        __lx_result__ = "Compile failed."
        return
      }
      if func.chunk.bytecode->len() == 1 {
        func.chunk.bytecode = [OP.NIL, OP.RETURN]->map(tohex)
      }
      __lx_result__ = objbuilder(func, false).bytes()
    },
    anf: fn() {
      let argsLength = len(Lx.args)
      let usageMessage = join(["Usage:", Lx.args[0], "anf <path>"], " ")
      if argsLength < 3 {
        groanln(usageMessage)
        Lx.exit(28)
      }
      let path = Lx.args[2]
      let source = loadSource(path, nil, nil)
      if !source {
        groanln("Failed to open", path)
        Lx.exit(2)
      }
      let parseResult = parse(source, path)
      if !parseResult.success {
        printErrors(parseResult.errors)
        Lx.exit(65)
      }
      let lowerResult = lower(parseResult.ast, .{
        startNodeId: parseResult.nextNodeId,
      })
      if !lowerResult.success {
        printErrors(lowerResult.errors)
        Lx.exit(65)
      }
      let anfResult = anf(lowerResult.ast, .{
        startNodeId: lowerResult.nextNodeId,
      })
      if !anfResult.success {
        printErrors(anfResult.errors)
        Lx.exit(65)
      }
      let ast = anfResult.ast
      dumpNode(ast, 0)
    },
  }
  handlers.c = handlers.compile
  handlers.r = handlers.run

  fn handleUnknownCommand() {
    if Lx.args[1] {
      groanln(Lx.args[0] + " " + Lx.args[1] + ": unknown command")
    }
    groanln("Run '" + Lx.args[0] + " help' for usage.")
    Lx.exit(28)
  }

  {Lx.args[1] and handlers[Lx.args[1]] or handleUnknownCommand}()
}()
