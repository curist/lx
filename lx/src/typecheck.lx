// Typechecker - monomorphic type inference with constraints.
//
// Pipeline assumptions:
// - Runs on lowered AST (no Arrow nodes; root is an implicit Block).
// - Uses resolver side tables to map Identifier â†’ declaration (`declaredAt`).
// - Unresolved names are `builtin` and type as Any at this phase.
//
// Features in this implementation:
// - Structural types: Array[T], Map[K,V], Record{...}, Option[T], Function(...)
// - Constraint solving + a single function body refinement pass.

let helper = import "src/typecheck-helper.lx"

// ========================================================
// Type Constructors
// ========================================================

fn typeAny()     { .{ kind: "Any" } }
fn typeNil()     { .{ kind: "Nil" } }
fn typeNumber()  { .{ kind: "Number" } }
fn typeBool()    { .{ kind: "Bool" } }
fn typeString()  { .{ kind: "String" } }

fn typeVar(id) {
  .{ kind: "TypeVar", id: id }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params: params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem: elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields: fields }
}

fn typeMap(key, elem) {
  .{ kind: "Map", key: key, elem: elem }
}

fn typeOption(value) {
  // Avoid Option[Option[T]]
  value and value.kind == "Option" and value or .{ kind: "Option", value: value }
}

// ========================================================
// Type Variable Management
// ========================================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = id + 1
  typeVar(id)
}

fn bindTypeVar(checker, id, type) {
  checker.typeVarBindings[id] = type
}

fn getTypeVarBinding(checker, id) {
  checker.typeVarBindings[id]
}

// Follow bindings until fixed point
fn deref(checker, type) {
  if type.kind == "TypeVar" {
    let bound = getTypeVarBinding(checker, type.id)
    if bound {
      return deref(checker, bound)
    }
  }
  type
}

fn derefWithRootVar(checker, t) {
  let root = nil
  for t and t.kind == "TypeVar" {
    root = t
    let bound = getTypeVarBinding(checker, t.id)
    if !bound { break }
    t = bound
  }
  .{ root: root, type: t }
}

// Occurs check: prevent infinite types
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for let i = 0; i < len(type.params); i = i + 1 {
      if occurs(checker, typeVarId, type.params[i]) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Map" {
    return occurs(checker, typeVarId, type.key) or occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Option" {
    return occurs(checker, typeVarId, type.value)
  }

  if type.kind == "Record" {
    let ks = keys(type.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      if occurs(checker, typeVarId, type.fields[ks[i]]) {
        return true
      }
    }
  }

  false
}

fn derefAll(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Function" {
    let ps = []
    for let i = 0; i < len(t.params); i = i + 1 {
      push(ps, derefAll(checker, t.params[i]))
    }
    return typeFunction(ps, derefAll(checker, t.return))
  }

  if t.kind == "Array" {
    return typeArray(derefAll(checker, t.elem))
  }

  if t.kind == "Map" {
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Option" {
    return typeOption(derefAll(checker, t.value))
  }

  if t.kind == "Record" {
    let fields = .{}
    let ks = keys(t.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      fields[ks[i]] = derefAll(checker, t.fields[ks[i]])
    }
    return typeRecord(fields)
  }

  t
}

// ========================================================
// Error Handling
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}


// ========================================================
// Unification (Eager, Structural)
// ========================================================

fn unify(checker, t1, t2) {
  let d1 = derefWithRootVar(checker, t1)
  let d2 = derefWithRootVar(checker, t2)

  let root1 = d1.root
  let root2 = d2.root

  t1 = d1.type
  t2 = d2.type

  // Fast path
  if t1.kind == t2.kind {
    if t1.kind == "TypeVar" {
      if t1.id == t2.id { return true }
      bindTypeVar(checker, t1.id, t2)
      return true
    }

    if t1.kind == "Function" {
      if len(t1.params) != len(t2.params) { return false }
      for let i = 0; i < len(t1.params); i = i + 1 {
        if !unify(checker, t1.params[i], t2.params[i]) {
          return false
        }
      }
      return unify(checker, t1.return, t2.return)
    }

    if t1.kind == "Array" {
      return unify(checker, t1.elem, t2.elem)
    }

    if t1.kind == "Map" {
      return unify(checker, t1.key, t2.key) and unify(checker, t1.elem, t2.elem)
    }

    if t1.kind == "Option" {
      return unify(checker, t1.value, t2.value)
    }

    if t1.kind == "Record" {
      let k1 = keys(t1.fields)
      let k2 = keys(t2.fields)
      if len(k1) != len(k2) { return false }
      for let i = 0; i < len(k1); i = i + 1 {
        let k = k1[i]
        if !t2.fields[k] { return false }
        if !unify(checker, t1.fields[k], t2.fields[k]) {
          return false
        }
      }
      return true
    }

    // Primitive types
    return true
  }

  // Any absorbs everything (but still bind TypeVars so they don't stay unconstrained).
  if t1.kind == "Any" {
    if root2 and root2.kind == "TypeVar" { bindTypeVar(checker, root2.id, t1) }
    return true
  }
  if t2.kind == "Any" {
    if root1 and root1.kind == "TypeVar" { bindTypeVar(checker, root1.id, t2) }
    return true
  }

  // Nil promotes to Option[T] (without double-wrapping).
  // This is how `nil` participates in "optional" types.
  fn optionizeRoot(root, baseType) {
    if !root or root.kind != "TypeVar" { return false }
    // Avoid binding a typevar to Option(of itself).
    let inner = baseType
    if baseType and baseType.kind == "TypeVar" and baseType.id == root.id {
      inner = freshTypeVar(checker)
    }
    bindTypeVar(checker, root.id, typeOption(inner))
    true
  }

  if t1.kind == "Nil" {
    if t2.kind == "Option" { return true }
    // Prefer to annotate the non-nil side's root var when possible.
    if optionizeRoot(root2, t2) { return true }
    if optionizeRoot(root1, t2) { return true }
    return true
  }

  if t2.kind == "Nil" {
    if t1.kind == "Option" { return true }
    if optionizeRoot(root1, t1) { return true }
    if optionizeRoot(root2, t1) { return true }
    return true
  }

  // Option[T] can unify with T (implicit lifting).
  if t1.kind == "Option" {
    return unify(checker, t1.value, t2)
  }
  if t2.kind == "Option" {
    return unify(checker, t1, t2.value)
  }

  // TypeVar binding
  if t1.kind == "TypeVar" {
    if occurs(checker, t1.id, t2) { return false }
    bindTypeVar(checker, t1.id, t2)
    return true
  }

  if t2.kind == "TypeVar" {
    if occurs(checker, t2.id, t1) { return false }
    bindTypeVar(checker, t2.id, t1)
    return true
  }

  false
}

fn constrain(checker, t1, t2, nodeId, msg) {
  if !unify(checker, t1, t2) {
    addError(checker, nodeId, msg)
    return typeAny()
  }
  t1
}

// ========================================================
// Constraints (Phase 2)
// ========================================================

fn emitEq(checker, t1, t2, nodeId, msg) {
  push(checker.constraints, .{
    kind: "Eq",
    t1: t1,
    t2: t2,
    nodeId: nodeId,
    msg: msg,
  })
  t2
}

fn emitHasField(checker, base, name, fieldType, nodeId, msg) {
  push(checker.constraints, .{
    kind: "HasField",
    base: base,
    fieldName: name,
    fieldType: fieldType,
    nodeId: nodeId,
    msg: msg,
  })
  fieldType
}

fn containEqFailure(checker, t1, t2) {
  if t1.kind == "TypeVar" { bindTypeVar(checker, t1.id, typeAny()) }
  if t2.kind == "TypeVar" { bindTypeVar(checker, t2.id, typeAny()) }
}

fn containHasFieldFailure(checker, fieldType) {
  if fieldType.kind == "TypeVar" {
    bindTypeVar(checker, fieldType.id, typeAny())
  }
}

fn trySolveConstraint(checker, c) {
  if c.kind == "Eq" {
    if !unify(checker, c.t1, c.t2) {
      addError(checker, c.nodeId, c.msg)
      containEqFailure(checker, deref(checker, c.t1), deref(checker, c.t2))
    }
    return true
  }

  if c.kind == "HasField" {
    let ft = deref(checker, c.fieldType)

    // Preserve the root typevar (for better containment), but do not "grow" records.
    let baseInfo = derefWithRootVar(checker, c.base)
    let root = baseInfo.root
    let base = baseInfo.type

    // Option[T] can be accessed as T (implicit lifting).
    if base.kind == "Option" and base.value {
      base = deref(checker, base.value)
    }

    if base.kind == "Any" {
      if ft.kind == "TypeVar" { bindTypeVar(checker, ft.id, typeAny()) }
      return true
    }

    // If the base is (or was) a typevar, consult its binding but do not extend.
    if root and root.kind == "TypeVar" {
      let binding = getTypeVarBinding(checker, root.id)
      if !binding {
        // Not enough information yet; keep the constraint around.
        return false
      }
      if binding.kind == "Any" {
        if ft.kind == "TypeVar" { bindTypeVar(checker, ft.id, typeAny()) }
        return true
      }
      if binding.kind == "Record" {
        let field = binding.fields[c.fieldName]
        if !field {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        } else if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
        return true
      }
      addError(checker, c.nodeId, c.msg)
      containHasFieldFailure(checker, ft)
      return true
    }

    // Closed record: must contain the field.
    if base.kind == "Record" {
      let field = base.fields[c.fieldName]
      if field {
        if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
      } else {
        addError(checker, c.nodeId, c.msg)
        containHasFieldFailure(checker, ft)
      }
      return true
    }

    // Non-record base
    addError(checker, c.nodeId, c.msg)
    containHasFieldFailure(checker, ft)
    return true
  }

  false
}

fn solveConstraints(checker) {
  checker.constraints = helper.solveWorklist(
    checker.constraints,
    fn(c) { trySolveConstraint(checker, c) },
    .{ maxRounds: 1000 },
  )
}

fn finalizeConstraints(checker) {
  // Any remaining constraints are unsolvable with the collected info;
  // report errors and contain to Any so downstream tooling doesn't crash.
  let remaining = checker.constraints
  checker.constraints = []

  for let i = 0; i < len(remaining); i = i + 1 {
    let c = remaining[i]
    if trySolveConstraint(checker, c) { continue }

    if c.kind == "HasField" {
      addError(checker, c.nodeId, c.msg)
      containHasFieldFailure(checker, deref(checker, c.fieldType))
      // If base is still unconstrained, contain it to Any.
      let baseInfo = derefWithRootVar(checker, c.base)
      if baseInfo and baseInfo.root and baseInfo.root.kind == "TypeVar" and !getTypeVarBinding(checker, baseInfo.root.id) {
        bindTypeVar(checker, baseInfo.root.id, typeAny())
      }
    }
  }
}


// ========================================================
// Type Environment (Lexical, No Cloning)
// ========================================================

fn TypeEnv(parent) {
  .{
    parent: parent,
    bindings: .{}, // declNodeId -> TypeVar
  }
}

fn lookupDecl(checker, declNodeId) {
  let env = checker.currentEnv
  for env {
    let t = env.bindings[declNodeId]
    if t { return t }
    env = env.parent
  }
  nil
}

fn bindDecl(checker, declNodeId) {
  let tv = freshTypeVar(checker)
  checker.currentEnv.bindings[declNodeId] = tv
  tv
}

fn enterScope(checker) {
  checker.currentEnv = TypeEnv(checker.currentEnv)
}

fn exitScope(checker) {
  checker.currentEnv = checker.currentEnv.parent
}


// ========================================================
// Expression Checking (Pure Phase 1)
// ========================================================

let synthExpr

// Some lowers wrap expressions as statements.
fn checkExprStmt(checker, node) {
  // Lower often wraps top-level statements this way.
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

fn checkLiteral(checker, node) {
  let t =
    node.type == "Number" and typeNumber() or
    node.type == "String" and typeString() or
    node.type == "Bool"   and typeBool()   or
    typeNil()

  checker.types[node.id] = t
  t
}

fn checkIdentifier(checker, node) {
  let binding = checker.resolvedNames[node.id]
  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Builtins/external names are not tracked by declaredAt.
  // Treat them as Any at this phase.
  if binding.kind == "builtin" {
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let declId = binding.declaredAt
  if !declId {
    // Compiler bug / unexpected resolver output; contain to Any.
    addError(checker, node.id, "Missing declaredAt for identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }
  let tv = lookupDecl(checker, declId)
  if !tv {
    tv = bindDecl(checker, declId)
  }

  checker.types[node.id] = tv
  tv
}

fn checkBinary(checker, node) {
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "+" {
    let l = deref(checker, lt)
    let r = deref(checker, rt)

    // Overloaded: Number + Number -> Number, String + String -> String
    if l.kind == "String" or r.kind == "String" {
      emitEq(checker, lt, typeString(), node.left.id, "Expected string")
      emitEq(checker, rt, typeString(), node.right.id, "Expected string")
      let t = typeString()
      checker.types[node.id] = t
      return t
    }

    // Default: numeric add (also helps inference for `fn add(a,b){a+b}`).
    emitEq(checker, lt, typeNumber(), node.left.id, "Expected number")
    emitEq(checker, rt, typeNumber(), node.right.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "-" or op == "*" or op == "/" {
    emitEq(checker, lt, typeNumber(), node.left.id, "Expected number")
    emitEq(checker, rt, typeNumber(), node.right.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "==" or op == "!=" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  addError(checker, node.id, "Unsupported binary operator")
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkCall(checker, node) {
  let callee = synthExpr(checker, node.callee)
  let args = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(args, synthExpr(checker, node.args[i]))
  }

  let paramTvs = []
  for let i = 0; i < len(args); i = i + 1 {
    push(paramTvs, freshTypeVar(checker))
  }
  let ret = freshTypeVar(checker)
  let fnType = typeFunction(paramTvs, ret)

  emitEq(checker, callee, fnType, node.callee.id, "Call requires function")
  for let i = 0; i < len(args); i = i + 1 {
    emitEq(checker, args[i], paramTvs[i], node.args[i].id, "Argument mismatch")
  }

  checker.types[node.id] = ret
  ret
}

fn checkFunction(checker, node) {
  // If this function is named (hoisted), ensure its declaration binding exists.
  let fnBinding = nil
  if node.name {
    fnBinding = lookupDecl(checker, node.id)
    if !fnBinding {
      fnBinding = bindDecl(checker, node.id)
    }
  }

  // Capture the lexical environment where this function is defined so the
  // refinement pass can see outer bindings (closures).
  let defEnv = checker.currentEnv

  enterScope(checker)

  let params = []
  for let i = 0; i < len(node.params); i = i + 1 {
    let tv = bindDecl(checker, node.params[i].id)
    checker.types[node.params[i].id] = tv
    push(params, tv)
  }

  let ret = freshTypeVar(checker)
  let prevReturn = checker.currentReturn
  checker.currentReturn = ret
  let bodyT = synthExpr(checker, node.body)
  checker.currentReturn = prevReturn
  emitEq(checker, bodyT, ret, node.body.id, "Return mismatch")

  exitScope(checker)

  // Store the function type with current bindings resolved.
  let resolvedParams = []
  for let i = 0; i < len(params); i = i + 1 {
    push(resolvedParams, deref(checker, params[i]))
  }
  let fnT = typeFunction(resolvedParams, deref(checker, ret))
  checker.types[node.id] = fnT
  if fnBinding {
    emitEq(checker, fnBinding, fnT, node.id, "Function declaration mismatch")
    checker.types[node.name.id] = fnBinding
  }

  // Track for second-pass refinement
  push(checker.functionInfos, .{
    node: node,
    defEnv: defEnv,
    params: params,
    ret: ret,
    fnType: fnT,
  })
  fnT
}

fn checkLet(checker, node) {
  let tv = bindDecl(checker, node.name.id)
  checker.types[node.name.id] = tv

  if node.init {
    let it = synthExpr(checker, node.init)
    constrain(checker, tv, it, node.init.id, "Initializer mismatch")
  }

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkIf(checker, node) {
  synthExpr(checker, node.condition)
  let thenT = synthExpr(checker, node.then)

  if node.else {
    let elseT = synthExpr(checker, node.else)
    let outT = freshTypeVar(checker)
    constrain(checker, outT, thenT, node.then.id, "Branch mismatch")
    constrain(checker, outT, elseT, node.else.id, "Branch mismatch")
    checker.types[node.id] = outT
    return outT
  }

  // If without else returns Option[T].
  let t = typeOption(thenT)
  checker.types[node.id] = t
  t
}

fn checkBlock(checker, node) {
  enterScope(checker)

  let lastT = typeNil()
  if node.expressions {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      lastT = synthExpr(checker, node.expressions[i])
    }
  }

  exitScope(checker)

  checker.types[node.id] = lastT
  lastT
}

fn checkGrouping(checker, node) {
  let t = synthExpr(checker, node.expression)
  checker.types[node.id] = t
  t
}

fn checkUnary(checker, node) {
  let ot = synthExpr(checker, node.operand)
  let op = node.operator.lexeme

  // Minimal Phase-1 semantics
  if op == "-" {
    emitEq(checker, ot, typeNumber(), node.operand.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "!" {
    emitEq(checker, ot, typeBool(), node.operand.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  // Unknown unary -> Any, but still traversed operand
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkLogical(checker, node) {
  // NOTE: pick semantics. If Lx is Lua-like and returns operands,
  // you cannot type it as Bool in general.
  // For Phase 1, simplest is to require bool operands and return bool.
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "and" or op == "or" {
    emitEq(checker, lt, typeBool(), node.left.id, "Expected bool")
    emitEq(checker, rt, typeBool(), node.right.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkFor(checker, node) {
  enterScope(checker)

  if node.init      { synthExpr(checker, node.init) }
  if node.condition {
    let ct = synthExpr(checker, node.condition)
    // If you want: constrain condition to Bool
    emitEq(checker, ct, typeBool(), node.condition.id, "Expected bool")
  }
  if node.update    { synthExpr(checker, node.update) }

  // Body can be Block or any stmt/expr
  if node.body      { synthExpr(checker, node.body) }

  exitScope(checker)

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkReturn(checker, node) {
  let rt = typeNil()
  if node.value { rt = synthExpr(checker, node.value) }

  if checker.currentReturn {
    emitEq(checker, checker.currentReturn, rt, node.id, "Return mismatch")
  }

  // Treat `return expr` as having the expression's type so block "last expr"
  // can still drive function return inference.
  checker.types[node.id] = rt
  rt
}

fn checkBreak(checker, node) {
  if node.value { synthExpr(checker, node.value) }
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkContinue(checker, node) {
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkArray(checker, node) {
  let elemT = freshTypeVar(checker)
  if node.elements {
    for let i = 0; i < len(node.elements); i = i + 1 {
      let it = synthExpr(checker, node.elements[i])
      emitEq(checker, it, elemT, node.elements[i].id, "Array element mismatch")
    }
  }
  let t = typeArray(elemT)
  checker.types[node.id] = t
  t
}

fn checkHashmap(checker, node) {
  // Treat hashmap literal as:
  // - Record when all keys are strings
  // - Map when keys are computed (no string keys)
  // - Any for mixed styles
  let fields = .{}
  let anyNonStringKey = false
  let sawStringKey = false
  let keyT = freshTypeVar(checker)
  let elemT = freshTypeVar(checker)

  if node.pairs {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let p = node.pairs[i]
      // Prefer string keys (parser lowers dot keys to String nodes)
      let isBareStringKey = p.key and p.key.type == "String" and
        p.key.lexeme and len(p.key.lexeme) > 0 and p.key.lexeme[0] != "\""
      if isBareStringKey {
        sawStringKey = true
        // Store record fields as typevars so later mutations can constrain them.
        let vType = synthExpr(checker, p.value)
        let fieldT = freshTypeVar(checker)
        constrain(checker, fieldT, vType, p.value.id, "Record field mismatch")
        fields[p.key.value] = fieldT
        continue
      }

      anyNonStringKey = true
      if p.key {
        let kt = synthExpr(checker, p.key)
        emitEq(checker, kt, keyT, p.key.id, "Map key mismatch")
      }
      if p.value {
        let vt = synthExpr(checker, p.value)
        emitEq(checker, vt, elemT, p.value.id, "Map value mismatch")
      }
      // If your lower uses p[0], p[1], adjust accordingly.
    }
  }

  let t = typeAny()
  if sawStringKey and !anyNonStringKey {
    t = typeRecord(fields)
  } else if !sawStringKey and anyNonStringKey {
    t = typeMap(keyT, elemT)
  } else if !sawStringKey and !anyNonStringKey {
    // Empty literal `.{}` is treated as an empty hashmap.
    t = typeMap(keyT, elemT)
  }

  checker.types[node.id] = t
  t
}

fn checkIndex(checker, node) {
  let objT = synthExpr(checker, node.object)
  let idxT = synthExpr(checker, node.index)

  let o = deref(checker, objT)
  let t = typeAny()

  if o.kind == "Array" {
    emitEq(checker, idxT, typeNumber(), node.index.id, "Array index must be a number")
    t = o.elem
  } else if o.kind == "Map" {
    emitEq(checker, idxT, o.key, node.index.id, "Map key mismatch")
    t = o.elem
  } else if o.kind == "String" {
    emitEq(checker, idxT, typeNumber(), node.index.id, "String index must be a number")
    t = typeString()
  }

  checker.types[node.id] = t
  t
}

fn checkDot(checker, node) {
  let objT = synthExpr(checker, node.object)
  // property is a Node (Identifier or StringKey)
  let propName = nil
  if node.property and node.property.type == "Identifier" {
    propName = node.property.name
  } else if node.property and node.property.type == "String" {
    propName = node.property.value
  } else {
    if node.property { synthExpr(checker, node.property) }
  }

  if !propName {
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let fieldT = freshTypeVar(checker)
  emitHasField(checker, objT, propName, fieldT, node.id, "Missing field: " + propName)
  checker.types[node.id] = fieldT
  fieldT
}

fn checkAssignment(checker, node) {
  let vt = synthExpr(checker, node.value)

  // Minimal: only support assignment to Identifier in Phase 1
  if node.target and node.target.type == "Identifier" {
    let lt = synthExpr(checker, node.target)
    emitEq(checker, lt, vt, node.id, "Assignment mismatch")
    checker.types[node.id] = vt
    return vt
  }

  // Property assignment: base.field = value
  if node.target and node.target.type == "Dot" {
    let objT = synthExpr(checker, node.target.object)

    let propName = nil
    if node.target.property and node.target.property.type == "Identifier" {
      propName = node.target.property.name
    } else if node.target.property and node.target.property.type == "String" {
      propName = node.target.property.value
    } else {
      if node.target.property { synthExpr(checker, node.target.property) }
    }

    if propName {
      let fieldT = freshTypeVar(checker)
      emitHasField(checker, objT, propName, fieldT, node.target.id, "Missing field: " + propName)
      emitEq(checker, fieldT, vt, node.id, "Assignment mismatch")
      checker.types[node.target.id] = fieldT
      checker.types[node.id] = vt
      return vt
    }
  }

  // Traverse target anyway
  if node.target { synthExpr(checker, node.target) }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkImport(checker, node) {
  // Path is usually String or Identifier
  if node.path { synthExpr(checker, node.path) }

  // Resolver may attach module type information for the import expression.
  if node.importType {
    checker.types[node.id] = node.importType
    return node.importType
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn refineFunctions(checker) {
  for let i = 0; i < len(checker.functionInfos); i = i + 1 {
    let info = checker.functionInfos[i]
    checker.currentEnv = info.defEnv or checker.rootEnv
    enterScope(checker)

    if info.node.name {
      checker.currentEnv.bindings[info.node.id] = lookupDecl(checker, info.node.id) or info.fnType
    }

    for let p = 0; p < len(info.params); p = p + 1 {
      let paramNode = info.node.params[p]
      checker.currentEnv.bindings[paramNode.id] = info.params[p]
      checker.types[paramNode.id] = info.params[p]
    }

    let prevReturn = checker.currentReturn
    checker.currentReturn = info.ret
    let bodyT = synthExpr(checker, info.node.body)
    checker.currentReturn = prevReturn
    emitEq(checker, bodyT, info.ret, info.node.body.id, "Return mismatch")

    exitScope(checker)
  }
}


// ========================================================
// Dispatcher
// ========================================================

synthExpr = fn(checker, node) {
  if !node { return typeNil() }

  // Literals
  if node.type == "Number" or node.type == "String" or
     node.type == "Bool" or node.type == "Nil" {
    return checkLiteral(checker, node)
  }

  // Names / bindings
  if node.type == "Identifier" { return checkIdentifier(checker, node) }

  // Structural containers / wrappers
  if node.type == "Block"    { return checkBlock(checker, node) }
  if node.type == "Grouping" { return checkGrouping(checker, node) }

  // Operators
  if node.type == "Unary"      { return checkUnary(checker, node) }
  if node.type == "Binary"     { return checkBinary(checker, node) }
  if node.type == "Logical"    { return checkLogical(checker, node) }
  if node.type == "Assignment" { return checkAssignment(checker, node) }

  // Calls / access
  if node.type == "Call"  { return checkCall(checker, node) }
  if node.type == "Dot"   { return checkDot(checker, node) }
  if node.type == "Index" { return checkIndex(checker, node) }

  // Collections
  if node.type == "Array"   { return checkArray(checker, node) }
  if node.type == "Hashmap" { return checkHashmap(checker, node) }

  // Declarations / definitions
  if node.type == "Let"      { return checkLet(checker, node) }
  if node.type == "Function" { return checkFunction(checker, node) }
  if node.type == "Import"   { return checkImport(checker, node) }

  // Control flow
  if node.type == "If"       { return checkIf(checker, node) }
  if node.type == "For"      { return checkFor(checker, node) }
  if node.type == "Return"   { return checkReturn(checker, node) }
  if node.type == "Break"    { return checkBreak(checker, node) }
  if node.type == "Continue" { return checkContinue(checker, node) }

  // XXX: should be unreachable, can we catch this?
  addError(checker, node.id, "Unsupported node: " + node.type)
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// ========================================================
// Public API
// ========================================================

fn makeChecker(resolveResult) {
  let root = TypeEnv(nil)
  .{
    types: .{},
    typeVarBindings: .{},
    errors: [],
    hadError: false,

    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,

    nextTypeVarId: 1,
    currentEnv: root,
    rootEnv: root,

    constraints: [],
    functionInfos: [],

    currentReturn: nil,
  }
}

fn predeclareTopLevel(checker, ast) {
  if !ast or ast.type != "Block" or !ast.expressions { return }

  for let i = 0; i < len(ast.expressions); i = i + 1 {
    let node = ast.expressions[i]
    if node.type == "Let" and node.name {
      if !lookupDecl(checker, node.name.id) {
        bindDecl(checker, node.name.id)
      }
    } else if node.type == "Function" and node.name {
      if !lookupDecl(checker, node.id) {
        bindDecl(checker, node.id)
      }
    }
  }
}

fn typecheck(ast, resolveResult) {
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      typeVarBindings: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  let checker = makeChecker(resolveResult)

  if !ast {
    // XXX: should we report some errors?
    return .{ success: false, types: .{}, typeVarBindings: .{}, errors: [] }
  }

  // Predeclare top-level lets/functions for forward references (Phase 2)
  predeclareTopLevel(checker, ast)

  synthExpr(checker, ast)

  // Solve constraints and refine functions once more
  solveConstraints(checker)
  refineFunctions(checker)
  solveConstraints(checker)
  finalizeConstraints(checker)

  let outTypes = .{}
  let typeKeys = keys(checker.types)
  for let i = 0; i < len(typeKeys); i = i + 1 {
    let k = typeKeys[i]
    outTypes[k] = derefAll(checker, checker.types[k])
  }

  let outBindings = .{}
  let bindKeys = keys(checker.typeVarBindings)
  for let i = 0; i < len(bindKeys); i = i + 1 {
    let k = bindKeys[i]
    outBindings[k] = derefAll(checker, checker.typeVarBindings[k])
  }

  .{
    success: !checker.hadError,
    types: outTypes,
    typeVarBindings: outBindings,
    errors: checker.errors,
  }
}

typecheck
