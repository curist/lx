// Fiber-based compiler API
//
// Provides a fiber-driven compilation interface that yields events
// for streaming diagnostics and progress.

let Events = import "src/events.lx"
let parse = import "src/passes/parse/parser.lx"
let lower = import "src/passes/transform/lower.lx"
let anf = import "src/passes/transform/anf.lx"
let resolve = import "src/passes/analysis/resolve.lx"
let anfInline = import "src/passes/transform/anf-inline.lx"
let lowerIntrinsics = import "src/passes/transform/lower-intrinsics.lx"
let codegen = import "src/passes/emit/codegen.lx"

// Parse error message format: [file:Lline:Ccol] context: message
// Returns: .{ line, col } or nil if parsing fails
fn parseErrorLocation(errorMsg) {
  // Find the L and C markers
  let lIdx = nil
  let cIdx = nil
  let closeBracket = nil

  for let i = 0; i < len(errorMsg); i = i + 1 {
    let ch = errorMsg[i]
    if ch == "L" and !lIdx {
      lIdx = i
    } else if ch == "C" and lIdx and !cIdx {
      cIdx = i
    } else if ch == "]" and !closeBracket {
      closeBracket = i
      break
    }
  }

  if !lIdx or !cIdx or !closeBracket {
    return nil
  }

  // Extract line number (between L and :C)
  let lineStr = ""
  for let i = lIdx + 1; i < cIdx; i = i + 1 {
    if errorMsg[i] != ":" {
      lineStr = lineStr + errorMsg[i]
    }
  }

  // Extract column number (between C and ])
  let colStr = ""
  for let i = cIdx + 1; i < closeBracket; i = i + 1 {
    colStr = colStr + errorMsg[i]
  }

  let line = tonumber(lineStr)
  let col = tonumber(colStr)

  if line and col {
    .{ line, col }
  } else {
    nil
  }
}

// Start a compilation fiber.
// - source: source code string to compile
// - opts: compilation options (.{ filename, ... })
// Returns: a fiber that can be polled for events
fn start(source, opts) {
  let filename = opts.filename or "unknown"

  Fiber.create(fn() {
    // Parse phase
    Fiber.yield(Events.progress("parse", "start", 0, 1))

    let parseResult = parse(source, filename)

    // Yield diagnostics for parse errors
    for errorMsg in parseResult.errors {
      let loc = parseErrorLocation(errorMsg)
      let range = if loc {
        .{ start: .{ line: loc.line, col: loc.col }, end: .{ line: loc.line, col: loc.col + 1 } }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("parse", filename, range, Events.Severity.ERROR, errorMsg, nil))
    }

    Fiber.yield(Events.progress("parse", "done", 1, 1))

    // Stop if parse failed
    if !parseResult.success {
      return Events.done(.{ success: false, errors: parseResult.errors })
    }

    // Lower phase
    Fiber.yield(Events.progress("lower", "start", 0, 1))
    let lowerResult = lower(parseResult.ast, .{ nextNodeId: parseResult.nextNodeId })
    Fiber.yield(Events.progress("lower", "done", 1, 1))

    if !lowerResult.success {
      return Events.done(.{ success: false, errors: lowerResult.errors })
    }

    // ANF phase
    Fiber.yield(Events.progress("anf", "start", 0, 1))
    let anfResult = anf(lowerResult.ast, .{ nextNodeId: lowerResult.nextNodeId })
    Fiber.yield(Events.progress("anf", "done", 1, 1))

    if !anfResult.success {
      return Events.done(.{ success: false, errors: anfResult.errors })
    }

    // Resolve phase
    Fiber.yield(Events.progress("resolve", "start", 0, 1))
    let resolveResult = resolve(anfResult.ast, .{})

    // Yield diagnostics for resolve errors
    for err in resolveResult.errors {
      // Look up node by id to get source location
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      let severity = if err.severity == "error" {
        Events.Severity.ERROR
      } else if err.severity == "warning" {
        Events.Severity.WARNING
      } else {
        Events.Severity.ERROR
      }
      Fiber.yield(Events.diag("resolve", filename, range, severity, err.message, nil))
    }

    Fiber.yield(Events.progress("resolve", "done", 1, 1))

    // Stop if resolve failed
    if !resolveResult.success {
      return Events.done(.{ success: false, errors: resolveResult.errors })
    }

    // ANF-inline phase (mutates AST in-place)
    Fiber.yield(Events.progress("anf-inline", "start", 0, 1))
    anfInline(anfResult.ast, resolveResult)
    Fiber.yield(Events.progress("anf-inline", "done", 1, 1))

    // Lower-intrinsics phase (mutates AST in-place)
    Fiber.yield(Events.progress("lower-intrinsics", "start", 0, 1))
    lowerIntrinsics(anfResult.ast, resolveResult, nil)
    Fiber.yield(Events.progress("lower-intrinsics", "done", 1, 1))

    // Codegen phase
    Fiber.yield(Events.progress("codegen", "start", 0, 1))
    let codegenResult = codegen(anfResult.ast, resolveResult, .{
      enumInfo: parseResult.enumInfo
    })

    // Yield diagnostics for codegen errors
    for err in codegenResult.errors {
      // Look up node by id to get source location
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("codegen", filename, range, Events.Severity.ERROR, err.message, nil))
    }

    Fiber.yield(Events.progress("codegen", "done", 1, 1))

    // Return done event with all results
    Events.done(.{
      success: codegenResult.success,
      ast: anfResult.ast,
      function: codegenResult.function,
      parseResult,
      lowerResult,
      anfResult,
      resolveResult,
      codegenResult
    })
  })
}

// Poll a compilation fiber for events.
// - fiber: the compilation fiber from start()
// - budget: .{ maxEvents } - how many events to collect before returning
// Returns: .{ events, done?, result?, error? }
fn poll(fiber, budget) {
  let events = []
  let maxEvents = budget.maxEvents

  for len(events) < maxEvents {
    let resumeResult = Fiber.resume(fiber)

    if resumeResult.tag == "yield" {
      push(events, resumeResult.value)
    } else if resumeResult.tag == "return" {
      return .{ events, done: true, result: resumeResult.value }
    } else if resumeResult.tag == "error" {
      return .{ events, done: true, error: resumeResult.error }
    }
  }

  .{ events, done: false }
}

.{ start, poll }
