// Module resolution helpers.
//
// Resolution strategy:
// - Given an entry file, start searching for `.lxroot` from the entry file's
//   directory, walking up the parent directories.
// - If found, use that as the project root.
// - Otherwise, if `Lx.env["LX_ROOT"]` is set, use it as the project root.
// - Otherwise, use the entry file's directory as the project root.
//
// Paths are kept simple:
// - No tilde expansion, no shell expansion.
// - Non-absolute paths are resolved relative to the project root.
//
// Usage:
//   let resolver = ModuleResolution.forEntry("src/main.lx")
//   resolver.slurp("utils/helpers.lx")

let _cache = .{}  // Map of baseDir -> {projectRoot}

fn _isAbs(path) { path and path[0] == "/" }

fn _computeRoots(baseDir) {
  // Check cache first
  if _cache[baseDir] {
    return _cache[baseDir]
  }

  let dir = baseDir
  let found = nil
  for true {
    if Lx.fs.exists(Lx.path.join(dir, ".lxroot")) {
      found = dir
      break
    }
    let parent = Lx.path.dirname(dir)
    if parent == dir { break }
    dir = parent
  }

  if !found and Lx.env and Lx.env["LX_ROOT"] {
    let envRoot = Lx.env["LX_ROOT"]
    if envRoot and envRoot != "" {
      if !_isAbs(envRoot) {
        envRoot = Lx.path.join(baseDir, envRoot)
      }

      // Only accept if it looks like an existing directory (when stat is available).
      if Lx.fs.stat {
        let st = Lx.fs.stat(envRoot)
        if st and st.type == "dir" {
          found = envRoot
        }
      } else if Lx.fs.exists(envRoot) {
        found = envRoot
      }
    }
  }

  let projectRoot = found or baseDir

  let roots = .{ projectRoot }

  _cache[baseDir] = roots
  roots
}

fn forEntry(entryPath) {
  // Resolve entry path to absolute
  let absEntry = entryPath
  if !_isAbs(absEntry) {
    absEntry = Lx.path.join(Lx.fs.cwd(), absEntry)
  }

  // Get the directory of the entry file
  let baseDir = Lx.path.dirname(absEntry)

  // Compute roots for this entry
  let roots = _computeRoots(baseDir)

  fn resolve(path) {
    if !path or _isAbs(path) {
      return path
    }
    if !roots or !roots.projectRoot {
      return path
    }

    // Resolve relative to project root
    Lx.path.join(roots.projectRoot, path)
  }

  .{
    resolve,
    slurp: fn(path) {
      let result = Lx.pcall(fn() { Lx.fs.readFile(resolve(path)) })
      if !result.error { result.value } else { nil }
    },
    roots: fn() { roots }
  }
}

.{ forEntry }
