// Repeatedly scans `items`, removing the ones `trySolve(item)` can solve.
// Returns the remaining (unsolved) items once no progress is made.
fn solveWorklist(items, trySolve, opts = .{}) {
  let maxRounds = opts.maxRounds or 1000
  let progress = opts.progress
  let resetProgress = opts.resetProgress

  let round = 0 // number of completed rounds
  let remaining = items or []
  let hitMaxRounds = false

  for round < maxRounds {
    if len(remaining) == 0 { break }
    round = round + 1

    if resetProgress { resetProgress() }

    let work = remaining
    remaining = []
    let solved = 0

    for item in work {
      if trySolve(item) {
        solved = solved + 1
      } else {
        push(remaining, item)
      }
    }

    let didProgress = progress and progress() or solved > 0
    if !didProgress { break }
  }

  if round == maxRounds and len(remaining) > 0 {
    hitMaxRounds = true
    if opts.onMaxRounds {
      opts.onMaxRounds(.{ rounds: round, remaining: remaining })
    }
  }

  .{
    remaining: remaining,
    rounds: round,
    hitMaxRounds: hitMaxRounds,
  }
}

// Tarjan SCC.
// - `nodes`: array of node ids (string/number)
// - `edgesFor`: fn(nodeId) -> array of neighbor node ids
// Returns:
//   .{ components: [[nodeId]], componentOf: .{ [nodeId]: compIndex } }
fn scc(nodes, edgesFor) {
  let indexBy = .{}   // nodeId -> index
  let lowBy = .{}     // nodeId -> lowlink
  let onStack = .{}   // nodeId -> bool
  let stack = []
  let nextIndex = 0

  let components = []
  let componentOf = .{}

  let strongConnect
  strongConnect = fn(v) {
    indexBy[v] = nextIndex
    lowBy[v] = nextIndex
    nextIndex = nextIndex + 1

    push(stack, v)
    onStack[v] = true

    let neighbors = (edgesFor and edgesFor(v)) or []
    for w in neighbors {
      if indexBy[w] == nil {
        strongConnect(w)
        lowBy[v] = min(lowBy[v], lowBy[w])
      } else if onStack[w] {
        lowBy[v] = min(lowBy[v], indexBy[w])
      }
    }

    if lowBy[v] == indexBy[v] {
      let comp = []
      for true {
        let w = pop(stack)
        onStack[w] = false
        push(comp, w)
        if w == v { break }
      }

      let compIndex = len(components)
      for c in comp {
        componentOf[c] = compIndex
      }
      push(components, comp)
    }
  }

  for v in nodes {
    if indexBy[v] == nil {
      strongConnect(v)
    }
  }

  .{ components, componentOf }
}

// Returns SCCs in a topological order of the condensation graph.
fn sccTopo(nodes, edgesFor) {
  let out = scc(nodes, edgesFor)
  let comps = out.components
  let compOf = out.componentOf

  // compEdges: compIndex -> set of neighbor compIndex
  let compEdges = []
  let indegree = []
  for comp in comps {
    push(compEdges, .{})
    push(indegree, 0)
  }

  for v in nodes {
    let vComp = compOf[v]
    let neighbors = (edgesFor and edgesFor(v)) or []
    for w in neighbors {
      let wComp = compOf[w]
      if vComp != wComp {
        // Dedup edges with a set.
        if !compEdges[vComp][wComp] {
          compEdges[vComp][wComp] = true
          indegree[wComp] = indegree[wComp] + 1
        }
      }
    }
  }

  // Kahn's algorithm over SCC DAG.
  let queue = []
  for deg, i in indegree {
    if deg == 0 { push(queue, i) }
  }

  let order = []
  let head = 0
  for head < len(queue) {
    let c = queue[head]
    head = head + 1
    push(order, c)

    for n in keys(compEdges[c]) {
      indegree[n] = indegree[n] - 1
      if indegree[n] == 0 { push(queue, n) }
    }
  }

  let orderedComps = []
  for idx in order {
    push(orderedComps, comps[idx])
  }

  .{
    components: orderedComps,
    componentOf: compOf,
    componentOrder: order,
  }
}

.{
  solveWorklist,
  scc,
  sccTopo,
}
