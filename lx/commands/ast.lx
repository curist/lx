// AST dumper - print AST at different compilation stages with enriched metadata
//
// METADATA GUIDE:
//
// Origin Tracking (lower, anf, lower-loops passes):
//   [origin: #N] - This node was created from node #N in the previous pass
//                  Helps trace transformations through the pipeline
//
// Name Bindings (resolve pass):
//   For Identifier nodes, shows what the name resolves to:
//
//   [local slot=N decl=#X depth=D]
//     - Local variable at slot N
//     - Declared at node #X
//     - At scope depth D (0=global scope, 1=first nested scope, etc.)
//
//   [upvalue idx=N decl=#X depth=D]
//     - Captured variable (closure) at upvalue index N
//     - Originally declared at node #X
//     - Accessed from scope depth D
//
//   [builtin name=X]
//     - Built-in global function/value (e.g., println, len, type)
//
// Scope Info (resolve pass):
//   For Function/Block nodes with scopes:
//   [scope depth=D locals=N upvalues=M]
//     - Scope at depth D
//     - N local variables declared
//     - M upvalues (captured variables from outer scopes)

let parse = import "src/passes/frontend/parser.lx"
let lower = import "src/passes/frontend/lower.lx"
let anf = import "src/passes/frontend/anf.lx"
let anfInline = import "src/passes/frontend/anf-inline.lx"
let resolve = import "src/passes/frontend/resolve.lx"
let lowerLoops = import "src/passes/backend/lower-loops.lx"
let pipeline = import "src/passes/pipeline.lx"
let types = import "src/types.lx"

let NODE = types.NODE

// Valid pass names
let VALID_PASSES = ["parse", "lower", "anf", "lower-loops", "resolve", "anf-inline"]
let DEFAULT_PASS = "anf-inline"

fn pad(n) {
  let s = ""
  for let i = 0; i < n; i = i + 1 { s = s + " " }
  s
}

fn dumpScalar(value, indent) {
  let t = type(value)
  if t == "string" {
    println(pad(indent) + "\"" + value + "\"")
  } else {
    println(pad(indent) + str(value))
  }
}

// Build metadata map from pipeline results
fn buildMetadata(pipelineResult) {
  let meta = .{
    origin: .{},        // nodeId -> originNodeId
    bindings: .{},      // nodeId -> binding info
    scopes: .{},        // nodeId -> scope info
  }

  if !pipelineResult or !pipelineResult.passes { return meta }

  let passes = pipelineResult.passes

  // Collect origin tracking from the last pass that has it
  // (Each pass maps new IDs to previous pass IDs, so we want the most recent)
  let originPasses = ["anf-inline", "resolve", "lower-loops", "anf", "lower"]
  for let i = 0; i < len(originPasses); i = i + 1 {
    let passName = originPasses[i]
    let passResult = passes[passName]
    if passResult and passResult.origin {
      meta.origin = passResult.origin
      break
    }
  }

  // Collect resolve metadata
  let resolveResult = passes.resolve
  if resolveResult and resolveResult.success {
    if resolveResult.resolvedNames {
      meta.bindings = resolveResult.resolvedNames
    }
    if resolveResult.scopeInfo {
      meta.scopes = resolveResult.scopeInfo
    }
  }

  meta
}

// Format binding info for display
fn formatBinding(binding) {
  if !binding { return nil }

  if binding.kind == "local" {
    let parts = ["local slot=" + str(binding.slot)]
    if binding.declaredAt { push(parts, "decl=#" + str(binding.declaredAt)) }
    if binding.depth != nil { push(parts, "depth=" + str(binding.depth)) }
    return join(parts, " ")
  }

  if binding.kind == "upvalue" {
    let parts = ["upvalue idx=" + str(binding.upvalueIndex)]
    if binding.declaredAt { push(parts, "decl=#" + str(binding.declaredAt)) }
    if binding.depth != nil { push(parts, "depth=" + str(binding.depth)) }
    return join(parts, " ")
  }

  if binding.kind == "builtin" {
    return "builtin name=" + (binding.name or "?")
  }

  // Unknown binding kind
  nil
}

// Format scope info for display
fn formatScope(scopeInfo) {
  if !scopeInfo { return nil }

  let parts = []
  if scopeInfo.scopeType {
    push(parts, scopeInfo.scopeType)
  }
  if scopeInfo.depth != nil {
    push(parts, "depth=" + str(scopeInfo.depth))
  }
  if scopeInfo.locals {
    push(parts, "locals=" + str(len(scopeInfo.locals)))
  }
  if scopeInfo.upvalues {
    push(parts, "upvalues=" + str(len(scopeInfo.upvalues)))
  }

  len(parts) > 0 and join(parts, " ") or nil
}

fn dumpNode(node, indent, meta) {
  if node == nil {
    println(pad(indent) + "nil")
    return
  }

  let t = type(node)
  if t == "array" {
    println(pad(indent) + "[")
    for let i = 0; i < len(node); i = i + 1 {
      dumpNode(node[i], indent + 2, meta)
    }
    println(pad(indent) + "]")
    return
  }
  if t != "map" {
    dumpScalar(node, indent)
    return
  }

  if node.type == nil {
    println(pad(indent) + "<map>")
    return
  }

  let typeName = nameOf(NODE, node.type) or str(node.type)
  let header = pad(indent) + typeName
  if node.id != nil { header = header + " #" + str(node.id) }
  if node.line != nil { header = header + " (L" + str(node.line) + ")" }
  if node.anfSynthetic { header = header + " [synthetic]" }

  // Add metadata annotations
  if meta and node.id != nil {
    // Show origin tracking
    let origin = meta.origin and meta.origin[node.id]
    if origin != nil {
      header = header + " [origin: #" + str(origin) + "]"
    }

    // Show binding info for identifiers
    if node.type == NODE.Identifier {
      let binding = meta.bindings and meta.bindings[node.id]
      let bindingStr = formatBinding(binding)
      if bindingStr {
        header = header + " [" + bindingStr + "]"
      }
    }

    // Show scope info for scopes
    let scopeInfo = meta.scopes and meta.scopes[node.id]
    let scopeStr = formatScope(scopeInfo)
    if scopeStr {
      header = header + " [scope " + scopeStr + "]"
    }
  }

  println(header)

  if node.type == NODE.Identifier {
    println(pad(indent + 2) + "name: " + node.name)
    return
  }

  if node.value != nil {
    println(pad(indent + 2) + "value:")
    dumpNode(node.value, indent + 4, meta)
  }

  if node.name {
    println(pad(indent + 2) + "name:")
    dumpNode(node.name, indent + 4, meta)
  }
  if node.params {
    println(pad(indent + 2) + "params:")
    dumpNode(node.params, indent + 4, meta)
  }
  if node.body {
    println(pad(indent + 2) + "body:")
    dumpNode(node.body, indent + 4, meta)
  }
  if node.expressions {
    println(pad(indent + 2) + "expressions:")
    dumpNode(node.expressions, indent + 4, meta)
  }
  if node.left {
    println(pad(indent + 2) + "left:")
    dumpNode(node.left, indent + 4, meta)
  }
  if node.right {
    println(pad(indent + 2) + "right:")
    dumpNode(node.right, indent + 4, meta)
  }
  if node.operand {
    println(pad(indent + 2) + "operand:")
    dumpNode(node.operand, indent + 4, meta)
  }
  if node.expression {
    println(pad(indent + 2) + "expression:")
    dumpNode(node.expression, indent + 4, meta)
  }
  if node.condition {
    println(pad(indent + 2) + "condition:")
    dumpNode(node.condition, indent + 4, meta)
  }
  if node.then {
    println(pad(indent + 2) + "then:")
    dumpNode(node.then, indent + 4, meta)
  }
  if node.else {
    println(pad(indent + 2) + "else:")
    dumpNode(node.else, indent + 4, meta)
  }
  if node.init {
    println(pad(indent + 2) + "init:")
    dumpNode(node.init, indent + 4, meta)
  }
  if node.update {
    println(pad(indent + 2) + "update:")
    dumpNode(node.update, indent + 4, meta)
  }
  if node.callee {
    println(pad(indent + 2) + "callee:")
    dumpNode(node.callee, indent + 4, meta)
  }
  if node.args {
    println(pad(indent + 2) + "args:")
    dumpNode(node.args, indent + 4, meta)
  }
  if node.object {
    println(pad(indent + 2) + "object:")
    dumpNode(node.object, indent + 4, meta)
  }
  if node.index {
    println(pad(indent + 2) + "index:")
    dumpNode(node.index, indent + 4, meta)
  }
  if node.property {
    println(pad(indent + 2) + "property:")
    dumpNode(node.property, indent + 4, meta)
  }
  if node.target {
    println(pad(indent + 2) + "target:")
    dumpNode(node.target, indent + 4, meta)
  }
  if node.elements {
    println(pad(indent + 2) + "elements:")
    dumpNode(node.elements, indent + 4, meta)
  }
  if node.pairs {
    println(pad(indent + 2) + "pairs:")
    dumpNode(node.pairs, indent + 4, meta)
  }
  if node.path {
    println(pad(indent + 2) + "path:")
    dumpNode(node.path, indent + 4, meta)
  }
}

fn printErrors(errors) {
  if !errors or len(errors) == 0 { return }
  for let i = 0; i < len(errors); i = i + 1 {
    let err = errors[i]
    if err.pos {
      let file = err.pos.filename or err.filename
      let prefix = file and join([file, ":", err.pos.line, ":", err.pos.col or 0], "") or
        join([err.pos.line, ":", err.pos.col or 0], "")
      groanln(join(["[", prefix, "] ", err.message], ""))
    } else if err.line {
      groanln(join(["[L", err.line, "] ", err.message], ""))
    } else {
      groanln(err.message)
    }
  }
}

// Count nodes in AST (recursively)
fn countNodes(node) {
  if !node { return 0 }

  let t = type(node)
  if t == "array" {
    let total = 0
    for let i = 0; i < len(node); i = i + 1 {
      total = total + countNodes(node[i])
    }
    return total
  }

  if t != "map" or !node.type { return 0 }

  // Count this node + all children
  let count = 1

  // Recursively count children
  if node.value { count = count + countNodes(node.value) }
  if node.name { count = count + countNodes(node.name) }
  if node.params { count = count + countNodes(node.params) }
  if node.body { count = count + countNodes(node.body) }
  if node.expressions { count = count + countNodes(node.expressions) }
  if node.left { count = count + countNodes(node.left) }
  if node.right { count = count + countNodes(node.right) }
  if node.operand { count = count + countNodes(node.operand) }
  if node.expression { count = count + countNodes(node.expression) }
  if node.condition { count = count + countNodes(node.condition) }
  if node.then { count = count + countNodes(node.then) }
  if node.else { count = count + countNodes(node.else) }
  if node.init { count = count + countNodes(node.init) }
  if node.update { count = count + countNodes(node.update) }
  if node.callee { count = count + countNodes(node.callee) }
  if node.args { count = count + countNodes(node.args) }
  if node.object { count = count + countNodes(node.object) }
  if node.index { count = count + countNodes(node.index) }
  if node.property { count = count + countNodes(node.property) }
  if node.target { count = count + countNodes(node.target) }
  if node.elements { count = count + countNodes(node.elements) }
  if node.pairs { count = count + countNodes(node.pairs) }
  if node.path { count = count + countNodes(node.path) }

  count
}

// Count synthetic nodes (nodes with anfSynthetic flag)
fn countSyntheticNodes(node) {
  if !node { return 0 }

  let t = type(node)
  if t == "array" {
    let total = 0
    for let i = 0; i < len(node); i = i + 1 {
      total = total + countSyntheticNodes(node[i])
    }
    return total
  }

  if t != "map" or !node.type { return 0 }

  let count = node.anfSynthetic and 1 or 0

  // Recursively count in children
  if node.value { count = count + countSyntheticNodes(node.value) }
  if node.name { count = count + countSyntheticNodes(node.name) }
  if node.params { count = count + countSyntheticNodes(node.params) }
  if node.body { count = count + countSyntheticNodes(node.body) }
  if node.expressions { count = count + countSyntheticNodes(node.expressions) }
  if node.left { count = count + countSyntheticNodes(node.left) }
  if node.right { count = count + countSyntheticNodes(node.right) }
  if node.operand { count = count + countSyntheticNodes(node.operand) }
  if node.expression { count = count + countSyntheticNodes(node.expression) }
  if node.condition { count = count + countSyntheticNodes(node.condition) }
  if node.then { count = count + countSyntheticNodes(node.then) }
  if node.else { count = count + countSyntheticNodes(node.else) }
  if node.init { count = count + countSyntheticNodes(node.init) }
  if node.update { count = count + countSyntheticNodes(node.update) }
  if node.callee { count = count + countSyntheticNodes(node.callee) }
  if node.args { count = count + countSyntheticNodes(node.args) }
  if node.object { count = count + countSyntheticNodes(node.object) }
  if node.index { count = count + countSyntheticNodes(node.index) }
  if node.property { count = count + countSyntheticNodes(node.property) }
  if node.target { count = count + countSyntheticNodes(node.target) }
  if node.elements { count = count + countSyntheticNodes(node.elements) }
  if node.pairs { count = count + countSyntheticNodes(node.pairs) }
  if node.path { count = count + countSyntheticNodes(node.path) }

  count
}

// Build summary statistics for each pass
fn buildSummaryStats(pipelineResult) {
  if !pipelineResult or !pipelineResult.passOrder { return [] }

  let stats = []
  let previousNodeCount = 0

  for let i = 0; i < len(pipelineResult.passOrder); i = i + 1 {
    let passName = pipelineResult.passOrder[i]
    let passResult = pipelineResult.passes[passName]

    if !passResult { continue }

    let ast = passResult.ast or pipelineResult.ast
    let nodeCount = ast and countNodes(ast) or 0
    let delta = nodeCount - previousNodeCount

    let passStats = .{
      name: passName,
      nodeCount: nodeCount,
      delta: delta,
      success: passResult.success,
    }

    // Pass-specific metrics
    if passName == "anf" and ast {
      passStats.syntheticNodes = countSyntheticNodes(ast)
    }

    if passName == "resolve" and passResult.resolvedNames {
      let locals = 0
      let upvalues = 0
      let builtins = 0
      let bindings = passResult.resolvedNames
      let ids = keys(bindings)
      for let j = 0; j < len(ids); j = j + 1 {
        let binding = bindings[ids[j]]
        if binding.kind == "local" { locals = locals + 1 }
        if binding.kind == "upvalue" { upvalues = upvalues + 1 }
        if binding.kind == "builtin" { builtins = builtins + 1 }
      }
      passStats.locals = locals
      passStats.upvalues = upvalues
      passStats.builtins = builtins
    }

    if passName == "resolve" and passResult.scopeInfo {
      let maxDepth = 0
      let scopes = passResult.scopeInfo
      let scopeIds = keys(scopes)
      for let j = 0; j < len(scopeIds); j = j + 1 {
        let scope = scopes[scopeIds[j]]
        if scope.depth and scope.depth > maxDepth {
          maxDepth = scope.depth
        }
      }
      passStats.maxScopeDepth = maxDepth
    }

    push(stats, passStats)
    previousNodeCount = nodeCount
  }

  stats
}

// Print summary statistics
fn printSummary(stats) {
  println("Compilation Pipeline Summary")
  println("=============================")
  println("")

  for let i = 0; i < len(stats); i = i + 1 {
    let s = stats[i]

    // Pass name and node count
    let line = s.name + ":"
    println(line)

    // Node count with delta
    let nodeInfo = "  Nodes: " + str(s.nodeCount)
    if s.delta > 0 {
      nodeInfo = nodeInfo + " (+" + str(s.delta) + ")"
    } else if s.delta < 0 {
      nodeInfo = nodeInfo + " (" + str(s.delta) + ")"
    }
    println(nodeInfo)

    // Pass-specific metrics
    if s.syntheticNodes != nil {
      println("  Synthetic temporaries: " + str(s.syntheticNodes))
    }

    if s.locals != nil {
      println("  Bindings: " + str(s.locals) + " locals, " + str(s.upvalues) + " upvalues, " + str(s.builtins) + " builtins")
    }

    if s.maxScopeDepth != nil {
      println("  Max scope depth: " + str(s.maxScopeDepth))
    }

    println("")
  }
}

// Find node by ID in AST
fn findNodeById(node, targetId) {
  if !node { return nil }

  let t = type(node)
  if t == "array" {
    for let i = 0; i < len(node); i = i + 1 {
      let found = findNodeById(node[i], targetId)
      if found { return found }
    }
    return nil
  }

  if t != "map" or !node.type { return nil }

  // Check if this is the node we're looking for
  if node.id == targetId { return node }

  // Search children
  if node.value {
    let found = findNodeById(node.value, targetId)
    if found { return found }
  }
  if node.name {
    let found = findNodeById(node.name, targetId)
    if found { return found }
  }
  if node.params {
    let found = findNodeById(node.params, targetId)
    if found { return found }
  }
  if node.body {
    let found = findNodeById(node.body, targetId)
    if found { return found }
  }
  if node.expressions {
    let found = findNodeById(node.expressions, targetId)
    if found { return found }
  }
  if node.left {
    let found = findNodeById(node.left, targetId)
    if found { return found }
  }
  if node.right {
    let found = findNodeById(node.right, targetId)
    if found { return found }
  }
  if node.operand {
    let found = findNodeById(node.operand, targetId)
    if found { return found }
  }
  if node.expression {
    let found = findNodeById(node.expression, targetId)
    if found { return found }
  }
  if node.condition {
    let found = findNodeById(node.condition, targetId)
    if found { return found }
  }
  if node.then {
    let found = findNodeById(node.then, targetId)
    if found { return found }
  }
  if node.else {
    let found = findNodeById(node.else, targetId)
    if found { return found }
  }
  if node.init {
    let found = findNodeById(node.init, targetId)
    if found { return found }
  }
  if node.update {
    let found = findNodeById(node.update, targetId)
    if found { return found }
  }
  if node.callee {
    let found = findNodeById(node.callee, targetId)
    if found { return found }
  }
  if node.args {
    let found = findNodeById(node.args, targetId)
    if found { return found }
  }
  if node.object {
    let found = findNodeById(node.object, targetId)
    if found { return found }
  }
  if node.index {
    let found = findNodeById(node.index, targetId)
    if found { return found }
  }
  if node.property {
    let found = findNodeById(node.property, targetId)
    if found { return found }
  }
  if node.target {
    let found = findNodeById(node.target, targetId)
    if found { return found }
  }
  if node.elements {
    let found = findNodeById(node.elements, targetId)
    if found { return found }
  }
  if node.pairs {
    let found = findNodeById(node.pairs, targetId)
    if found { return found }
  }
  if node.path {
    let found = findNodeById(node.path, targetId)
    if found { return found }
  }

  nil
}

// Build reverse origin map (newId -> oldId becomes oldId -> [newIds])
fn buildReverseOriginMap(origin) {
  if !origin { return .{} }

  let reverse = .{}
  let newIds = keys(origin)
  for let i = 0; i < len(newIds); i = i + 1 {
    let newId = newIds[i]
    let oldId = origin[newId]
    if !reverse[oldId] {
      reverse[oldId] = []
    }
    push(reverse[oldId], newId)
  }
  reverse
}

// Track node through compilation passes
fn trackNodeThroughPasses(nodeId, pipelineResult) {
  if !pipelineResult or !pipelineResult.passOrder { return [] }

  let history = []
  let currentIds = [nodeId]  // Track multiple descendants

  for let i = 0; i < len(pipelineResult.passOrder); i = i + 1 {
    let passName = pipelineResult.passOrder[i]
    let passResult = pipelineResult.passes[passName]

    if !passResult { continue }

    let ast = passResult.ast or pipelineResult.ast

    // Find all current nodes in this pass's AST
    let foundNodes = []
    for let j = 0; j < len(currentIds); j = j + 1 {
      let id = currentIds[j]
      let node = findNodeById(ast, id)
      if node {
        push(foundNodes, node)
      }
    }

    if len(foundNodes) > 0 {
      push(history, .{
        pass: passName,
        nodes: foundNodes,
        ids: currentIds,
      })
    } else {
      push(history, .{
        pass: passName,
        nodes: [],
        ids: currentIds,
        notFound: true,
      })
    }

    // Track forward using origin map from next pass
    if i + 1 < len(pipelineResult.passOrder) {
      let nextPassName = pipelineResult.passOrder[i + 1]
      let nextPassResult = pipelineResult.passes[nextPassName]

      if nextPassResult and nextPassResult.origin {
        // Build reverse map to find descendants
        let reverseOrigin = buildReverseOriginMap(nextPassResult.origin)

        let nextIds = []
        for let j = 0; j < len(currentIds); j = j + 1 {
          let id = currentIds[j]
          let descendants = reverseOrigin[id]
          if descendants {
            for let k = 0; k < len(descendants); k = k + 1 {
              push(nextIds, descendants[k])
            }
          }
        }

        if len(nextIds) > 0 {
          currentIds = nextIds
        }
      }
    }
  }

  history
}

// Format node for tracking display (concise)
fn formatNodeForTracking(node) {
  if !node { return "<not found>" }

  let typeName = nameOf(NODE, node.type) or str(node.type)
  let info = typeName

  // Add key identifying information
  if node.type == NODE.Identifier and node.name {
    info = info + " '" + node.name + "'"
  } else if node.type == NODE.Number and node.value != nil {
    info = info + " " + str(node.value)
  } else if node.type == NODE.String and node.value {
    info = info + " \"" + node.value + "\""
  } else if node.type == NODE.Binary {
    info = info + " (operator)"
  }

  if node.anfSynthetic {
    info = info + " [synthetic]"
  }

  info
}

// Print node tracking history
fn printNodeTracking(nodeId, history) {
  println("Tracking node #" + str(nodeId) + " through compilation pipeline")
  println("=======================================================")
  println("")

  for let i = 0; i < len(history); i = i + 1 {
    let entry = history[i]
    println("[" + entry.pass + "]")

    if entry.notFound {
      println("  Node not found (may have been removed or transformed)")
      if len(entry.ids) > 0 {
        println("  Looked for: #" + join(collect id in entry.ids { str(id) }, ", #"))
      }
    } else if len(entry.nodes) == 0 {
      println("  No matching nodes")
    } else if len(entry.nodes) == 1 {
      let node = entry.nodes[0]
      println("  " + formatNodeForTracking(node) + " #" + str(node.id))
      if node.line {
        println("  Line: " + str(node.line))
      }
    } else {
      println("  Split into " + str(len(entry.nodes)) + " nodes:")
      for let j = 0; j < len(entry.nodes); j = j + 1 {
        let node = entry.nodes[j]
        println("    - " + formatNodeForTracking(node) + " #" + str(node.id))
      }
    }

    println("")
  }
}

fn parseArgs(argv) {
  // Parse command line arguments
  // Returns .{ path: "...", pass: "...", showHelp: bool, summary: bool, trackNode: num } or .{ error: "..." }

  let path = nil
  let pass = DEFAULT_PASS
  let showHelp = false
  let summary = false
  let trackNode = nil

  let i = 2  // Start after command name
  for true {
    if i >= len(argv) { break }

    let arg = argv[i]
    if arg == "--pass" {
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--pass requires a pass name" }
      }
      pass = argv[i]
      i = i + 1
    } else if arg == "--help-metadata" {
      showHelp = true
      i = i + 1
    } else if arg == "--summary" {
      summary = true
      i = i + 1
    } else if arg == "--track-node" {
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--track-node requires a node ID" }
      }
      trackNode = tonumber(argv[i])
      if !trackNode or trackNode <= 0 {
        return .{ error: "--track-node requires a positive integer node ID" }
      }
      i = i + 1
    } else {
      if path {
        return .{ error: "Multiple file paths specified" }
      }
      path = arg
      i = i + 1
    }
  }

  if showHelp {
    return .{ showHelp: true }
  }

  if !path {
    return .{ error: "No file path specified" }
  }

  .{ path: path, pass: pass, showHelp: false, summary: summary, trackNode: trackNode }
}

fn printMetadataHelp() {
  println("AST Metadata Guide")
  println("==================")
  println("")
  println("The ast command enriches AST nodes with metadata from compilation passes.")
  println("")
  println("ORIGIN TRACKING (lower, anf, lower-loops passes)")
  println("  [origin: #N]")
  println("    This node was created from node #N in the previous pass.")
  println("    Helps trace how nodes transform through the compilation pipeline.")
  println("")
  println("    Example: After ANF transform, you might see:")
  println("      Identifier #33 [origin: #3]")
  println("    This means identifier #33 in the ANF AST came from node #3 in the lowered AST.")
  println("")
  println("NAME BINDINGS (resolve pass)")
  println("  Shows what each identifier resolves to:")
  println("")
  println("  [local slot=N decl=#X depth=D]")
  println("    - Local variable stored at stack slot N")
  println("    - Declared at node #X")
  println("    - At scope depth D (0=global scope, 1=first nested scope, etc.)")
  println("")
  println("  [upvalue idx=N decl=#X depth=D]")
  println("    - Captured variable (closure) at upvalue index N")
  println("    - Originally declared at node #X")
  println("    - Accessed from scope depth D")
  println("")
  println("  [builtin name=X]")
  println("    - Built-in global function or value")
  println("    - Examples: println, len, type, str")
  println("")
  println("SCOPE INFORMATION (resolve pass)")
  println("  For Function and Block nodes:")
  println("")
  println("  [scope function depth=D locals=N upvalues=M]")
  println("    - Function scope at depth D")
  println("    - N local variables declared in this scope")
  println("    - M upvalues (variables captured from outer scopes)")
  println("")
  println("  [scope block depth=D locals=N]")
  println("    - Block scope at depth D")
  println("    - N local variables")
  println("")
  println("EXAMPLES")
  println("")
  println("  Input code:")
  println("    let x = 1")
  println("    fn foo() { x }")
  println("")
  println("  With --pass resolve, the identifier 'x' inside foo might show:")
  println("    Identifier #15 [upvalue idx=0 decl=#5 depth=1]")
  println("")
  println("  This means:")
  println("    - It's a captured variable (upvalue)")
  println("    - At upvalue index 0 in the closure")
  println("    - Originally declared at node #5 (the 'let x' statement)")
  println("    - Accessed from scope depth 1 (inside the function)")
  println("")
  println("PASS-SPECIFIC METADATA AVAILABILITY")
  println("  parse:        No metadata (baseline AST)")
  println("  lower:        Origin tracking")
  println("  anf:          Origin tracking")
  println("  lower-loops:  Origin tracking (currently disabled)")
  println("  resolve:      Name bindings, scope info, plus origin from previous passes")
  println("  anf-inline:   All metadata from resolve, plus any new origins")
}

fn buildPassList() {
  // Build pass list similar to driver, but simplified for single-file compilation
  [
    .{
      name: "parse",
      mutatesAst: false,
      provides: ["ast", "parseTree"],
      run: fn(ctx, state) {
        parse(state.source, state.path)
      },
    },
    .{
      name: "lower",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["loweredAst"],
      run: fn(ctx, state) {
        lower(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },
    .{
      name: "anf",
      mutatesAst: false,
      requires: ["loweredAst"],
      provides: ["anfAst", "loweredAst"],
      run: fn(ctx, state) {
        anf(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },
    .{
      name: "lower-loops",
      mutatesAst: false,
      requires: ["anfAst"],
      provides: ["loweredLoopsAst"],
      enabled: fn(ctx, state) { false },  // Currently disabled
      run: fn(ctx, state) {
        lowerLoops(state.ast, .{ nextNodeId: state.nextNodeId })
      },
    },
    .{
      name: "resolve",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["resolution", "scopeInfo"],
      run: fn(ctx, state) {
        // Minimal resolve - no import handling for this debug command
        resolve(state.ast, .{
          importCache: .{},
          compileModule: fn(path) {
            .{
              status: "failed",
              success: false,
              errors: ["Import not supported in ast command"]
            }
          },
        })
      },
    },
    .{
      name: "anf-inline",
      mutatesAst: true,
      requires: ["anfAst", "resolution"],
      provides: ["optimizedAst"],
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        anfInline(state.ast, resolveResult)
      },
    },
  ]
}

fn run(ctx) {
  let args = parseArgs(ctx.argv)

  if args.showHelp {
    printMetadataHelp()
    return
  }

  if args.error {
    groanln("Error: " + args.error)
    groanln("Usage: " + ctx.prog + " ast [--pass <pass-name>] <path>")
    groanln("       " + ctx.prog + " ast --summary <path>")
    groanln("       " + ctx.prog + " ast --track-node <id> <path>")
    groanln("       " + ctx.prog + " ast --help-metadata")
    groanln("")
    groanln("Available passes: " + join(VALID_PASSES, ", "))
    groanln("Default pass: " + DEFAULT_PASS)
    Lx.exit(28)
  }

  let path = args.path
  let passName = args.pass

  // Validate pass name
  let validPass = false
  for let i = 0; i < len(VALID_PASSES); i = i + 1 {
    if VALID_PASSES[i] == passName {
      validPass = true
      break
    }
  }

  if !validPass {
    groanln("Error: Invalid pass name '" + passName + "'")
    groanln("Available passes: " + join(VALID_PASSES, ", "))
    Lx.exit(28)
  }

  // Load source
  let source = slurp(path)
  if !source {
    groanln("Failed to open " + path)
    Lx.exit(2)
  }

  // Build context and state
  let pipelineCtx = .{
    debug: .{ stopAfter: passName }
  }

  let state = .{
    path: path,
    source: source,
    ast: nil,
    nextNodeId: 1,
    passes: .{},
  }

  // Run passes
  let passList = buildPassList()
  let result = pipeline.runPasses(passList, pipelineCtx, state)

  // Check for errors
  if !result.success {
    printErrors(result.passes[result.failedPass].errors)
    Lx.exit(65)
  }

  // Summary mode, tracking mode, or AST dump mode
  if args.summary {
    let stats = buildSummaryStats(result)
    printSummary(stats)
  } else if args.trackNode {
    let history = trackNodeThroughPasses(args.trackNode, result)
    printNodeTracking(args.trackNode, history)
  } else {
    // Build metadata from pipeline results
    let meta = buildMetadata(result)
    // Dump the AST with metadata
    dumpNode(result.ast, 0, meta)
  }
}

.{
  name: "ast",
  usage: "ast [--pass <pass-name>] <path>\n       ast --summary <path>\n       ast --track-node <id> <path>\n       ast --help-metadata",
  summary: "Dump AST with metadata at different compilation stages (debug)",
  run: run,
}
