// Query Service Tests - MINIMAL SET FOR SKELETON
//
// This file contains only basic query tests that work with the typecheck skeleton.
// Tests removed (depend on type inference features):
// - Hover showing inferred types beyond literals
// - Type-specific assertions (expecting Number, String, etc. from inference)
// - Import type resolution
// - Record field type inference
// - Function type inference
//
// Tests kept:
// - Basic goto/navigation (doesn't depend on typecheck)
// - Hover on literals (skeleton handles these)
// - Infrastructure tests
//
// When rebuilding the type checker, add back tests incrementally as features are implemented.

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let Driver = import "src/driver.lx"
let query = import "services/query.lx"
let types = import "src/types.lx"
let ModuleResolution = import "src/module_resolution.lx"

let NODE = types.NODE

// Helper: compile source through full pipeline and create query context
fn compileAndQuery(source, filename) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == filename { return source }
      let resolver = ModuleResolution.forEntry(Lx.args[2])
      return resolver.slurp(path)
    },
    withTypecheck: true,
    withAnf: false,
  })

  let result = driver.compileModule(filename)

  if result.status != "done" {
    let phase = "unknown"
    let errors = []
    let passes = result.passes or .{}

    if passes.parse and passes.parse.errors {
      phase = "parse"
      errors = passes.parse.errors
    } else if passes.lower and passes.lower.errors {
      phase = "lower"
      errors = passes.lower.errors
    } else if passes.resolve and !passes.resolve.success {
      phase = "resolve"
      errors = passes.resolve.errors
    }

    return .{ success: false, phase, errors, passes: result.passes }
  }

  let initResult = query.queryInit(
    result.passes.lower.ast,
    result.passes.resolve,
    result.passes.typecheck,
  )

  .{
    success: true,
    ctx: initResult.ctx,
    parseResult: result.passes.parse,
    lowerResult: result.passes.lower,
    resolveResult: result.passes.resolve,
    typecheckResult: result.passes.typecheck,
  }
}

// ========================================
// Basic Hover Tests
// ========================================

test("query - hover on number literal", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
})

test("query - hover on empty position returns no node", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success)

  // Hover on line 10 (beyond source)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 10, 0)

  assert.truthy(!hoverResult.success, "Query should succeed even if no node found")
  assert.equal(hoverResult.kind, "hover")
})

// ========================================
// Goto Definition Tests
// ========================================

test("query - goto local variable", fn(assert) {
  let result = compileAndQuery("let x = 1\nx + 1", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'x' usage (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.line, 1, "Should goto line 1 (let)")
  assert.equal(gotoResult.target.col, 4, "Should goto col 4 (variable name)")
})

test("query - goto function parameter", fn(assert) {
  let result = compileAndQuery("fn add(a, b) { a + b }", "test.lx")
  assert.truthy(result.success)

  // Goto on 'a' in body (line 1, col 15)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 15)

  assert.truthy(gotoResult.success)
  assert.truthy(gotoResult.target)
  assert.equal(gotoResult.target.line, 1, "Should goto parameter line")
  assert.equal(gotoResult.target.col, 7, "Should goto parameter col")
})

test("query - goto named function normalized to name", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success)

  // Goto on 'foo' in call (line 2, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success)
  assert.truthy(gotoResult.target)
  assert.equal(gotoResult.target.line, 1, "Should goto function declaration")
  assert.equal(gotoResult.target.col, 3, "Should goto function name")
})

test("query - goto builtin has no definition", fn(assert) {
  let result = compileAndQuery("println(42)", "test.lx")
  assert.truthy(result.success)

  // Goto on 'println'
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)
  assert.truthy(!gotoResult.success)
})

test("query - goto on non-identifier fails gracefully", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success)

  // Goto on number literal
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.truthy(!gotoResult.success, "Should succeed even if no goto target")
})

// TODO: Add back these test categories when rebuilding type checker:
// - Hover showing inferred variable types
// - Hover on record fields
// - Import type resolution
// - Multi-module queries
// - Function type inference
// - Collection type inference

suite.run()
