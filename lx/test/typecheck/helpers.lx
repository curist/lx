// Shared helpers for typecheck tests

let parse = import "src/passes/frontend/parser.lx"
let lower = import "src/passes/frontend/lower.lx"
let resolve = import "src/passes/frontend/resolve.lx"
let typecheck = import "src/passes/frontend/typecheck.lx"
let types = import "src/types.lx"

let NODE = types.NODE

// Dereference through type variable bindings
fn deref(result, t) {
  if t and t.kind == "TypeVar" {
    let bindings = result.typeVarBindings or .{}
    let bound = bindings[t.id]
    if bound { return deref(result, bound) }
  }
  t
}

fn hasError(result, needle) {
  for let i = 0; i < len(result.errors); i = i + 1 {
    if result.errors[i].message == needle { return true }
  }
  false
}

// parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  // Remap parse enumInfo (parse node ids) to lowered node ids via `origin`.
  let remappedEnumInfo = .{}
  if parseResult.enumInfo and lowerResult.origin {
    let newIds = keys(lowerResult.origin)
    for let i = 0; i < len(newIds); i = i + 1 {
      let newId = newIds[i]
      let oldId = lowerResult.origin[newId]
      let info = parseResult.enumInfo[oldId]
      if info {
        remappedEnumInfo[newId] = info
      }
    }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{ enumInfo: remappedEnumInfo })
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    typeVarBindings: typecheckResult.typeVarBindings,
    errors: typecheckResult.errors,
    recordEnumKeyOrigins: typecheckResult.recordEnumKeyOrigins,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

fn normalizeExprList(ast) {
  if !ast { return nil }

  // Block → expressions
  if ast.type == NODE.Block and ast.expressions {
    // Root implicit block often wraps a single `{...}` block in tests.
    if len(ast.expressions) == 1 and ast.expressions[0].type == NODE.Block and ast.expressions[0].expressions {
      return ast.expressions[0].expressions
    }
    return ast.expressions
  }

  if ast.type != nil {
    return [ast]
  }

  nil
}

fn getExprType(result, exprIndex) {
  if !result or !result.lowerResult or !result.lowerResult.ast { return nil }

  let ast = result.lowerResult.ast
  let exprs = normalizeExprList(ast)
  if !exprs or exprIndex >= len(exprs) { return nil }

  let node = exprs[exprIndex]
  if node.type == NODE.ExprStmt and node.expr { node = node.expr }
  if node.type == NODE.Let and node.name {
    return result.types[node.name.id]
  }

  result.types[node.id]
}

fn getExprNode(result, exprIndex) {
  if !result or !result.lowerResult or !result.lowerResult.ast { return nil }

  let ast = result.lowerResult.ast
  let exprs = normalizeExprList(ast)
  if !exprs or exprIndex >= len(exprs) { return nil }

  let node = exprs[exprIndex]
  if node.type == NODE.ExprStmt and node.expr { return node.expr }
  node
}

fn findFirstImport(ast) {
  if !ast or ast.type != NODE.Block or !ast.expressions { return nil }

  for let i = 0; i < len(ast.expressions); i = i + 1 {
    let expr = ast.expressions[i]
    if expr.type == NODE.Import {
      return expr
    }
    if expr.type == NODE.Let and expr.init and expr.init.type == NODE.Import {
      return expr.init
    }
  }
  nil
}

.{ 
  parseAndTypecheck: parseAndTypecheck,
  normalizeExprList: normalizeExprList,
  getExprType: getExprType,
  getExprNode: getExprNode,
  deref: deref,
  hasError: hasError,
  findFirstImport: findFirstImport,
}
