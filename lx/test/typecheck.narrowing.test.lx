// Typecheck Phase Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"

// Helper: parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{})
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    errors: typecheckResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

// Helper: Get type of expression in test block
fn getExprType(result, exprIndex) {
  // For tests like "{ expr1\nexpr2 }", ast.body[0] is the Block
  // and the expressions are in Block.expressions
  let ast = result.lowerResult.ast
  if !ast or !ast.body or len(ast.body) == 0 {
    return nil
  }

  let blockNode = ast.body[0]
  if !blockNode or blockNode.type != "Block" or !blockNode.expressions {
    return nil
  }

  if exprIndex >= len(blockNode.expressions) {
    return nil
  }

  let node = blockNode.expressions[exprIndex]

  // For Let nodes, get the type of the bound variable (from name.id)
  if node.type == "Let" {
    return result.types[node.name.id]
  }

  // Direct expression - return its type
  return result.types[node.id]
}

// Helper: Get the actual AST node at an index
fn getExprNode(result, exprIndex) {
  let ast = result.lowerResult.ast
  if len(ast.body) > 0 {
    let blockNode = ast.body[0]
    if blockNode.type == "Block" and exprIndex < len(blockNode.expressions) {
      return blockNode.expressions[exprIndex]
    }
  }
  nil
}

// ========================================
// Type Narrowing
// ========================================

test("typecheck - narrowing: x != nil preserves type", fn(assert) {
  let code = "{
    let x = 42
    if x != nil {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck with nil guard")

  // In then branch, x should still be Number (non-nil is implicit)
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Number", "x should still be Number in then branch")
})

test("typecheck - narrowing: x == nil refines to Nil", fn(assert) {
  let code = "{
    let x = 42
    if x == nil {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  // In then branch, x should be refined to Nil
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Nil", "x should be Nil in then branch")
})

test("typecheck - narrowing: nil != x works (reversed)", fn(assert) {
  let code = "{
    let x = 42
    if nil != x {
      let y = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck reversed nil check")
})

test("typecheck - narrowing: type test refines to expected type", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"string\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  // In then branch, x should be refined to String
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "String", "x should be String in then branch")
})

test("typecheck - narrowing: type test supports all primitives", fn(assert) {
  let code = "{
    let x = nil
    if type(x) == \"number\" { x }
    if type(x) == \"string\" { x }
    if type(x) == \"bool\" { x }
    if type(x) == \"nil\" { x }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck all type tests")

  // Verify each if branch has the correct refined type
  let ast = result.lowerResult.ast
  let blockExprs = ast.body[0].expressions

  // First if: type(x) == "number"
  let if1 = blockExprs[1]
  let then1Type = result.types[if1.then.expressions[0].id]
  assert.equal(then1Type.kind, "Number", "Should refine to Number")

  // Second if: type(x) == "string"
  let if2 = blockExprs[2]
  let then2Type = result.types[if2.then.expressions[0].id]
  assert.equal(then2Type.kind, "String", "Should refine to String")

  // Third if: type(x) == "bool"
  let if3 = blockExprs[3]
  let then3Type = result.types[if3.then.expressions[0].id]
  assert.equal(then3Type.kind, "Bool", "Should refine to Bool")

  // Fourth if: type(x) == "nil"
  let if4 = blockExprs[4]
  let then4Type = result.types[if4.then.expressions[0].id]
  assert.equal(then4Type.kind, "Nil", "Should refine to Nil")
})

test("typecheck - narrowing: type test supports array", fn(assert) {
  let code = "{
    let x = [1, 2, 3]
    if type(x) == \"array\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck array type test")

  // In then branch, x should be refined to Array
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Array", "x should be Array in then branch")
})

test("typecheck - narrowing: type test supports map", fn(assert) {
  let code = "{
    let x = .{ a: 1 }
    if type(x) == \"map\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck map type test")

  // In then branch, x should be refined to Record
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Record", "x should be Record in then branch")
})

test("typecheck - narrowing: type test supports function", fn(assert) {
  let code = "{
    let x = fn() { 42 }
    if type(x) == \"function\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck function type test")

  // In then branch, x should be refined to Function
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Function", "x should be Function in then branch")
})

test("typecheck - narrowing: tag check infrastructure", fn(assert) {
  let code = "{
    let x = .{ kind: \"Foo\", value: 42 }
    if x.kind == \"Foo\" {
      let y = x.value
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck tag check")
})

test("typecheck - narrowing: else branch works", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"string\" {
      let a = x
    } else {
      let b = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck both branches")
})

test("typecheck - narrowing: nested ifs work", fn(assert) {
  let code = "{
    let x = nil
    if x != nil {
      if type(x) == \"string\" {
        let y = x
      }
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck nested ifs")
})

test("typecheck - narrowing: polymorphic bindings not refined", fn(assert) {
  let code = "{
    let f = fn(x) { x }
    if type(f) == \"string\" {
      let y = f
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle polymorphic bindings")
})

test("typecheck - narrowing: unknown type string ignored", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"unknown_type\" {
      let y = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should ignore unknown type strings")
})

test("typecheck - narrowing: non-identifier expressions ignored", fn(assert) {
  let code = "{
    if type(42) == \"number\" {
      let y = 1
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should ignore non-identifier type tests")
})

suite.run()
