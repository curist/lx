// Driver to compile globals.lx with NEW PR3 codegen
let driver = import "src/driver.lx"
let codegen = import "src/passes/backend/codegen.lx"
let verify = import "src/passes/backend/verify-bytecode.lx"
let ModuleResolution = import "src/module_resolution.lx"

println("=== Building lxglobals.h with NEW codegen (PR3) ===")
println("")

// Create driver with NEW codegen (PR3)
let d = driver.make(.{
  profile: "default",
  withTypecheck: false,
  loadSource: fn(path) { ModuleResolution.slurpPath(path) },
})

// Codegen with recursive module compilation
println("=== Compiling globals.lx and all dependencies ===")

let moduleCache = .{}

fn codegenModule(modulePath) {
  let cached = moduleCache[modulePath]
  if cached { return cached }

  let modResult = d.compileModule(modulePath)
  if !modResult or modResult.status != "done" {
    println("Failed to compile module: " + modulePath)
    return nil
  }

  let passes = modResult.passes or .{}
  let ast = (passes["anf-inline"] and passes["anf-inline"].ast) or
            (passes.anf and passes.anf.ast) or
            (passes.lower and passes.lower.ast)
  let enumInfo =
    (passes.anf and passes.anf.enumInfo) or
    (passes.lower and passes.lower.enumInfo) or
    (passes.parse and passes.parse.enumInfo) or
    .{}
  let cg = codegen(ast, modResult.passes.resolve, .{
    codegenModule: codegenModule,
    enumInfo: enumInfo,
  })

  if !cg.success or len(cg.errors) > 0 {
    println("Codegen errors in " + modulePath + ":")
    for let i = 0; i < len(cg.errors); i = i + 1 {
      println("  " + cg.errors[i].message)
    }
    return nil
  }

  // Verify
  let verifyResult = verify.verifyFunction(cg.function)
  if !verifyResult.success {
    println("Verification failed for " + modulePath)
    return nil
  }

  moduleCache[modulePath] = cg.function
  cg.function
}

let mainFunction = codegenModule("globals.lx")
if !mainFunction {
  println("Codegen failed")
  Lx.exit(1)
}

println("Codegen successful")
println("")
println("=== Verification ===")
println("Bytecode verification PASSED")
println("")

// Build object
println("=== Building Object ===")
let objbuilder = import "src/objbuilder.lx"
let hexBytes = objbuilder(mainFunction, false).bytes()
println("Object size: " + str(len(hexBytes)) + " bytes")

// Convert byte numbers to string
let byteString = ""
for let i = 0; i < len(hexBytes); i = i + 1 {
  byteString = byteString + chr(hexBytes[i])
}

let outputPath = "out/lxglobals-new.lxobj"
let ok = spit(outputPath, byteString)
if ok != true {
  groanln(ok or "Failed to write output.")
  Lx.exit(1)
}

println("Saved to " + outputPath)
println("")
println("SUCCESS: lxglobals bytecode built with NEW codegen")

nil
