#!/usr/bin/env -S ../out/lx run

let driver = import "src/driver.lx"
let errors = import "src/errors.lx"

fn usage() {
  groanln("Usage:")
  groanln("  ./cmd/lxcheck.lx <entry>")
  groanln("  # e.g. from lx/: ./cmd/lxcheck.lx cmd/mlx.lx")
  groanln("")
  groanln("Notes:")
  groanln("  - Run from the `lx/` directory so imports like \"src/...\" resolve.")
  groanln("  - `<entry>` should be the module you want to typecheck (plus transitive imports).")
}

fn typecheckEntry(entry) {
  let d = driver.make(.{
    profile: "tooling",
    withTypecheck: true,
    loadSource: fn(p) { slurp(p) },
  })

  if !d {
    groanln("Failed to initialize driver.")
    Lx.exit(70)
  }

  let result = d.compileModule(entry)
  if !result {
    groanln("Internal error: compileModule returned nil.")
    Lx.exit(70)
  }

  // Summarize across all compiled modules (including transitive imports).
  let total = 0
  let fatalFailures = 0
  let typeFailures = 0

  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r { continue }
    total = total + 1

    if r.status != "done" {
      fatalFailures = fatalFailures + 1
      continue
    }

    let tc = r.passes and r.passes.typecheck
    if tc and tc.success == false {
      typeFailures = typeFailures + 1
    }
  }

  groanln("Typecheck summary:")
  groanln("  entry: " + entry)
  groanln("  modules: " + str(total))
  groanln("  fatal failures: " + str(fatalFailures))
  groanln("  typecheck failures: " + str(typeFailures))

  // Print details: fatal failures first, then typecheck failures.
  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r or r.status == "done" { continue }
    groanln("")
    groanln("== " + path + " (" + (r.status or "unknown") + ") ==")
    errors.printErrors(errors.collectErrors(r), r)
  }

  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r or r.status != "done" { continue }
    let tc = r.passes and r.passes.typecheck
    if !tc or tc.success != false { continue }

    groanln("")
    groanln("== " + path + " (typecheck) ==")
    errors.printErrors(tc.errors or [], r)
  }

  if fatalFailures > 0 or typeFailures > 0 {
    Lx.exit(65)
  }
}

fn main() {
  // This script is intended to be executed via `lx run <file> ...`, which keeps
  // the outer argv (so args[1] is typically "run" and args[2] is the script path).
  // Support both modes:
  // - `lx run cmd/lxcheck.lx <entry>`    => base=3
  // - embedded main program execution    => base=1
  let base = 1
  if Lx.args[1] == "run" { base = 3 }

  let entry = Lx.args[base]
  if !entry or entry == "help" or entry == "--help" or entry == "-h" {
    usage()
    return
  }

  if Lx.args[base + 1] {
    groanln("Unexpected extra arguments.")
    usage()
    Lx.exit(28)
  }

  typecheckEntry(entry)
}

main()
