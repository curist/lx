// Driver - Orchestrates compilation pipeline (passes):
//   parse → lower → anf → resolve → anf-inline → lower-intrinsics → (codegen)
//
// Responsibilities:
// - Coordinate pass execution
// - Manage import cache for multi-file compilation
// - Handle circular import detection
// - Provide compilation artifacts for query service and codegen
// - ANF runs after lower (optional, default on)
// - Loop lowering runs post-ANF, pre-resolve (always on with ANF, materializes loop limits)
// - ANF inline runs post-resolve (optional, default on)

let typecheck = import "src/passes/analysis/typecheck.lx"
let pipeline = import "src/driver/pipeline.lx"
let fastcheck = import "src/passes/analysis/fastcheck.lx"
let codegen = import "src/passes/emit/codegen.lx"
let verify = import "src/passes/verify/verify-bytecode.lx"
let .{ NODE } = import "src/types.lx"
let stamps = import "src/driver/stamps.lx"
let helpers = import "src/driver/helpers.lx"
let profiles = import "src/driver/profiles.lx"
let passesModule = import "src/driver/passes.lx"
let .{ PASS_ORDER, PASS_DEFS, passEnabled } = passesModule
let artifactsModule = import "src/driver/artifacts.lx"
let .{ ARTIFACT, validateArtifactSpec } = artifactsModule
let plannerModule = import "src/driver/planner.lx"
let .{ planArtifactGraph, derivePassPlan, trimPassPlan, hasRequiredPasses } = plannerModule

// ========================================
// Driver Factory
// ========================================

fn normalizeDriverOpts(opts) {
  let shape = .{
    loadSource: nil,
    profile: nil,
    withLower: nil,
    withTypecheck: nil,
    withAnf: nil,
    withAnfInline: nil,
    withLowerIntrinsics: nil,
    withDce: nil,
    withImportLower: nil,
    debug: nil,
  }
  let out = shape
  if opts { out = opts }
  out
}

fn make(opts) {
  opts = normalizeDriverOpts(opts)
  let cache = .{}
  let compiledModules = []  // Track compilation order
  let loadSource = opts.loadSource

  // Profile support: profile sets defaults, explicit flags override
  let profileName = opts.profile or "default"
  let profileDefaults = profiles.getProfile(profileName)
  let defaultTarget = profiles.getDefaultTarget(profileName, ARTIFACT)

  if !profileDefaults {
    // Unknown profile - error
    Lx.stderr.println("Error: Unknown profile '" + profileName + "'")
    Lx.stderr.println("Available profiles: default, typecheck, query")
    return nil
  }

  // Apply profile defaults, then override with explicit flags
  // Check if flag is explicitly set (not nil), if so use it, else use profile default
  let withLower = nil
  let explicitWithLower = opts.withLower
  if explicitWithLower != nil {
    withLower = explicitWithLower
  } else {
    withLower = profileDefaults.withLower
  }

  let withTypecheck = nil
  let explicitWithTypecheck = opts.withTypecheck
  if explicitWithTypecheck != nil {
    withTypecheck = explicitWithTypecheck
  } else {
    withTypecheck = profileDefaults.withTypecheck
  }

  let withAnf = nil
  let explicitWithAnf = opts.withAnf
  if explicitWithAnf != nil {
    withAnf = explicitWithAnf
  } else {
    withAnf = profileDefaults.withAnf
  }

  let withAnfInline = nil
  let explicitWithAnfInline = opts.withAnfInline
  if explicitWithAnfInline != nil {
    withAnfInline = explicitWithAnfInline
  } else {
    withAnfInline = profileDefaults.withAnfInline
  }

  let withLowerIntrinsics = nil
  let explicitWithLowerIntrinsics = opts.withLowerIntrinsics
  if explicitWithLowerIntrinsics != nil {
    withLowerIntrinsics = explicitWithLowerIntrinsics
  } else {
    withLowerIntrinsics = profileDefaults.withLowerIntrinsics
  }

  // DCE is on by default
  let withDce = opts.withDce != false

  // Optional import overrides (used when compiling transitive imports).
  // Defaults to top-level behavior unless overridden.
  let withImportLower = opts.withImportLower
  if withImportLower == nil { withImportLower = withLower }

  let planNeeds = .{
    withLower: withLower == true,
    withAnf: withAnf == true,
    withAnfInline: withAnfInline == true,
    withLowerIntrinsics: withLowerIntrinsics == true,
    withTypecheck: withTypecheck == true,
    withDce: withDce == true,
  }
  if !validateArtifactSpec(planNeeds) { return nil }

  // Debug flags (optional)
  let debug = opts.debug
  let wholeProgramTypecheckDone = false
  let wholeProgramTypecheckStamp = nil
  let wholeProgramDceDone = false
  let wholeProgramDceStamp = nil
  let wholeProgramDceArtifact = nil  // Cached artifact for ANALYSIS_DCE_WHOLE_PROGRAM
  let compileDepth = 0

  // Build dependency graph from import info in resolve pass results
  fn buildDependencyGraph() {
    // Returns: { modulePath: [importedModulePaths] }
    let deps = .{}
    for path in compiledModules {
      deps[path] = []
      let r = cache[path]
      if !r or r.status != "done" { continue }
      let passes = r.passes or .{}
      let resolveResult = passes.resolve
      if !resolveResult { continue }

      let importInfo = resolveResult.importInfoByNodeId or .{}
      for nodeId in keys(importInfo) {
        let info = importInfo[nodeId]
        let importResult = info and info.importResult
        let importPath = importResult and importResult.path
        if importPath {
          push(deps[path], importPath)
        }
      }
    }
    deps
  }

  // Topologically sort modules using Kahn's algorithm
  // Returns modules in dependency order (dependencies before dependents)
  fn topologicalSort(deps) {
    // Build in-degree map and adjacency (dependents) list
    let inDegree = .{}
    let dependents = .{}  // module -> [modules that depend on it]
    let allModules = keys(deps)

    for path in allModules {
      inDegree[path] = 0
      dependents[path] = []
    }

    // Calculate in-degrees
    for path in allModules {
      let imports = deps[path] or []
      for importPath in imports {
        // Only count if the imported module is in our graph
        if inDegree[importPath] != nil {
          inDegree[path] = inDegree[path] + 1
          push(dependents[importPath], path)
        }
      }
    }

    // Kahn's algorithm: start with modules that have no dependencies
    let queue = []
    let result = []

    for path in allModules {
      if inDegree[path] == 0 {
        push(queue, path)
      }
    }

    for len(queue) > 0 {
      let path = queue[0]
      // Remove first element (shift)
      let newQueue = []
      for let i = 1; i < len(queue); i = i + 1 {
        push(newQueue, queue[i])
      }
      queue = newQueue

      push(result, path)

      // Decrease in-degree of dependents
      for dependent in dependents[path] {
        inDegree[dependent] = inDegree[dependent] - 1
        if inDegree[dependent] == 0 {
          push(queue, dependent)
        }
      }
    }

    // If result doesn't contain all modules, there's a cycle
    // Add remaining modules in original order
    if len(result) < len(allModules) {
      let inResult = .{}
      for path in result { inResult[path] = true }
      for path in compiledModules {
        if !inResult[path] {
          push(result, path)
        }
      }
    }

    result
  }

  fn runWholeProgramTypecheck(entryResult) {
    // Typecheck in dependency order so imports are processed before dependents.

    // Check if we need to rerun based on programStamp
    let currentProgramStamp = stamps.computeProgramStamp(compiledModules)
    if wholeProgramTypecheckDone and wholeProgramTypecheckStamp == currentProgramStamp {
      return entryResult  // Already done with same module graph
    }

    let programExports = .{}

    // Build dependency graph and topologically sort
    let deps = buildDependencyGraph()
    let sortedModules = topologicalSort(deps)

    for path in sortedModules {
      let r = cache[path]
      if !r or r.status != "done" { continue }
      let passes = r.passes or .{}
      let resolveResult = passes.resolve
      if !resolveResult or resolveResult.success != true { continue }

      let lowerResult = passes.lower
      let resolveLower = passes["resolve-lower"]
      let useLower = lowerResult and lowerResult.ast and resolveLower and resolveLower.success == true

      let ast = useLower and lowerResult.ast or helpers.getFinalAst(passes)
      if !ast { continue }

      let enumInfo = useLower and lowerResult.enumInfo or helpers.getFinalEnumInfo(passes)

      let tcResolve = useLower and resolveLower or resolveResult
      if !tcResolve or tcResolve.success != true { continue }

      let tc = typecheck(ast, tcResolve, .{
        enumInfo: enumInfo,
        program: .{ exports: programExports },
      }) or .{ success: false, errors: ["typecheck returned nil"], types: .{}, typeVarBindings: .{} }

      // Attach as a non-fatal pass result for tooling to inspect.
      passes.typecheck = tc
      r.passes = passes
      if r.passOrder { push(r.passOrder, "typecheck") }

      // Record module's export type (type of last expression) for downstream imports.
      if ast.type == NODE.Block and ast.expressions and len(ast.expressions) > 0 {
        let last = ast.expressions[len(ast.expressions) - 1]
        if last and tc.types and tc.types[last.id] {
          programExports[path] = tc.types[last.id]
        }
      }
    }

    wholeProgramTypecheckDone = true
    wholeProgramTypecheckStamp = currentProgramStamp
    entryResult
  }

  fn compileModuleInternal(path, targetArtifact) {
    let isImport = compileDepth > 1
    let effectiveWithLower = isImport and withImportLower or withLower
    let effectiveWithAnf = withAnf
    let effectiveWithAnfInline = withAnfInline
    let effectiveWithLowerIntrinsics = withLowerIntrinsics
    let effectiveWithTypecheck = withTypecheck
    let effectiveWithDce = withDce
    // If lower is disabled, downstream passes depending on lowered AST must be disabled.
    if effectiveWithLower == false {
      effectiveWithAnf = false
      effectiveWithAnfInline = false
      effectiveWithLowerIntrinsics = false
      effectiveWithTypecheck = false
    }
    if effectiveWithAnf == false {
      effectiveWithAnfInline = false
      effectiveWithLowerIntrinsics = false
    }

    let needs = .{
      withLower: effectiveWithLower == true,
      withAnf: effectiveWithAnf == true,
      withAnfInline: effectiveWithAnfInline == true,
      withLowerIntrinsics: effectiveWithLowerIntrinsics == true,
      withTypecheck: effectiveWithTypecheck == true,
      withDce: effectiveWithDce == true,
    }

    let target = targetArtifact or defaultTarget
    let graph = planArtifactGraph(target, needs)
    let passNames = derivePassPlan(graph, needs)
    if debug and debug.stopAfter {
      passNames = trimPassPlan(passNames, debug.stopAfter)
    }

    // Load source to compute hash for cache validation
    let source = nil
    if loadSource {
      source = loadSource(path)
    }

    if !source {
      // Source loading failed - represent as failed parse pass
      let result = .{
        status: "failed",
        success: false,
        path: path,
        failedPass: "parse",
        passOrder: ["parse"],
        passes: .{
          parse: .{
            success: false,
            errors: ["Failed to load source: " + path],
          },
        },
      }
      cache[path] = result
      return result
    }

    // Compute astStamp including source hash
    let sourceHash = stamps.simpleStringHash(source)
    let currentStamp = stamps.computeAstStamp(needs, sourceHash)

    // Check cache first
    let cached = cache[path]
    if cached {
      // Respect "compiling" sentinel for circular import detection.
      if cached.status != "done" and cached.status != "failed" {
        return cached
      }
      // Check if cached result matches current configuration via stamp
      // This now includes source content, so file edits invalidate cache
      if cached.astStamp == currentStamp and hasRequiredPasses(cached, passNames) {
        return cached
      }
      // Otherwise: upgrade/downgrade by recompiling with current needs.
    }

    // Track compilation (first time only)
    push(compiledModules, path)
    // Graph changed; any previous whole-program results are stale.
    wholeProgramTypecheckDone = false
    wholeProgramDceArtifact = nil  // Invalidate cached whole-program DCE

    // Mark as compiling (for circular import detection)
    cache[path] = .{
      status: "compiling",
      path: path,
    }

    // ========================================
    // Run Pipeline
    // ========================================

    // Build context for passes
    let ctx = .{
      importCache: cache,
      // Use the public wrapper so nested imports bump compileDepth, enabling
      // per-import build options like `withImportLower`.
      compileModule: compileModule,
      opts: .{
        withLower: effectiveWithLower,
        withAnf: effectiveWithAnf,
        withAnfInline: effectiveWithAnfInline,
        withLowerIntrinsics: effectiveWithLowerIntrinsics,
        withTypecheck: effectiveWithTypecheck,
        withDce: effectiveWithDce,
      },
      debug: debug or .{},
    }

    // Build initial state
    let state = .{
      path: path,
      source: source,
      ast: nil,
      nextNodeId: 1,
      passes: .{},
    }

    // Execute passes
    let passList = collect passName in passNames {
      let pass = PASS_DEFS[passName]
      if pass { pass } else { continue }
    }
    let pipelineResult = pipeline.runPasses(passList, ctx, state)

    // Build result with pipeline fields
    let result = .{
      // Core fields
      status: pipelineResult.status,
      success: pipelineResult.success,
      path: path,
      failedPass: pipelineResult.failedPass,
      buildOpts: needs,

      // Pipeline fields
      passOrder: pipelineResult.passOrder,
      passes: pipelineResult.passes,

      // Cache invalidation
      astStamp: currentStamp,
    }

    cache[path] = result
    return result
  }

  fn compileModuleForArtifact(path, artifactId) {
    compileDepth = compileDepth + 1
    let isTop = compileDepth == 1
    let result = compileModuleInternal(path, artifactId)
    compileDepth = compileDepth - 1

    if isTop and withTypecheck != false and !wholeProgramTypecheckDone {
      result = runWholeProgramTypecheck(result)
    }

    // Whole-program DCE is now handled via the artifact API:
    // buildModule(path, ARTIFACT.ANALYSIS_DCE_FINAL) computes it on-demand
    // This preserves local DCE as pristine and derives final DCE without mutation.

    result
  }

  fn compileModule(path) {
    compileModuleForArtifact(path, defaultTarget)
  }

  fn planPasses(artifactId) {
    let needs = .{
      withLower: withLower == true,
      withAnf: withAnf == true,
      withAnfInline: withAnfInline == true,
      withLowerIntrinsics: withLowerIntrinsics == true,
      withTypecheck: withTypecheck == true,
      withDce: withDce == true,
    }

    let graph = planArtifactGraph(artifactId or defaultTarget, needs)
    derivePassPlan(graph, needs)
  }

  fn planPassesDetailed(artifactId) {
    let needs = .{
      withLower: withLower == true,
      withAnf: withAnf == true,
      withAnfInline: withAnfInline == true,
      withLowerIntrinsics: withLowerIntrinsics == true,
      withTypecheck: withTypecheck == true,
      withDce: withDce == true,
    }

    let graph = planArtifactGraph(artifactId or defaultTarget, needs)
    let required = derivePassPlan(graph, needs)
    let requiredSet = .{}
    for passName in required { requiredSet[passName] = true }

    collect passName in PASS_ORDER {
      .{
        name: passName,
        enabled: passEnabled(passName, needs),
        required: requiredSet[passName] == true,
      }
    }
  }

  fn planArtifactGraphForTarget(artifactId) {
    let needs = .{
      withLower: withLower == true,
      withAnf: withAnf == true,
      withAnfInline: withAnfInline == true,
      withLowerIntrinsics: withLowerIntrinsics == true,
      withTypecheck: withTypecheck == true,
      withDce: withDce == true,
    }
    planArtifactGraph(artifactId or defaultTarget, needs)
  }

  // ========================================
  // Backend Artifact Producers
  // ========================================

  fn produceFastcheck(path) {
    // Produce ARTIFACT.ANALYSIS_FASTCHECK for a module
    let result = cache[path]
    if !result or result.status != "done" { return nil }

    // Check if already computed
    if result.fastcheckResult { return result.fastcheckResult }

    let passes = result.passes or .{}
    let ast = helpers.getFinalAst(passes)
    let enumInfo = helpers.getFinalEnumInfo(passes)
    let resolveResult = passes.resolve

    if !ast or !resolveResult { return nil }

    let fc = fastcheck(ast, resolveResult, .{ enumInfo: enumInfo })
    result.fastcheckResult = fc
    fc
  }

  fn produceCodegen(path) {
    // Produce ARTIFACT.BYTECODE_FUNCTION for a module
    let result = cache[path]
    if !result or result.status != "done" { return nil }

    // Check if already computed
    if result.codegenResult and result.codegenResult.function {
      return result.codegenResult.function
    }

    let passes = result.passes or .{}
    let ast = helpers.getFinalAst(passes)
    let enumInfo = helpers.getFinalEnumInfo(passes)
    let resolveResult = passes.resolve

    if !ast or !resolveResult { return nil }

    // Ensure fastcheck is available
    let fc = produceFastcheck(path)
    if !fc { return nil }

    // Get final DCE (includes whole-program DCE if at top level)
    let finalDce = buildModule(path, ARTIFACT.ANALYSIS_DCE_FINAL)
    let deadNodes = finalDce and finalDce.deadNodes or .{}

    // Recursive codegenModule callback for imports
    let codegenModule = fn(modulePath) {
      produceCodegen(modulePath)
    }

    let cg = codegen(ast, resolveResult, .{
      codegenModule: codegenModule,
      enumInfo: enumInfo,
      fastcheck: fc,
      dceResult: .{ deadNodes: deadNodes },
    })

    result.codegenResult = cg
    if !cg.success { return nil }

    cg.function
  }

  fn produceVerify(path) {
    // Produce ARTIFACT.BYTECODE_VERIFIED for a module
    let result = cache[path]
    if !result or result.status != "done" { return nil }

    // Check if already computed
    if result.verifyResult and result.verifyResult.success {
      // Return the function (verify just validates, doesn't transform)
      let cg = result.codegenResult
      if cg and cg.function { return cg.function }
      return nil
    }

    // Ensure codegen is available
    let function = produceCodegen(path)
    if !function { return nil }

    let verifyResult = verify.verifyFunction(function)
    result.verifyResult = verifyResult

    if !verifyResult.success { return nil }

    function
  }

  // ========================================
  // Artifact Build API
  // ========================================

  fn buildModule(path, artifactId) {
    // Build a specific artifact for a module.
    // This is the artifact-driven compilation API.
    //
    // Args:
    //   path: Module path
    //   artifactId: One of ARTIFACT.* constants
    //
    // Returns: Artifact payload or nil on error

    // First, ensure the module is compiled
    let result = compileModuleForArtifact(path, artifactId)
    if !result or result.status != "done" {
      return nil
    }

    let passes = result.passes or .{}

    // Map artifact IDs to their sources
    if artifactId == ARTIFACT.AST_FINAL {
      return helpers.getFinalAst(passes)
    }

    if artifactId == ARTIFACT.ANALYSIS_RESOLVE {
      return passes.resolve
    }

    if artifactId == ARTIFACT.ANALYSIS_DCE_LOCAL {
      return passes.dce
    }

    if artifactId == ARTIFACT.ANALYSIS_TYPECHECK {
      return passes.typecheck
    }

    if artifactId == ARTIFACT.ANALYSIS_FASTCHECK {
      return produceFastcheck(path)
    }

    if artifactId == ARTIFACT.BYTECODE_FUNCTION {
      return produceCodegen(path)
    }

    if artifactId == ARTIFACT.BYTECODE_VERIFIED {
      return produceVerify(path)
    }

    if artifactId == ARTIFACT.ANALYSIS_DCE_FINAL {
      // Derive final DCE by combining local DCE with whole-program DCE
      // This is the DCE result that codegen should use

      let localDce = passes.dce
      if !localDce { return nil }

      // If whole-program DCE is disabled, just use local DCE
      if !withDce {
        return localDce
      }

      // Get whole-program DCE artifact (this triggers whole-program analysis)
      // We need to find the entry point - for imports, we can't run whole-program DCE
      // So we only apply whole-program DCE at the top level
      if compileDepth > 1 {
        // This is an import - use local DCE only
        return localDce
      }

      // At top level - compute whole-program DCE
      let wholeProgramDce = buildProgram(path, ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM)
      if !wholeProgramDce or !wholeProgramDce.success {
        // Whole-program DCE failed - use local DCE
        return localDce
      }

      // Merge local DCE with whole-program findings
      let finalDce = .{
        success: true,
        deadNodes: .{},
        usedImportProperties: localDce.usedImportProperties,
      }

      // Copy local dead nodes
      let localDeadNodes = localDce.deadNodes or .{}
      for nodeId in keys(localDeadNodes) {
        finalDce.deadNodes[nodeId] = true
      }

      // Add dead nodes from unused exports
      let usedExports = wholeProgramDce.usedExportsPerModule[path] or .{}
      let ast = helpers.getFinalAst(passes)
      if ast and ast.type == NODE.Block and ast.expressions and len(ast.expressions) > 0 {
        let lastExpr = ast.expressions[len(ast.expressions) - 1]
        if lastExpr and lastExpr.type == NODE.Hashmap {
          let entries = lastExpr.entries or []
          for entry in entries {
            if !entry { continue }
            let key = entry.key
            let keyName = key and (key.name or key.value or key.lexeme)
            if !keyName { continue }

            if !usedExports[keyName] {
              // This export is unused - mark its value as dead
              if entry.value and entry.value.id {
                finalDce.deadNodes[entry.value.id] = true
              }
            }
          }
        }
      }

      return finalDce
    }

    // Unknown artifact
    nil
  }

  fn buildProgram(entryPath, artifactId) {
    // Build a program-level artifact.
    // Program-level artifacts require all modules to be compiled.
    //
    // Args:
    //   entryPath: Entry module path
    //   artifactId: One of ARTIFACT.PROGRAM_* constants
    //
    // Returns: Artifact payload or nil on error

    // Compile the entry module (this recursively compiles all imports)
    let compileTarget =
      artifactId == ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM and ARTIFACT.ANALYSIS_DCE_LOCAL or
      artifactId == ARTIFACT.PROGRAM_MODULE_GRAPH and ARTIFACT.ANALYSIS_RESOLVE or
      defaultTarget

    let entryResult = compileModuleForArtifact(entryPath, compileTarget)
    if !entryResult or entryResult.status != "done" {
      return nil
    }

    if artifactId == ARTIFACT.PROGRAM_MODULE_GRAPH {
      // Return the compiled module graph
      return .{
        entry: entryPath,
        modules: compiledModules,
        cache: cache,
      }
    }

    if artifactId == ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM {
      // Compute whole-program DCE facts by analyzing all modules
      // This artifact represents the complete program-level dead code analysis

      // Ensure all modules are compiled
      compileModuleForArtifact(entryPath, ARTIFACT.ANALYSIS_DCE_LOCAL)

      // Check if we have a cached result
      let programStamp = stamps.computeProgramStamp(compiledModules)
      if wholeProgramDceArtifact and wholeProgramDceArtifact.programStamp == programStamp {
        return wholeProgramDceArtifact
      }

      // Build usedExportsPerModule: { modulePath: { exportName: true } }
      let usedExportsPerModule = .{}

      for path in compiledModules {
        let r = cache[path]
        if !r or r.status != "done" { continue }
        let passes = r.passes or .{}
        let dceResult = passes.dce
        if !dceResult or !dceResult.success { continue }

        // Collect used imports from this module
        let usedProps = dceResult.usedImportProperties or .{}
        for importPath in keys(usedProps) {
          let props = usedProps[importPath]
          if !usedExportsPerModule[importPath] {
            usedExportsPerModule[importPath] = .{}
          }
          for propName in keys(props) {
            usedExportsPerModule[importPath][propName] = true
          }
        }
      }

      // Build and cache the whole-program DCE artifact
      let artifact = .{
        success: true,
        programStamp: programStamp,
        usedExportsPerModule: usedExportsPerModule,
        modules: compiledModules,
      }
      wholeProgramDceArtifact = artifact
      artifact
    }

    // Unknown artifact
    nil
  }

  .{
    cache: cache,
    compiledModules: compiledModules,
    loadSource: loadSource,
    withLower: withLower,
    withTypecheck: withTypecheck,
    withAnf: withAnf,
    withAnfInline: withAnfInline,
    debug: debug,
    compileModule: compileModule,
    planPasses: planPasses,
    planPassesDetailed: planPassesDetailed,
    planArtifactGraph: planArtifactGraphForTarget,
    buildModule: buildModule,
    buildProgram: buildProgram,
  }
}

// ========================================
// Module Exports
// ========================================

.{
  make,
  ARTIFACT,
  getFinalAst: helpers.getFinalAst,
  getFinalEnumInfo: helpers.getFinalEnumInfo,
}
