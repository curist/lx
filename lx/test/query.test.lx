// Query Service Tests - MINIMAL SET FOR SKELETON
//
// This file contains only basic query tests that work with the typecheck skeleton.
// Tests removed (depend on type inference features):
// - Hover showing inferred types beyond literals
// - Type-specific assertions (expecting Number, String, etc. from inference)
// - Import type resolution
// - Record field type inference
// - Function type inference
//
// Tests kept:
// - Basic goto/navigation (doesn't depend on typecheck)
// - Hover on literals (skeleton handles these)
// - Infrastructure tests
//
// When rebuilding the type checker, add back tests incrementally as features are implemented.

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let Driver = import "src/driver.lx"
let query = import "services/query.lx"
let types = import "src/types.lx"
let ModuleResolution = import "src/module_resolution.lx"

let NODE = types.NODE

// Helper: compile source through full pipeline and create query context
fn compileAndQuery(source, filename) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == filename { return source }
      let resolver = ModuleResolution.forEntry(Lx.args[2])
      return resolver.slurp(path)
    },
    withTypecheck: true,
    withAnf: false,
  })

  // Use compileWithDriver to get full context including moduleAsts
  let result = query.compileWithDriver(driver, filename, .{
    withTypecheck: true,
    mergeScope: "reachable",
  })

  if !result.success {
    return result
  }

  .{
    success: true,
    ctx: result.ctx,
    compileResult: result.compileResult,
  }
}

// ========================================
// Basic Hover Tests
// ========================================

test("query - hover on number literal", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
})

test("query - hover on empty position returns no node", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success)

  // Hover on line 10 (beyond source)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 10, 0)

  assert.truthy(!hoverResult.success, "Query should succeed even if no node found")
  assert.equal(hoverResult.kind, "hover")
})

// ========================================
// Goto Definition Tests
// ========================================

test("query - goto local variable", fn(assert) {
  let result = compileAndQuery("let x = 1\nx + 1", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'x' usage (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.line, 1, "Should goto line 1 (let)")
  assert.equal(gotoResult.target.col, 4, "Should goto col 4 (variable name)")
})

test("query - goto function parameter", fn(assert) {
  let result = compileAndQuery("fn add(a, b) { a + b }", "test.lx")
  assert.truthy(result.success)

  // Goto on 'a' in body (line 1, col 15)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 15)

  assert.truthy(gotoResult.success)
  assert.truthy(gotoResult.target)
  assert.equal(gotoResult.target.line, 1, "Should goto parameter line")
  assert.equal(gotoResult.target.col, 7, "Should goto parameter col")
})

test("query - goto named function normalized to name", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success)

  // Goto on 'foo' in call (line 2, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success)
  assert.truthy(gotoResult.target)
  assert.equal(gotoResult.target.line, 1, "Should goto function declaration")
  assert.equal(gotoResult.target.col, 3, "Should goto function name")
})

test("query - goto builtin has no definition", fn(assert) {
  let result = compileAndQuery("println(42)", "test.lx")
  assert.truthy(result.success)

  // Goto on 'println'
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)
  assert.truthy(!gotoResult.success)
})

test("query - goto on non-identifier fails gracefully", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success)

  // Goto on number literal
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.truthy(!gotoResult.success, "Should succeed even if no goto target")
})

// TODO: Add back these test categories when rebuilding type checker:
// - Hover showing inferred variable types
// - Hover on record fields
// - Import type resolution
// - Multi-module queries
// - Function type inference
// - Collection type inference

// ========================================
// Import Goto Definition Tests
// ========================================

test("query - goto import binding jumps to exported value", fn(assert) {
  // Source: let greet = import "test/fixtures/imports/simple-fn.lx"
  //         greet("world")
  // Goto on 'greet' in line 2 should jump to the function in simple-fn.lx
  let source = "let greet = import \"test/fixtures/imports/simple-fn.lx\"\ngreet(\"world\")"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'greet' usage (line 2, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/simple-fn.lx", "Should jump to imported file")
  // The function 'greet' is defined at line 2 in simple-fn.lx
  assert.equal(gotoResult.target.line, 2, "Should jump to function definition line")
})

test("query - goto import binding jumps to anonymous function export", fn(assert) {
  // Source: let greet = import "test/fixtures/imports/anon-fn.lx"
  //         greet("world")
  // The module exports an anonymous function directly (no identifier reference)
  let source = "let greet = import \"test/fixtures/imports/anon-fn.lx\"\ngreet(\"world\")"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'greet' usage (line 2, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/anon-fn.lx", "Should jump to imported file")
  // The anonymous function starts at line 2
  assert.equal(gotoResult.target.line, 2, "Should jump to function definition line")
})

test("query - goto destructured import binding jumps to export field", fn(assert) {
  // Source: let .{ add } = import "test/fixtures/imports/named-exports.lx"
  //         add(1, 2)
  // Goto on 'add' in line 2 should jump to where 'add' is defined in named-exports.lx
  let source = "let .{ add } = import \"test/fixtures/imports/named-exports.lx\"\nadd(1, 2)"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'add' usage (line 2, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/named-exports.lx", "Should jump to imported file")
  // The function 'add' is defined at line 2 in named-exports.lx
  assert.equal(gotoResult.target.line, 2, "Should jump to add function definition line")
})

// ========================================
// Control Flow Goto Definition Tests
// ========================================

test("query - goto continue jumps to loop start", fn(assert) {
  let source = "for let i = 0; i < 10; i = i + 1 {\n  if i == 5 {\n    continue\n  }\n  println(i)\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'continue' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.line, 1, "Should jump to for keyword")
  assert.equal(gotoResult.target.col, 0, "Should jump to start of for")
})

test("query - goto break jumps to loop end", fn(assert) {
  let source = "for let i = 0; i < 10; i = i + 1 {\n  if i == 5 {\n    break\n  }\n  println(i)\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'break' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.line, 6, "Should jump to closing brace")
  assert.equal(gotoResult.target.col, 0, "Should jump to closing brace col")
})

test("query - goto continue in for-in loop", fn(assert) {
  let source = "for item in [1, 2, 3] {\n  if item == 2 {\n    continue\n  }\n  println(item)\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'continue' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should jump to for keyword")
  assert.equal(gotoResult.target.col, 0, "Should jump to start of for")
})

test("query - goto break in for-in loop", fn(assert) {
  let source = "for item in [1, 2, 3] {\n  if item == 2 {\n    break\n  }\n  println(item)\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'break' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 6, "Should jump to closing brace")
})

test("query - goto continue in collect expression", fn(assert) {
  let source = "let results = collect i in [1, 2, 3] {\n  if i == 2 {\n    continue\n  }\n  i * 2\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'continue' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should jump to collect keyword")
  assert.equal(gotoResult.target.col, 14, "Should jump to start of collect")
})

test("query - goto break in collect expression", fn(assert) {
  let source = "let results = collect i in [1, 2, 3] {\n  if i == 2 {\n    break\n  }\n  i * 2\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'break' (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 6, "Should jump to closing brace")
})

test("query - goto continue in nested loops jumps to innermost", fn(assert) {
  let source = "for let i = 0; i < 3; i = i + 1 {\n  for let j = 0; j < 3; j = j + 1 {\n    continue\n  }\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'continue' in inner loop (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 2, "Should jump to inner for keyword")
})

test("query - goto break in nested loops jumps to innermost", fn(assert) {
  let source = "for let i = 0; i < 3; i = i + 1 {\n  for let j = 0; j < 3; j = j + 1 {\n    break\n  }\n}"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'break' in inner loop (line 3, col 4)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 3, 4)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 4, "Should jump to inner loop closing brace")
})

suite.run()
