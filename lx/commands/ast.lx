// AST dumper - print AST at different compilation stages with enriched metadata
//
// METADATA GUIDE:
//
// Origin Tracking (lower, anf passes):
//   [origin: #N] - This node was created from node #N in the previous pass
//                  Helps trace transformations through the pipeline
//
// Name Bindings (resolve pass):
//   For Identifier nodes, shows what the name resolves to:
//
//   [local slot=N decl=#X depth=D]
//     - Local variable at slot N
//     - Declared at node #X
//     - At scope depth D (0=global scope, 1=first nested scope, etc.)
//
//   [upvalue idx=N decl=#X depth=D]
//     - Captured variable (closure) at upvalue index N
//     - Originally declared at node #X
//     - Accessed from scope depth D
//
//   [builtin name=X]
//     - Built-in global function/value (e.g., println, len, type)
//
// Scope Info (resolve pass):
//   For Function/Block nodes with scopes:
//   [scope depth=D locals=N upvalues=M]
//     - Scope at depth D
//     - N local variables declared
//     - M upvalues (captured variables from outer scopes)

let parse = import "src/passes/parse/parser.lx"
let lower = import "src/passes/transform/lower.lx"
let anf = import "src/passes/transform/anf.lx"
let anfInline = import "src/passes/transform/anf-inline.lx"
let resolve = import "src/passes/analysis/resolve.lx"
let dce = import "src/passes/analysis/dce.lx"
let pipeline = import "src/passes/pipeline.lx"
let types = import "src/types.lx"
let ModuleResolution = import "src/module_resolution.lx"

let NODE = types.NODE

// Valid pass names
let VALID_PASSES = ["parse", "lower", "anf", "resolve", "anf-inline", "dce"]
let DEFAULT_PASS = "dce"

fn pad(n) {
  let s = ""
  for let i = 0; i < n; i = i + 1 { s = s + " " }
  s
}

fn dumpScalar(value, indent) {
  let t = type(value)
  if t == "string" {
    println(pad(indent) + "\"" + value + "\"")
  } else {
    println(pad(indent) + str(value))
  }
}

// Build metadata map from pipeline results
fn buildMetadata(pipelineResult) {
  let meta = .{
    origin: .{},        // nodeId -> originNodeId
    bindings: .{},      // nodeId -> binding info
    scopes: .{},        // nodeId -> scope info
    deadNodes: .{},     // nodeId -> true (dead code)
  }

  if !pipelineResult or !pipelineResult.passes { return meta }

  let passes = pipelineResult.passes

  // Collect origin tracking from the last pass that has it
  // (Each pass maps new IDs to previous pass IDs, so we want the most recent)
  let originPasses = ["anf-inline", "resolve", "anf", "lower"]
  for let i = 0; i < len(originPasses); i = i + 1 {
    let passName = originPasses[i]
    let passResult = passes[passName]
    if passResult and passResult.origin {
      meta.origin = passResult.origin
      break
    }
  }

  // Collect resolve metadata
  let resolveResult = passes.resolve
  if resolveResult and resolveResult.success {
    if resolveResult.resolvedNames {
      meta.bindings = resolveResult.resolvedNames
    }
    if resolveResult.scopeInfo {
      meta.scopes = resolveResult.scopeInfo
    }
  }

  // Collect DCE metadata
  let dceResult = passes.dce
  if dceResult and dceResult.success {
    if dceResult.deadNodes {
      meta.deadNodes = dceResult.deadNodes
    }
  }

  meta
}

// Format binding info for display
fn formatBinding(binding) {
  if !binding { return nil }

  if binding.kind == "local" {
    let parts = ["local slot=" + str(binding.slot)]
    if binding.declaredAt { push(parts, "decl=#" + str(binding.declaredAt)) }
    if binding.depth != nil { push(parts, "depth=" + str(binding.depth)) }
    return join(parts, " ")
  }

  if binding.kind == "upvalue" {
    let parts = ["upvalue idx=" + str(binding.upvalueIndex)]
    if binding.declaredAt { push(parts, "decl=#" + str(binding.declaredAt)) }
    if binding.depth != nil { push(parts, "depth=" + str(binding.depth)) }
    return join(parts, " ")
  }

  if binding.kind == "builtin" {
    return "builtin name=" + (binding.name or "?")
  }

  // Unknown binding kind
  nil
}

// Format scope info for display
fn formatScope(scopeInfo) {
  if !scopeInfo { return nil }

  let parts = []
  if scopeInfo.scopeType {
    push(parts, scopeInfo.scopeType)
  }
  if scopeInfo.depth != nil {
    push(parts, "depth=" + str(scopeInfo.depth))
  }
  if scopeInfo.locals {
    push(parts, "locals=" + str(len(scopeInfo.locals)))
  }
  if scopeInfo.upvalues {
    push(parts, "upvalues=" + str(len(scopeInfo.upvalues)))
  }

  len(parts) > 0 and join(parts, " ") or nil
}

fn dumpNode(node, indent, meta) {
  if node == nil {
    println(pad(indent) + "nil")
    return
  }

  let t = type(node)
  if t == "array" {
    println(pad(indent) + "[")
    for let i = 0; i < len(node); i = i + 1 {
      dumpNode(node[i], indent + 2, meta)
    }
    println(pad(indent) + "]")
    return
  }
  if t != "map" {
    dumpScalar(node, indent)
    return
  }

  if node.type == nil {
    println(pad(indent) + "<map>")
    return
  }

  let typeName = nameOf(NODE, node.type) or str(node.type)
  let header = pad(indent) + typeName
  if node.id != nil { header = header + " #" + str(node.id) }
  if node.line != nil { header = header + " (L" + str(node.line) + ")" }
  if node.anfSynthetic { header = header + " [synthetic]" }

  // Add metadata annotations
  if meta and node.id != nil {
    // Show origin tracking
    let origin = meta.origin and meta.origin[node.id]
    if origin != nil {
      header = header + " [origin: #" + str(origin) + "]"
    }

    // Show binding info for identifiers
    if node.type == NODE.Identifier {
      let binding = meta.bindings and meta.bindings[node.id]
      let bindingStr = formatBinding(binding)
      if bindingStr {
        header = header + " [" + bindingStr + "]"
      }
    }

    // Show scope info for scopes
    let scopeInfo = meta.scopes and meta.scopes[node.id]
    let scopeStr = formatScope(scopeInfo)
    if scopeStr {
      header = header + " [scope " + scopeStr + "]"
    }

    // Show DCE dead code annotation
    if meta.deadNodes and meta.deadNodes[node.id] {
      header = header + " [DEAD]"
    }
  }

  println(header)

  if node.type == NODE.Identifier {
    println(pad(indent + 2) + "name: " + node.name)
    return
  }

  if node.value != nil {
    println(pad(indent + 2) + "value:")
    dumpNode(node.value, indent + 4, meta)
  }

  if node.name {
    println(pad(indent + 2) + "name:")
    dumpNode(node.name, indent + 4, meta)
  }
  if node.params {
    println(pad(indent + 2) + "params:")
    dumpNode(node.params, indent + 4, meta)
  }
  if node.body {
    println(pad(indent + 2) + "body:")
    dumpNode(node.body, indent + 4, meta)
  }
  if node.expressions {
    println(pad(indent + 2) + "expressions:")
    dumpNode(node.expressions, indent + 4, meta)
  }
  if node.left {
    println(pad(indent + 2) + "left:")
    dumpNode(node.left, indent + 4, meta)
  }
  if node.right {
    println(pad(indent + 2) + "right:")
    dumpNode(node.right, indent + 4, meta)
  }
  if node.operand {
    println(pad(indent + 2) + "operand:")
    dumpNode(node.operand, indent + 4, meta)
  }
  if node.expression {
    println(pad(indent + 2) + "expression:")
    dumpNode(node.expression, indent + 4, meta)
  }
  if node.condition {
    println(pad(indent + 2) + "condition:")
    dumpNode(node.condition, indent + 4, meta)
  }
  if node.then {
    println(pad(indent + 2) + "then:")
    dumpNode(node.then, indent + 4, meta)
  }
  if node.else {
    println(pad(indent + 2) + "else:")
    dumpNode(node.else, indent + 4, meta)
  }
  if node.init {
    println(pad(indent + 2) + "init:")
    dumpNode(node.init, indent + 4, meta)
  }
  if node.update {
    println(pad(indent + 2) + "update:")
    dumpNode(node.update, indent + 4, meta)
  }
  if node.callee {
    println(pad(indent + 2) + "callee:")
    dumpNode(node.callee, indent + 4, meta)
  }
  if node.args {
    println(pad(indent + 2) + "args:")
    dumpNode(node.args, indent + 4, meta)
  }
  if node.object {
    println(pad(indent + 2) + "object:")
    dumpNode(node.object, indent + 4, meta)
  }
  if node.index {
    println(pad(indent + 2) + "index:")
    dumpNode(node.index, indent + 4, meta)
  }
  if node.property {
    println(pad(indent + 2) + "property:")
    dumpNode(node.property, indent + 4, meta)
  }
  if node.target {
    println(pad(indent + 2) + "target:")
    dumpNode(node.target, indent + 4, meta)
  }
  if node.elements {
    println(pad(indent + 2) + "elements:")
    dumpNode(node.elements, indent + 4, meta)
  }
  if node.pairs {
    println(pad(indent + 2) + "pairs:")
    dumpNode(node.pairs, indent + 4, meta)
  }
  if node.path {
    println(pad(indent + 2) + "path:")
    dumpNode(node.path, indent + 4, meta)
  }
}

fn printErrors(errors) {
  if !errors or len(errors) == 0 { return }
  for let i = 0; i < len(errors); i = i + 1 {
    let err = errors[i]
    if err.pos {
      let file = err.pos.filename or err.filename
      let prefix = file and join([file, ":", err.pos.line, ":", err.pos.col or 0], "") or
        join([err.pos.line, ":", err.pos.col or 0], "")
      Lx.stderr.println(join(["[", prefix, "] ", err.message], ""))
    } else if err.line {
      Lx.stderr.println(join(["[L", err.line, "] ", err.message], ""))
    } else {
      Lx.stderr.println(err.message)
    }
  }
}

// Count nodes in AST (recursively)
fn countNodes(node) {
  if !node { return 0 }

  let t = type(node)
  if t == "array" {
    let total = 0
    for let i = 0; i < len(node); i = i + 1 {
      total = total + countNodes(node[i])
    }
    return total
  }

  if t != "map" or !node.type { return 0 }

  // Count this node + all children
  let count = 1

  // Recursively count children
  if node.value { count = count + countNodes(node.value) }
  if node.name { count = count + countNodes(node.name) }
  if node.params { count = count + countNodes(node.params) }
  if node.body { count = count + countNodes(node.body) }
  if node.expressions { count = count + countNodes(node.expressions) }
  if node.left { count = count + countNodes(node.left) }
  if node.right { count = count + countNodes(node.right) }
  if node.operand { count = count + countNodes(node.operand) }
  if node.expression { count = count + countNodes(node.expression) }
  if node.condition { count = count + countNodes(node.condition) }
  if node.then { count = count + countNodes(node.then) }
  if node.else { count = count + countNodes(node.else) }
  if node.init { count = count + countNodes(node.init) }
  if node.update { count = count + countNodes(node.update) }
  if node.callee { count = count + countNodes(node.callee) }
  if node.args { count = count + countNodes(node.args) }
  if node.object { count = count + countNodes(node.object) }
  if node.index { count = count + countNodes(node.index) }
  if node.property { count = count + countNodes(node.property) }
  if node.target { count = count + countNodes(node.target) }
  if node.elements { count = count + countNodes(node.elements) }
  if node.pairs { count = count + countNodes(node.pairs) }
  if node.path { count = count + countNodes(node.path) }

  count
}

// Count synthetic nodes (nodes with anfSynthetic flag)
fn countSyntheticNodes(node) {
  if !node { return 0 }

  let t = type(node)
  if t == "array" {
    let total = 0
    for let i = 0; i < len(node); i = i + 1 {
      total = total + countSyntheticNodes(node[i])
    }
    return total
  }

  if t != "map" or !node.type { return 0 }

  let count = node.anfSynthetic and 1 or 0

  // Recursively count in children
  if node.value { count = count + countSyntheticNodes(node.value) }
  if node.name { count = count + countSyntheticNodes(node.name) }
  if node.params { count = count + countSyntheticNodes(node.params) }
  if node.body { count = count + countSyntheticNodes(node.body) }
  if node.expressions { count = count + countSyntheticNodes(node.expressions) }
  if node.left { count = count + countSyntheticNodes(node.left) }
  if node.right { count = count + countSyntheticNodes(node.right) }
  if node.operand { count = count + countSyntheticNodes(node.operand) }
  if node.expression { count = count + countSyntheticNodes(node.expression) }
  if node.condition { count = count + countSyntheticNodes(node.condition) }
  if node.then { count = count + countSyntheticNodes(node.then) }
  if node.else { count = count + countSyntheticNodes(node.else) }
  if node.init { count = count + countSyntheticNodes(node.init) }
  if node.update { count = count + countSyntheticNodes(node.update) }
  if node.callee { count = count + countSyntheticNodes(node.callee) }
  if node.args { count = count + countSyntheticNodes(node.args) }
  if node.object { count = count + countSyntheticNodes(node.object) }
  if node.index { count = count + countSyntheticNodes(node.index) }
  if node.property { count = count + countSyntheticNodes(node.property) }
  if node.target { count = count + countSyntheticNodes(node.target) }
  if node.elements { count = count + countSyntheticNodes(node.elements) }
  if node.pairs { count = count + countSyntheticNodes(node.pairs) }
  if node.path { count = count + countSyntheticNodes(node.path) }

  count
}

// Build summary statistics for each pass
fn buildSummaryStats(pipelineResult) {
  if !pipelineResult or !pipelineResult.passOrder { return [] }

  let stats = []
  let previousNodeCount = 0

  for let i = 0; i < len(pipelineResult.passOrder); i = i + 1 {
    let passName = pipelineResult.passOrder[i]
    let passResult = pipelineResult.passes[passName]

    if !passResult { continue }

    let ast = passResult.ast or pipelineResult.ast
    let nodeCount = ast and countNodes(ast) or 0
    let delta = nodeCount - previousNodeCount

    let passStats = .{
      name: passName,
      nodeCount: nodeCount,
      delta: delta,
      success: passResult.success,
    }

    // Pass-specific metrics
    if passName == "anf" and ast {
      passStats.syntheticNodes = countSyntheticNodes(ast)
    }

    if passName == "resolve" and passResult.resolvedNames {
      let locals = 0
      let upvalues = 0
      let builtins = 0
      let bindings = passResult.resolvedNames
      let ids = keys(bindings)
      for let j = 0; j < len(ids); j = j + 1 {
        let binding = bindings[ids[j]]
        if binding.kind == "local" { locals = locals + 1 }
        if binding.kind == "upvalue" { upvalues = upvalues + 1 }
        if binding.kind == "builtin" { builtins = builtins + 1 }
      }
      passStats.locals = locals
      passStats.upvalues = upvalues
      passStats.builtins = builtins
    }

    if passName == "resolve" and passResult.scopeInfo {
      let maxDepth = 0
      let scopes = passResult.scopeInfo
      let scopeIds = keys(scopes)
      for let j = 0; j < len(scopeIds); j = j + 1 {
        let scope = scopes[scopeIds[j]]
        if scope.depth and scope.depth > maxDepth {
          maxDepth = scope.depth
        }
      }
      passStats.maxScopeDepth = maxDepth
    }

    push(stats, passStats)
    previousNodeCount = nodeCount
  }

  stats
}

// Print summary statistics
fn printSummary(stats) {
  println("Compilation Pipeline Summary")
  println("=============================")
  println("")

  for let i = 0; i < len(stats); i = i + 1 {
    let s = stats[i]

    // Pass name and node count
    let line = s.name + ":"
    println(line)

    // Node count with delta
    let nodeInfo = "  Nodes: " + str(s.nodeCount)
    if s.delta > 0 {
      nodeInfo = nodeInfo + " (+" + str(s.delta) + ")"
    } else if s.delta < 0 {
      nodeInfo = nodeInfo + " (" + str(s.delta) + ")"
    }
    println(nodeInfo)

    // Pass-specific metrics
    if s.syntheticNodes != nil {
      println("  Synthetic temporaries: " + str(s.syntheticNodes))
    }

    if s.locals != nil {
      println("  Bindings: " + str(s.locals) + " locals, " + str(s.upvalues) + " upvalues, " + str(s.builtins) + " builtins")
    }

    if s.maxScopeDepth != nil {
      println("  Max scope depth: " + str(s.maxScopeDepth))
    }

    println("")
  }
}

// Find node by ID in AST
fn findNodeById(node, targetId) {
  if !node { return nil }

  let t = type(node)
  if t == "array" {
    for let i = 0; i < len(node); i = i + 1 {
      if let found = findNodeById(node[i], targetId) {
        return found
      }
    }
    return nil
  }

  if t != "map" or !node.type { return nil }

  // Check if this is the node we're looking for
  if node.id == targetId { return node }

  // Search children
  if node.value {
    if let found = findNodeById(node.value, targetId) {
      return found
    }
  }
  if node.name {
    if let found = findNodeById(node.name, targetId) {
      return found
    }
  }
  if node.params {
    if let found = findNodeById(node.params, targetId) {
      return found
    }
  }
  if node.body {
    if let found = findNodeById(node.body, targetId) {
      return found
    }
  }
  if node.expressions {
    if let found = findNodeById(node.expressions, targetId) {
      return found
    }
  }
  if node.left {
    if let found = findNodeById(node.left, targetId) {
      return found
    }
  }
  if node.right {
    if let found = findNodeById(node.right, targetId) {
      return found
    }
  }
  if node.operand {
    if let found = findNodeById(node.operand, targetId) {
      return found
    }
  }
  if node.expression {
    if let found = findNodeById(node.expression, targetId) {
      return found
    }
  }
  if node.condition {
    if let found = findNodeById(node.condition, targetId) {
      return found
    }
  }
  if node.then {
    if let found = findNodeById(node.then, targetId) {
      return found
    }
  }
  if node.else {
    if let found = findNodeById(node.else, targetId) {
      return found
    }
  }
  if node.init {
    if let found = findNodeById(node.init, targetId) {
      return found
    }
  }
  if node.update {
    if let found = findNodeById(node.update, targetId) {
      return found
    }
  }
  if node.callee {
    if let found = findNodeById(node.callee, targetId) {
      return found
    }
  }
  if node.args {
    if let found = findNodeById(node.args, targetId) {
      return found
    }
  }
  if node.object {
    if let found = findNodeById(node.object, targetId) {
      return found
    }
  }
  if node.index {
    if let found = findNodeById(node.index, targetId) {
      return found
    }
  }
  if node.property {
    if let found = findNodeById(node.property, targetId) {
      return found
    }
  }
  if node.target {
    if let found = findNodeById(node.target, targetId) {
      return found
    }
  }
  if node.elements {
    if let found = findNodeById(node.elements, targetId) {
      return found
    }
  }
  if node.pairs {
    if let found = findNodeById(node.pairs, targetId) {
      return found
    }
  }
  if node.path {
    if let found = findNodeById(node.path, targetId) {
      return found
    }
  }

  nil
}

// Build reverse origin map (newId -> oldId becomes oldId -> [newIds])
fn buildReverseOriginMap(origin) {
  if !origin { return .{} }

  let reverse = .{}
  let newIds = keys(origin)
  for let i = 0; i < len(newIds); i = i + 1 {
    let newId = newIds[i]
    let oldId = origin[newId]
    // Skip if oldId is nil or not a valid key type
    if !oldId { continue }
    let oldIdType = type(oldId)
    if oldIdType != "number" and oldIdType != "string" { continue }

    if !reverse[oldId] {
      reverse[oldId] = []
    }
    push(reverse[oldId], newId)
  }
  reverse
}

// Track node through compilation passes
fn trackNodeThroughPasses(nodeId, pipelineResult) {
  if !pipelineResult or !pipelineResult.passOrder { return [] }

  let history = []
  let currentIds = [nodeId]  // Track multiple descendants

  for let i = 0; i < len(pipelineResult.passOrder); i = i + 1 {
    let passName = pipelineResult.passOrder[i]
    let passResult = pipelineResult.passes[passName]

    if !passResult { continue }

    let ast = passResult.ast or pipelineResult.ast

    // Find all current nodes in this pass's AST
    let foundNodes = []
    for let j = 0; j < len(currentIds); j = j + 1 {
      let id = currentIds[j]
      let node = findNodeById(ast, id)
      if node {
        push(foundNodes, node)
      }
    }

    if len(foundNodes) > 0 {
      push(history, .{
        pass: passName,
        nodes: foundNodes,
        ids: currentIds,
      })
    } else {
      push(history, .{
        pass: passName,
        nodes: [],
        ids: currentIds,
        notFound: true,
      })
    }

    // Track forward using origin map from next pass
    if i + 1 < len(pipelineResult.passOrder) {
      let nextPassName = pipelineResult.passOrder[i + 1]
      let nextPassResult = pipelineResult.passes[nextPassName]

      if nextPassResult and nextPassResult.origin {
        // Build reverse map to find descendants
        let reverseOrigin = buildReverseOriginMap(nextPassResult.origin)

        let nextIds = []
        for let j = 0; j < len(currentIds); j = j + 1 {
          let id = currentIds[j]
          let descendants = reverseOrigin[id]
          if descendants {
            for let k = 0; k < len(descendants); k = k + 1 {
              push(nextIds, descendants[k])
            }
          }
        }

        if len(nextIds) > 0 {
          currentIds = nextIds
        }
      }
    }
  }

  history
}

// Format node for tracking display (concise)
fn formatNodeForTracking(node) {
  if !node { return "<not found>" }

  let typeName = nameOf(NODE, node.type) or str(node.type)
  let info = typeName

  // Add key identifying information
  if node.type == NODE.Identifier and node.name {
    info = info + " '" + node.name + "'"
  } else if node.type == NODE.Number and node.value != nil {
    info = info + " " + str(node.value)
  } else if node.type == NODE.String and node.value {
    info = info + " \"" + node.value + "\""
  } else if node.type == NODE.Binary {
    info = info + " (operator)"
  }

  if node.anfSynthetic {
    info = info + " [synthetic]"
  }

  info
}

// Print node tracking history
fn printNodeTracking(nodeId, history) {
  println("Tracking node #" + str(nodeId) + " through compilation pipeline")
  println("=======================================================")
  println("")

  for let i = 0; i < len(history); i = i + 1 {
    let entry = history[i]
    println("[" + entry.pass + "]")

    if entry.notFound {
      println("  Node not found (may have been removed or transformed)")
      if len(entry.ids) > 0 {
        println("  Looked for: #" + join(collect id in entry.ids { str(id) }, ", #"))
      }
    } else if len(entry.nodes) == 0 {
      println("  No matching nodes")
    } else if len(entry.nodes) == 1 {
      let node = entry.nodes[0]
      println("  " + formatNodeForTracking(node) + " #" + str(node.id))
      if node.line {
        println("  Line: " + str(node.line))
      }
    } else {
      println("  Split into " + str(len(entry.nodes)) + " nodes:")
      for let j = 0; j < len(entry.nodes); j = j + 1 {
        let node = entry.nodes[j]
        println("    - " + formatNodeForTracking(node) + " #" + str(node.id))
      }
    }

    println("")
  }
}

// Build origin chain from one pass to another
fn buildOriginChain(pipelineResult, fromPass, toPass) {
  // Returns a map: fromNodeId -> [toNodeIds]
  if !pipelineResult or !pipelineResult.passOrder { return .{} }

  let chain = .{}  // Maps node ID to array of node IDs
  let passOrder = pipelineResult.passOrder

  // Find indices of from and to passes
  let fromIdx = -1
  let toIdx = -1
  for let i = 0; i < len(passOrder); i = i + 1 {
    if passOrder[i] == fromPass { fromIdx = i }
    if passOrder[i] == toPass { toIdx = i }
  }

  if fromIdx == -1 or toIdx == -1 or fromIdx >= toIdx {
    return .{}
  }

  // Initialize chain with identity mapping for fromPass nodes
  let fromPassResult = pipelineResult.passes[fromPass]
  if fromPassResult and fromPassResult.ast {
    let fromAst = fromPassResult.ast
    // Collect all node IDs from fromPass
    let collectIds = nil
    collectIds = fn collectIds(node) {
      if !node { return }
      let t = type(node)
      if t == "array" {
        for let i = 0; i < len(node); i = i + 1 {
          collectIds(node[i])
        }
      } else if t == "map" and node.id {
        chain[node.id] = [node.id]
        // Recursively collect from children
        if node.value { collectIds(node.value) }
        if node.name { collectIds(node.name) }
        if node.params { collectIds(node.params) }
        if node.body { collectIds(node.body) }
        if node.expressions { collectIds(node.expressions) }
        if node.left { collectIds(node.left) }
        if node.right { collectIds(node.right) }
        if node.operand { collectIds(node.operand) }
        if node.expression { collectIds(node.expression) }
        if node.condition { collectIds(node.condition) }
        if node.then { collectIds(node.then) }
        if node.else { collectIds(node.else) }
        if node.init { collectIds(node.init) }
        if node.update { collectIds(node.update) }
        if node.callee { collectIds(node.callee) }
        if node.args { collectIds(node.args) }
        if node.object { collectIds(node.object) }
        if node.index { collectIds(node.index) }
        if node.property { collectIds(node.property) }
        if node.target { collectIds(node.target) }
        if node.elements { collectIds(node.elements) }
        if node.pairs { collectIds(node.pairs) }
        if node.path { collectIds(node.path) }
      }
    }
    collectIds(fromAst)
  }

  // Chain through intermediate passes
  for let i = fromIdx + 1; i <= toIdx; i = i + 1 {
    let passResult = pipelineResult.passes[passOrder[i]]
    if passResult and passResult.origin {
      let reverseOrigin = buildReverseOriginMap(passResult.origin)
      let newChain = .{}

      let oldIds = keys(chain)
      for let j = 0; j < len(oldIds); j = j + 1 {
        let oldId = oldIds[j]
        let currentIds = chain[oldId]
        let nextIds = []

        for let k = 0; k < len(currentIds); k = k + 1 {
          let id = currentIds[k]
          let descendants = reverseOrigin[id]
          if descendants {
            for let m = 0; m < len(descendants); m = m + 1 {
              push(nextIds, descendants[m])
            }
          }
        }

        if len(nextIds) > 0 {
          newChain[oldId] = nextIds
        }
      }

      chain = newChain
    }
  }

  chain
}

// Compute diff between two passes
fn computeDiff(pipelineResult, fromPass, toPass) {
  let fromPassResult = pipelineResult.passes[fromPass]
  let toPassResult = pipelineResult.passes[toPass]

  if !fromPassResult or !toPassResult {
    return .{ error: "One or both passes not found in pipeline" }
  }

  let fromAst = fromPassResult.ast
  let toAst = toPassResult.ast

  let originChain = buildOriginChain(pipelineResult, fromPass, toPass)

  // Collect all nodes from both passes
  let fromNodes = .{}
  let toNodes = .{}

  let collectNodes = fn collectNodes(node, map) {
    if !node { return }
    let t = type(node)
    if t == "array" {
      for let i = 0; i < len(node); i = i + 1 {
        collectNodes(node[i], map)
      }
    } else if t == "map" and node.id {
      map[node.id] = node
      if node.value { collectNodes(node.value, map) }
      if node.name { collectNodes(node.name, map) }
      if node.params { collectNodes(node.params, map) }
      if node.body { collectNodes(node.body, map) }
      if node.expressions { collectNodes(node.expressions, map) }
      if node.left { collectNodes(node.left, map) }
      if node.right { collectNodes(node.right, map) }
      if node.operand { collectNodes(node.operand, map) }
      if node.expression { collectNodes(node.expression, map) }
      if node.condition { collectNodes(node.condition, map) }
      if node.then { collectNodes(node.then, map) }
      if node.else { collectNodes(node.else, map) }
      if node.init { collectNodes(node.init, map) }
      if node.update { collectNodes(node.update, map) }
      if node.callee { collectNodes(node.callee, map) }
      if node.args { collectNodes(node.args, map) }
      if node.object { collectNodes(node.object, map) }
      if node.index { collectNodes(node.index, map) }
      if node.property { collectNodes(node.property, map) }
      if node.target { collectNodes(node.target, map) }
      if node.elements { collectNodes(node.elements, map) }
      if node.pairs { collectNodes(node.pairs, map) }
      if node.path { collectNodes(node.path, map) }
    }
  }

  collectNodes(fromAst, fromNodes)
  collectNodes(toAst, toNodes)

  // Find added nodes (in toPass but not descended from fromPass)
  let descendantIds = .{}
  let originIds = keys(originChain)
  for let i = 0; i < len(originIds); i = i + 1 {
    let descendants = originChain[originIds[i]]
    for let j = 0; j < len(descendants); j = j + 1 {
      descendantIds[descendants[j]] = true
    }
  }

  let addedNodes = []
  let toIds = keys(toNodes)
  for let i = 0; i < len(toIds); i = i + 1 {
    let id = toIds[i]
    if !descendantIds[id] {
      push(addedNodes, toNodes[id])
    }
  }

  // Find removed nodes (in fromPass but no descendants in toPass)
  let removedNodes = []
  let fromIds = keys(fromNodes)
  for let i = 0; i < len(fromIds); i = i + 1 {
    let id = fromIds[i]
    let descendants = originChain[id]
    if !descendants or len(descendants) == 0 {
      push(removedNodes, fromNodes[id])
    }
  }

  // Find transformed nodes (same semantic node but different structure)
  let transformedNodes = []
  for let i = 0; i < len(fromIds); i = i + 1 {
    let id = fromIds[i]
    let descendants = originChain[id]
    if descendants and len(descendants) > 1 {
      // Node split into multiple
      push(transformedNodes, .{
        from: fromNodes[id],
        to: collect did in descendants { toNodes[did] },
        change: "split",
      })
    }
  }

  .{
    added: addedNodes,
    removed: removedNodes,
    transformed: transformedNodes,
    fromCount: len(fromIds),
    toCount: len(toIds),
  }
}

// Print diff between two passes
fn printDiff(fromPass, toPass, diff) {
  println("Changes from " + fromPass + " → " + toPass)
  println("=======================================")
  println("")

  // Added nodes
  if len(diff.added) > 0 {
    println("Added nodes: " + str(len(diff.added)))
    let limit = len(diff.added) > 10 and 10 or len(diff.added)
    for let i = 0; i < limit; i = i + 1 {
      let node = diff.added[i]
      println("  + " + formatNodeForTracking(node) + " #" + str(node.id))
    }
    if len(diff.added) > 10 {
      println("  ... and " + str(len(diff.added) - 10) + " more")
    }
    println("")
  }

  // Removed nodes
  if len(diff.removed) > 0 {
    println("Removed nodes: " + str(len(diff.removed)))
    let limit = len(diff.removed) > 10 and 10 or len(diff.removed)
    for let i = 0; i < limit; i = i + 1 {
      let node = diff.removed[i]
      println("  - " + formatNodeForTracking(node) + " #" + str(node.id))
    }
    if len(diff.removed) > 10 {
      println("  ... and " + str(len(diff.removed) - 10) + " more")
    }
    println("")
  }

  // Transformed nodes
  if len(diff.transformed) > 0 {
    println("Transformed nodes: " + str(len(diff.transformed)))
    let limit = len(diff.transformed) > 5 and 5 or len(diff.transformed)
    for let i = 0; i < limit; i = i + 1 {
      let t = diff.transformed[i]
      println("  ~ " + formatNodeForTracking(t.from) + " #" + str(t.from.id))
      println("    → split into " + str(len(t.to)) + " nodes")
    }
    if len(diff.transformed) > 5 {
      println("  ... and " + str(len(diff.transformed) - 5) + " more")
    }
    println("")
  }

  // Statistics
  println("Statistics:")
  println("  " + fromPass + ": " + str(diff.fromCount) + " nodes")
  println("  " + toPass + ": " + str(diff.toCount) + " nodes")
  let delta = diff.toCount - diff.fromCount
  if delta > 0 {
    println("  Net change: +" + str(delta) + " nodes")
  } else if delta < 0 {
    println("  Net change: " + str(delta) + " nodes")
  } else {
    println("  Net change: no change")
  }
}

fn parseArgs(argv) {
  // Parse command line arguments
  // Returns .{ path: "...", pass: "...", showHelp: bool, summary: bool, trackNode: num, diff: .{from, to}, withImports: bool } or .{ error: "..." }

  let path = nil
  let pass = DEFAULT_PASS
  let showHelp = false
  let summary = false
  let trackNode = nil
  let diff = nil
  let withImports = false

  let i = 2  // Start after command name
  for true {
    if i >= len(argv) { break }

    let arg = argv[i]
    if arg == "--pass" {
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--pass requires a pass name" }
      }
      pass = argv[i]
      i = i + 1
    } else if arg == "--help-metadata" {
      showHelp = true
      i = i + 1
    } else if arg == "--summary" {
      summary = true
      i = i + 1
    } else if arg == "--track-node" {
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--track-node requires a node ID" }
      }
      trackNode = tonumber(argv[i])
      if !trackNode or trackNode <= 0 {
        return .{ error: "--track-node requires a positive integer node ID" }
      }
      i = i + 1
    } else if arg == "--diff" {
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--diff requires two pass names (from and to)" }
      }
      let fromPass = argv[i]
      i = i + 1
      if i >= len(argv) {
        return .{ error: "--diff requires two pass names (from and to)" }
      }
      let toPass = argv[i]
      diff = .{ from: fromPass, to: toPass }
      i = i + 1
    } else if arg == "--with-imports" {
      withImports = true
      i = i + 1
    } else {
      if path {
        return .{ error: "Multiple file paths specified" }
      }
      path = arg
      i = i + 1
    }
  }

  if showHelp {
    return .{ showHelp: true }
  }

  if !path {
    return .{ error: "No file path specified" }
  }

  .{ path: path, pass: pass, showHelp: false, summary: summary, trackNode: trackNode, diff: diff, withImports: withImports }
}

fn printMetadataHelp() {
  println("AST Metadata Guide")
  println("==================")
  println("")
  println("The ast command enriches AST nodes with metadata from compilation passes.")
  println("")
  println("ORIGIN TRACKING (lower, anf passes)")
  println("  [origin: #N]")
  println("    This node was created from node #N in the previous pass.")
  println("    Helps trace how nodes transform through the compilation pipeline.")
  println("")
  println("    Example: After ANF transform, you might see:")
  println("      Identifier #33 [origin: #3]")
  println("    This means identifier #33 in the ANF AST came from node #3 in the lowered AST.")
  println("")
  println("NAME BINDINGS (resolve pass)")
  println("  Shows what each identifier resolves to:")
  println("")
  println("  [local slot=N decl=#X depth=D]")
  println("    - Local variable stored at stack slot N")
  println("    - Declared at node #X")
  println("    - At scope depth D (0=global scope, 1=first nested scope, etc.)")
  println("")
  println("  [upvalue idx=N decl=#X depth=D]")
  println("    - Captured variable (closure) at upvalue index N")
  println("    - Originally declared at node #X")
  println("    - Accessed from scope depth D")
  println("")
  println("  [builtin name=X]")
  println("    - Built-in global function or value")
  println("    - Examples: println, len, type, str")
  println("")
  println("SCOPE INFORMATION (resolve pass)")
  println("  For Function and Block nodes:")
  println("")
  println("  [scope function depth=D locals=N upvalues=M]")
  println("    - Function scope at depth D")
  println("    - N local variables declared in this scope")
  println("    - M upvalues (variables captured from outer scopes)")
  println("")
  println("  [scope block depth=D locals=N]")
  println("    - Block scope at depth D")
  println("    - N local variables")
  println("")
  println("EXAMPLES")
  println("")
  println("  Input code:")
  println("    let x = 1")
  println("    fn foo() { x }")
  println("")
  println("  With --pass resolve, the identifier 'x' inside foo might show:")
  println("    Identifier #15 [upvalue idx=0 decl=#5 depth=1]")
  println("")
  println("  This means:")
  println("    - It's a captured variable (upvalue)")
  println("    - At upvalue index 0 in the closure")
  println("    - Originally declared at node #5 (the 'let x' statement)")
  println("    - Accessed from scope depth 1 (inside the function)")
  println("")
  println("PASS-SPECIFIC METADATA AVAILABILITY")
  println("  parse:        No metadata (baseline AST)")
  println("  lower:        Origin tracking")
  println("  anf:          Origin tracking")
  println("  resolve:      Name bindings, scope info, plus origin from previous passes")
  println("  anf-inline:   All metadata from resolve, plus any new origins")
}

fn buildPassList(resolver, importCache, compileImportedModule) {
  // Build pass list similar to driver, but simplified for single-file compilation
  [
    .{
      name: "parse",
      mutatesAst: false,
      provides: ["ast", "parseTree"],
      run: fn(ctx, state) {
        parse(state.source, state.path)
      },
    },
    .{
      name: "lower",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["loweredAst"],
      run: fn(ctx, state) {
        lower(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },
    .{
      name: "anf",
      mutatesAst: false,
      requires: ["loweredAst"],
      provides: ["anfAst", "loweredAst"],
      run: fn(ctx, state) {
        anf(state.ast, .{ startNodeId: state.nextNodeId })
      },
    },
    .{
      name: "resolve",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["resolution", "scopeInfo"],
      run: fn(ctx, state) {
        resolve(state.ast, .{
          importCache: importCache,
          compileModule: compileImportedModule,
        })
      },
    },
    .{
      name: "anf-inline",
      mutatesAst: true,
      requires: ["anfAst", "resolution"],
      provides: ["optimizedAst"],
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        anfInline(state.ast, resolveResult)
      },
    },
    .{
      name: "dce",
      mutatesAst: false,
      requires: ["resolution"],
      provides: ["dce"],
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        dce(state.ast, resolveResult)
      },
    },
  ]
}

fn run(ctx) {
  let args = parseArgs(ctx.argv)

  if args.showHelp {
    printMetadataHelp()
    return
  }

  if args.error {
    Lx.stderr.println("Error: " + args.error)
    Lx.stderr.println("Usage: " + ctx.prog + " ast [--pass <pass-name>] [--with-imports] <path>")
    Lx.stderr.println("       " + ctx.prog + " ast --summary <path>")
    Lx.stderr.println("       " + ctx.prog + " ast --track-node <id> <path>")
    Lx.stderr.println("       " + ctx.prog + " ast --diff <from-pass> <to-pass> <path>")
    Lx.stderr.println("       " + ctx.prog + " ast --help-metadata")
    Lx.stderr.println("")
    Lx.stderr.println("Options:")
    Lx.stderr.println("  --pass <name>    Stop after specified pass (default: " + DEFAULT_PASS + ")")
    Lx.stderr.println("  --with-imports   Also dump AST of imported modules")
    Lx.stderr.println("  --summary        Show pipeline statistics")
    Lx.stderr.println("  --track-node <id> Track a node through passes")
    Lx.stderr.println("  --diff <from> <to> Compare two passes")
    Lx.stderr.println("")
    Lx.stderr.println("Available passes: " + join(VALID_PASSES, ", "))
    Lx.exit(28)
  }

  let path = args.path
  let passName = args.pass

  // Validate diff passes if in diff mode
  if args.diff {
    let fromPass = args.diff.from
    let toPass = args.diff.to

    // Validate from pass
    let validFrom = false
    for let i = 0; i < len(VALID_PASSES); i = i + 1 {
      if VALID_PASSES[i] == fromPass {
        validFrom = true
        break
      }
    }
    if !validFrom {
      Lx.stderr.println("Error: Invalid from pass '" + fromPass + "'")
      Lx.stderr.println("Available passes: " + join(VALID_PASSES, ", "))
      Lx.exit(28)
    }

    // Validate to pass
    let validTo = false
    for let i = 0; i < len(VALID_PASSES); i = i + 1 {
      if VALID_PASSES[i] == toPass {
        validTo = true
        break
      }
    }
    if !validTo {
      Lx.stderr.println("Error: Invalid to pass '" + toPass + "'")
      Lx.stderr.println("Available passes: " + join(VALID_PASSES, ", "))
      Lx.exit(28)
    }

    // Check ordering
    let fromIdx = -1
    let toIdx = -1
    for let i = 0; i < len(VALID_PASSES); i = i + 1 {
      if VALID_PASSES[i] == fromPass { fromIdx = i }
      if VALID_PASSES[i] == toPass { toIdx = i }
    }
    if fromIdx >= toIdx {
      Lx.stderr.println("Error: from pass must come before to pass in pipeline")
      Lx.stderr.println("Pass order: " + join(VALID_PASSES, " → "))
      Lx.exit(28)
    }

    // For diff mode, we need to run up to toPass
    passName = toPass
  } else {
    // Validate pass name for non-diff modes
    let validPass = false
    for let i = 0; i < len(VALID_PASSES); i = i + 1 {
      if VALID_PASSES[i] == passName {
        validPass = true
        break
      }
    }

    if !validPass {
      Lx.stderr.println("Error: Invalid pass name '" + passName + "'")
      Lx.stderr.println("Available passes: " + join(VALID_PASSES, ", "))
      Lx.exit(28)
    }
  }

  // Resolve path to absolute
  let absPath = if path == "-" {
    "<stdin>"
  } else if path[0] == "/" {
    path
  } else {
    Lx.path.join(Lx.fs.cwd(), path)
  }

  // Set up module resolution
  let resolver = if path == "-" {
    nil
  } else {
    ModuleResolution.forEntry(path)
  }

  // Load source
  let source = if path == "-" {
    Lx.stdin.readAll()
  } else if resolver {
    resolver.slurp(absPath)
  } else {
    Lx.fs.readFile(path)
  }
  if !source {
    Lx.stderr.println("Failed to open " + path)
    Lx.exit(2)
  }

  // Import cache for compiled modules
  let importCache = .{}

  // Recursive module compilation for imports
  fn compileImportedModule(importPath) {
    // Check cache first
    if importCache[importPath] {
      return importCache[importPath]
    }

    // Mark as in-progress to detect cycles
    importCache[importPath] = .{ status: "compiling" }

    // Load source for imported module
    let importSource = resolver and resolver.slurp(importPath) or Lx.fs.readFile(importPath)
    if !importSource {
      let result = .{
        status: "failed",
        success: false,
        errors: [.{ message: "Failed to load module: " + importPath }],
      }
      importCache[importPath] = result
      return result
    }

    // Compile the imported module through same passes
    let importState = .{
      path: importPath,
      source: importSource,
      ast: nil,
      nextNodeId: 1,
      passes: .{},
    }

    let importCtx = .{
      debug: .{ stopAfter: passName }
    }

    let importPassList = buildPassList(resolver, importCache, compileImportedModule)
    let importResult = pipeline.runPasses(importPassList, importCtx, importState)

    let cached = .{
      status: importResult.success and "done" or "failed",
      success: importResult.success,
      ast: importResult.ast,
      passes: importResult.passes,
    }
    if !importResult.success {
      cached.errors = importResult.passes[importResult.failedPass].errors
    }

    importCache[importPath] = cached
    cached
  }

  // Build context and state
  let pipelineCtx = .{
    debug: .{ stopAfter: passName }
  }

  let state = .{
    path: absPath,
    source: source,
    ast: nil,
    nextNodeId: 1,
    passes: .{},
  }

  // Run passes
  let passList = buildPassList(resolver, importCache, compileImportedModule)
  let result = pipeline.runPasses(passList, pipelineCtx, state)

  // Check for errors
  if !result.success {
    printErrors(result.passes[result.failedPass].errors)
    Lx.exit(65)
  }

  // Summary mode, tracking mode, diff mode, or AST dump mode
  if args.summary {
    let stats = buildSummaryStats(result)
    printSummary(stats)
  } else if args.trackNode {
    let history = trackNodeThroughPasses(args.trackNode, result)
    printNodeTracking(args.trackNode, history)
  } else if args.diff {
    let diff = computeDiff(result, args.diff.from, args.diff.to)
    if diff.error {
      Lx.stderr.println("Error: " + diff.error)
      Lx.exit(1)
    }
    printDiff(args.diff.from, args.diff.to, diff)
  } else {
    // Build metadata from pipeline results
    let meta = buildMetadata(result)
    // Dump the AST with metadata
    println("== " + absPath + " ==")
    println("")
    dumpNode(result.ast, 0, meta)

    // Dump imported modules if requested
    if args.withImports {
      let importPaths = keys(importCache)
      for let i = 0; i < len(importPaths); i = i + 1 {
        let importPath = importPaths[i]
        let cached = importCache[importPath]
        if cached and cached.status == "done" and cached.ast {
          println("")
          println("== " + importPath + " ==")
          println("")
          let importMeta = buildMetadata(cached)
          dumpNode(cached.ast, 0, importMeta)
        }
      }
    }
  }
}

.{
  name: "ast",
  usage: "ast [--pass <pass-name>] [--with-imports] <path>\n       ast --summary <path>\n       ast --track-node <id> <path>\n       ast --diff <from-pass> <to-pass> <path>\n       ast --help-metadata",
  summary: "Dump AST with metadata at different compilation stages (debug)",
  run: run,
}
