let driver = import "src/driver.lx"
let errors = import "src/errors.lx"
let ModuleResolution = import "src/module_resolution.lx"

fn run(ctx) {
  if len(ctx.argv) < 3 {
    Lx.stderr.println("Usage: " + ctx.prog + " check <entry>")
    Lx.exit(28)
  }

  let entry = ctx.argv[2]
  if !entry {
    Lx.stderr.println("Usage: " + ctx.prog + " check <entry>")
    Lx.exit(28)
  }
  if ctx.argv[3] {
    Lx.stderr.println("Usage: " + ctx.prog + " check <entry>")
    Lx.exit(28)
  }

  let resolver = ModuleResolution.forEntry(entry)
  let d = driver.make(.{
    profile: "tooling",
    withTypecheck: true,
    loadSource: fn(p) { resolver.slurp(p) },
  }) or {
    Lx.stderr.println("Failed to initialize driver.")
    Lx.exit(70)
  }

  let entryPath = if entry[0] == "/" {
    entry
  } else {
    Lx.path.join(Lx.fs.cwd(), entry)
  }

  let result = d.compileModule(entryPath) or {
    Lx.stderr.println("Internal error: compileModule returned nil.")
    Lx.exit(70)
  }

  let total = 0
  let fatalFailures = 0
  let typeFailures = 0

  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r { continue }
    total = total + 1

    if r.status != "done" {
      fatalFailures = fatalFailures + 1
      continue
    }

    let tc = r.passes and r.passes.typecheck
    if tc and tc.success == false {
      typeFailures = typeFailures + 1
    }
  }

  Lx.stderr.println("Typecheck summary:")
  Lx.stderr.println("  entry: " + entry)
  Lx.stderr.println("  modules: " + str(total))
  Lx.stderr.println("  fatal failures: " + str(fatalFailures))
  Lx.stderr.println("  typecheck failures: " + str(typeFailures))

  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r or r.status == "done" { continue }
    Lx.stderr.println("")
    Lx.stderr.println("== " + path + " (" + (r.status or "unknown") + ") ==")
    errors.printErrors(errors.collectErrors(r), r)
  }

  for let i = 0; i < len(d.compiledModules); i = i + 1 {
    let path = d.compiledModules[i]
    let r = d.cache[path]
    if !r or r.status != "done" { continue }
    let tc = r.passes and r.passes.typecheck
    if !tc or tc.success != false { continue }

    Lx.stderr.println("")
    Lx.stderr.println("== " + path + " (typecheck) ==")
    errors.printErrors(tc.errors or [], r)
  }

  if fatalFailures > 0 or typeFailures > 0 {
    Lx.exit(65)
  }
}

.{
  name: "check",
  aliases: ["lxcheck"],
  usage: "check <entry>",
  summary: "Typecheck an entry module (dev)",
  run: run,
}
