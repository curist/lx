// ANF Validator - Check structural invariants for ANF output
// Responsibility: Ensure subexpressions that must be atomic are atomic.

fn addError(state, node, message) {
  push(state.errors, .{
    nodeId: node and node.id or 0,
    message: message,
    severity: "error",
  })
}

fn isAtomic(node) {
  if !node { return true }
  node.type == "Number" or node.type == "String" or node.type == "Bool" or
  node.type == "Nil" or node.type == "Identifier" or node.type == "Function"
}

let validateNode = nil

fn requireAtomic(state, node, context) {
  if !isAtomic(node) {
    addError(state, node, "ANF invariant: " + context + " must be atomic")
  }
}

fn validateList(state, nodes) {
  if !nodes { return }
  for let i = 0; i < len(nodes); i = i + 1 {
    validateNode(state, nodes[i])
  }
}

validateNode = fn(state, node) {
  if !node { return }

  if node.type == "Block" {
    validateList(state, node.expressions)
    return
  }

  if node.type == "Let" {
    if node.name and node.name.type != "Identifier" {
      addError(state, node.name, "ANF invariant: let name must be Identifier")
    }
    validateNode(state, node.init)
    return
  }

  if node.type == "Binary" {
    requireAtomic(state, node.left, "binary left")
    requireAtomic(state, node.right, "binary right")
    validateNode(state, node.left)
    validateNode(state, node.right)
    return
  }

  if node.type == "Unary" {
    requireAtomic(state, node.operand, "unary operand")
    validateNode(state, node.operand)
    return
  }

  if node.type == "Logical" {
    requireAtomic(state, node.left, "logical left")
    validateNode(state, node.left)
    validateNode(state, node.right)
    return
  }

  if node.type == "Grouping" {
    validateNode(state, node.expression)
    return
  }

  if node.type == "Call" {
    requireAtomic(state, node.callee, "call callee")
    validateNode(state, node.callee)
    for let i = 0; i < len(node.args); i = i + 1 {
      let arg = node.args[i]
      requireAtomic(state, arg, "call arg")
      validateNode(state, arg)
    }
    return
  }

  if node.type == "Function" {
    if node.name and node.name.type != "Identifier" {
      addError(state, node.name, "ANF invariant: function name must be Identifier")
    }
    for let i = 0; i < len(node.params); i = i + 1 {
      let param = node.params[i]
      if param.type != "Identifier" {
        addError(state, param, "ANF invariant: function param must be Identifier")
      }
    }
    validateNode(state, node.body)
    return
  }

  if node.type == "If" {
    requireAtomic(state, node.condition, "if condition")
    validateNode(state, node.condition)
    validateNode(state, node.then)
    if node.else {
      validateNode(state, node.else)
    }
    return
  }

  if node.type == "For" {
    validateNode(state, node.init)
    validateNode(state, node.condition)
    validateNode(state, node.update)
    validateNode(state, node.body)
    return
  }

  if node.type == "Return" or node.type == "Break" {
    validateNode(state, node.value)
    return
  }

  if node.type == "Continue" {
    return
  }

  if node.type == "Array" {
    for let i = 0; i < len(node.elements); i = i + 1 {
      let elem = node.elements[i]
      requireAtomic(state, elem, "array element")
      validateNode(state, elem)
    }
    return
  }

  if node.type == "Hashmap" {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let pair = node.pairs[i]
      requireAtomic(state, pair.key, "hashmap key")
      requireAtomic(state, pair.value, "hashmap value")
      validateNode(state, pair.key)
      validateNode(state, pair.value)
    }
    return
  }

  if node.type == "Index" {
    requireAtomic(state, node.object, "index object")
    requireAtomic(state, node.index, "index key")
    validateNode(state, node.object)
    validateNode(state, node.index)
    return
  }

  if node.type == "Dot" {
    requireAtomic(state, node.object, "dot object")
    if node.property and node.property.type != "String" {
      addError(state, node.property, "ANF invariant: dot property must be String")
    }
    validateNode(state, node.object)
    validateNode(state, node.property)
    return
  }

  if node.type == "Assignment" {
    if node.target.type == "Identifier" {
      // ok
    } else if node.target.type == "Index" {
      requireAtomic(state, node.target.object, "assignment index object")
      requireAtomic(state, node.target.index, "assignment index key")
    } else if node.target.type == "Dot" {
      requireAtomic(state, node.target.object, "assignment dot object")
      if node.target.property and node.target.property.type != "String" {
        addError(state, node.target.property, "ANF invariant: dot property must be String")
      }
    } else {
      addError(state, node.target, "ANF invariant: assignment target must be Identifier/Index/Dot")
    }
    requireAtomic(state, node.value, "assignment value")
    validateNode(state, node.target)
    validateNode(state, node.value)
    return
  }

  if node.type == "Import" {
    validateNode(state, node.path)
    return
  }
}

fn validate(ast, opts) {
  let state = .{
    errors: [],
  }
  validateNode(state, ast)
  .{
    success: len(state.errors) == 0,
    errors: state.errors,
  }
}

validate
