// Typechecker - monomorphic type inference with constraints.
//
// Pipeline assumptions:
// - Runs on lowered AST (no Arrow nodes; root is an implicit Block).
// - Uses resolver side tables to map Identifier â†’ declaration (`declaredAt`).
// - Unresolved names are `builtin` and type as Any at this phase.
//
// Features in this implementation:
// - Structural types: Array[T], Map[K,V], Record{...}, Option[T], Function(...)
// - Constraint solving + a single function body refinement pass.

let helper = import "src/typecheck-helper.lx"

// ========================================================
// Type Constructors
// ========================================================

fn typeAny()     { .{ kind: "Any" } }
fn typeNil()     { .{ kind: "Nil" } }
fn typeNumber()  { .{ kind: "Number" } }
fn typeBool()    { .{ kind: "Bool" } }
fn typeString()  { .{ kind: "String" } }

fn typeVar(id) {
  .{ kind: "TypeVar", id: id }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params: params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem: elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields: fields }
}

fn typeMap(key, elem) {
  .{ kind: "Map", key: key, elem: elem }
}

fn typeOption(value) {
  // Avoid Option[Option[T]]
  value and value.kind == "Option" and value or .{ kind: "Option", value: value }
}

fn typeIndexable(elem, key, nodeId) {
  .{
    kind: "Indexable",
    elem: elem,
    key: key,
    nodeId: nodeId,
  }
}

// ========================================================
// Type Variable Management
// ========================================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = id + 1
  typeVar(id)
}

fn getTypeVarBinding(checker, id) {
  checker.typeVarBindings[id]
}

// Follow bindings until fixed point
fn deref(checker, type) {
  if type.kind == "TypeVar" {
    let bound = getTypeVarBinding(checker, type.id)
    if bound {
      return deref(checker, bound)
    }
  }
  type
}

fn typeEquals(checker, a, b) {
  let eq
  eq = fn(x, y, depth) {
    if depth > 200 {
      // Defensive: if something went cyclic due to a bug, be conservative and
      // treat as not equal so we don't suppress progress.
      return false
    }
    x = x and deref(checker, x) or x
    y = y and deref(checker, y) or y

    if !x and !y { return true }
    if !x or !y { return false }

    // Fast paths
    if x.kind != y.kind { return false }
    if x.kind == "Any" or x.kind == "Nil" or x.kind == "Number" or
       x.kind == "Bool" or x.kind == "String" {
      return true
    }
    if x.kind == "TypeVar" { return x.id == y.id }

    if x.kind == "Array" { return eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Map" { return eq(x.key, y.key, depth + 1) and eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Option" { return eq(x.value, y.value, depth + 1) }
    if x.kind == "Function" {
      if len(x.params) != len(y.params) { return false }
      for let i = 0; i < len(x.params); i = i + 1 {
        if !eq(x.params[i], y.params[i], depth + 1) { return false }
      }
      return eq(x.return, y.return, depth + 1)
    }
    if x.kind == "Record" {
      let kx = keys(x.fields)
      let ky = keys(y.fields)
      if len(kx) != len(ky) { return false }
      for let i = 0; i < len(kx); i = i + 1 {
        let k = kx[i]
        if !y.fields[k] { return false }
        if !eq(x.fields[k], y.fields[k], depth + 1) { return false }
      }
      return true
    }

    // Fallback: treat as not equal.
    false
  }

  eq(a, b, 0)
}

fn bindTypeVar(checker, id, type) {
  let old = checker.typeVarBindings[id]
  if !old {
    checker.typeVarBindings[id] = type
    checker.changed = true
    return
  }

  // Avoid counting no-op rebindings as progress.
  if typeEquals(checker, old, type) {
    return
  }

  checker.typeVarBindings[id] = type
  checker.changed = true
}

fn derefWithRootVar(checker, t) {
  let root = nil
  for t and t.kind == "TypeVar" {
    root = t
    let bound = getTypeVarBinding(checker, t.id)
    if !bound { break }
    t = bound
  }
  .{ root: root, type: t }
}

// Occurs check: prevent infinite types
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for let i = 0; i < len(type.params); i = i + 1 {
      if occurs(checker, typeVarId, type.params[i]) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Map" {
    return occurs(checker, typeVarId, type.key) or occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Option" {
    return occurs(checker, typeVarId, type.value)
  }

  if type.kind == "Record" {
    let ks = keys(type.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      if occurs(checker, typeVarId, type.fields[ks[i]]) {
        return true
      }
    }
  }

  false
}

fn derefAll(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Function" {
    let ps = []
    for let i = 0; i < len(t.params); i = i + 1 {
      push(ps, derefAll(checker, t.params[i]))
    }
    return typeFunction(ps, derefAll(checker, t.return))
  }

  if t.kind == "Array" {
    return typeArray(derefAll(checker, t.elem))
  }

  if t.kind == "Map" {
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Option" {
    let v = derefAll(checker, t.value)
    if v and v.kind == "Nil" {
      return typeNil()
    }
    return typeOption(v)
  }

  if t.kind == "Indexable" {
    // Should be finalized away; default to Map for a stable printed type.
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Record" {
    let fields = .{}
    let ks = keys(t.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      fields[ks[i]] = derefAll(checker, t.fields[ks[i]])
    }
    return typeRecord(fields)
  }

  t
}

// ========================================================
// Error Handling
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}


// ========================================================
// Unification (Eager, Structural)
// ========================================================

fn unify(checker, t1, t2) {
  let d1 = derefWithRootVar(checker, t1)
  let d2 = derefWithRootVar(checker, t2)

  let root1 = d1.root
  let root2 = d2.root

  t1 = d1.type
  t2 = d2.type

  // Fast path
  if t1.kind == t2.kind {
    if t1.kind == "TypeVar" {
      if t1.id == t2.id { return true }
      bindTypeVar(checker, t1.id, t2)
      return true
    }

    if t1.kind == "Function" {
      if len(t1.params) != len(t2.params) { return false }
      for let i = 0; i < len(t1.params); i = i + 1 {
        if !unify(checker, t1.params[i], t2.params[i]) {
          return false
        }
      }
      return unify(checker, t1.return, t2.return)
    }

    if t1.kind == "Array" {
      return unify(checker, t1.elem, t2.elem)
    }

    if t1.kind == "Map" {
      return unify(checker, t1.key, t2.key) and unify(checker, t1.elem, t2.elem)
    }

    if t1.kind == "Option" {
      return unify(checker, t1.value, t2.value)
    }

    if t1.kind == "Record" {
      let k1 = keys(t1.fields)
      let k2 = keys(t2.fields)
      if len(k1) != len(k2) { return false }
      for let i = 0; i < len(k1); i = i + 1 {
        let k = k1[i]
        if !t2.fields[k] { return false }
        if !unify(checker, t1.fields[k], t2.fields[k]) {
          return false
        }
      }
      return true
    }

    // Primitive types
    return true
  }

  // Any absorbs everything (but still bind TypeVars so they don't stay unconstrained).
  if t1.kind == "Any" {
    if root2 and root2.kind == "TypeVar" { bindTypeVar(checker, root2.id, t1) }
    return true
  }
  if t2.kind == "Any" {
    if root1 and root1.kind == "TypeVar" { bindTypeVar(checker, root1.id, t2) }
    return true
  }

  // Indexable can be committed by unifying with a concrete container type.
  if t1.kind == "Indexable" and root1 and root1.kind == "TypeVar" {
    if t2.kind == "Array" {
      unify(checker, t1.elem, t2.elem)
      unify(checker, t1.key, typeNumber())
      bindTypeVar(checker, root1.id, typeArray(t1.elem))
      return true
    }
    if t2.kind == "Map" {
      unify(checker, t1.key, t2.key)
      unify(checker, t1.elem, t2.elem)
      bindTypeVar(checker, root1.id, typeMap(t1.key, t1.elem))
      return true
    }
    if t2.kind == "String" {
      unify(checker, t1.key, typeNumber())
      unify(checker, t1.elem, typeString())
      bindTypeVar(checker, root1.id, typeString())
      return true
    }
  }
  if t2.kind == "Indexable" and root2 and root2.kind == "TypeVar" {
    if t1.kind == "Array" {
      unify(checker, t2.elem, t1.elem)
      unify(checker, t2.key, typeNumber())
      bindTypeVar(checker, root2.id, typeArray(t2.elem))
      return true
    }
    if t1.kind == "Map" {
      unify(checker, t2.key, t1.key)
      unify(checker, t2.elem, t1.elem)
      bindTypeVar(checker, root2.id, typeMap(t2.key, t2.elem))
      return true
    }
    if t1.kind == "String" {
      unify(checker, t2.key, typeNumber())
      unify(checker, t2.elem, typeString())
      bindTypeVar(checker, root2.id, typeString())
      return true
    }
  }

  // Nil promotes to Option[T] (without double-wrapping).
  // This is how `nil` participates in "optional" types.
  fn optionizeRoot(root, baseType) {
    if !root or root.kind != "TypeVar" { return false }
    // Avoid binding a typevar to Option(of itself).
    let inner = baseType
    if baseType and baseType.kind == "TypeVar" and baseType.id == root.id {
      inner = freshTypeVar(checker)
    }
    bindTypeVar(checker, root.id, typeOption(inner))
    true
  }

  if t1.kind == "Nil" {
    if t2.kind == "Option" { return true }
    // Prefer to annotate the non-nil side's root var when possible.
    if optionizeRoot(root2, t2) { return true }
    if optionizeRoot(root1, t2) { return true }
    return true
  }

  if t2.kind == "Nil" {
    if t1.kind == "Option" { return true }
    if optionizeRoot(root1, t1) { return true }
    if optionizeRoot(root2, t1) { return true }
    return true
  }

  // Option[T] can unify with T (implicit lifting).
  if t1.kind == "Option" {
    return unify(checker, t1.value, t2)
  }
  if t2.kind == "Option" {
    return unify(checker, t1, t2.value)
  }

  // TypeVar binding
  if t1.kind == "TypeVar" {
    if occurs(checker, t1.id, t2) { return false }
    bindTypeVar(checker, t1.id, t2)
    return true
  }

  if t2.kind == "TypeVar" {
    if occurs(checker, t2.id, t1) { return false }
    bindTypeVar(checker, t2.id, t1)
    return true
  }

  false
}

fn constrain(checker, t1, t2, nodeId, msg) {
  if !unify(checker, t1, t2) {
    addError(checker, nodeId, msg)
    return typeAny()
  }
  t1
}

// ========================================================
// Constraints (Phase 2)
// ========================================================

fn emitEq(checker, t1, t2, nodeId, msg) {
  push(checker.constraints, .{
    kind: "Eq",
    t1: t1,
    t2: t2,
    nodeId: nodeId,
    msg: msg,
  })
  t2
}

fn emitHasField(checker, base, name, fieldType, nodeId, msg) {
  push(checker.constraints, .{
    kind: "HasField",
    base: base,
    fieldName: name,
    fieldType: fieldType,
    nodeId: nodeId,
    msg: msg,
  })
  fieldType
}

fn emitCall(checker, callee, args, argNodeIds, out, nodeId) {
  push(checker.constraints, .{
    kind: "Call",
    callee: callee,
    args: args,
    argNodeIds: argNodeIds,
    out: out,
    nodeId: nodeId,
  })
  out
}

fn emitKeyLike(checker, t, nodeId) {
  push(checker.constraints, .{
    kind: "KeyLike",
    t: t,
    nodeId: nodeId,
    msg: "Hashmap key type must be number or string.",
  })
  t
}

fn emitIndex(checker, base, index, out, nodeId) {
  push(checker.constraints, .{
    kind: "Index",
    base: base,
    index: index,
    // If index expression is a literal String/Number (possibly via Grouping),
    // carry the key so Records can enforce closed-shape access.
    literalKey: nil,
    out: out,
    nodeId: nodeId,
  })
  out
}

fn emitIndexSet(checker, base, index, value, nodeId) {
  push(checker.constraints, .{
    kind: "IndexSet",
    base: base,
    index: index,
    literalKey: nil,
    value: value,
    nodeId: nodeId,
  })
  value
}

fn containEqFailure(checker, t1, t2) {
  if t1.kind == "TypeVar" { bindTypeVar(checker, t1.id, typeAny()) }
  if t2.kind == "TypeVar" { bindTypeVar(checker, t2.id, typeAny()) }
}

fn containHasFieldFailure(checker, fieldType) {
  if fieldType.kind == "TypeVar" {
    bindTypeVar(checker, fieldType.id, typeAny())
  }
}

fn trySolveConstraint(checker, c) {
  if c.kind == "Eq" {
    if !unify(checker, c.t1, c.t2) {
      addError(checker, c.nodeId, c.msg)
      containEqFailure(checker, deref(checker, c.t1), deref(checker, c.t2))
    }
    return true
  }

  if c.kind == "HasField" {
    let ft = deref(checker, c.fieldType)

    // Preserve the root typevar (for better containment), but do not "grow" records.
    let baseInfo = derefWithRootVar(checker, c.base)
    let root = baseInfo.root
    let base = baseInfo.type

    // Option[T] can be accessed as T (implicit lifting).
    if base.kind == "Option" and base.value {
      base = deref(checker, base.value)
    }

    if base.kind == "Any" {
      if ft.kind == "TypeVar" { bindTypeVar(checker, ft.id, typeAny()) }
      return true
    }

    // If the base is (or was) a typevar, consult its binding but do not extend.
    if root and root.kind == "TypeVar" {
      let binding = getTypeVarBinding(checker, root.id)
      if !binding {
        // Not enough information yet; keep the constraint around.
        return false
      }
      if binding.kind == "Any" {
        if ft.kind == "TypeVar" { bindTypeVar(checker, ft.id, typeAny()) }
        return true
      }
      if binding.kind == "Record" {
        let field = binding.fields[c.fieldName]
        if !field {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        } else if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
        return true
      }
      addError(checker, c.nodeId, c.msg)
      containHasFieldFailure(checker, ft)
      return true
    }

    // Closed record: must contain the field.
    if base.kind == "Record" {
      let field = base.fields[c.fieldName]
      if field {
        if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
      } else {
        addError(checker, c.nodeId, c.msg)
        containHasFieldFailure(checker, ft)
      }
      return true
    }

    // Non-record base
    addError(checker, c.nodeId, c.msg)
    containHasFieldFailure(checker, ft)
    return true
  }

  if c.kind == "Call" {
    let callee = derefWithRootVar(checker, c.callee)
    let root = callee.root
    let t = callee.type

    // If callee is still an unbound typevar, infer it as a function with
    // required param count equal to the call arg count (extra args remain allowed).
    if root and root.kind == "TypeVar" and t.kind == "TypeVar" and !getTypeVarBinding(checker, root.id) {
      let params = []
      for let i = 0; i < len(c.args); i = i + 1 {
        push(params, freshTypeVar(checker))
      }
      bindTypeVar(checker, root.id, typeFunction(params, c.out))
      return true
    }

    t = deref(checker, t)

    if t.kind == "Any" {
      if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      return true
    }

    if t.kind != "Function" {
      addError(checker, c.nodeId, "Call requires function")
      if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      return true
    }

    let params = t.params
    let args = c.args

    if len(args) < len(params) {
      addError(checker, c.nodeId,
        "Too few arguments: expected at least " + str(len(params)) + ", got " + str(len(args)))
      if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      return true
    }

    // Constrain only the required args; ignore extras.
    for let i = 0; i < len(params); i = i + 1 {
      let ok = unify(checker, args[i], params[i])
      if !ok {
        let nid = (c.argNodeIds and c.argNodeIds[i]) or c.nodeId
        addError(checker, nid, "Argument mismatch")
        containEqFailure(checker, deref(checker, args[i]), deref(checker, params[i]))
      }
    }

    if !unify(checker, c.out, t.return) {
      addError(checker, c.nodeId, "Return mismatch")
      containEqFailure(checker, deref(checker, c.out), deref(checker, t.return))
      if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
    }

    return true
  }

  if c.kind == "KeyLike" {
    let info = derefWithRootVar(checker, c.t)
    let root = info.root
    let t = deref(checker, info.type)

    if t.kind == "Any" { return true }
    if t.kind == "Number" or t.kind == "String" { return true }

    if root and root.kind == "TypeVar" and t.kind == "TypeVar" and !getTypeVarBinding(checker, root.id) {
      return false
    }

    addError(checker, c.nodeId, c.msg)
    if root and root.kind == "TypeVar" { bindTypeVar(checker, root.id, typeAny()) }
    return true
  }

  if c.kind == "Index" {
    let baseInfo = derefWithRootVar(checker, c.base)
    let root = baseInfo.root
    let base = deref(checker, baseInfo.type)
    let idx = deref(checker, c.index)

    if base.kind == "Any" {
      if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      return true
    }

    if base.kind == "Record" {
      if c.literalKey == nil {
        addError(checker, c.nodeId, "Record index must be a literal string or number key")
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
        return true
      }
      let ft = base.fields[c.literalKey]
      if !ft {
        addError(checker, c.nodeId, "Missing field: " + str(c.literalKey))
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
        return true
      }
      if !unify(checker, c.out, ft) {
        addError(checker, c.nodeId, "Index result mismatch")
        containEqFailure(checker, deref(checker, c.out), deref(checker, ft))
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      }
      return true
    }

    if base.kind == "Array" {
      if !unify(checker, c.index, typeNumber()) {
        addError(checker, c.nodeId, "Array index must be a number")
        containEqFailure(checker, deref(checker, c.index), typeNumber())
      }
      if !unify(checker, c.out, base.elem) {
        addError(checker, c.nodeId, "Index result mismatch")
        containEqFailure(checker, deref(checker, c.out), deref(checker, base.elem))
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      }
      return true
    }
    if base.kind == "Map" {
      emitKeyLike(checker, base.key, c.nodeId)
      if !unify(checker, c.index, base.key) {
        addError(checker, c.nodeId, "Map key mismatch")
        containEqFailure(checker, deref(checker, c.index), deref(checker, base.key))
      }
      if !unify(checker, c.out, base.elem) {
        addError(checker, c.nodeId, "Index result mismatch")
        containEqFailure(checker, deref(checker, c.out), deref(checker, base.elem))
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      }
      return true
    }
    if base.kind == "String" {
      if !unify(checker, c.index, typeNumber()) {
        addError(checker, c.nodeId, "String index must be a number")
        containEqFailure(checker, deref(checker, c.index), typeNumber())
      }
      if !unify(checker, c.out, typeString()) {
        addError(checker, c.nodeId, "Index result mismatch")
        containEqFailure(checker, deref(checker, c.out), typeString())
        if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      }
      return true
    }

    if root and root.kind == "TypeVar" and base.kind == "TypeVar" and !getTypeVarBinding(checker, root.id) {
      let elemT = freshTypeVar(checker)
      let keyT = freshTypeVar(checker)
      bindTypeVar(checker, root.id, typeIndexable(elemT, keyT, c.nodeId))
      emitKeyLike(checker, keyT, c.nodeId)
      return false
    }

    if base.kind == "Indexable" {
      // Always unify output with element; commit decisions come from index evidence.
      unify(checker, c.out, base.elem)

      // If index is non-number, array/string cannot apply -> commit to Map.
      if idx and idx.kind != "TypeVar" and idx.kind != "Number" {
        // KeyLike already enforced; now commit to Map.
        bindTypeVar(checker, root.id, typeMap(base.key, base.elem))
        if !unify(checker, base.key, c.index) {
          addError(checker, c.nodeId, "Map key mismatch")
          containEqFailure(checker, deref(checker, base.key), deref(checker, c.index))
        }
        return true
      }

      // Numeric or unknown: still ambiguous; keep constraint.
      return false
    }

    // Not indexable
    addError(checker, c.nodeId, "Only array / hashmap / string can get value by index.")
    if c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
    return true
  }

  if c.kind == "IndexSet" {
    let baseInfo = derefWithRootVar(checker, c.base)
    let root = baseInfo.root
    let base = deref(checker, baseInfo.type)
    let idx = deref(checker, c.index)

    if base.kind == "Any" { return true }

    if base.kind == "Record" {
      if c.literalKey == nil {
        addError(checker, c.nodeId, "Record index assignment must use a literal string or number key")
        return true
      }
      let ft = base.fields[c.literalKey]
      if !ft {
        addError(checker, c.nodeId, "Missing field: " + str(c.literalKey))
        return true
      }
      if !unify(checker, c.value, ft) {
        addError(checker, c.nodeId, "Index assignment mismatch")
        containEqFailure(checker, deref(checker, c.value), deref(checker, ft))
      }
      return true
    }

    if base.kind == "Array" {
      if !unify(checker, c.index, typeNumber()) {
        addError(checker, c.nodeId, "Array index must be a number")
        containEqFailure(checker, deref(checker, c.index), typeNumber())
      }
      if !unify(checker, c.value, base.elem) {
        addError(checker, c.nodeId, "Index assignment mismatch")
        containEqFailure(checker, deref(checker, c.value), deref(checker, base.elem))
      }
      return true
    }
    if base.kind == "Map" {
      emitKeyLike(checker, base.key, c.nodeId)
      if !unify(checker, c.index, base.key) {
        addError(checker, c.nodeId, "Map key mismatch")
        containEqFailure(checker, deref(checker, c.index), deref(checker, base.key))
      }
      if !unify(checker, c.value, base.elem) {
        addError(checker, c.nodeId, "Index assignment mismatch")
        containEqFailure(checker, deref(checker, c.value), deref(checker, base.elem))
      }
      return true
    }
    if base.kind == "String" {
      addError(checker, c.nodeId, "Cannot assign into string by index.")
      return true
    }

    if root and root.kind == "TypeVar" and base.kind == "TypeVar" and !getTypeVarBinding(checker, root.id) {
      let elemT = freshTypeVar(checker)
      let keyT = freshTypeVar(checker)
      bindTypeVar(checker, root.id, typeIndexable(elemT, keyT, c.nodeId))
      emitKeyLike(checker, keyT, c.nodeId)
      return false
    }

    if base.kind == "Indexable" {
      unify(checker, c.value, base.elem)

      if idx and idx.kind != "TypeVar" and idx.kind != "Number" {
        bindTypeVar(checker, root.id, typeMap(base.key, base.elem))
        if !unify(checker, base.key, c.index) {
          addError(checker, c.nodeId, "Map key mismatch")
          containEqFailure(checker, deref(checker, base.key), deref(checker, c.index))
        }
        return true
      }

      return false
    }

    addError(checker, c.nodeId, "Only array / hashmap / string can set value by index.")
    return true
  }

  false
}

fn solveConstraints(checker) {
  let out = helper.solveWorklist(
    checker.constraints,
    fn(c) { trySolveConstraint(checker, c) },
    .{
      maxRounds: 1000,
      resetProgress: fn() { checker.changed = false },
      progress: fn() { checker.changed },
      onMaxRounds: fn(meta) { checker.solverHitMaxRounds = meta },
    },
  )
  checker.constraints = out.remaining

  if out.hitMaxRounds {
    let kinds = []
    for let i = 0; i < len(out.remaining) and i < 10; i = i + 1 {
      let c = out.remaining[i]
      push(kinds, c.kind)
    }
    let nodeId = (len(out.remaining) > 0 and out.remaining[0].nodeId) or 0
    addError(checker, nodeId,
      "Constraint solver exceeded maxRounds (" + str(out.rounds) + "); remaining: " +
      str(len(out.remaining)) + " (" + join(kinds, ", ") + ")")
  }
}

fn finalizeConstraints(checker) {
  // Any remaining constraints are unsolvable with the collected info;
  // report errors and contain to Any so downstream tooling doesn't crash.
  let remaining = checker.constraints
  checker.constraints = []

  for let i = 0; i < len(remaining); i = i + 1 {
    let c = remaining[i]
    if trySolveConstraint(checker, c) { continue }

    if c.kind == "HasField" {
      addError(checker, c.nodeId, c.msg)
      containHasFieldFailure(checker, deref(checker, c.fieldType))
      // If base is still unconstrained, contain it to Any.
      let baseInfo = derefWithRootVar(checker, c.base)
      if baseInfo and baseInfo.root and baseInfo.root.kind == "TypeVar" and !getTypeVarBinding(checker, baseInfo.root.id) {
        bindTypeVar(checker, baseInfo.root.id, typeAny())
      }
    }

    if c.kind == "Call" {
      addError(checker, c.nodeId, "Unresolved call")
      if c.out and c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      let callee = derefWithRootVar(checker, c.callee)
      if callee and callee.root and callee.root.kind == "TypeVar" and !getTypeVarBinding(checker, callee.root.id) {
        bindTypeVar(checker, callee.root.id, typeAny())
      }
    }

    if c.kind == "Index" {
      addError(checker, c.nodeId, "Unresolved index")
      if c.out and c.out.kind == "TypeVar" { bindTypeVar(checker, c.out.id, typeAny()) }
      let baseInfo = derefWithRootVar(checker, c.base)
      if baseInfo and baseInfo.root and baseInfo.root.kind == "TypeVar" and !getTypeVarBinding(checker, baseInfo.root.id) {
        bindTypeVar(checker, baseInfo.root.id, typeAny())
      }
    }

    if c.kind == "IndexSet" {
      addError(checker, c.nodeId, "Unresolved index assignment")
      let baseInfo = derefWithRootVar(checker, c.base)
      if baseInfo and baseInfo.root and baseInfo.root.kind == "TypeVar" and !getTypeVarBinding(checker, baseInfo.root.id) {
        bindTypeVar(checker, baseInfo.root.id, typeAny())
      }
    }

    if c.kind == "KeyLike" {
      // If still unbound at finalize time, degrade to Any without emitting
      // an additional error (no evidence the key is invalid).
      let info = derefWithRootVar(checker, c.t)
      if info and info.root and info.root.kind == "TypeVar" and !getTypeVarBinding(checker, info.root.id) {
        bindTypeVar(checker, info.root.id, typeAny())
      } else {
        // Otherwise, force solver to report a concrete mismatch.
        addError(checker, c.nodeId, c.msg)
      }
    }
  }
}

fn finalizeIndexables(checker) {
  let ids = keys(checker.typeVarBindings)
  for let i = 0; i < len(ids); i = i + 1 {
    let id = ids[i]
    // Defensively ensure we use numeric ids as stored by typeVarBindings.
    if type(id) == "string" { id = int(tonumber(id) or 0) }

    let t = deref(checker, checker.typeVarBindings[id])
    if t and t.kind == "Indexable" {
      let nid = t.nodeId or 0
      addError(checker, nid, "Ambiguous indexed container; defaulting to Map")
      bindTypeVar(checker, id, typeMap(t.key, t.elem))
    }
  }
}


// ========================================================
// Type Environment (Lexical, No Cloning)
// ========================================================

fn TypeEnv(parent) {
  .{
    parent: parent,
    bindings: .{}, // declNodeId -> TypeVar
  }
}

fn lookupDecl(checker, declNodeId) {
  let env = checker.currentEnv
  for env {
    let t = env.bindings[declNodeId]
    if t { return t }
    env = env.parent
  }
  nil
}

fn bindDecl(checker, declNodeId) {
  let tv = freshTypeVar(checker)
  checker.currentEnv.bindings[declNodeId] = tv
  tv
}

fn enterScope(checker) {
  checker.currentEnv = TypeEnv(checker.currentEnv)
}

fn exitScope(checker) {
  checker.currentEnv = checker.currentEnv.parent
}


// ========================================================
// Expression Checking (Pure Phase 1)
// ========================================================

let synthExpr

// Some lowers wrap expressions as statements.
fn checkExprStmt(checker, node) {
  // Lower often wraps top-level statements this way.
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

fn checkLiteral(checker, node) {
  let t =
    node.type == "Number" and typeNumber() or
    node.type == "String" and typeString() or
    node.type == "Bool"   and typeBool()   or
    typeNil()

  checker.types[node.id] = t
  t
}

fn checkIdentifier(checker, node) {
  let binding = checker.resolvedNames[node.id]
  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Builtins/external names are not tracked by declaredAt.
  // Treat them as Any at this phase.
  if binding.kind == "builtin" {
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let declId = binding.declaredAt
  if !declId {
    // Compiler bug / unexpected resolver output; contain to Any.
    addError(checker, node.id, "Missing declaredAt for identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }
  let tv = lookupDecl(checker, declId)
  if !tv {
    tv = bindDecl(checker, declId)
  }

  checker.types[node.id] = tv
  tv
}

fn checkBinary(checker, node) {
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "+" {
    let l = deref(checker, lt)
    let r = deref(checker, rt)

    // Overloaded: Number + Number -> Number, String + String -> String
    if l.kind == "String" or r.kind == "String" {
      emitEq(checker, lt, typeString(), node.left.id, "Expected string")
      emitEq(checker, rt, typeString(), node.right.id, "Expected string")
      let t = typeString()
      checker.types[node.id] = t
      return t
    }

    // Default: numeric add (also helps inference for `fn add(a,b){a+b}`).
    emitEq(checker, lt, typeNumber(), node.left.id, "Expected number")
    emitEq(checker, rt, typeNumber(), node.right.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "-" or op == "*" or op == "/" {
    emitEq(checker, lt, typeNumber(), node.left.id, "Expected number")
    emitEq(checker, rt, typeNumber(), node.right.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "==" or op == "!=" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  addError(checker, node.id, "Unsupported binary operator")
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkCall(checker, node) {
  let callee = synthExpr(checker, node.callee)
  let args = []
  let argNodeIds = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(args, synthExpr(checker, node.args[i]))
    push(argNodeIds, node.args[i].id)
  }

  let out = freshTypeVar(checker)
  emitCall(checker, callee, args, argNodeIds, out, node.id)
  checker.types[node.id] = out
  out
}

fn checkFunction(checker, node) {
  // If this function is named (hoisted), ensure its declaration binding exists.
  let fnBinding = nil
  if node.name {
    fnBinding = lookupDecl(checker, node.id)
    if !fnBinding {
      fnBinding = bindDecl(checker, node.id)
    }
  }

  // Capture the lexical environment where this function is defined so the
  // refinement pass can see outer bindings (closures).
  let defEnv = checker.currentEnv

  enterScope(checker)

  let params = []
  for let i = 0; i < len(node.params); i = i + 1 {
    let tv = bindDecl(checker, node.params[i].id)
    checker.types[node.params[i].id] = tv
    push(params, tv)
  }

  let ret = freshTypeVar(checker)
  let prevReturn = checker.currentReturn
  checker.currentReturn = ret
  let bodyT = synthExpr(checker, node.body)
  checker.currentReturn = prevReturn
  emitEq(checker, bodyT, ret, node.body.id, "Return mismatch")

  exitScope(checker)

  // Store the function type with current bindings resolved.
  let resolvedParams = []
  for let i = 0; i < len(params); i = i + 1 {
    push(resolvedParams, deref(checker, params[i]))
  }
  let fnT = typeFunction(resolvedParams, deref(checker, ret))
  checker.types[node.id] = fnT
  if fnBinding {
    emitEq(checker, fnBinding, fnT, node.id, "Function declaration mismatch")
    checker.types[node.name.id] = fnBinding
  }

  // Track for second-pass refinement
  push(checker.functionInfos, .{
    node: node,
    defEnv: defEnv,
    params: params,
    ret: ret,
    fnType: fnT,
  })
  fnT
}

fn checkLet(checker, node) {
  let tv = bindDecl(checker, node.name.id)
  checker.types[node.name.id] = tv

  if node.init {
    let it = synthExpr(checker, node.init)
    constrain(checker, tv, it, node.init.id, "Initializer mismatch")
  }

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkIf(checker, node) {
  synthExpr(checker, node.condition)
  let thenT = synthExpr(checker, node.then)

  if node.else {
    let elseT = synthExpr(checker, node.else)
    let outT = freshTypeVar(checker)
    constrain(checker, outT, thenT, node.then.id, "Branch mismatch")
    constrain(checker, outT, elseT, node.else.id, "Branch mismatch")
    checker.types[node.id] = outT
    return outT
  }

  // If without else returns Option[T].
  let t = typeOption(thenT)
  checker.types[node.id] = t
  t
}

fn checkBlock(checker, node) {
  enterScope(checker)

  let lastT = typeNil()
  if node.expressions {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      lastT = synthExpr(checker, node.expressions[i])
    }
  }

  exitScope(checker)

  checker.types[node.id] = lastT
  lastT
}

fn checkGrouping(checker, node) {
  let t = synthExpr(checker, node.expression)
  checker.types[node.id] = t
  t
}

fn checkUnary(checker, node) {
  let ot = synthExpr(checker, node.operand)
  let op = node.operator.lexeme

  // Minimal Phase-1 semantics
  if op == "-" {
    emitEq(checker, ot, typeNumber(), node.operand.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "!" {
    emitEq(checker, ot, typeBool(), node.operand.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  // Unknown unary -> Any, but still traversed operand
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkLogical(checker, node) {
  // NOTE: pick semantics. If Lx is Lua-like and returns operands,
  // you cannot type it as Bool in general.
  // For Phase 1, simplest is to require bool operands and return bool.
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "and" or op == "or" {
    emitEq(checker, lt, typeBool(), node.left.id, "Expected bool")
    emitEq(checker, rt, typeBool(), node.right.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkFor(checker, node) {
  enterScope(checker)

  if node.init      { synthExpr(checker, node.init) }
  if node.condition {
    let ct = synthExpr(checker, node.condition)
    // If you want: constrain condition to Bool
    emitEq(checker, ct, typeBool(), node.condition.id, "Expected bool")
  }
  if node.update    { synthExpr(checker, node.update) }

  // Body can be Block or any stmt/expr
  if node.body      { synthExpr(checker, node.body) }

  exitScope(checker)

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkReturn(checker, node) {
  let rt = typeNil()
  if node.value { rt = synthExpr(checker, node.value) }

  if checker.currentReturn {
    emitEq(checker, checker.currentReturn, rt, node.id, "Return mismatch")
  }

  // Treat `return expr` as having the expression's type so block "last expr"
  // can still drive function return inference.
  checker.types[node.id] = rt
  rt
}

fn checkBreak(checker, node) {
  if node.value { synthExpr(checker, node.value) }
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkContinue(checker, node) {
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkArray(checker, node) {
  let elemT = freshTypeVar(checker)
  if node.elements {
    for let i = 0; i < len(node.elements); i = i + 1 {
      let it = synthExpr(checker, node.elements[i])
      emitEq(checker, it, elemT, node.elements[i].id, "Array element mismatch")
    }
  }
  let t = typeArray(elemT)
  checker.types[node.id] = t
  t
}

fn checkHashmap(checker, node) {
  // Hashmap literals:
  // - Empty `.{}` is a Map (hashmap).
  // - Any non-empty `.{ ... }` is a closed Record.
  // - Computed keys in a Record must be literal String/Number (Option A).
  let fields = .{}

  // Empty literal `.{}` is treated as an empty hashmap.
  if !node.pairs or len(node.pairs) == 0 {
    let keyT = freshTypeVar(checker)
    let elemT = freshTypeVar(checker)
    let t = typeMap(keyT, elemT)
    emitKeyLike(checker, keyT, node.id)
    checker.types[node.id] = t
    return t
  }

  for let i = 0; i < len(node.pairs); i = i + 1 {
    let p = node.pairs[i]
    if p.key { synthExpr(checker, p.key) }
    if p.value { synthExpr(checker, p.value) }

    // Determine record field key.
    // Bare keys are normalized to String nodes with lexeme not starting with '"'.
    // Computed keys (`[expr]`) come through as expression nodes; we only accept
    // literal String/Number for closed record shapes.
    let key = nil
    if p.key and p.key.type == "String" and p.key.lexeme and len(p.key.lexeme) > 0 and p.key.lexeme[0] != "\"" {
      // Bare key: `.{ a: 1 }`
      key = p.key.value
    } else if p.key and p.key.type == "String" {
      // Computed string literal: `.{ [\"a\"]: 1 }`
      key = p.key.value
    } else if p.key and p.key.type == "Number" {
      // Computed number literal: `.{ [1]: \"a\" }`
      key = p.key.value
    }

    if key == nil {
      addError(checker, (p.key and p.key.id) or node.id,
        "Record literal computed key must be a string or number literal")
      continue
    }

    let existing = fields[key]
    let vType = checker.types[p.value.id] or typeAny()
    if existing {
      emitEq(checker, vType, existing, p.value.id, "Record field mismatch")
    } else {
      let fieldT = freshTypeVar(checker)
      emitEq(checker, vType, fieldT, p.value.id, "Record field mismatch")
      fields[key] = fieldT
    }
  }

  let t = typeRecord(fields)

  checker.types[node.id] = t
  t
}

fn literalKeyFromIndexExpr(node) {
  if !node { return nil }
  if node.type == "Grouping" {
    return literalKeyFromIndexExpr(node.expression)
  }
  if node.type == "String" { return node.value }
  if node.type == "Number" { return node.value }
  nil
}

fn checkIndex(checker, node) {
  let objT = synthExpr(checker, node.object)
  let idxT = synthExpr(checker, node.index)
  let out = freshTypeVar(checker)
  let c = .{
    kind: "Index",
    base: objT,
    index: idxT,
    literalKey: literalKeyFromIndexExpr(node.index),
    out: out,
    nodeId: node.id,
  }
  push(checker.constraints, c)
  checker.types[node.id] = out
  out
}

fn checkDot(checker, node) {
  let objT = synthExpr(checker, node.object)
  // property is a Node (Identifier or StringKey)
  let propName = nil
  if node.property and node.property.type == "Identifier" {
    propName = node.property.name
  } else if node.property and node.property.type == "String" {
    propName = node.property.value
  } else {
    if node.property { synthExpr(checker, node.property) }
  }

  if !propName {
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let fieldT = freshTypeVar(checker)
  emitHasField(checker, objT, propName, fieldT, node.id, "Missing field: " + propName)
  checker.types[node.id] = fieldT
  fieldT
}

fn checkAssignment(checker, node) {
  let vt = synthExpr(checker, node.value)

  // Minimal: only support assignment to Identifier in Phase 1
  if node.target and node.target.type == "Identifier" {
    let lt = synthExpr(checker, node.target)
    emitEq(checker, lt, vt, node.id, "Assignment mismatch")
    checker.types[node.id] = vt
    return vt
  }

  // Property assignment: base.field = value
  if node.target and node.target.type == "Dot" {
    let objT = synthExpr(checker, node.target.object)

    let propName = nil
    if node.target.property and node.target.property.type == "Identifier" {
      propName = node.target.property.name
    } else if node.target.property and node.target.property.type == "String" {
      propName = node.target.property.value
    } else {
      if node.target.property { synthExpr(checker, node.target.property) }
    }

    if propName {
      let fieldT = freshTypeVar(checker)
      emitHasField(checker, objT, propName, fieldT, node.target.id, "Missing field: " + propName)
      emitEq(checker, fieldT, vt, node.id, "Assignment mismatch")
      checker.types[node.target.id] = fieldT
      checker.types[node.id] = vt
      return vt
    }
  }

  // Index assignment: base[index] = value
  if node.target and node.target.type == "Index" {
    let objT = synthExpr(checker, node.target.object)
    let idxT = synthExpr(checker, node.target.index)
    push(checker.constraints, .{
      kind: "IndexSet",
      base: objT,
      index: idxT,
      literalKey: literalKeyFromIndexExpr(node.target.index),
      value: vt,
      nodeId: node.id,
    })
    checker.types[node.id] = vt
    return vt
  }

  // Traverse target anyway
  if node.target { synthExpr(checker, node.target) }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkImport(checker, node) {
  // Path is usually String or Identifier
  if node.path { synthExpr(checker, node.path) }

  // Resolver may attach module type information for the import expression.
  if node.importType {
    checker.types[node.id] = node.importType
    return node.importType
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn refineFunctions(checker) {
  for let i = 0; i < len(checker.functionInfos); i = i + 1 {
    let info = checker.functionInfos[i]
    checker.currentEnv = info.defEnv or checker.rootEnv
    enterScope(checker)

    if info.node.name {
      checker.currentEnv.bindings[info.node.id] = lookupDecl(checker, info.node.id) or info.fnType
    }

    for let p = 0; p < len(info.params); p = p + 1 {
      let paramNode = info.node.params[p]
      checker.currentEnv.bindings[paramNode.id] = info.params[p]
      checker.types[paramNode.id] = info.params[p]
    }

    let prevReturn = checker.currentReturn
    checker.currentReturn = info.ret
    let bodyT = synthExpr(checker, info.node.body)
    checker.currentReturn = prevReturn
    emitEq(checker, bodyT, info.ret, info.node.body.id, "Return mismatch")

    exitScope(checker)
  }
}


// ========================================================
// Dispatcher
// ========================================================

synthExpr = fn(checker, node) {
  if !node { return typeNil() }

  // Literals
  if node.type == "Number" or node.type == "String" or
     node.type == "Bool" or node.type == "Nil" {
    return checkLiteral(checker, node)
  }

  // Names / bindings
  if node.type == "Identifier" { return checkIdentifier(checker, node) }

  // Structural containers / wrappers
  if node.type == "Block"    { return checkBlock(checker, node) }
  if node.type == "Grouping" { return checkGrouping(checker, node) }

  // Operators
  if node.type == "Unary"      { return checkUnary(checker, node) }
  if node.type == "Binary"     { return checkBinary(checker, node) }
  if node.type == "Logical"    { return checkLogical(checker, node) }
  if node.type == "Assignment" { return checkAssignment(checker, node) }

  // Calls / access
  if node.type == "Call"  { return checkCall(checker, node) }
  if node.type == "Dot"   { return checkDot(checker, node) }
  if node.type == "Index" { return checkIndex(checker, node) }

  // Collections
  if node.type == "Array"   { return checkArray(checker, node) }
  if node.type == "Hashmap" { return checkHashmap(checker, node) }

  // Declarations / definitions
  if node.type == "Let"      { return checkLet(checker, node) }
  if node.type == "Function" { return checkFunction(checker, node) }
  if node.type == "Import"   { return checkImport(checker, node) }

  // Control flow
  if node.type == "If"       { return checkIf(checker, node) }
  if node.type == "For"      { return checkFor(checker, node) }
  if node.type == "Return"   { return checkReturn(checker, node) }
  if node.type == "Break"    { return checkBreak(checker, node) }
  if node.type == "Continue" { return checkContinue(checker, node) }

  // XXX: should be unreachable, can we catch this?
  addError(checker, node.id, "Unsupported node: " + node.type)
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// ========================================================
// Public API
// ========================================================

fn makeChecker(resolveResult) {
  let root = TypeEnv(nil)
  .{
    types: .{},
    typeVarBindings: .{},
    errors: [],
    hadError: false,

    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,

    nextTypeVarId: 1,
    currentEnv: root,
    rootEnv: root,

    constraints: [],
    functionInfos: [],

    currentReturn: nil,

    changed: false,
    solverHitMaxRounds: nil,
  }
}

fn predeclareTopLevel(checker, ast) {
  if !ast or ast.type != "Block" or !ast.expressions { return }

  for let i = 0; i < len(ast.expressions); i = i + 1 {
    let node = ast.expressions[i]
    if node.type == "Let" and node.name {
      if !lookupDecl(checker, node.name.id) {
        bindDecl(checker, node.name.id)
      }
    } else if node.type == "Function" and node.name {
      if !lookupDecl(checker, node.id) {
        bindDecl(checker, node.id)
      }
    }
  }
}

fn typecheck(ast, resolveResult) {
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      typeVarBindings: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  let checker = makeChecker(resolveResult)

  if !ast {
    // XXX: should we report some errors?
    return .{ success: false, types: .{}, typeVarBindings: .{}, errors: [] }
  }

  // Predeclare top-level lets/functions for forward references (Phase 2)
  predeclareTopLevel(checker, ast)

  synthExpr(checker, ast)

  // Solve constraints and refine functions once more
  solveConstraints(checker)
  refineFunctions(checker)
  solveConstraints(checker)
  finalizeIndexables(checker)
  solveConstraints(checker)
  finalizeConstraints(checker)

  let outTypes = .{}
  let typeKeys = keys(checker.types)
  for let i = 0; i < len(typeKeys); i = i + 1 {
    let k = typeKeys[i]
    outTypes[k] = derefAll(checker, checker.types[k])
  }

  let outBindings = .{}
  let bindKeys = keys(checker.typeVarBindings)
  for let i = 0; i < len(bindKeys); i = i + 1 {
    let k = bindKeys[i]
    outBindings[k] = derefAll(checker, checker.typeVarBindings[k])
  }

  .{
    success: !checker.hadError,
    types: outTypes,
    typeVarBindings: outBindings,
    errors: checker.errors,
  }
}

typecheck
