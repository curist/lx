// Typecheck Phase Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"

// Helper: parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{})
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    errors: typecheckResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

// Helper: Get type of expression in test block
fn getExprType(result, exprIndex) {
  // For tests like "{ expr1\nexpr2 }", ast.body[0] is the Block
  // and the expressions are in Block.expressions
  let ast = result.lowerResult.ast
  if !ast or !ast.body or len(ast.body) == 0 {
    return nil
  }

  let blockNode = ast.body[0]
  if !blockNode or blockNode.type != "Block" or !blockNode.expressions {
    return nil
  }

  if exprIndex >= len(blockNode.expressions) {
    return nil
  }

  let node = blockNode.expressions[exprIndex]

  // For Let nodes, get the type of the bound variable (from name.id)
  if node.type == "Let" {
    return result.types[node.name.id]
  }

  // Direct expression - return its type
  return result.types[node.id]
}

// Helper: Get the actual AST node at an index
fn getExprNode(result, exprIndex) {
  let ast = result.lowerResult.ast
  if len(ast.body) > 0 {
    let blockNode = ast.body[0]
    if blockNode.type == "Block" and exprIndex < len(blockNode.expressions) {
      return blockNode.expressions[exprIndex]
    }
  }
  nil
}

// ========================================
// Primitive Literals
// ========================================

test("typecheck - number literal", fn(assert) {
  let result = parseAndTypecheck("{ 42 }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Number", "42 should have type Number")
})

test("typecheck - string literal", fn(assert) {
  let result = parseAndTypecheck("{ \"hello\" }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "String", "\"hello\" should have type String")
})

test("typecheck - bool literal", fn(assert) {
  let result = parseAndTypecheck("{ true }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Bool", "true should have type Bool")
})

test("typecheck - nil literal", fn(assert) {
  let result = parseAndTypecheck("{ nil }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Nil", "nil should have type Nil")
})

// ========================================
// Variables
// ========================================

test("typecheck - let with number", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42 }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Number", "x should have type Number")
})

test("typecheck - variable reference", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx }")
  let varType = getExprType(result, 1)
  assert.equal(varType.kind, "Number", "x reference should have type Number")
})

test("typecheck - variable assignment", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx = 100 }")
  assert.truthy(result.success, "Should typecheck assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx = \"hello\" }")
  assert.equal(result.success, false, "Should fail on type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - dot assignment refinement on parameter", fn(assert) {
  let result = parseAndTypecheck("fn(o) { o.x = 1\no.x + 1 }")
  assert.truthy(result.success, "Should refine param type via dot assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - index assignment refinement on parameter", fn(assert) {
  let result = parseAndTypecheck("fn(a) { a[0] = 1\nlet x = a[0]\nif x != nil { x + 1 } else { 0 } }")
  assert.truthy(result.success, "Should refine param type via index assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - dot assignment to number fails", fn(assert) {
  let result = parseAndTypecheck("{ let n = 1\nn.x = 2 }")
  assert.equal(result.success, false, "Should fail when assigning to non-record")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - index assignment to number fails", fn(assert) {
  let result = parseAndTypecheck("{ let n = 1\nn[0] = 2 }")
  assert.equal(result.success, false, "Should fail when assigning to non-array")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Operators
// ========================================

test("typecheck - arithmetic operators", fn(assert) {
  let result = parseAndTypecheck("1 + 2 * 3 - 4 / 5")
  assert.truthy(result.success, "Should typecheck arithmetic")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arithmetic type error", fn(assert) {
  let result = parseAndTypecheck("\"hello\" + 42")
  assert.equal(result.success, false, "Should fail on arithmetic type error")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - unary operators", fn(assert) {
  let result = parseAndTypecheck("-42")
  assert.truthy(result.success, "Should typecheck unary negation")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - logical not", fn(assert) {
  let result = parseAndTypecheck("!true")
  assert.truthy(result.success, "Should typecheck logical not")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Arrays
// ========================================

test("typecheck - empty array", fn(assert) {
  let result = parseAndTypecheck("[]")
  assert.truthy(result.success, "Should typecheck empty array")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - homogeneous array", fn(assert) {
  let result = parseAndTypecheck("[1, 2, 3]")
  assert.truthy(result.success, "Should typecheck homogeneous array")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element type error", fn(assert) {
  let result = parseAndTypecheck("[1, \"hello\", 3]")
  assert.equal(result.success, false, "Should fail on mixed array")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - array index access", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] }")
  assert.truthy(result.success, "Should typecheck array access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element assignment", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] = 42 }")
  assert.truthy(result.success, "Should typecheck array element assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] = \"hello\" }")
  assert.equal(result.success, false, "Should fail on element type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Records
// ========================================

test("typecheck - record literal", fn(assert) {
  let result = parseAndTypecheck(".{ x: 1, y: 2 }")
  assert.truthy(result.success, "Should typecheck record literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record field access", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1, y: 2 }\nobj.x }")
  assert.truthy(result.success, "Should typecheck record field access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - missing field error", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.y }")
  assert.equal(result.success, false, "Should fail on missing field")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - record field assignment", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.x = 42 }")
  assert.truthy(result.success, "Should typecheck field assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record field assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.x = \"hello\" }")
  assert.equal(result.success, false, "Should fail on field type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow
// ========================================

test("typecheck - if expression", fn(assert) {
  let result = parseAndTypecheck("if true { 1 } else { 2 }")
  assert.truthy(result.success, "Should typecheck if expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - if without else", fn(assert) {
  let result = parseAndTypecheck("if true { 1 }")
  assert.truthy(result.success, "Should typecheck if without else")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - if branch type mismatch", fn(assert) {
  let result = parseAndTypecheck("if true { 1 } else { \"hello\" }")
  assert.equal(result.success, false, "Should fail on branch type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - for loop", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { i }")
  assert.truthy(result.success, "Should typecheck for loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - break", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { break }")
  assert.truthy(result.success, "Should typecheck break")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - continue", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { continue }")
  assert.truthy(result.success, "Should typecheck continue")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Complex Examples
// ========================================

test("typecheck - factorial function", fn(assert) {
  let source = "fn factorial(n) { if n <= 1 { 1 } else { n * factorial(n - 1) } }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck factorial")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array map pattern", fn(assert) {
  let source = "{ let arr = [1, 2, 3]\nlet result = []\nfor let i = 0; i < len(arr); i = i + 1 { let x = arr[i]\nif x != nil { push(result, x + 1) } }\nresult }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck array map pattern")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record with functions", fn(assert) {
  let source = ".{ add: fn(x, y) { x + y }, sub: fn(x, y) { x - y } }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck record with functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested records", fn(assert) {
  let source = "{ let obj = .{ inner: .{ x: 42 } }\nobj.inner.x }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck nested records")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array of records", fn(assert) {
  let source = "[.{ x: 1 }, .{ x: 2 }, .{ x: 3 }]"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck array of records")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - higher-order function", fn(assert) {
  let source = "{ let apply = fn(f, x) { f(x) }\nlet inc = fn(n) { n + 1 }\napply(inc, 42) }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck higher-order function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Edge Cases
// ========================================

test("typecheck - grouping expression", fn(assert) {
  let result = parseAndTypecheck("(1 + 2) * 3")
  assert.truthy(result.success, "Should typecheck grouped expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - block expression", fn(assert) {
  let result = parseAndTypecheck("{ 1\n2\n3 }")
  assert.truthy(result.success, "Should typecheck block")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested blocks", fn(assert) {
  let result = parseAndTypecheck("{ { 1 } }")
  assert.truthy(result.success, "Should typecheck nested blocks")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - shadowing", fn(assert) {
  let result = parseAndTypecheck("{ let x = 1\n{ let x = \"hello\"\nx }\nx }")
  assert.truthy(result.success, "Should typecheck shadowing")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Arity Widening Tests
// ========================================

test("typecheck - arity widening allows extra args", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x + 1 }\nf(1, 2, 3) }")
  assert.truthy(result.success, "Should allow extra arguments")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arity error on missing args", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x, y) { x + y }\nf(1) }")
  assert.equal(result.success, false, "Should fail with missing arguments")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// TypeVar Refinement Tests
// ========================================

test("typecheck - empty array refinement via index", fn(assert) {
  let result = parseAndTypecheck("{ let arr = []\narr[0] = 5\nlet x = arr[0]\nif x != nil { x + 1 } else { 0 } }")
  assert.truthy(result.success, "Should refine empty array element type")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Regression Tests for Type System Gaps
// ========================================

test("typecheck - regression: named function call type checking", fn(assert) {
  let code = "{
    fn f() { \"hello\" }
    f() + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: can't add String and Number")
})

test("typecheck - regression: recursive function type inference", fn(assert) {
  let code = "{
    fn fact(n) {
      if n == 0 { 1 } else { n * fact(n - 1) }
    }
    fact(5)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow recursive calls")
})

test("typecheck - regression: global consistency checking", fn(assert) {
  let code = "{
    let a = println
    let b = println
    a(1)
    b(\"hello\")
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle consistent global usage")
})

test("typecheck - regression: unknown type refinement", fn(assert) {
  let code = "{
    fn getVal(x) { x.value }
    let obj = .{ value: 42 }
    getVal(obj)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should refine unknown to record shape")
})

test("typecheck - regression: keys on real records", fn(assert) {
  let code = "{
    let obj = .{ a: 1, b: 2 }
    keys(obj)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow keys on non-empty records")
})

test("typecheck - regression: invalid index assignment", fn(assert) {
  let code = "{
    let x = 1
    x[0] = 2
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: can't index into number")
})

test("typecheck - regression: invalid dot assignment", fn(assert) {
  let code = "{
    let obj = .{ x: 1 }
    obj.y = 3
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: field y doesn't exist")
})

test("typecheck - if without else returns Option(T)", fn(assert) {
  let code = "{
    fn f(cond) {
      if cond { 1 }
    }
    f(true)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck if-without-else")
})

test("typecheck - Option(Number) cannot be used in arithmetic", fn(assert) {
  let code = "{
    let x = if true { 1 }
    x + 1
  }"
  let result = parseAndTypecheck(code)
  assert.equal(result.success, false, "Should reject arithmetic on Option(Number)")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - nil-check unwraps Option(T)", fn(assert) {
  let code = "{
    let x = if true { 1 }
    if x != nil {
      x + 1
    } else {
      0
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should accept arithmetic after nil-check")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - Option(T) can unify with Nil", fn(assert) {
  let code = "{
    let x = if true { 1 }
    let y = nil
    x == y
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow comparing Option(T) with nil")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - map: empty literal is Map", fn(assert) {
  let code = "{
    let m = .{}
    m[\"a\"] = 1
    m
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck map init and assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - map: lookup returns Option", fn(assert) {
  let code = "{
    let m = .{}
    m[\"a\"] = 1
    let x = m[\"b\"]
    x + 1
  }"
  let result = parseAndTypecheck(code)
  assert.equal(result.success, false, "Should fail: x is Option(Number)")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - map: nil-check refines Option", fn(assert) {
  let code = "{
    let m = .{}
    m[\"a\"] = 1
    let x = m[\"b\"]
    if x != nil { x + 1 } else { 0 }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should succeed after nil-check")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - map: keys() accepts maps", fn(assert) {
  let code = "{
    let m = .{}
    m[\"a\"] = 1
    keys(m)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "keys() should accept maps")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record: non-empty literal is Record not Map", fn(assert) {
  let code = "{
    let r = .{ a: 1 }
    r.a
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow dot access on Record")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record: keys() accepts records", fn(assert) {
  let code = "keys(.{a:1, b:2})"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "keys() should accept records")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - map/record separation: Map rejects dot access", fn(assert) {
  let code = "{
    let m = .{}
    m.a
  }"
  let result = parseAndTypecheck(code)
  assert.equal(result.success, false, "Should reject dot access on Map")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - array: index returns Option", fn(assert) {
  let code = "{
    let arr = [1, 2, 3]
    let x = arr[0]
    x + 1
  }"
  let result = parseAndTypecheck(code)
  assert.equal(result.success, false, "Should fail: array index returns Option")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - array: nil-check unwraps indexed value", fn(assert) {
  let code = "{
    let arr = [1, 2, 3]
    let x = arr[0]
    if x != nil { x + 1 } else { 0 }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should succeed after nil-check")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: Option(T) or T unwraps to T", fn(assert) {
  let code = "{
    let x = if true { 1 }
    let y = x or 0
    y + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should unwrap Option(Number) or Number to Number")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: T or Option(T) unwraps to T", fn(assert) {
  let code = "{
    let x = if true { 1 }
    let y = 0 or x
    y + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should unwrap Number or Option(Number) to Number")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: safe defaulting for missing map value", fn(assert) {
  let code = "{
    let m = .{}
    m[\"a\"] = 1
    let x = m[\"b\"] or 0
    x + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should default missing map value")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: safe defaulting for array index", fn(assert) {
  let code = "{
    let arr = [1, 2, 3]
    let x = arr[10] or 0
    x + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should default missing array element")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: chained defaulting", fn(assert) {
  let code = "{
    let x = if false { 1 }
    let y = if false { 2 }
    let z = x or y or 3
    z + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle chained or with Options")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: incompatible types fall back to Any", fn(assert) {
  let code = "{
    let x = if true { 1 }
    let y = x or \"default\"
    y  // Result is Any (types don't unify)
  }"
  let result = parseAndTypecheck(code)
  // Incompatible types use general unification which falls back to Any
  assert.truthy(result.success, "Incompatible types fall back to Any")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - and: does not unwrap Option like or does", fn(assert) {
  // Unlike 'or', 'and' does not provide Option unwrapping
  // This test documents that 'or' is special for defaulting, 'and' is not
  let code = "{
    let x = if true { 1 }
    let y = x and 0
    y  // Result is Any (general case), not specifically Number like with 'or'
  }"
  let result = parseAndTypecheck(code)
  // This succeeds because incompatible types fall back to Any
  assert.truthy(result.success, "and uses general unification (not Option-aware)")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - or: Option(T) or Option(T) stays Option", fn(assert) {
  let code = "{
    let x = if true { 1 }
    let y = if false { 2 }
    let z = x or y
    z + 1
  }"
  let result = parseAndTypecheck(code)
  assert.equal(result.success, false, "Option or Option should not unwrap")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

suite.run()
