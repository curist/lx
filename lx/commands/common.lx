let driver = import "src/driver.lx"
let codegen = import "src/passes/emit/codegen.lx"
let fastcheck = import "src/passes/analysis/fastcheck.lx"
let peephole = (import "src/passes/opt/peephole-bytecode.lx").peephole
let verify = import "src/passes/verify/verify-bytecode.lx"
let objbuilder = import "src/objbuilder.lx"
let errors = import "src/errors.lx"
let ModuleResolution = import "src/module_resolution.lx"
let OP = (import "src/types.lx").OP

let DEBUG_BUILD = true

fn loadSource(path, sourceOverride, overridePath, resolver) {
  if sourceOverride and path == overridePath { return sourceOverride }
  resolver.slurp(path)
}

fn makeDriverWithSource(sourceOverride, overridePath, entryPath) {
  let resolver = ModuleResolution.forEntry(entryPath)
  driver.make(.{
    withTypecheck: false,
    loadSource: fn(p) { loadSource(p, sourceOverride, overridePath, resolver) },
  })
}

fn compileWithDriver(driverInstance, path) {
  let moduleCache = .{}

  fn codegenModule(modulePath) {
    let cached = moduleCache[modulePath]
    if cached { return cached }

    let result = driverInstance.compileModule(modulePath)
    if !result or result.status != "done" {
      errors.printErrors(errors.collectErrors(result or .{}), result)
      return nil
    }

    // Print warnings even if compilation succeeded (e.g., nilcheck warnings)
    let allErrors = errors.collectErrors(result)
    if allErrors and len(allErrors) > 0 {
      errors.printErrors(allErrors, result)
    }

    let passes = result.passes or .{}
    let ast = (passes["anf-inline"] and passes["anf-inline"].ast) or
              (passes.anf and passes.anf.ast) or
              (passes.lower and passes.lower.ast)
    let enumInfo =
      (passes.anf and passes.anf.enumInfo) or
      (passes.lower and passes.lower.enumInfo) or
      (passes.parse and passes.parse.enumInfo) or
      .{}

    let deadNodes = passes.dce and passes.dce.deadNodes or .{}

    let fc = fastcheck(ast, result.passes.resolve, .{ enumInfo: enumInfo })
    result.fastcheckResult = fc
    let cg = codegen(ast, result.passes.resolve, .{
      codegenModule: codegenModule,
      enumInfo: enumInfo,
      fastcheck: fc,
      dceResult: .{ deadNodes: deadNodes },
    })
    result.codegenResult = cg
    if !cg.success {
      errors.printErrors(cg.errors, result)
      return nil
    }

    // Apply peephole optimizations to the generated bytecode
    // cg.function.chunk = peephole(cg.function.chunk)

    let verifyResult = verify.verifyFunction(cg.function)
    result.verifyResult = verifyResult
    if !verifyResult.success {
      errors.printErrors(verifyResult.errors, result)
      return nil
    }

    moduleCache[modulePath] = cg.function
    cg.function
  }

  codegenModule(path)
}

fn compilePathToFunction(path, sourceOverride) {
  let resolver = ModuleResolution.forEntry(path)
  let d = makeDriverWithSource(sourceOverride, path, path)

  // Convert path to module specifier relative to project root
  let roots = resolver.roots()
  let moduleSpec = path
  if roots and roots.projectRoot {
    let absPath = path
    if len(absPath) > 0 and absPath[0] != "/" {
      absPath = Lx.path.join(Lx.fs.cwd(), absPath)
    }
    let prefix = roots.projectRoot + "/"
    if len(absPath) >= len(prefix) {
      let matches = true
      for let i = 0; i < len(prefix); i = i + 1 {
        if absPath[i] != prefix[i] {
          matches = false
          break
        }
      }
      if matches {
        moduleSpec = ""
        for let i = len(prefix); i < len(absPath); i = i + 1 {
          moduleSpec = moduleSpec + absPath[i]
        }
      }
    }
  }

  compileWithDriver(d, moduleSpec)
}

fn bytesToString(bytes) {
  collect byte in bytes { chr(byte) }->join("")
}

fn slurpUserPath(path, entryPath) {
  // Prefer reading literal filesystem paths when they exist relative to CWD
  // (e.g. `out/foo.lxobj`), otherwise fall back to module resolution (`cmd/...`).
  if Lx and Lx.fs and Lx.fs.exists and Lx.fs.exists(path) {
    return Lx.fs.readFile(path)
  }
  let resolver = ModuleResolution.forEntry(entryPath or path)
  resolver.slurp(path)
}

fn printRuntimeError(err) {
  if !err {
    Lx.stderr.println("Runtime error.")
    return
  }
  if err.message {
    Lx.stderr.println(err.message)
  } else {
    Lx.stderr.println(err)
    return
  }

  let stack = err.stack
  if !stack { return }
  for let i = 0; i < len(stack); i = i + 1 {
    let f = stack[i] or .{}
    let file = f.file or "[unknown]"
    let line = Math.floor(f.line or 0)
    let name = f.name or "script"
    Lx.stderr.println("[" + file + " L" + str(line) + "] in " + name + "()")
  }
}

.{
  DEBUG_BUILD,
  OP,
  ModuleResolution,
  compilePathToFunction,
  compileWithDriver,
  makeDriverWithSource,
  bytesToString,
  slurpUserPath,
  objbuilder,
  printRuntimeError,
}
