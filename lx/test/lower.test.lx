let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/passes/parse/parser.lx"
let lower = import "src/passes/transform/lower.lx"
let types = import "src/types.lx"

let NODE = types.NODE

// Helper to parse and lower
fn parseAndLower(src) {
  let parseResult = parse(src, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseResult: parseResult }
  }
  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  .{
    success: lowerResult.success,
    parseResult: parseResult,
    lowerResult: lowerResult,
  }
}

// Helper to get first statement from lowered AST
fn first(result) {
  result.lowerResult.ast.expressions[0]
}

// ========================================
// Arrow Transformation Tests
// ========================================

test("lower - simple arrow to call", fn(assert) {
  let result = parseAndLower("x->f()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Call)
  assert.equal(node.callee.type, NODE.Identifier)
  assert.equal(node.callee.name, "f")
  assert.equal(len(node.args), 1)
  assert.equal(node.args[0].type, NODE.Identifier)
  assert.equal(node.args[0].name, "x")
})

test("lower - arrow with existing args", fn(assert) {
  let result = parseAndLower("x->f(a, b)")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Call)
  assert.equal(node.callee.name, "f")
  assert.equal(len(node.args), 3)
  assert.equal(node.args[0].name, "x")
  assert.equal(node.args[1].name, "a")
  assert.equal(node.args[2].name, "b")
})

test("lower - chained arrows", fn(assert) {
  let result = parseAndLower("x->a()->b()")
  assert.truthy(result.success)

  let node = first(result)
  // x->a()->b() should become b(a(x))
  assert.equal(node.type, NODE.Call)
  assert.equal(node.callee.name, "b")
  assert.equal(len(node.args), 1)

  let innerCall = node.args[0]
  assert.equal(innerCall.type, NODE.Call)
  assert.equal(innerCall.callee.name, "a")
  assert.equal(len(innerCall.args), 1)
  assert.equal(innerCall.args[0].name, "x")
})

test("lower - arrow with non-call RHS produces error", fn(assert) {
  let result = parseAndLower("x->42")
  assert.equal(result.success, false)
  assert.equal(len(result.lowerResult.errors), 1)
  // Just check that we got an error message
  assert.truthy(len(result.lowerResult.errors[0].message) > 0)
})

test("lower - arrow preserves position span", fn(assert) {
  let result = parseAndLower("x->f()")
  assert.truthy(result.success)

  let parsed = result.parseResult.ast.expressions[0]
  let lowered = first(result)

  // Position should be preserved from original arrow node
  assert.equal(lowered.line, parsed.line)
  assert.equal(lowered.col, parsed.col)
  assert.equal(lowered.endLine, parsed.endLine)
  assert.equal(lowered.endCol, parsed.endCol)
})

// ========================================
// If Expression Tests
// ========================================

test("lower - if with else unchanged", fn(assert) {
  let result = parseAndLower("if true { 1 } else { 2 }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.If)
  assert.truthy(node.condition)
  assert.truthy(node.then)
  assert.truthy(node.else)
  assert.equal(node.else.type, NODE.Block)
  assert.equal(node.else.expressions[0].value, 2)
})

test("lower - if without else stays nil", fn(assert) {
  let result = parseAndLower("if true { 1 }")
  assert.truthy(result.success)

  let parsedIf = result.parseResult.ast.expressions[0]
  let loweredIf = first(result)

  assert.equal(loweredIf.type, NODE.If)
  assert.truthy(loweredIf.condition)
  assert.truthy(loweredIf.then)

  // Else should remain nil (no synthetic nodes)
  assert.equal(parsedIf.else, nil)
  assert.equal(loweredIf.else, nil)
})

test("lower - nested if without else", fn(assert) {
  let result = parseAndLower("if true { if false { 1 } }")
  assert.truthy(result.success)

  let outerIf = first(result)
  assert.equal(outerIf.type, NODE.If)

  // Inner if should also have nil else
  let innerIf = outerIf.then.expressions[0]
  assert.equal(innerIf.type, NODE.If)
  assert.equal(innerIf.else, nil)
})

// ========================================
// Node ID Tests
// ========================================

test("lower - creates fresh node IDs", fn(assert) {
  let result = parseAndLower("1 + 2")
  assert.truthy(result.success)

  let parsedNode = result.parseResult.ast.expressions[0]
  let loweredNode = first(result)

  // Lowered IDs should be higher (continuing from parse)
  assert.truthy(loweredNode.id > parsedNode.id)
})

test("lower - nextNodeId continues from parse", fn(assert) {
  let result = parseAndLower("1 + 2")
  assert.truthy(result.success)

  let parseNextId = result.parseResult.nextNodeId
  let lowerNextId = result.lowerResult.nextNodeId

  // Lower should continue from where parse left off
  assert.truthy(lowerNextId > parseNextId)
})

test("lower - origin map tracks provenance", fn(assert) {
  let result = parseAndLower("x")
  assert.truthy(result.success)

  let parsedNode = result.parseResult.ast.expressions[0]
  let loweredNode = first(result)

  // Origin map should link new ID to old ID
  let origin = result.lowerResult.origin
  assert.equal(origin[loweredNode.id], parsedNode.id)
})

// ========================================
// Complex Expression Tests
// ========================================

test("lower - binary expression", fn(assert) {
  let result = parseAndLower("1 + 2")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Binary)
  assert.equal(node.left.value, 1)
  assert.equal(node.right.value, 2)
})

test("lower - function declaration", fn(assert) {
  let result = parseAndLower("fn foo() { 42 }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  // Function name is an Identifier node, not a string
  assert.equal(node.name.type, NODE.Identifier)
  assert.equal(node.name.name, "foo")
  assert.equal(node.body.type, NODE.Block)
})

test("lower - function with arrow in body", fn(assert) {
  let result = parseAndLower("fn foo() { x->f() }")
  assert.truthy(result.success)

  let node = first(result)
  let bodyExpr = node.body.expressions[0]
  assert.equal(bodyExpr.type, NODE.Call)
  assert.equal(bodyExpr.callee.name, "f")
  assert.equal(bodyExpr.args[0].name, "x")
})

test("lower - array with arrow elements", fn(assert) {
  let result = parseAndLower("[1->str(), 2->str()]")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Array)
  assert.equal(len(node.elements), 2)
  assert.equal(node.elements[0].type, NODE.Call)
  assert.equal(node.elements[1].type, NODE.Call)
})

test("lower - hashmap with arrow values", fn(assert) {
  let result = parseAndLower(".{ a: x->f() }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Hashmap)
  assert.equal(len(node.pairs), 1)
  assert.equal(node.pairs[0].value.type, NODE.Call)
})

test("lower - block with mixed expressions", fn(assert) {
  let result = parseAndLower("{ let x = 1\n x->str() }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Block)
  assert.equal(len(node.expressions), 2)
  assert.equal(node.expressions[0].type, NODE.Let)
  assert.equal(node.expressions[1].type, NODE.Call)
})

test("lower - for loop with arrow", fn(assert) {
  let result = parseAndLower("for let i = 0; i < 10; i = i + 1 { i->print() }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.For)
  assert.equal(node.body.expressions[0].type, NODE.Call)
})

// ========================================
// Edge Cases
// ========================================

test("lower - empty program", fn(assert) {
  let result = parseAndLower("")
  assert.truthy(result.success)

  assert.equal(len(result.lowerResult.ast.expressions), 0)
})

test("lower - preserves literals", fn(assert) {
  let result = parseAndLower("42")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Number)
  assert.equal(node.value, 42)
})

test("lower - preserves import", fn(assert) {
  let result = parseAndLower("import \"foo\"")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Import)
})

test("lower - return with arrow", fn(assert) {
  let result = parseAndLower("return x->f()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Return)
  assert.equal(node.value.type, NODE.Call)
})

test("lower - assignment with arrow", fn(assert) {
  let result = parseAndLower("x = y->f()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Assignment)
  assert.equal(node.value.type, NODE.Call)
})

test("lower - dot access with arrow", fn(assert) {
  let result = parseAndLower("obj.method()->process()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Call)
  assert.equal(node.callee.name, "process")
  assert.equal(node.args[0].type, NODE.Call)
  assert.equal(node.args[0].callee.type, NODE.Dot)
})

test("lower - index with arrow", fn(assert) {
  let result = parseAndLower("arr[0]->process()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Call)
  assert.equal(node.callee.name, "process")
  assert.equal(node.args[0].type, NODE.Index)
})

// ========================================
// Child Node Freshening Tests
// ========================================

test("lower - grouping with arrow gets fresh IDs", fn(assert) {
  let result = parseAndLower("(x)->f()")
  assert.truthy(result.success)

  let parsedArrow = result.parseResult.ast.expressions[0]
  let parsedGrouping = parsedArrow.left
  let loweredCall = first(result)

  // The lowered result should be a Call (arrow was lowered)
  assert.equal(loweredCall.type, NODE.Call)

  // The argument should be the lowered grouping
  let loweredGrouping = loweredCall.args[0]
  assert.equal(loweredGrouping.type, NODE.Grouping)

  // Lowered grouping should have fresh ID
  assert.truthy(loweredGrouping.id > parsedGrouping.id)
  assert.truthy(loweredGrouping.expression.id > parsedGrouping.expression.id)
})

test("lower - let name gets fresh ID", fn(assert) {
  let result = parseAndLower("let x = 42")
  assert.truthy(result.success)

  let parsedLet = result.parseResult.ast.expressions[0]
  let loweredLet = first(result)

  // Let node itself should have fresh ID
  assert.truthy(loweredLet.id > parsedLet.id)
  assert.truthy(loweredLet.name.id > parsedLet.name.id)
})

test("lower - function name and params get fresh IDs", fn(assert) {
  let result = parseAndLower("fn foo(a, b) { a + b }")
  assert.truthy(result.success)

  let parsedFn = result.parseResult.ast.expressions[0]
  let loweredFn = first(result)

  // Function node itself should have fresh ID
  assert.truthy(loweredFn.id > parsedFn.id)

  // Function.name (Identifier node) should have fresh ID
  assert.truthy(loweredFn.name.id > parsedFn.name.id)

  // Function.params (array of Identifier nodes) should have fresh IDs
  assert.equal(len(loweredFn.params), 2)
  for let i = 0; i < len(loweredFn.params); i = i + 1 {
    let loweredParam = loweredFn.params[i]
    let parsedParam = parsedFn.params[i]
    assert.truthy(loweredParam.id > parsedParam.id)
  }
})

test("lower - dot property gets fresh ID", fn(assert) {
  let result = parseAndLower("obj.foo")
  assert.truthy(result.success)

  let parsedDot = result.parseResult.ast.expressions[0]
  let loweredDot = first(result)

  // Dot node itself should have fresh ID
  assert.truthy(loweredDot.id > parsedDot.id)

  // Dot.property (String key node) should have fresh ID
  assert.truthy(loweredDot.property.id > parsedDot.property.id)
})

test("lower - let destructure", fn(assert) {
  let result = parseAndLower("let .{ a, B: b } = rec")
  assert.truthy(result.success)

  // Destructuring lowers into multiple lets in the current block.
  let exprs = result.lowerResult.ast.expressions
  assert.equal(len(exprs), 3)

  let tmpLet = exprs[0]
  assert.equal(tmpLet.type, NODE.Let)
  let originId = result.lowerResult.origin[tmpLet.id]
  assert.truthy(originId != nil)
  assert.equal(tmpLet.name.type, NODE.Identifier)
  assert.equal(tmpLet.name.name, "$destr_" + str(originId))
  assert.equal(tmpLet.init.type, NODE.Identifier)
  assert.equal(tmpLet.init.name, "rec")

  let aLet = exprs[1]
  assert.equal(aLet.type, NODE.Let)
  assert.equal(aLet.name.name, "a")
  assert.equal(aLet.init.type, NODE.Dot)
  assert.equal(aLet.init.object.type, NODE.Identifier)
  assert.equal(aLet.init.object.name, tmpLet.name.name)
  assert.equal(aLet.init.property.type, NODE.String)
  assert.equal(aLet.init.property.value, "a")

  let bLet = exprs[2]
  assert.equal(bLet.type, NODE.Let)
  assert.equal(bLet.name.name, "b")
  assert.equal(bLet.init.type, NODE.Dot)
  assert.equal(bLet.init.object.name, tmpLet.name.name)
  assert.equal(bLet.init.property.type, NODE.String)
  assert.equal(bLet.init.property.value, "B")
})

test("lower - import path gets fresh ID", fn(assert) {
  let result = parseAndLower("import \"foo.lx\"")
  assert.truthy(result.success)

  let parsedImport = result.parseResult.ast.expressions[0]
  let loweredImport = first(result)

  // Import node itself should have fresh ID
  assert.truthy(loweredImport.id > parsedImport.id)

  // Import.path (String node) should have fresh ID
  assert.truthy(loweredImport.path.id > parsedImport.path.id)
})

// ========================================
// Default Arguments Tests
// ========================================

test("lower - function with one default argument", fn(assert) {
  let result = parseAndLower("fn greet(name = \"World\") { \"Hello \" + name }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(len(node.params), 1)
  assert.equal(node.params[0].name, "name")

  // Check that defaults array exists
  assert.truthy(node.defaults)
  assert.equal(len(node.defaults), 1)
  assert.equal(node.defaults[0].type, NODE.String)
  assert.equal(node.defaults[0].value, "World")

  // Check that body has been augmented with nil check
  let body = node.body
  assert.equal(body.type, NODE.Block)
  assert.truthy(len(body.expressions) >= 2)

  // First expression should be: if name == nil { name = "World" }
  let ifNode = body.expressions[0]
  assert.equal(ifNode.type, NODE.If)
  assert.equal(ifNode.condition.type, NODE.Binary)
  assert.equal(ifNode.condition.operator.lexeme, "==")
  assert.equal(ifNode.condition.left.name, "name")
  assert.equal(ifNode.condition.right.type, NODE.Nil)

  // Then branch should assign the default value
  assert.equal(ifNode.then.type, NODE.Block)
  assert.equal(len(ifNode.then.expressions), 1)
  let assignment = ifNode.then.expressions[0]
  assert.equal(assignment.type, NODE.Assignment)
  assert.equal(assignment.target.name, "name")
  assert.equal(assignment.value.value, "World")
})

test("lower - function with multiple default arguments", fn(assert) {
  let result = parseAndLower("fn foo(a, b = 1, c = 2) { a + b + c }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(len(node.params), 3)

  // Check defaults array
  assert.truthy(node.defaults)
  assert.equal(len(node.defaults), 3)
  assert.equal(node.defaults[0], nil)
  assert.equal(node.defaults[1].type, NODE.Number)
  assert.equal(node.defaults[1].value, 1)
  assert.equal(node.defaults[2].type, NODE.Number)
  assert.equal(node.defaults[2].value, 2)

  // Check that body has nil checks for b and c
  let body = node.body
  assert.equal(body.type, NODE.Block)
  assert.truthy(len(body.expressions) >= 3)

  // First two expressions should be nil checks for b and c
  let ifB = body.expressions[0]
  assert.equal(ifB.type, NODE.If)
  assert.equal(ifB.condition.left.name, "b")

  let ifC = body.expressions[1]
  assert.equal(ifC.type, NODE.If)
  assert.equal(ifC.condition.left.name, "c")
})

test("lower - function with all default arguments", fn(assert) {
  let result = parseAndLower("fn foo(a = 1, b = 2) { a + b }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(len(node.params), 2)

  // All parameters should have defaults
  assert.equal(len(node.defaults), 2)
  assert.equal(node.defaults[0].value, 1)
  assert.equal(node.defaults[1].value, 2)

  // Body should have nil checks for both parameters
  let body = node.body
  assert.truthy(len(body.expressions) >= 3)
})

test("lower - function with no default arguments", fn(assert) {
  let result = parseAndLower("fn foo(a, b) { a + b }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(len(node.params), 2)

  // Defaults should be empty or all nil
  if node.defaults {
    assert.equal(len(node.defaults), 2)
    assert.equal(node.defaults[0], nil)
    assert.equal(node.defaults[1], nil)
  }

  // Body should not have extra nil checks
  let body = node.body
  assert.equal(body.type, NODE.Block)
  assert.equal(len(body.expressions), 1)
})

test("lower - default argument with expression", fn(assert) {
  let result = parseAndLower("fn foo(a = 1 + 2) { a }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.defaults[0].type, NODE.Binary)
  assert.equal(node.defaults[0].operator.lexeme, "+")
  assert.equal(node.defaults[0].left.value, 1)
  assert.equal(node.defaults[0].right.value, 2)
})

test("lower - anonymous function with defaults", fn(assert) {
  let result = parseAndLower("fn(x = 0) { x + 1 }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 1)
  assert.equal(node.defaults[0].value, 0)
})

test("lower - default arguments preserve position spans", fn(assert) {
  let result = parseAndLower("fn foo(a = 42) { a }")
  assert.truthy(result.success)

  let parsed = result.parseResult.ast.expressions[0]
  let lowered = first(result)

  // Position should be preserved
  assert.equal(lowered.line, parsed.line)
  assert.equal(lowered.col, parsed.col)
})

// ========================================
// Lambda (Arrow Function) Lowering Tests
// ========================================

test("lower - lambda single param expression body", fn(assert) {
  let result = parseAndLower("x => x + 1")
  assert.truthy(result.success)

  let node = first(result)
  // Lambda should be lowered to anonymous Function
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 1)
  assert.equal(node.params[0].name, "x")

  // Body should be a Block wrapping the expression
  assert.equal(node.body.type, NODE.Block)
  assert.equal(len(node.body.expressions), 1)
  assert.equal(node.body.expressions[0].type, NODE.Binary)
})

test("lower - lambda single param block body", fn(assert) {
  let result = parseAndLower("x => { x + 1 }")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 1)
  assert.equal(node.params[0].name, "x")

  // Body is already a Block, should stay as-is
  assert.equal(node.body.type, NODE.Block)
  assert.equal(len(node.body.expressions), 1)
  assert.equal(node.body.expressions[0].type, NODE.Binary)
})

test("lower - lambda no params", fn(assert) {
  let result = parseAndLower("() => 42")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 0)

  // Body should be a Block wrapping the number
  assert.equal(node.body.type, NODE.Block)
  assert.equal(node.body.expressions[0].type, NODE.Number)
  assert.equal(node.body.expressions[0].value, 42)
})

test("lower - lambda multiple params", fn(assert) {
  let result = parseAndLower("(x, y) => x + y")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 2)
  assert.equal(node.params[0].name, "x")
  assert.equal(node.params[1].name, "y")
})

test("lower - lambda with default value", fn(assert) {
  let result = parseAndLower("(x = 1) => x")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 1)
  assert.equal(node.params[0].name, "x")

  // Should have defaults and nil check injected
  assert.truthy(node.defaults)
  assert.equal(len(node.defaults), 1)
  assert.equal(node.defaults[0].type, NODE.Number)
  assert.equal(node.defaults[0].value, 1)

  // Body should have nil check for x
  assert.equal(node.body.type, NODE.Block)
  assert.truthy(len(node.body.expressions) >= 2)
  assert.equal(node.body.expressions[0].type, NODE.If)
})

test("lower - lambda with multiple defaults", fn(assert) {
  let result = parseAndLower("(x, y = 2, z = 3) => x + y + z")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)
  assert.equal(len(node.params), 3)

  assert.equal(node.defaults[0], nil)
  assert.equal(node.defaults[1].value, 2)
  assert.equal(node.defaults[2].value, 3)
})

test("lower - lambda in let binding", fn(assert) {
  let result = parseAndLower("let add = x => x + 1")
  assert.truthy(result.success)

  let letNode = first(result)
  assert.equal(letNode.type, NODE.Let)

  let lambda = letNode.init
  assert.equal(lambda.type, NODE.Function)
  assert.equal(lambda.name, nil)
})

test("lower - lambda as call argument", fn(assert) {
  let result = parseAndLower("map(arr, x => x * 2)")
  assert.truthy(result.success)

  let call = first(result)
  assert.equal(call.type, NODE.Call)
  assert.equal(call.args[1].type, NODE.Function)
  assert.equal(call.args[1].name, nil)
})

test("lower - lambda with arrow operator in body", fn(assert) {
  let result = parseAndLower("x => x->str()")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, NODE.Function)

  // The body should have the arrow lowered to a Call
  let bodyExpr = node.body.expressions[0]
  assert.equal(bodyExpr.type, NODE.Call)
  assert.equal(bodyExpr.callee.name, "str")
  assert.equal(bodyExpr.args[0].name, "x")
})

test("lower - nested lambdas", fn(assert) {
  let result = parseAndLower("x => y => x + y")
  assert.truthy(result.success)

  let outer = first(result)
  assert.equal(outer.type, NODE.Function)
  assert.equal(outer.params[0].name, "x")

  // Inner lambda should also be lowered to Function
  let inner = outer.body.expressions[0]
  assert.equal(inner.type, NODE.Function)
  assert.equal(inner.params[0].name, "y")
})

test("lower - lambda preserves position", fn(assert) {
  let result = parseAndLower("x => x")
  assert.truthy(result.success)

  let parsed = result.parseResult.ast.expressions[0]
  let lowered = first(result)

  assert.equal(lowered.line, parsed.line)
  assert.equal(lowered.col, parsed.col)
})

suite.run()
