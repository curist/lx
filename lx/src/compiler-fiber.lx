// Fiber-based compiler API
//
// Provides a fiber-driven compilation interface that yields events
// for streaming diagnostics and progress.

let Events = import "src/events.lx"
let Driver = import "src/driver.lx"
let parse = import "src/passes/parse/parser.lx"
let lower = import "src/passes/transform/lower.lx"
let anf = import "src/passes/transform/anf.lx"
let resolve = import "src/passes/analysis/resolve.lx"
let anfInline = import "src/passes/transform/anf-inline.lx"
let lowerIntrinsics = import "src/passes/transform/lower-intrinsics.lx"
let codegen = import "src/passes/emit/codegen.lx"

// Parse error message format: [file:line:col] context: message
// Returns: .{ line, col } or nil if parsing fails
fn parseErrorLocation(errorMsg) {
  let openBracket = nil
  let closeBracket = nil
  let prevColon = nil
  let lastColon = nil

  for let i = 0; i < len(errorMsg); i = i + 1 {
    let ch = errorMsg[i]
    if ch == "[" and !openBracket {
      openBracket = i
    } else if ch == ":" and openBracket != nil and closeBracket == nil {
      prevColon = lastColon
      lastColon = i
    } else if ch == "]" and !closeBracket {
      closeBracket = i
      break
    }
  }

  // Need at least 2 colons (file:line:col)
  if !openBracket or !closeBracket {
    return nil
  }

  // Extract line & column numbers
  let line = errorMsg->substr(prevColon + 1, lastColon)->tonumber()
  let col = errorMsg->substr(lastColon + 1, closeBracket)->tonumber()

  .{ line, col }
}

// Internal: Create the compilation fiber with optional cancellation support
// - cancelled: nil (no cancellation) or .{ value: bool } for cancellation state
fn createCompilerFiber(source, filename, cancelled) {
  Fiber.create(fn() {
    // Helper to check cancellation - returns true if cancelled
    fn checkCancel() {
      cancelled and cancelled.value
    }

    // Parse phase
    Fiber.yield(Events.progress("parse", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }

    let parseResult = parse(source, filename)

    // Yield diagnostics for parse errors
    for errorMsg in parseResult.errors {
      let loc = parseErrorLocation(errorMsg)
      let range = if loc {
        .{ start: .{ line: loc.line, col: loc.col }, end: .{ line: loc.line, col: loc.col + 1 } }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("parse", filename, range, Events.Severity.ERROR, errorMsg, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("parse", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Stop if parse failed
    if !parseResult.success {
      return Events.done(.{ success: false, errors: parseResult.errors })
    }

    // Lower phase
    Fiber.yield(Events.progress("lower", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let lowerResult = lower(parseResult.ast, .{ nextNodeId: parseResult.nextNodeId })
    Fiber.yield(Events.progress("lower", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    if !lowerResult.success {
      return Events.done(.{ success: false, errors: lowerResult.errors })
    }

    // ANF phase
    Fiber.yield(Events.progress("anf", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let anfResult = anf(lowerResult.ast, .{ nextNodeId: lowerResult.nextNodeId })
    Fiber.yield(Events.progress("anf", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    if !anfResult.success {
      return Events.done(.{ success: false, errors: anfResult.errors })
    }

    // Resolve phase
    Fiber.yield(Events.progress("resolve", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let resolveResult = resolve(anfResult.ast, .{})

    // Yield diagnostics for resolve errors
    for err in resolveResult.errors {
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      let severity = if err.severity == "error" {
        Events.Severity.ERROR
      } else if err.severity == "warning" {
        Events.Severity.WARNING
      } else {
        Events.Severity.ERROR
      }
      Fiber.yield(Events.diag("resolve", filename, range, severity, err.message, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("resolve", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Stop if resolve failed
    if !resolveResult.success {
      return Events.done(.{ success: false, errors: resolveResult.errors })
    }

    // ANF-inline phase
    Fiber.yield(Events.progress("anf-inline", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    anfInline(anfResult.ast, resolveResult)
    Fiber.yield(Events.progress("anf-inline", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Lower-intrinsics phase
    Fiber.yield(Events.progress("lower-intrinsics", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    lowerIntrinsics(anfResult.ast, resolveResult, nil)
    Fiber.yield(Events.progress("lower-intrinsics", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Codegen phase
    Fiber.yield(Events.progress("codegen", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }
    let codegenResult = codegen(anfResult.ast, resolveResult, .{
      enumInfo: parseResult.enumInfo
    })

    // Yield diagnostics for codegen errors
    for err in codegenResult.errors {
      let node = resolveResult.nodes and resolveResult.nodes[err.nodeId]
      let range = if node and node.line {
        .{
          start: .{ line: node.line, col: node.col },
          end: .{ line: node.endLine or node.line, col: node.endCol or (node.col + 1) }
        }
      } else {
        .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }
      }
      Fiber.yield(Events.diag("codegen", filename, range, Events.Severity.ERROR, err.message, nil))
      if checkCancel() { return Events.error("Cancelled") }
    }

    Fiber.yield(Events.progress("codegen", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Return done event with all results
    Events.done(.{
      success: codegenResult.success,
      ast: anfResult.ast,
      function: codegenResult.function,
      parseResult,
      lowerResult,
      anfResult,
      resolveResult,
      codegenResult
    })
  })
}

// Start a compilation fiber.
// - source: source code string to compile
// - opts: compilation options (.{ filename, ... })
// Returns: .{ fiber, cancel } where cancel() requests cancellation
fn start(source, opts) {
  let filename = opts.filename or "unknown"
  let cancelled = .{ value: false }

  let fiber = createCompilerFiber(source, filename, cancelled)

  let cancel = fn() {
    cancelled.value = true
  }

  .{ fiber, cancel }
}

// Poll a compilation fiber for events.
// - fiber: the compilation fiber from start()
// - budget: .{ maxEvents } - how many events to collect before returning
// Returns: .{ events, done?, result?, error? }
fn poll(fiber, budget) {
  let events = []
  let maxEvents = budget.maxEvents

  for len(events) < maxEvents {
    let resumeResult = Fiber.resume(fiber)

    if resumeResult.tag == "yield" {
      push(events, resumeResult.value)
    } else if resumeResult.tag == "return" {
      return .{ events, done: true, result: resumeResult.value }
    } else if resumeResult.tag == "error" {
      return .{ events, done: true, error: resumeResult.error }
    }
  }

  .{ events, done: false }
}

// Start a module compilation fiber using a driver.
// - driver: a driver instance (from Driver.make())
// - path: module path to compile
// - opts: compilation options
// Returns: .{ fiber, cancel }
fn startModule(driver, path, opts) {
  let cancelled = .{ value: false }

  let fiber = Fiber.create(fn() {
    // Helper to check cancellation
    fn checkCancel() {
      cancelled and cancelled.value
    }

    // Check if entry source exists before compiling
    let source = driver.loadSource(path)
    if !source {
      return Events.error("Failed to load source: " + path)
    }

    // Use driver's buildModule to handle imports and full compilation
    Fiber.yield(Events.progress("compile", "start", 0, 1))
    if checkCancel() { return Events.error("Cancelled") }

    let func = driver.buildModule(path, Driver.ARTIFACT.BYTECODE_FUNCTION)

    Fiber.yield(Events.progress("compile", "done", 1, 1))
    if checkCancel() { return Events.error("Cancelled") }

    // Check for compilation failure
    let cached = driver.cache[path]
    if !cached or cached.status != "done" {
      // Emit diagnostics from failed passes
      if cached and cached.passes {
        let passes = cached.passes
        for passName in keys(passes) {
          let passResult = passes[passName]
          if passResult and passResult.errors {
            for err in passResult.errors {
              let msg = if type(err) == "string" { err } else { err.message or str(err) }
              Fiber.yield(Events.diag(passName, path, .{ start: .{ line: 1, col: 0 }, end: .{ line: 1, col: 1 } }, Events.Severity.ERROR, msg, nil))
            }
          }
        }
      }
      return Events.done(.{ success: false, path: path })
    }

    // Emit DEPS events for all compiled modules
    for modulePath in driver.compiledModules {
      if checkCancel() { return Events.error("Cancelled") }

      let moduleResult = driver.cache[modulePath]
      if !moduleResult or moduleResult.status != "done" { continue }

      let resolveResult = moduleResult.passes and moduleResult.passes.resolve
      if !resolveResult { continue }

      // Extract dependencies from importInfoByNodeId
      let deps = []
      let importInfoByNodeId = resolveResult.importInfoByNodeId or .{}
      for nodeId in keys(importInfoByNodeId) {
        let info = importInfoByNodeId[nodeId]
        if info and info.importResult and info.importResult.path {
          push(deps, info.importResult.path)
        }
      }

      Fiber.yield(Events.deps(modulePath, deps))
    }

    // Success - return result with bytecode function
    Events.done(.{
      success: true,
      path: path,
      function: func,
      compiledModules: driver.compiledModules,
    })
  })

  let cancel = fn() {
    cancelled.value = true
  }

  .{ fiber, cancel }
}

.{ start, poll, startModule }
