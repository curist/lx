// ANF Inline Optimization (Post-Resolve, Binder-Aware)
//
// Goal:
// - Inline single-use ANF temps ($anf.N) using binding metadata (declaredAt)
// - Remove their `let` bindings when inlined
//
// Key facts / invariants:
// - Node shapes:
//   - Let: { type:"Let", id, name: Identifier{id,name}, init: expr }
//   - declaredAt == Let.name.id (binder identifier id)
//   - Block: { type:"Block", id, expressions:[...] }
// - This pass mutates the AST in-place (performance-critical).
// - Later phases (typecheck, codegen, etc.) are read-only.
//
// Performance design:
// - One traversal builds:
//   - letByDeclId: declId -> { letNode, blockId, indexInBlock }
//   - useCount: declId -> count
//   - useSite: declId -> { parent, field, index } (kept only if single-use)
//   - blockById: blockId -> blockNode (for compaction)
// - Apply edits:
//   - Replace the unique Identifier use-site with RHS (structural sharing)
//   - Mark Let indices for removal per block, then compact each affected block once
//
// Validation:
// - Cheap binder-aware validation:
//   - Every removed let had uses == 1
//   - Every removed let had a remembered single-use site
//   - Replacement succeeded

let .{ NODE } = import "src/types.lx"

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

fn isAnfTempName(name) {
  if !name or type(name) != "string" { return false }
  if len(name) < 6 { return false }
  // Check "$anf." prefix
  name[0] == "$" and name[1] == "a" and name[2] == "n" and
  name[3] == "f" and name[4] == "."
}

// ------------------------------------------------------------
// Inline-safety predicate
// ------------------------------------------------------------

fn isInlineSafeExpr(node) {
  isInlineSafeExprImpl(node, 0)
}

fn isInlineSafeExprImpl(node, depth) {
  // Depth limit to prevent infinite recursion
  if depth > 50 { return false }

  if !node { return true }
  if type(node) != "map" { return true }

  let t = node.type

  // Conservative whitelist
  if t == NODE.Nil or t == NODE.Bool or t == NODE.Number or t == NODE.String or t == NODE.Identifier {
    return true
  }

  let d = depth + 1

  if t == NODE.Binary {
    return isInlineSafeExprImpl(node.left, d) and isInlineSafeExprImpl(node.right, d)
  }

  if t == NODE.Unary {
    return isInlineSafeExprImpl(node.operand, d)
  }

  if t == NODE.Logical {
    return isInlineSafeExprImpl(node.left, d) and isInlineSafeExprImpl(node.right, d)
  }

  if t == NODE.Dot {
    return isInlineSafeExprImpl(node.object, d) and node.property and node.property.type == NODE.String
  }

  if t == NODE.Index {
    return isInlineSafeExprImpl(node.object, d) and isInlineSafeExprImpl(node.index, d)
  }

  if t == NODE.IntrinsicCall {
    let args = node.args or []
    for arg in args {
      if !isInlineSafeExprImpl(arg, d) { return false }
    }
    return true
  }

  // Synthetic blocks with single safe expression
  if t == NODE.Block and node.anfSynthetic {
    let exprs = node.expressions or []
    if len(exprs) == 1 {
      return isInlineSafeExprImpl(exprs[0], d)
    }
  }

  false
}

// ------------------------------------------------------------
// Block-local de-ANF helpers
// ------------------------------------------------------------

fn unwrapAnfSyntheticSingleExpr(node) {
  if node and node.type == NODE.Block and node.anfSynthetic {
    let exprs = node.expressions or []
    if len(exprs) == 1 { return exprs[0] }
  }
  node
}

fn getDeclaredAt(node, resolvedNames) {
  // Get declaredAt for an identifier node, or nil
  if !node or node.type != NODE.Identifier or !node.id { return nil }
  let resolved = resolvedNames[node.id]
  if resolved and resolved.declaredAt { return resolved.declaredAt }
  nil
}

// ------------------------------------------------------------
// Walker (single traversal)
// ------------------------------------------------------------

fn walk(node, resolvedNames, state, parent, parentField, parentIndex, curBlockId, curExprIndex) {
  if !node { return }
  let t = type(node)

  if t == "array" {
    for item, i in node {
      // Parent is this array; field name is nil; index is i
      walk(item, resolvedNames, state, node, nil, i, curBlockId, curExprIndex)
    }
    return
  }

  if t != "map" { return }

  // Remember blocks by id for later compaction
  if node.type == NODE.Block and node.id != nil {
    state.blockById[node.id] = node
    // Traverse expressions with precise parent info
    // Each expression becomes the current expr index within this block
    let exprs = node.expressions or []
    for expr, i in exprs {
      walk(expr, resolvedNames, state, node, "expressions", i, node.id, i)
    }
    return
  }

  // Track ANF temp lets and their position in Block.expressions
  if node.type == NODE.Let and node.name and isAnfTempName(node.name.name) and node.name.id {
    let declId = node.name.id
    // Record where the let lives (only deletable when it's a direct element of Block.expressions)
    if parent and parent.type == NODE.Block and parentField == "expressions" and parentIndex != nil and parent.id != nil {
      state.letByDeclId[declId] = .{
        letNode: node,
        blockId: parent.id,
        index: parentIndex,
      }
    } else {
      // Still record the let node for completeness (but cannot delete unless in a block expr list)
      state.letByDeclId[declId] = .{
        letNode: node,
        blockId: nil,
        index: nil,
      }
    }

    // Traverse init only (skip binder name)
    walk(node.init, resolvedNames, state, node, "init", nil, curBlockId, curExprIndex)
    return
  }

  // Count identifier uses by binding identity + remember unique use-site
  if node.type == NODE.Identifier and node.id {
    let resolved = resolvedNames[node.id]
    if resolved and resolved.declaredAt {
      let declId = resolved.declaredAt
      let c = state.useCount[declId] or 0
      c = c + 1
      state.useCount[declId] = c

      if c == 1 {
        state.useSite[declId] = .{
          parent: parent,
          field: parentField,
          index: parentIndex,
          useBlockId: curBlockId,
          useExprIndex: curExprIndex,
        }
      } else if c == 2 {
        // No longer single-use
        state.useSite[declId] = nil
      }
    }
  }

  // Specialized traversal for Let (non-temp or non-ANF let): init only
  if node.type == NODE.Let {
    walk(node.init, resolvedNames, state, node, "init", nil, curBlockId, curExprIndex)
    return
  }

  // Specialized traversal for common node types (avoid expensive keys() calls)
  // Only specialize node types where we're certain of the field structure
  let nt = node.type

  if nt == NODE.Binary or nt == NODE.Logical {
    walk(node.left, resolvedNames, state, node, "left", nil, curBlockId, curExprIndex)
    walk(node.right, resolvedNames, state, node, "right", nil, curBlockId, curExprIndex)
    return
  }

  if nt == NODE.Unary {
    walk(node.operand, resolvedNames, state, node, "operand", nil, curBlockId, curExprIndex)
    return
  }

  if nt == NODE.Dot {
    walk(node.object, resolvedNames, state, node, "object", nil, curBlockId, curExprIndex)
    walk(node.property, resolvedNames, state, node, "property", nil, curBlockId, curExprIndex)
    return
  }

  if nt == NODE.Index {
    walk(node.object, resolvedNames, state, node, "object", nil, curBlockId, curExprIndex)
    walk(node.index, resolvedNames, state, node, "index", nil, curBlockId, curExprIndex)
    return
  }

  if nt == NODE.IntrinsicCall {
    let args = node.args or []
    for a, i in args {
      walk(a, resolvedNames, state, node, "args", i, curBlockId, curExprIndex)
    }
    return
  }

  if nt == NODE.Call {
    walk(node.callee, resolvedNames, state, node, "callee", nil, curBlockId, curExprIndex)
    let args = node.args or []
    for a, i in args {
      walk(a, resolvedNames, state, node, "args", i, curBlockId, curExprIndex)
    }
    return
  }

  if nt == NODE.If {
    walk(node.condition, resolvedNames, state, node, "condition", nil, curBlockId, curExprIndex)
    walk(node.then, resolvedNames, state, node, "then", nil, curBlockId, curExprIndex)
    walk(node.else, resolvedNames, state, node, "else", nil, curBlockId, curExprIndex)
    return
  }

  if nt == NODE.Return {
    walk(node.value, resolvedNames, state, node, "value", nil, curBlockId, curExprIndex)
    return
  }

  // Literals and other leaf nodes - no traversal needed
  if nt == NODE.Nil or nt == NODE.Bool or nt == NODE.Number or nt == NODE.String or nt == NODE.Import {
    return
  }

  // Fallback traversal (should be rare now):
  // We avoid copying; we only walk map/array children.
  for k in keys(node) {
    let v = node[k]
    let vt = type(v)
    if vt == "map" or vt == "array" {
      walk(v, resolvedNames, state, node, k, nil, curBlockId, curExprIndex)
    }
  }
}

fn replaceInParent(site, newNode) {
  let p = site and site.parent
  if !p { return false }

  let f = site.field
  let idx = site.index

  // parent is an array itself (field == nil)
  if f == nil and idx != nil {
    p[idx] = newNode
    return true
  }

  // parent[f] is an array
  if idx != nil {
    p[f][idx] = newNode
    return true
  }

  // parent field assignment
  if f != nil {
    p[f] = newNode
    return true
  }

  false
}

fn markRemoval(removedByBlockId, blockId, index) {
  let flags = removedByBlockId[blockId]
  if !flags {
    flags = .{}
    removedByBlockId[blockId] = flags
  }
  flags[index] = true
}

fn compactBlock(block, flags) {
  if !flags { return }
  let exprs = block.expressions or []
  let out = []
  for expr, i in exprs {
    if flags[i] { continue }
    push(out, expr)
  }
  block.expressions = out
}

// ------------------------------------------------------------
// Entrypoint
// ------------------------------------------------------------

fn anfInline(ast, resolveResult) {
  let resolvedNames = (resolveResult and resolveResult.resolvedNames) or .{}

  let state = .{
    // declId -> { letNode, blockId, index }
    letByDeclId: .{},
    // declId -> count
    useCount: .{},
    // declId -> site (only kept when count == 1)
    useSite: .{},
    // blockId -> block node
    blockById: .{},
  }

  // One traversal builds all maps
  walk(ast, resolvedNames, state, nil, nil, nil, nil, nil)

  // Apply edits
  let removedByBlockId = .{} // blockId -> { index:true }
  let inlined = 0

  // Phase 1: Pure inlining (safe everywhere)
  for declId in keys(state.letByDeclId) {
    let info = state.letByDeclId[declId]
    let letNode = info and info.letNode
    if !letNode { continue }

    // Only delete lets that are directly in a block expressions list
    // (info.blockId/index present) and are truly single-use.
    let uses = state.useCount[declId] or 0
    if uses != 1 { continue }

    let site = state.useSite[declId]
    if !site { continue }

    // Only inline pure expressions in this phase
    if !isInlineSafeExpr(letNode.init) { continue }

    // Unwrap synthetic single-expression blocks
    let rhs = unwrapAnfSyntheticSingleExpr(letNode.init)

    // Replace the unique use-site with RHS (structural sharing).
    if !replaceInParent(site, rhs) {
      return .{
        success: false,
        error: "ANF-inline: failed to replace single-use site for declId " + str(declId),
        declId: declId,
        ast: ast,
      }
    }

    // Remove the let from its block (deferred)
    if info.blockId != nil and info.index != nil {
      markRemoval(removedByBlockId, info.blockId, info.index)
    }

    inlined = inlined + 1
  }

  // Phase 2: Block-local de-ANF (safe, preserves evaluation order)
  // Only handle Binary consumers initially (sufficient for fib case)
  for blockId in keys(state.blockById) {
    let block = state.blockById[blockId]
    if !block { continue }
    let exprs = block.expressions or []
    if len(exprs) < 2 { continue }

    // Find runs of ANF temp lets followed by a Binary consumer
    let i = 0
    for true {
      if i >= len(exprs) { break }

      // Find start of run: an ANF temp let
      let expr = exprs[i]
      if !expr or expr.type != NODE.Let or !expr.name or !isAnfTempName(expr.name.name) or !expr.name.id {
        i = i + 1
        continue
      }

      // Collect run of single-use ANF lets
      let runStart = i
      let runDeclIds = []
      for true {
        if i >= len(exprs) { break }
        let e = exprs[i]
        if !e or e.type != NODE.Let or !e.name or !isAnfTempName(e.name.name) or !e.name.id {
          break
        }
        let declId = e.name.id
        let uses = state.useCount[declId] or 0
        if uses != 1 {
          break // Not single-use
        }
        push(runDeclIds, declId)
        i = i + 1
      }

      // Need consumer expression after the run
      if i >= len(exprs) or len(runDeclIds) == 0 {
        continue
      }

      let consumerIndex = i
      let consumerExpr = exprs[consumerIndex]

      // Conservative: only handle Binary consumers (covers fib case: t1 + t2)
      if !consumerExpr or consumerExpr.type != NODE.Binary {
        i = i + 1
        continue
      }

      // Verify all temps in run are used in THIS specific consumer
      let allInConsumer = true
      for declId in runDeclIds {
        let site = state.useSite[declId]
        if !site or site.useBlockId != blockId or site.useExprIndex != consumerIndex {
          allInConsumer = false
          break
        }
      }

      if !allInConsumer {
        i = i + 1
        continue
      }

      // For Binary with 2 temps: verify operand order matches run order
      // (this enforces evaluation order preservation)
      if len(runDeclIds) == 2 {
        let leftDeclAt = getDeclaredAt(consumerExpr.left, resolvedNames)
        let rightDeclAt = getDeclaredAt(consumerExpr.right, resolvedNames)

        if leftDeclAt != runDeclIds[0] or rightDeclAt != runDeclIds[1] {
          i = i + 1
          continue
        }
      } else if len(runDeclIds) == 1 {
        // Single temp: verify it's used in the binary (either left or right)
        let leftDeclAt2 = getDeclaredAt(consumerExpr.left, resolvedNames)
        let rightDeclAt2 = getDeclaredAt(consumerExpr.right, resolvedNames)

        if leftDeclAt2 != runDeclIds[0] and rightDeclAt2 != runDeclIds[0] {
          i = i + 1
          continue
        }
      } else {
        // More than 2 temps: skip for now (could be nested within operands)
        i = i + 1
        continue
      }

      // Apply replacements using the already-collected useSite pointers
      for declId in runDeclIds {
        let info2 = state.letByDeclId[declId]
        if !info2 or !info2.letNode { continue }

        let site = state.useSite[declId]
        if !site { continue }

        let rhs2 = unwrapAnfSyntheticSingleExpr(info2.letNode.init)

        // Replace using the exact site pointer
        if !replaceInParent(site, rhs2) {
          return .{
            success: false,
            error: "ANF-inline Phase 2: failed to replace declId " + str(declId),
            declId: declId,
            ast: ast,
          }
        }
      }

      // Mark all lets in run for removal
      for declId in runDeclIds {
        let info3 = state.letByDeclId[declId]
        if info3 and info3.blockId == blockId and info3.index != nil {
          markRemoval(removedByBlockId, blockId, info3.index)
          inlined = inlined + 1
        }
      }

      i = i + 1
    }
  }

  // Compact each affected block once
  for bid in keys(removedByBlockId) {
    let block = state.blockById[bid]
    if !block {
      return .{
        success: false,
        error: "ANF-inline: missing block for id " + str(bid),
        blockId: bid,
        ast: ast,
      }
    }
    compactBlock(block, removedByBlockId[bid])
  }

  // Cheap validation (binder-aware):
  // For every removed let, ensure uses==1 and useSite existed (by construction).
  // Also ensure the removed Let node is not still present in its original block
  // at the same index prior to compaction (not checkable now), so we rely on
  // compaction correctness. For extra safety, enable a full debug validator
  // behind an option later (not default).

  .{
    success: true,
    ast: ast,          // mutated in place
    inlined: inlined,
  }
}

anfInline
