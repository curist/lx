// Loop Lowering Pass - Materialize loop limits into local slots
//
// Purpose:
// - Ensure numeric for-loop limits are identifiers (not expressions/literals)
// - Enables fusion of loops like `for i = 0; i < len(arr); i = i + 1`
//
// Transformation:
//   for let i = 0; i < expr; i = i + 1 { body }
// →
//   {
//     let __loop_limit_N = expr
//     for let i = 0; i < __loop_limit_N; i = i + 1 { body }
//     nil
//   }
//
// Pipeline placement: After ANF, before Codegen
//
// Output:
// .{
//   success: true,
//   ast: <transformed AST>,
//   origin: .{ [newNodeId]: oldNodeId },  // Track node provenance
//   nextNodeId: <next available ID>,
//   errors: [],
// }

let .{ NODE } = import "src/types.lx"

// ============================================================================
// Span Helpers (FIX: snapshot span BEFORE node construction)
// ============================================================================

fn spanOf(n) {
  // Snapshot span early to avoid accidental mutation / reuse bugs.
  if !n {
    return .{ filename: nil, line: 0, col: 0, endLine: 0, endCol: 0 }
  }
  .{
    filename: n.filename,
    line: n.line,
    col: n.col,
    endLine: n.endLine,
    endCol: n.endCol,
  }
}

fn applySpan(dst, sp) {
  // Apply a pre-snapshotted span.
  dst.filename = sp.filename
  dst.line = sp.line
  dst.col = sp.col
  dst.endLine = sp.endLine
  dst.endCol = sp.endCol
}

// ============================================================================
// Node Creation Helpers (following anf.lx pattern)
// ============================================================================

fn allocNodeId(gen) {
  let id = gen.nextNodeId
  gen.nextNodeId = gen.nextNodeId + 1
  id
}

fn makeIdentifier(gen, templateNode, name) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.Identifier,
    id: id,
    name: name,
    value: name,
    lexeme: name,
  }
  applySpan(out, sp)
  out
}

fn makeLet(gen, templateNode, nameNode, initNode) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.Let,
    id: id,
    name: nameNode,
    init: initNode,
  }
  applySpan(out, sp)
  out
}

fn makeBlock(gen, templateNode, expressions) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.Block,
    id: id,
    expressions: expressions,
  }
  applySpan(out, sp)
  out
}

fn makeFor(gen, templateNode, initNode, condNode, updateNode, bodyNode) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.For,
    id: id,
    init: initNode,
    condition: condNode,
    update: updateNode,
    body: bodyNode,
  }
  applySpan(out, sp)
  out
}

fn makeBinary(gen, templateNode, leftNode, op, rightNode) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.Binary,
    id: id,
    left: leftNode,
    operator: op,
    right: rightNode,
  }
  applySpan(out, sp)
  out
}

fn makeNil(gen, templateNode) {
  let sp = spanOf(templateNode)
  let id = allocNodeId(gen)
  gen.origin[id] = templateNode and templateNode.id or nil

  let out = .{
    type: NODE.Nil,
    id: id,
    lexeme: "nil",
  }
  applySpan(out, sp)
  out
}

// ============================================================================
// Pattern Matching (mirrors codegen.lx matchNumericForLoop)
// ============================================================================

fn extractConditionFromAnfBlock(block) {
  // ANF may wrap condition in a synthetic block:
  // { let $anf.0 = expr; i < $anf.0 }
  if !block or block.type != NODE.Block { return nil }
  if !block.anfSynthetic { return nil }
  if !block.expressions or len(block.expressions) == 0 { return nil }

  let lastIdx = len(block.expressions) - 1
  let finalExpr = block.expressions[lastIdx]
  if !finalExpr or finalExpr.type != NODE.Binary { return nil }

  let anfLets = []
  for let i = 0; i < lastIdx; i = i + 1 {
    let expr = block.expressions[i]
    if !expr or expr.type != NODE.Let { return nil }
    push(anfLets, expr)
  }

  .{ condition: finalExpr, anfLets: anfLets }
}

fn shouldLowerLoop(node) {
  if !node or node.type != NODE.For { return false }

  // Skip "for-in" / lowered variants that reuse NODE.For.
  // (These field names come from your earlier notes; keep whichever applies in your tree.)
  if node.indexBinder or node.index { return false }

  if !node.init or !node.condition or !node.update { return false }

  // init: let i = <expr>
  if node.init.type != NODE.Let { return false }
  if !node.init.name or node.init.name.type != NODE.Identifier { return false }

  let i_name = node.init.name.value or node.init.name.name or node.init.name.lexeme

  // condition: (maybe ANF block) -> Binary(i <limit-op> rhs)
  let hasAnfBlock = false
  let condNode = node.condition
  if condNode.type == NODE.Block and condNode.anfSynthetic {
    let extracted = extractConditionFromAnfBlock(condNode)
    if !extracted { return false }
    condNode = extracted.condition
    hasAnfBlock = true
  }

  if !condNode or condNode.type != NODE.Binary { return false }

  let op = condNode.operator and (condNode.operator.lexeme or condNode.operator)
  if op != "<" and op != "<=" and op != ">" and op != ">=" { return false }

  if !condNode.left or condNode.left.type != NODE.Identifier { return false }
  let left_name = condNode.left.value or condNode.left.name or condNode.left.lexeme
  if left_name != i_name { return false }

  if !condNode.right { return false }

  // If RHS is already an Identifier and no ANF block to hoist, no lowering needed.
  if condNode.right.type == NODE.Identifier and !hasAnfBlock {
    return false
  }

  // update: i = i + K   or   i = i - K
  if node.update.type != NODE.Assignment { return false }
  if !node.update.target or node.update.target.type != NODE.Identifier { return false }
  let update_target_name = node.update.target.value or node.update.target.name or node.update.target.lexeme
  if update_target_name != i_name { return false }

  let update_value = node.update.value
  if !update_value or update_value.type != NODE.Binary { return false }

  let update_op = update_value.operator and (update_value.operator.lexeme or update_value.operator)
  if update_op != "+" and update_op != "-" { return false }

  if !update_value.left or update_value.left.type != NODE.Identifier { return false }
  let update_left_name = update_value.left.value or update_value.left.name or update_value.left.lexeme
  if update_left_name != i_name { return false }

  // Post-ANF: don't require Number; require "some RHS" exists.
  if !update_value.right { return false }

  true
}

// ============================================================================
// Loop Lowering Transformation
// ============================================================================

fn lowerLoop(node, gen) {
  // Transform: for let i = init; i < expr; i = i + 1 { body }
  // Into:      { let $loop_limit_N = expr; for let i = init; i < $loop_limit_N; ... { body } }
  //
  // Special case for ANF blocks:
  //   for let i = init; { let $anf.0 = expr; i < $anf.0 }; i = i + 1 { body }
  // → { let $anf.0 = expr; for let i = init; i < $anf.0; i = i + 1 { body } }

  if !shouldLowerLoop(node) {
    // Not a loop we should lower - return original unchanged
    return node
  }

  // Check if condition is an ANF synthetic block
  let anfExtracted = nil
  let actualCond = node.condition
  let hoistedStmts = []  // Statements to hoist outside loop

  if node.condition.type == NODE.Block and node.condition.anfSynthetic {
    anfExtracted = extractConditionFromAnfBlock(node.condition)
    if anfExtracted {
      actualCond = anfExtracted.condition
      hoistedStmts = anfExtracted.anfLets  // Hoist ANF lets
    }
  }

  // ANF case: hoist ANF lets (simple extraction, no cloning needed)
  if anfExtracted {
    // Input:  for init; { let $anf.0 = expr; i < $anf.0 }; update { body }
    // Output: { let $anf.0 = expr; for init; i < $anf.0; update { body } }

    // Create new For with extracted condition (not the synthetic block)
    let newFor = makeFor(gen, node, node.init, anfExtracted.condition, node.update, node.body)

    // Build block with hoisted lets + new For + explicit nil
    let stmts = collect s in anfExtracted.anfLets { s }
    push(stmts, newFor)
    push(stmts, makeNil(gen, node))  // Ensure VALUE mode yields nil

    // Create wrapper block and mark as expression-safe
    let wrapper = makeBlock(gen, node, stmts)
    return wrapper
  }

  // Literal/expression case - create new temp variable
  if !actualCond or !actualCond.right {
    // Safety check - should not happen if shouldLowerLoop passed
    return node
  }

  let tempName = "$loop_limit_" + str(gen.limitCounter)
  gen.limitCounter = gen.limitCounter + 1

  // Create synthetic Let node for limit
  let limitIdent = makeIdentifier(gen, actualCond, tempName)
  let limitLet = makeLet(gen, actualCond, limitIdent, actualCond.right)

  // Create new identifier reference for condition
  let condLimitIdent = makeIdentifier(gen, actualCond.right, tempName)

  // Create new condition with synthetic limit identifier
  let newCond = makeBinary(gen, actualCond, actualCond.left, actualCond.operator, condLimitIdent)

  // Create new For node with modified condition
  let newFor = makeFor(gen, node, node.init, newCond, node.update, node.body)

  // Build expressions array: limit let + new loop + explicit nil
  let allStmts = []
  push(allStmts, limitLet)
  push(allStmts, newFor)
  push(allStmts, makeNil(gen, node))  // Ensure VALUE mode yields nil

  let wrapper = makeBlock(gen, node, allStmts)
  wrapper
}

// ============================================================================
// AST Traversal
// ============================================================================

fn walkFor(node, gen) {
  // Recurse only into body; leave init/cond/update intact (pattern matcher depends on shape).
  let body2 = walkExpr(node.body, gen)

  let node2 = node
  if body2 != node.body {
    // Rebuild For with preserved span.
    let sp = spanOf(node)
    let id = allocNodeId(gen)
    gen.origin[id] = node.id

    node2 = .{
      type: NODE.For,
      id: id,
      init: node.init,
      condition: node.condition,
      update: node.update,
      body: body2,
    }
    applySpan(node2, sp)
  }

  lowerLoop(node2, gen)
}

fn walkExprs(exprs, gen) {
  if !exprs { return [] }
  collect e in exprs { walkExpr(e, gen) }
}

fn walkExpr(node, gen) {
  if !node { return nil }

  if node.type == NODE.For {
    return walkFor(node, gen)
  }

  if node.type == NODE.Block {
    let newExprs = walkExprs(node.expressions, gen)

    // Only allocate a new block if something changed.
    let anyChanged = false
    for newExpr, i in newExprs {
      if newExpr != node.expressions[i] { anyChanged = true; break }
    }
    if !anyChanged { return node }

    let sp = spanOf(node)
    let id = allocNodeId(gen)
    gen.origin[id] = node.id
    let out = .{ type: NODE.Block, id: id, expressions: newExprs }
    applySpan(out, sp)
    return out
  }

  if node.type == NODE.Function {
    let newBody = walkExpr(node.body, gen)
    if newBody == node.body { return node }

    let sp = spanOf(node)
    let id = allocNodeId(gen)
    gen.origin[id] = node.id
    let out = .{
      type: NODE.Function,
      id: id,
      name: node.name,
      params: node.params,
      body: newBody,
    }
    applySpan(out, sp)
    return out
  }

  if node.type == NODE.If {
    let newThen = walkExpr(node.then, gen)
    let newElse = walkExpr(node.else, gen)
    if newThen == node.then and newElse == node.else { return node }

    let sp = spanOf(node)
    let id = allocNodeId(gen)
    gen.origin[id] = node.id
    let out = .{
      type: NODE.If,
      id: id,
      condition: node.condition,
      then: newThen,
      else: newElse,
    }
    applySpan(out, sp)
    return out
  }

  if node.type == NODE.Let {
    let newInit = walkExpr(node.init, gen)
    if newInit == node.init { return node }

    let sp = spanOf(node)
    let id = allocNodeId(gen)
    gen.origin[id] = node.id
    let out = .{
      type: NODE.Let,
      id: id,
      name: node.name,
      init: newInit,
    }
    applySpan(out, sp)
    return out
  }

  node
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn lowerLoops(ast, opts) {
  // Require nextNodeId to avoid ID collisions
  if !opts or opts.nextNodeId == nil {
    return .{
      success: false,
      ast: ast,
      origin: .{},
      nextNodeId: (ast and (ast.id + 1) or 1),
      errors: [.{ message: "lowerLoops requires opts.nextNodeId from previous pass" }],
    }
  }

  let gen = .{
    nextNodeId: opts.nextNodeId,
    origin: .{},
    limitCounter: 0,
    errors: [],
  }

  let transformedAst = walkExpr(ast, gen)

  .{
    success: len(gen.errors) == 0,
    ast: transformedAst,
    origin: gen.origin,
    nextNodeId: gen.nextNodeId,
    errors: gen.errors,
  }
}

lowerLoops
