// Typecheck Phase Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"

// Helper: parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{})
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    errors: typecheckResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

// Helper: Get type of expression in test block
fn getExprType(result, exprIndex) {
  // For tests like "{ expr1\nexpr2 }", ast.body[0] is the Block
  // and the expressions are in Block.expressions
  let ast = result.lowerResult.ast
  if !ast or !ast.body or len(ast.body) == 0 {
    return nil
  }

  let blockNode = ast.body[0]
  if !blockNode or blockNode.type != "Block" or !blockNode.expressions {
    return nil
  }

  if exprIndex >= len(blockNode.expressions) {
    return nil
  }

  let node = blockNode.expressions[exprIndex]

  // For Let nodes, get the type of the bound variable (from name.id)
  if node.type == "Let" {
    return result.types[node.name.id]
  }

  // Direct expression - return its type
  return result.types[node.id]
}

// Helper: Get the actual AST node at an index
fn getExprNode(result, exprIndex) {
  let ast = result.lowerResult.ast
  if len(ast.body) > 0 {
    let blockNode = ast.body[0]
    if blockNode.type == "Block" and exprIndex < len(blockNode.expressions) {
      return blockNode.expressions[exprIndex]
    }
  }
  nil
}

// ========================================
// Primitive Literals
// ========================================

test("typecheck - number literal", fn(assert) {
  let result = parseAndTypecheck("{ 42 }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Number", "42 should have type Number")
})

test("typecheck - string literal", fn(assert) {
  let result = parseAndTypecheck("{ \"hello\" }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "String", "\"hello\" should have type String")
})

test("typecheck - bool literal", fn(assert) {
  let result = parseAndTypecheck("{ true }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Bool", "true should have type Bool")
})

test("typecheck - nil literal", fn(assert) {
  let result = parseAndTypecheck("{ nil }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Nil", "nil should have type Nil")
})

// ========================================
// Variables
// ========================================

test("typecheck - let with number", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42 }")
  let type = getExprType(result, 0)
  assert.equal(type.kind, "Number", "x should have type Number")
})

test("typecheck - variable reference", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx }")
  let varType = getExprType(result, 1)
  assert.equal(varType.kind, "Number", "x reference should have type Number")
})

test("typecheck - variable assignment", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx = 100 }")
  assert.truthy(result.success, "Should typecheck assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx = \"hello\" }")
  assert.equal(result.success, false, "Should fail on type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Operators
// ========================================

test("typecheck - arithmetic operators", fn(assert) {
  let result = parseAndTypecheck("1 + 2 * 3 - 4 / 5")
  assert.truthy(result.success, "Should typecheck arithmetic")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - comparison operators", fn(assert) {
  let result = parseAndTypecheck("1 < 2 and 3 > 4 or 5 == 6")
  assert.truthy(result.success, "Should typecheck comparison")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arithmetic type error", fn(assert) {
  let result = parseAndTypecheck("\"hello\" + 42")
  assert.equal(result.success, false, "Should fail on arithmetic type error")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - unary operators", fn(assert) {
  let result = parseAndTypecheck("-42")
  assert.truthy(result.success, "Should typecheck unary negation")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - logical not", fn(assert) {
  let result = parseAndTypecheck("!true")
  assert.truthy(result.success, "Should typecheck logical not")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Arrays
// ========================================

test("typecheck - empty array", fn(assert) {
  let result = parseAndTypecheck("[]")
  assert.truthy(result.success, "Should typecheck empty array")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - homogeneous array", fn(assert) {
  let result = parseAndTypecheck("[1, 2, 3]")
  assert.truthy(result.success, "Should typecheck homogeneous array")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element type error", fn(assert) {
  let result = parseAndTypecheck("[1, \"hello\", 3]")
  assert.equal(result.success, false, "Should fail on mixed array")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - array index access", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] }")
  assert.truthy(result.success, "Should typecheck array access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element assignment", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] = 42 }")
  assert.truthy(result.success, "Should typecheck array element assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array element assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\narr[0] = \"hello\" }")
  assert.equal(result.success, false, "Should fail on element type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Records
// ========================================

test("typecheck - record literal", fn(assert) {
  let result = parseAndTypecheck(".{ x: 1, y: 2 }")
  assert.truthy(result.success, "Should typecheck record literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record field access", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1, y: 2 }\nobj.x }")
  assert.truthy(result.success, "Should typecheck record field access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - missing field error", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.y }")
  assert.equal(result.success, false, "Should fail on missing field")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - record field assignment", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.x = 42 }")
  assert.truthy(result.success, "Should typecheck field assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record field assignment type error", fn(assert) {
  let result = parseAndTypecheck("{ let obj = .{ x: 1 }\nobj.x = \"hello\" }")
  assert.equal(result.success, false, "Should fail on field type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Functions
// ========================================

test("typecheck - function definition", fn(assert) {
  let result = parseAndTypecheck("fn(x) { x }")
  assert.truthy(result.success, "Should typecheck function definition")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function call", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x }\nf(42) }")
  assert.truthy(result.success, "Should typecheck function call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function with multiple params", fn(assert) {
  let result = parseAndTypecheck("fn(x, y) { x + y }")
  assert.truthy(result.success, "Should typecheck multi-param function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - function return type", fn(assert) {
  let result = parseAndTypecheck("fn(x) { return x + 1 }")
  assert.truthy(result.success, "Should typecheck function with return")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arity mismatch", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x, y) { x + y }\nf(42) }")
  assert.equal(result.success, false, "Should fail on arity mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - argument type error", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x + 1 }\nf(\"hello\") }")
  assert.equal(result.success, false, "Should fail on argument type error")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - closure", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nfn() { x } }")
  assert.truthy(result.success, "Should typecheck closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested functions", fn(assert) {
  let result = parseAndTypecheck("fn(x) { fn(y) { x + y } }")
  assert.truthy(result.success, "Should typecheck nested functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - return type mismatch", fn(assert) {
  let result = parseAndTypecheck("fn() { if true { return 1 } else { return \"hello\" } }")
  assert.equal(result.success, false, "Should fail on return type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow
// ========================================

test("typecheck - if expression", fn(assert) {
  let result = parseAndTypecheck("if true { 1 } else { 2 }")
  assert.truthy(result.success, "Should typecheck if expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - if without else", fn(assert) {
  let result = parseAndTypecheck("if true { 1 }")
  assert.truthy(result.success, "Should typecheck if without else")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - if branch type mismatch", fn(assert) {
  let result = parseAndTypecheck("if true { 1 } else { \"hello\" }")
  assert.equal(result.success, false, "Should fail on branch type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - for loop", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { i }")
  assert.truthy(result.success, "Should typecheck for loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - break", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { break }")
  assert.truthy(result.success, "Should typecheck break")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - continue", fn(assert) {
  let result = parseAndTypecheck("for let i = 0; i < 10; i = i + 1 { continue }")
  assert.truthy(result.success, "Should typecheck continue")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Complex Examples
// ========================================

test("typecheck - factorial function", fn(assert) {
  let source = "fn factorial(n) { if n <= 1 { 1 } else { n * factorial(n - 1) } }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck factorial")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array map pattern", fn(assert) {
  let source = "{ let arr = [1, 2, 3]\nlet result = []\nfor let i = 0; i < len(arr); i = i + 1 { push(result, arr[i] + 1) }\nresult }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck array map pattern")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - record with functions", fn(assert) {
  let source = ".{ add: fn(x, y) { x + y }, sub: fn(x, y) { x - y } }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck record with functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested records", fn(assert) {
  let source = "{ let obj = .{ inner: .{ x: 42 } }\nobj.inner.x }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck nested records")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - array of records", fn(assert) {
  let source = "[.{ x: 1 }, .{ x: 2 }, .{ x: 3 }]"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck array of records")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - higher-order function", fn(assert) {
  let source = "{ let apply = fn(f, x) { f(x) }\nlet inc = fn(n) { n + 1 }\napply(inc, 42) }"
  let result = parseAndTypecheck(source)
  assert.truthy(result.success, "Should typecheck higher-order function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Edge Cases
// ========================================

test("typecheck - grouping expression", fn(assert) {
  let result = parseAndTypecheck("(1 + 2) * 3")
  assert.truthy(result.success, "Should typecheck grouped expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - block expression", fn(assert) {
  let result = parseAndTypecheck("{ 1\n2\n3 }")
  assert.truthy(result.success, "Should typecheck block")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - nested blocks", fn(assert) {
  let result = parseAndTypecheck("{ { 1 } }")
  assert.truthy(result.success, "Should typecheck nested blocks")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - shadowing", fn(assert) {
  let result = parseAndTypecheck("{ let x = 1\n{ let x = \"hello\"\nx }\nx }")
  assert.truthy(result.success, "Should typecheck shadowing")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Arity Widening Tests
// ========================================

test("typecheck - arity widening allows extra args", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x + 1 }\nf(1, 2, 3) }")
  assert.truthy(result.success, "Should allow extra arguments")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - arity error on missing args", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x, y) { x + y }\nf(1) }")
  assert.equal(result.success, false, "Should fail with missing arguments")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Builtin Function Signature Tests
// ========================================

test("typecheck - len with array", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\nlet n = len(arr)\nn + 1 }")
  assert.truthy(result.success, "Should typecheck len")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - push with array", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\npush(arr, 4) }")
  assert.truthy(result.success, "Should typecheck push")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - push type error", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\npush(arr, \"hello\") }")
  assert.equal(result.success, false, "Should fail with type mismatch")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - map with array", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\nlet doubled = map(arr, fn(x) { x * 2 })\ndoubled }")
  assert.truthy(result.success, "Should typecheck map")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - fold with array", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\nlet sum = fold(arr, 0, fn(acc, x) { acc + x })\nsum }")
  assert.truthy(result.success, "Should typecheck fold")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - join with strings", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [\"a\", \"b\", \"c\"]\nlet s = join(arr, \",\")\ns }")
  assert.truthy(result.success, "Should typecheck join")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - range returns array of numbers", fn(assert) {
  let result = parseAndTypecheck("{ let arr = range(5)\nlet x = arr[0]\nx + 1 }")
  assert.truthy(result.success, "Should typecheck range")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// TypeVar Refinement Tests
// ========================================

test("typecheck - empty array refinement via index", fn(assert) {
  let result = parseAndTypecheck("{ let arr = []\narr[0] = 5\nlet x = arr[0]\nx + 1 }")
  assert.truthy(result.success, "Should refine empty array element type")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Polymorphism Tests
// ========================================

test("typecheck - polymorphic identity function", fn(assert) {
  let result = parseAndTypecheck("{ let id = fn(x) { x }\nlet n = id(42)\nlet s = id(\"hello\")\nn + 1 }")
  assert.truthy(result.success, "Should allow polymorphic identity")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic function with constraints", fn(assert) {
  let result = parseAndTypecheck("{ let add1 = fn(x) { x + 1 }\nlet n1 = add1(10)\nlet n2 = add1(20)\nn1 + n2 }")
  assert.truthy(result.success, "Should allow multiple uses with same constraint")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic higher-order function", fn(assert) {
  let result = parseAndTypecheck("{ let apply = fn(f, x) { f(x) }\nlet inc = fn(n) { n + 1 }\napply(inc, 42) }")
  assert.truthy(result.success, "Should typecheck higher-order polymorphic function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - value restriction prevents generalization", fn(assert) {
  // Non-function values should not be generalized
  let result = parseAndTypecheck("{ let x = 42\nx = x + 1\nx }")
  assert.truthy(result.success, "Should allow assignment to monomorphic binding")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - cannot assign to polymorphic binding", fn(assert) {
  let result = parseAndTypecheck("{ let f = fn(x) { x }\nf = fn(y) { y + 1 }\nf }")
  assert.equal(result.success, false, "Should fail on assignment to poly binding")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("typecheck - polymorphic function in array operations", fn(assert) {
  let result = parseAndTypecheck("{ let double = fn(x) { x + x }\nlet nums = [1, 2, 3]\nmap(nums, double) }")
  assert.truthy(result.success, "Should work with polymorphic map")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("typecheck - polymorphic pair selector", fn(assert) {
  let result = parseAndTypecheck("{ let fst = fn(a, b) { a }\nlet n = fst(1, \"x\")\nlet s = fst(\"hello\", 42)\nn + 1 }")
  assert.truthy(result.success, "Should generalize pair selectors")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Type Verification Tests (checking actual inferred types)
// ========================================

test("typecheck - verify literal types", fn(assert) {
  let result = parseAndTypecheck("{ 42\n\"hello\"\ntrue\nnil }")
  assert.truthy(result.success, "Should typecheck")

  let t0 = getExprType(result, 0)
  assert.equal(t0.kind, "Number", "42 should be Number")

  let t1 = getExprType(result, 1)
  assert.equal(t1.kind, "String", "\"hello\" should be String")

  let t2 = getExprType(result, 2)
  assert.equal(t2.kind, "Bool", "true should be Bool")

  let t3 = getExprType(result, 3)
  assert.equal(t3.kind, "Nil", "nil should be Nil")
})

test("typecheck - verify array type", fn(assert) {
  let result = parseAndTypecheck("{ [1, 2, 3] }")
  assert.truthy(result.success, "Should typecheck")

  let arrayType = getExprType(result, 0)
  assert.equal(arrayType.kind, "Array", "Should be Array type")
  assert.equal(arrayType.elem.kind, "Number", "Element type should be Number")
})

test("typecheck - verify record type", fn(assert) {
  let result = parseAndTypecheck("{ .{ x: 42, y: \"hello\" } }")
  assert.truthy(result.success, "Should typecheck")

  let recordType = getExprType(result, 0)
  assert.equal(recordType.kind, "Record", "Should be Record type")
  assert.equal(recordType.fields.x.kind, "Number", "Field x should be Number")
  assert.equal(recordType.fields.y.kind, "String", "Field y should be String")
})

test("typecheck - verify function type", fn(assert) {
  let result = parseAndTypecheck("{ fn(x, y) { x + y } }")
  assert.truthy(result.success, "Should typecheck")

  let fnType = getExprType(result, 0)
  assert.equal(fnType.kind, "Function", "Should be Function type")
  assert.equal(len(fnType.params), 2, "Should have 2 parameters")
  assert.equal(fnType.params[0].kind, "Number", "First param should be Number")
  assert.equal(fnType.params[1].kind, "Number", "Second param should be Number")
  assert.equal(fnType.return.kind, "Number", "Return type should be Number")
})

test("typecheck - verify builtin len returns Number", fn(assert) {
  let result = parseAndTypecheck("{ let arr = [1, 2, 3]\nlen(arr) }")
  assert.truthy(result.success, "Should typecheck")

  let lenCallType = getExprType(result, 1)
  assert.equal(lenCallType.kind, "Number", "len should return Number")
})

test("typecheck - verify map returns Array", fn(assert) {
  let result = parseAndTypecheck("{ let nums = [1, 2, 3]\nmap(nums, fn(x) { x * 2 }) }")
  assert.truthy(result.success, "Should typecheck")

  let mapType = getExprType(result, 1)
  assert.equal(mapType.kind, "Array", "map should return Array")
  assert.equal(mapType.elem.kind, "Number", "Mapped array should contain Numbers")
})

test("typecheck - verify polymorphic instantiation creates different types", fn(assert) {
  let result = parseAndTypecheck("{ let id = fn(x) { x }\nid(42)\nid(\"hello\") }")
  assert.truthy(result.success, "Should typecheck")

  let call1Type = getExprType(result, 1)
  assert.equal(call1Type.kind, "Number", "First call should return Number")

  let call2Type = getExprType(result, 2)
  assert.equal(call2Type.kind, "String", "Second call should return String")
})

test("typecheck - verify let binding gets correct type", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx }")
  assert.truthy(result.success, "Should typecheck")

  // The second expression is the identifier reference
  let xType = getExprType(result, 1)
  assert.equal(xType.kind, "Number", "Variable x should have type Number")
})

// ========================================
// Type Narrowing
// ========================================

test("typecheck - narrowing: x != nil preserves type", fn(assert) {
  let code = "{
    let x = 42
    if x != nil {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck with nil guard")

  // In then branch, x should still be Number (non-nil is implicit)
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Number", "x should still be Number in then branch")
})

test("typecheck - narrowing: x == nil refines to Nil", fn(assert) {
  let code = "{
    let x = 42
    if x == nil {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  // In then branch, x should be refined to Nil
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Nil", "x should be Nil in then branch")
})

test("typecheck - narrowing: nil != x works (reversed)", fn(assert) {
  let code = "{
    let x = 42
    if nil != x {
      let y = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck reversed nil check")
})

test("typecheck - narrowing: type test refines to expected type", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"string\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  // In then branch, x should be refined to String
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "String", "x should be String in then branch")
})

test("typecheck - narrowing: type test supports all primitives", fn(assert) {
  let code = "{
    let x = nil
    if type(x) == \"number\" { x }
    if type(x) == \"string\" { x }
    if type(x) == \"bool\" { x }
    if type(x) == \"nil\" { x }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck all type tests")

  // Verify each if branch has the correct refined type
  let ast = result.lowerResult.ast
  let blockExprs = ast.body[0].expressions

  // First if: type(x) == "number"
  let if1 = blockExprs[1]
  let then1Type = result.types[if1.then.expressions[0].id]
  assert.equal(then1Type.kind, "Number", "Should refine to Number")

  // Second if: type(x) == "string"
  let if2 = blockExprs[2]
  let then2Type = result.types[if2.then.expressions[0].id]
  assert.equal(then2Type.kind, "String", "Should refine to String")

  // Third if: type(x) == "bool"
  let if3 = blockExprs[3]
  let then3Type = result.types[if3.then.expressions[0].id]
  assert.equal(then3Type.kind, "Bool", "Should refine to Bool")

  // Fourth if: type(x) == "nil"
  let if4 = blockExprs[4]
  let then4Type = result.types[if4.then.expressions[0].id]
  assert.equal(then4Type.kind, "Nil", "Should refine to Nil")
})

test("typecheck - narrowing: type test supports array", fn(assert) {
  let code = "{
    let x = [1, 2, 3]
    if type(x) == \"array\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck array type test")

  // In then branch, x should be refined to Array
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Array", "x should be Array in then branch")
})

test("typecheck - narrowing: type test supports map", fn(assert) {
  let code = "{
    let x = .{ a: 1 }
    if type(x) == \"map\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck map type test")

  // In then branch, x should be refined to Record
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Record", "x should be Record in then branch")
})

test("typecheck - narrowing: type test supports function", fn(assert) {
  let code = "{
    let x = fn() { 42 }
    if type(x) == \"function\" {
      x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck function type test")

  // In then branch, x should be refined to Function
  let ast = result.lowerResult.ast
  let ifNode = ast.body[0].expressions[1]
  let thenExpr = ifNode.then.expressions[0]
  let thenType = result.types[thenExpr.id]
  assert.equal(thenType.kind, "Function", "x should be Function in then branch")
})

test("typecheck - narrowing: tag check infrastructure", fn(assert) {
  let code = "{
    let x = .{ kind: \"Foo\", value: 42 }
    if x.kind == \"Foo\" {
      let y = x.value
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck tag check")
})

test("typecheck - narrowing: else branch works", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"string\" {
      let a = x
    } else {
      let b = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck both branches")
})

test("typecheck - narrowing: nested ifs work", fn(assert) {
  let code = "{
    let x = nil
    if x != nil {
      if type(x) == \"string\" {
        let y = x
      }
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck nested ifs")
})

test("typecheck - narrowing: polymorphic bindings not refined", fn(assert) {
  let code = "{
    let f = fn(x) { x }
    if type(f) == \"string\" {
      let y = f
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle polymorphic bindings")
})

test("typecheck - narrowing: unknown type string ignored", fn(assert) {
  let code = "{
    let x = 42
    if type(x) == \"unknown_type\" {
      let y = x
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should ignore unknown type strings")
})

test("typecheck - narrowing: non-identifier expressions ignored", fn(assert) {
  let code = "{
    if type(42) == \"number\" {
      let y = 1
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should ignore non-identifier type tests")
})

// ========================================
// Tagged Records Tests
// ========================================

test("typecheck - tagged: detect literal with kind field", fn(assert) {
  let code = "{ .{ kind: \"Int\", value: 42 } }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  let exprType = getExprType(result, 0)
  assert.equal(exprType.kind, "Tagged", "Should be Tagged type")
  assert.equal(exprType.tagField, "kind", "Should use kind as tag field")

  let intCase = exprType.cases["Int"]
  assert.truthy(intCase, "Should have Int case")
  assert.equal(intCase.kind, "Record", "Case should be Record")
  assert.truthy(intCase.fields["value"], "Should have value field")
})

test("typecheck - tagged: non-literal tag value remains Record", fn(assert) {
  let code = "{
    let x = \"Int\"
    .{ kind: x, value: 42 }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  let exprType = getExprType(result, 1)
  assert.equal(exprType.kind, "Record", "Should be Record type with non-literal tag")
})

test("typecheck - tagged: tag field access returns String", fn(assert) {
  let code = "{
    let x = .{ kind: \"Int\", value: 42 }
    x.kind
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  let accessType = getExprType(result, 1)
  assert.equal(accessType.kind, "String", "Tag field access should return String")
})

test("typecheck - tagged: unify creates multi-case union", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"Int\", value: 42 } } else { .{ kind: \"Str\", text: \"hi\" } }
    x
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should typecheck")

  let xType = getExprType(result, 0)
  assert.equal(xType.kind, "Tagged", "Should be Tagged type")
  assert.truthy(xType.cases["Int"], "Should have Int case")
  assert.truthy(xType.cases["Str"], "Should have Str case")
})

test("typecheck - tagged: incompatible tag fields error", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"Int\", value: 42 } } else { .{ type: \"Str\", text: \"hi\" } }
    x
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should fail with incompatible tag fields")
})

test("typecheck - tagged: common field accessible without narrowing", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"A\", id: 1 } } else { .{ kind: \"B\", id: 2 } }
    x.id
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should access common field")

  let idType = getExprType(result, 1)
  assert.equal(idType.kind, "Number", "Common field should have Number type")
})

test("typecheck - tagged: case-specific field without narrowing errors", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"Int\", value: 42 } } else { .{ kind: \"Str\", text: \"hi\" } }
    x.value
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error accessing case-specific field without narrowing")
})

test("typecheck - tagged: field type mismatch across cases errors", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"A\", data: 42 } } else { .{ kind: \"B\", data: \"str\" } }
    x.data
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error with incompatible field types across cases")
})

test("typecheck - tagged: tag check enables case-specific access", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"Int\", value: 42 } } else { .{ kind: \"Str\", text: \"hi\" } }
    if x.kind == \"Int\" {
      x.value
    } else {
      0
    }
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should enable case-specific access after tag check")
})

test("typecheck - tagged: narrowed access in both branches", fn(assert) {
  let code = "{
    let x = if true { .{ kind: \"Int\", value: 42 } } else { .{ kind: \"Str\", text: \"hi\" } }
    let intAccess = if x.kind == \"Int\" { x.value } else { 0 }
    let strAccess = if x.kind == \"Str\" { x.text } else { \"\" }
    0
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should work with narrowing in both branches")
})

test("typecheck - tagged: nested tagged records", fn(assert) {
  let code = "{
    let outer = .{ kind: \"Container\", inner: .{ type: \"Leaf\", value: 42 } }
    outer.inner.type
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle nested tagged records")

  let accessType = getExprType(result, 1)
  assert.equal(accessType.kind, "String", "Nested tag field access should return String")
})

test("typecheck - tagged: array of tagged", fn(assert) {
  let code = "{
    let arr = [.{ kind: \"Int\", value: 1 }, .{ kind: \"Int\", value: 2 }]
    arr
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle array of tagged records")

  // Arrays with tagged records should work
  // Note: We don't verify the exact type structure as it may vary
})

test("typecheck - tagged: with polymorphic functions", fn(assert) {
  let code = "{
    let identity = fn(x) { x }
    identity(.{ kind: \"Int\", value: 42 })
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should work with polymorphic functions")

  let callType = getExprType(result, 1)
  assert.equal(callType.kind, "Tagged", "Should preserve Tagged type through generic function")
})

test("typecheck - tagged: multiple tag field names", fn(assert) {
  let code1 = "{ .{ kind: \"A\", x: 1 } }"
  let result1 = parseAndTypecheck(code1)
  assert.truthy(result1.success, "Should support kind")
  assert.equal(getExprType(result1, 0).kind, "Tagged", "kind should create Tagged")

  let code2 = "{ .{ type: \"B\", y: 2 } }"
  let result2 = parseAndTypecheck(code2)
  assert.truthy(result2.success, "Should support type")
  assert.equal(getExprType(result2, 0).kind, "Tagged", "type should create Tagged")

  let code3 = "{ .{ tag: \"C\", z: 3 } }"
  let result3 = parseAndTypecheck(code3)
  assert.truthy(result3.success, "Should support tag")
  assert.equal(getExprType(result3, 0).kind, "Tagged", "tag should create Tagged")
})

// ========================================
// Regression Tests for Type System Gaps
// ========================================

test("typecheck - regression: named function call type checking", fn(assert) {
  let code = "{
    fn f() { \"hello\" }
    f() + 1
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: can't add String and Number")
})

test("typecheck - regression: recursive function type inference", fn(assert) {
  let code = "{
    fn fact(n) {
      if n == 0 { 1 } else { n * fact(n - 1) }
    }
    fact(5)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow recursive calls")
})

test("typecheck - regression: global consistency checking", fn(assert) {
  let code = "{
    let a = println
    let b = println
    a(1)
    b(\"hello\")
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should handle consistent global usage")
})

test("typecheck - regression: unknown type refinement", fn(assert) {
  let code = "{
    fn getVal(x) { x.value }
    let obj = .{ value: 42 }
    getVal(obj)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should refine unknown to record shape")
})

test("typecheck - regression: keys on real records", fn(assert) {
  let code = "{
    let obj = .{ a: 1, b: 2 }
    keys(obj)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Should allow keys on non-empty records")
})

test("typecheck - regression: invalid index assignment", fn(assert) {
  let code = "{
    1[0] = 2
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: can't index into number")
})

test("typecheck - regression: invalid dot assignment", fn(assert) {
  let code = "{
    let obj = .{ x: 1 }
    obj.y = 3
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(!result.success, "Should error: field y doesn't exist")
})

test("typecheck - regression: if without else known limitation", fn(assert) {
  // Note: Without union types, if-without-else cannot be properly typed as "T | Nil"
  // This is a known limitation - the typecheck phase returns the then-branch type
  // even though the result could be Nil at runtime
  let code = "{
    fn f(cond) {
      if cond { 1 }
    }
    f(true)
  }"
  let result = parseAndTypecheck(code)
  assert.truthy(result.success, "Currently allows if-without-else (known limitation)")
})

suite.run()
