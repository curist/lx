// Driver - Orchestrates compilation pipeline (passes): parse → lower → anf → resolve → anf-inline → typecheck
//
// Responsibilities:
// - Coordinate pass execution
// - Manage import cache for multi-file compilation
// - Handle circular import detection
// - Provide compilation artifacts for query service and codegen
// - ANF runs after lower (optional, default on)
// - ANF inline runs post-resolve (optional, default on)

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let anf = import "src/anf.lx"
let anfInline = import "src/anf-inline.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"
let pipeline = import "src/passes/pipeline.lx"

// ========================================
// Profile Definitions
// ========================================

fn getProfile(name) {
  // Returns .{ withAnf, withAnfInline, withTypecheck } for the given profile
  // Profiles define curated pass combinations for specific use cases

  if name == "default" {
    // Current compiler semantics: all passes enabled
    // parse → lower → anf → resolve → anf-inline → typecheck (non-fatal)
    return .{
      withAnf: true,
      withAnfInline: true,
      withTypecheck: true,
    }
  }

  if name == "tooling" {
    // Best AST/tables for IDE/LSP
    // Same as default: parse → lower → anf → resolve → anf-inline → typecheck (non-fatal)
    return .{
      withAnf: true,
      withAnfInline: true,
      withTypecheck: true,
    }
  }

  if name == "O0" {
    // No optimizations, but keep passes that establish correctness invariants
    // parse → lower → anf → resolve → typecheck (non-fatal)
    // Skip anf-inline optimization
    return .{
      withAnf: true,
      withAnfInline: false,
      withTypecheck: true,
    }
  }

  // Unknown profile - return nil to signal error
  nil
}

// ========================================
// Build Pass List
// ========================================

fn buildPassList(ctx) {
  // Build the list of passes with their adapters
  // ctx contains: importCache, compileModule, opts (withAnf, withAnfInline, withTypecheck)

  [
    // PASS 1: Parse
    .{
      name: "parse",
      mutatesAst: false,
      provides: ["ast", "parseTree"],
      run: fn(ctx, state) {
        parse(state.source, state.path)
      },
    },

    // PASS 2: Lower
    .{
      name: "lower",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["loweredAst"],
      run: fn(ctx, state) {
        let result = lower(state.ast, .{ startNodeId: state.nextNodeId })

        // Remap parse enum info (if present) onto lowered node IDs via origin.
        let parseResult = state.passes and state.passes.parse
        if parseResult and parseResult.enumInfo and result and result.origin {
          let remapped = .{}
          let newIds = keys(result.origin)
          for let i = 0; i < len(newIds); i = i + 1 {
            let newId = newIds[i]
            let oldId = result.origin[newId]
            if (type(oldId) == "number" or type(oldId) == "string") {
              let info = parseResult.enumInfo[oldId]
              if info { remapped[newId] = info }
            }
          }
          return .{
            success: result.success,
            ast: result.ast,
            origin: result.origin,
            errors: result.errors,
            nextNodeId: result.nextNodeId,
            enumInfo: remapped,
          }
        }

        result
      },
    },

    // PASS 3: ANF (optional, default on)
    .{
      name: "anf",
      mutatesAst: false,
      requires: ["loweredAst"],
      provides: ["anfAst", "loweredAst"],  // ANF is a refinement, still satisfies loweredAst contracts
      enabled: fn(ctx, state) {
        // Explicit boolean: default to true if opts missing
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        true
      },
      run: fn(ctx, state) {
        let result = anf(state.ast, .{ startNodeId: state.nextNodeId })

        // Remap enum info through ANF transform (node IDs change again).
        let prev = state.passes and state.passes.lower
        if prev and prev.enumInfo and result and result.origin {
          let remapped = .{}
          let newIds = keys(result.origin)
          for let i = 0; i < len(newIds); i = i + 1 {
            let newId = newIds[i]
            let oldId = result.origin[newId]
            if (type(oldId) == "number" or type(oldId) == "string") {
              let info = prev.enumInfo[oldId]
              if info { remapped[newId] = info }
            }
          }
          return .{
            success: result.success,
            ast: result.ast,
            origin: result.origin,
            errors: result.errors,
            nextNodeId: result.nextNodeId,
            enumInfo: remapped,
          }
        }

        result
      },
    },

    // PASS 4: Resolve
    .{
      name: "resolve",
      mutatesAst: false,  // Phase 2: import metadata moved to side tables
      requires: ["loweredAst"],  // Requires lowered form (works with lowered or ANF)
      provides: ["resolution", "scopeInfo"],
      run: fn(ctx, state) {
        let opts = .{
          importCache: ctx.importCache,
          compileModule: ctx.compileModule,
        }
        resolve(state.ast, opts)
      },
    },

    // PASS 5: ANF Inline Optimization (optional, default on, post-resolve)
    .{
      name: "anf-inline",
      mutatesAst: true,  // Explicitly mutates AST in-place
      requires: ["anfAst", "resolution"],
      provides: ["optimizedAst"],
      enabled: fn(ctx, state) {
        // Only run if both ANF and ANF-inline are enabled
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        if ctx.opts.withAnfInline == false { return false }
        true
      },
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        anfInline(state.ast, resolveResult)
      },
    },

    // PASS 6: Typecheck (optional, non-fatal)
    .{
      name: "typecheck",
      mutatesAst: false,
      fatal: false,  // Non-fatal: don't stop pipeline on typecheck errors
      requires: ["resolution"],
      provides: ["typeInfo"],
      enabled: fn(ctx, state) {
        // Explicit boolean: default to true if opts missing
        if !ctx.opts { return true }
        if ctx.opts.withTypecheck == false { return false }
        true
      },
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        // Pass enum info through opts for future special handling.
        let enumInfo =
          (state.passes and state.passes.anf and state.passes.anf.enumInfo) or
          (state.passes and state.passes.lower and state.passes.lower.enumInfo) or
          (state.passes and state.passes.parse and state.passes.parse.enumInfo)
        let result = typecheck(state.ast, resolveResult, .{ enumInfo: enumInfo })

        // Defensive: handle nil return (shouldn't happen, but be safe)
        if !result {
          return .{
            success: false,
            errors: [.{
              pass: "typecheck",
              message: "typecheck returned nil",
              severity: "error",
            }],
          }
        }

        result
      },
    },
  ]
}

// ========================================
// Driver Factory
// ========================================

fn make(opts) {
  let driver = .{}
  driver.cache = .{}
  driver.compiledModules = []  // Track compilation order
  driver.loadSource = opts.loadSource

  // Profile support: profile sets defaults, explicit flags override
  let profileName = opts.profile or "default"
  let profileDefaults = getProfile(profileName)

  if !profileDefaults {
    // Unknown profile - error
    groanln("Error: Unknown profile '" + profileName + "'")
    groanln("Available profiles: default, tooling, O0")
    return nil
  }

  // Apply profile defaults, then override with explicit flags
  // Check if flag is explicitly set (not nil), if so use it, else use profile default
  if opts.withTypecheck != nil {
    driver.withTypecheck = opts.withTypecheck
  } else {
    driver.withTypecheck = profileDefaults.withTypecheck
  }

  if opts.withAnf != nil {
    driver.withAnf = opts.withAnf
  } else {
    driver.withAnf = profileDefaults.withAnf
  }

  if opts.withAnfInline != nil {
    driver.withAnfInline = opts.withAnfInline
  } else {
    driver.withAnfInline = profileDefaults.withAnfInline
  }

  // Debug flags (optional)
  driver.debug = opts.debug

  driver.compileModule = fn(path) {
    // Check cache first
    let cached = driver.cache[path]
    if cached {
      return cached
    }

    // Track compilation (first time only)
    push(driver.compiledModules, path)

    // Mark as compiling (for circular import detection)
    driver.cache[path] = .{
      status: "compiling",
      path: path,
    }

    // Load source via callback
    let source = nil
    if driver.loadSource {
      source = driver.loadSource(path)
    }

    if !source {
      // Source loading failed - represent as failed parse pass
      let result = .{
        status: "failed",
        success: false,
        path: path,
        failedPass: "parse",
        passOrder: ["parse"],
        passes: .{
          parse: .{
            success: false,
            errors: ["Failed to load source: " + path],
          },
        },
      }
      driver.cache[path] = result
      return result
    }

    // ========================================
    // Run Pipeline
    // ========================================

    // Build context for passes
    let ctx = .{
      importCache: driver.cache,
      compileModule: driver.compileModule,
      opts: .{
        withAnf: driver.withAnf,
        withAnfInline: driver.withAnfInline,
        withTypecheck: driver.withTypecheck,
      },
      debug: driver.debug,
    }

    // Build initial state
    let state = .{
      path: path,
      source: source,
      ast: nil,
      nextNodeId: 1,
      passes: .{},
    }

    // Execute passes
    let passList = buildPassList(ctx)
    let pipelineResult = pipeline.runPasses(passList, ctx, state)

    // Build result with pipeline fields
    let result = .{
      // Core fields
      status: pipelineResult.status,
      success: pipelineResult.success,
      path: path,
      failedPass: pipelineResult.failedPass,

      // Pipeline fields
      passOrder: pipelineResult.passOrder,
      passes: pipelineResult.passes,
    }

    driver.cache[path] = result
    return result
  }

  driver
}

// ========================================
// Module Exports
// ========================================

.{
  make: make
}
