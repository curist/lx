// src/select.lx
//
// Opcode selection and micro-optimizations for codegen.
// Purpose:
// - Centralize all "policy" decisions (fastcheck/rep facts, opcode choice, superinstructions).
// - Keep codegen mechanical: evaluate operands, ask select, emit.
//
// Contract:
// - No byte emission.
// - No mutation of gen slot counters / scope stacks.
// - May read gen.fastcheck (today) or gen.rep (future).
// - Must be deterministic and side-effect free.

let .{ OP, NODE } = import "src/types.lx"

// -----------------------------------------------------------------------------
// Facts access (fastcheck today, rep analysis tomorrow)
// -----------------------------------------------------------------------------

fn facts(gen) {
  // Prefer future rep pass if present; fall back to fastcheck.
  // rep.facts format suggestion:
  //   facts[nodeId] = "FIXNUM" | "NUM_FLOAT" | "NUM_ANY" | "STR" | "BOOL" | "NIL" | ...
  if gen.rep and gen.rep.facts { return gen.rep.facts }
  if gen.fastcheck and gen.fastcheck.facts { return gen.fastcheck.facts }
  nil
}

fn classOf(gen, node) {
  let fc = facts(gen)
  fc and fc[node and node.id]
}

fn isNumericClass(cls) {
  cls == "NUM_INT" or cls == "NUM_FLOAT" or cls == "NUM_ANY" or
  cls == "FIXNUM" // forward-compat alias if you rename later
}

fn isIntClass(cls) {
  cls == "NUM_INT" or cls == "FIXNUM"
}

fn isStrClass(cls) {
  cls == "STR"
}

// -----------------------------------------------------------------------------
// Unary selection
// -----------------------------------------------------------------------------

fn selectUnaryOpcode(gen, node) {
  // node: NODE.Unary
  let op = node.operator and node.operator.lexeme or ""
  if op == "!" { return OP.NOT }
  if op == "-" {
    let operandCls = classOf(gen, node.operand)
    return isIntClass(operandCls) and OP.NEGATE_INT or OP.NEGATE
  }
  nil
}

// -----------------------------------------------------------------------------
// Binary selection
// -----------------------------------------------------------------------------

// Returns either:
// - single opcode (number), or
// - array [opcode1, opcode2] for 2-step sequences (e.g. "!=").
fn selectBinaryCode(gen, node) {
  // node: NODE.Binary, operands already compiled by codegen.
  let op = node.operator and node.operator.lexeme or ""

  let leftCls = classOf(gen, node.left)
  let rightCls = classOf(gen, node.right)

  let leftInt = isIntClass(leftCls)
  let rightInt = isIntClass(rightCls)
  let bothInt = leftInt and rightInt

  let leftNum = isNumericClass(leftCls)
  let rightNum = isNumericClass(rightCls)
  let bothNum = leftNum and rightNum

  let leftStr = isStrClass(leftCls)
  let rightStr = isStrClass(rightCls)
  let bothStr = leftStr and rightStr

  // Choose opcode for + based on facts (matches your current policy)
  let addOp = OP.ADD
  if bothInt {
    addOp = OP.ADD_INT
  } else if bothStr {
    addOp = OP.ADD_STR
  } else if bothNum {
    addOp = OP.ADD_NUM
  }

  let opCodes = .{
    ["+"]: addOp,
    ["-"]: bothInt and OP.SUBTRACT_INT or OP.SUBTRACT,
    ["*"]: bothInt and OP.MULTIPLY_INT or OP.MULTIPLY,
    ["/"]: OP.DIVIDE,
    ["%"]: OP.MOD,

    ["=="]: OP.EQUAL,
    ["!="]: [OP.EQUAL, OP.NOT],

    [">"]: OP.GREATER,
    [">="]: [OP.LESS, OP.NOT],
    ["<"]: OP.LESS,
    ["<="]: [OP.GREATER, OP.NOT],

    ["|"]: OP.BIT_OR,
    ["^"]: OP.BIT_XOR,
    ["&"]: OP.BIT_AND,
    ["<<"]: OP.BIT_LSHIFT,
    [">>"]: OP.BIT_RSHIFT,
  }

  opCodes[op]
}

// -----------------------------------------------------------------------------
// Logical OR coalesce selection
// -----------------------------------------------------------------------------

// Returns nil if not applicable, otherwise:
//   .{ kind: "coalesce_const", valueType: "Number"|"String", value: <literal> }
//
// Codegen will turn this into COALESCE_CONST/COALESCE_CONST_LONG by allocating constant.
// We keep this pass pure (no makeConstant here).
fn selectLogicalOrCoalesceConst(gen, node) {
  // node: NODE.Logical
  // Only handles op == "or" and RHS literal (Number/String).
  let op = node.operator and node.operator.lexeme or ""
  if op != "or" { return nil }

  let rhs = node.right
  if !rhs { return nil }

  // Match current behavior: only Number/String literals.
  // (Bool literals aren't in the constant pool; nil also isn't.)
  if rhs.type == NODE.Number {
    return .{ kind: "coalesce_const", valueType: "Number", value: rhs.value }
  }
  if rhs.type == NODE.String {
    return .{ kind: "coalesce_const", valueType: "String", value: rhs.value }
  }

  nil
}

// -----------------------------------------------------------------------------
// Assignment superinstructions
// -----------------------------------------------------------------------------

// Returns nil if not applicable, otherwise a plan with verified bindings:
//
// 1) ADD_LOCAL_IMM pattern:
//    .{ kind: "ADD_LOCAL_IMM", targetBinding: <binding>, imm: <0..255> }
//
// 2) BINOP_LOCALS pattern (general x = y op z):
//    .{ kind: "BINOP_LOCALS", operator: "+"|"-"|"*"|"/",
//       targetBinding, lhsBinding, rhsBinding }
//
// 3) SETI pattern (arr[idx] = val where all are identifiers):
//    .{ kind: "SETI", objBinding, idxBinding, valBinding }
//
// 4) SET_PROPERTY pattern (obj.field = val or obj[const] = val):
//    .{ kind: "SET_PROPERTY", objBinding, key: {type, value}, valBinding }
//
// All bindings are verified to be locals before returning.
// Codegen just computes slots and emits opcodes in STMT mode.
fn selectAssignmentSuper(gen, node, mode) {
  // node: NODE.Assignment
  if !node or node.type != NODE.Assignment { return }

  // Patterns for Identifier targets (ADD_LOCAL_IMM, BINOP_LOCALS)
  if node.target.type == NODE.Identifier {
    let value = node.value
    if !value or value.type != NODE.Binary { return }

    let binOp = value.operator and value.operator.lexeme or ""

    // Try ADD_LOCAL_IMM pattern first (more specific: i = i + imm)
    if binOp == "+" {
      // target: i
      // value: (i + <imm>)
      if value.left and value.left.type == NODE.Identifier and
         value.right and value.right.type == NODE.Number and
         value.left.name == node.target.name {
        let imm = value.right.value
        if imm >= 0 and imm < 256 and Math.floor(imm) == imm {
          // Verify target is a local
          let targetBinding = gen.resolvedNames[node.target.id]
          if targetBinding and targetBinding.kind == "local" {
            return .{
              kind: "ADD_LOCAL_IMM",
              targetBinding: targetBinding,
              imm: Math.floor(imm),
            }
          }
        }
      }
    }

    // Try BINOP_LOCALS pattern (general x = y op z where all are identifiers)
    // Only for numeric operations to avoid issues with string concatenation
    let operators = .{
      ["+"]: OP.ADD_LOCALS,
      ["-"]: OP.SUB_LOCALS,
      ["*"]: OP.MUL_LOCALS,
      ["/"]: OP.DIV_LOCALS,
    }
    if let opcode = operators[binOp] {
      if !value.left or value.left.type != NODE.Identifier { return }
      if !value.right or value.right.type != NODE.Identifier { return }

      // Check if operands are numeric (to avoid string concatenation case for +)
      let leftCls = classOf(gen, value.left)
      let rightCls = classOf(gen, value.right)

      // Only emit BINOP_LOCALS if we know both operands are numeric
      // For +, we need to be sure they're not strings
      // For -, *, /, they're always numeric operations
      if binOp == "+" {
        // For addition, only optimize if we know both are numeric
        let leftNum = isNumericClass(leftCls)
        let rightNum = isNumericClass(rightCls)
        if !leftNum or !rightNum {
          return nil  // Could be strings, don't optimize
        }
      }
      // For -, *, /, we can assume numeric (they'd error at runtime otherwise)

      // Verify all three are locals
      let targetBinding = gen.resolvedNames[node.target.id]
      let lhsBinding = gen.resolvedNames[value.left.id]
      let rhsBinding = gen.resolvedNames[value.right.id]

      if targetBinding and targetBinding.kind == "local" and
         lhsBinding and lhsBinding.kind == "local" and
         rhsBinding and rhsBinding.kind == "local" {
        return .{
          kind: "BINOP_LOCALS",
          opcode,
          targetBinding,
          lhsBinding,
          rhsBinding,
        }
      }
    }

    return nil
  }

  // Pattern for Index targets: SETI or SET_PROPERTY
  if node.target.type == NODE.Index {
    // SETI pattern: arr[idx] = val where all are identifiers
    if node.target.object.type == NODE.Identifier and
       node.target.index.type == NODE.Identifier and
       node.value.type == NODE.Identifier {
      // Verify all three are locals
      let objBinding = gen.resolvedNames[node.target.object.id]
      let idxBinding = gen.resolvedNames[node.target.index.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         idxBinding and idxBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        return .{
          kind: "SETI",
          objBinding: objBinding,
          idxBinding: idxBinding,
          valBinding: valBinding,
        }
      }
    }

    // SET_PROPERTY pattern: obj[const] = val where const is a literal
    if node.target.object.type == NODE.Identifier and
       (node.target.index.type == NODE.String or node.target.index.type == NODE.Number) and
       node.value.type == NODE.Identifier {
      // Verify obj and val are locals
      let objBinding = gen.resolvedNames[node.target.object.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        let keyType = if node.target.index.type == NODE.String {
          "String"
        } else {
          "Number"
        }
        return .{
          kind: "SET_PROPERTY",
          objBinding: objBinding,
          key: .{
            type: keyType,
            value: node.target.index.value,
          },
          valBinding: valBinding,
        }
      }
    }

    return nil
  }

  // Pattern for Dot targets: SET_PROPERTY
  if node.target.type == NODE.Dot {
    // SET_PROPERTY pattern: obj.field = val
    if node.target.object.type == NODE.Identifier and
       node.value.type == NODE.Identifier {
      // Verify obj and val are locals
      let objBinding = gen.resolvedNames[node.target.object.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        return .{
          kind: "SET_PROPERTY",
          objBinding: objBinding,
          key: .{
            type: "property",
            value: node.target.property.value,
          },
          valBinding: valBinding,
        }
      }
    }
  }

  nil
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

let select = .{
  // unary/binary
  unaryOpcode: selectUnaryOpcode,
  binaryCode: selectBinaryCode,

  // logical OR coalesce (pure match)
  logicalOrCoalesceConst: selectLogicalOrCoalesceConst,

  // assignment superinstructions (pure match)
  assignmentSuper: selectAssignmentSuper,
}

select
