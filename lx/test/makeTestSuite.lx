fn makeTestSuite() {
  let startTime = Date.now()
  let tests = []
  let totalAssertions = 0
  let passedAssertions = 0

  fn defineTest(testName, testBody) {
    let testPassed = true
    let testAssertions = 0
    let assert = .{
      equal: fn(actual, expect) {
        totalAssertions = totalAssertions + 1
        testAssertions = testAssertions + 1
        if expect == actual {
          passedAssertions = passedAssertions + 1
          return
        }
        println(
          "assertion fail (" + str(testAssertions) + "):", testName, "\n",
          "\texpect:", expect, "\n",
          "\tactual:", actual, "\n",
        )
        testPassed = false
      },
      truthy: fn(actual) {
        totalAssertions = totalAssertions + 1
        testAssertions = testAssertions + 1
        if actual {
          passedAssertions = passedAssertions + 1
          return
        }
        println(
          "assertion fail (" + str(testAssertions) + "):", testName, "\n",
          "\texpect to be truthy:", actual, "\n",
        )
        testPassed = false
      },
      throws: fn(func, expectedMessage) {
        totalAssertions = totalAssertions + 1
        testAssertions = testAssertions + 1
        let result = Lx.pcall(func)

        if result.ok {
          println(
            "assertion fail (" + str(testAssertions) + "):", testName, "\n",
            "\texpected function to throw but it succeeded with value:", result.value, "\n",
          )
          testPassed = false
          return
        }

        if expectedMessage {
          let errorMsg = result.error and result.error.message or ""
          if contains(errorMsg, expectedMessage) {
            passedAssertions = passedAssertions + 1
            return
          }
          println(
            "assertion fail (" + str(testAssertions) + "):", testName, "\n",
            "\texpected error message to contain:", expectedMessage, "\n",
            "\tactual error message:", errorMsg, "\n",
          )
          testPassed = false
          return
        }

        passedAssertions = passedAssertions + 1
      },
    }
    push(tests, fn() {
      testBody(assert)
      testPassed
    })
  }

  fn run() {
    let startTime = Date.now()
    let passedTests = tests->fold(0, fn(acc, testCase) {
      acc + { testCase() and 1 or 0 }
    })

    let endTime = Date.now()
    let elapsed = endTime - startTime

    let timeStr = if elapsed > 50 {
      if elapsed < 1000 {
        " (" + str(Math.floor(elapsed)) + "ms)"
      } else {
        " (" + str(elapsed / 1000) + "s)"
      }
    } else {
      ""
    }

    // In batch mode, don't print filename since all tests show the runner file
    let batchMode = Lx.env["LX_TEST_BATCH"] == "1"
    if !batchMode {
      println(last(Lx.args))
    }

    print("\e[1;" + if passedTests < len(tests) {"31"} else {"32"} + "m")
    println(
      "passed tests", str(passedTests) + "/" + len(tests)->str(),
      "asserts", str(passedAssertions) + "/" + str(totalAssertions) + timeStr,
      "\e[0m\n"
    )

    // In batch mode, don't exit - let other tests run
    if !batchMode {
      Lx.exit(len(tests) == passedTests and 0 or 1)
    }
  }

  return .{
    defineTest: defineTest,
    run: run,
  }
}
