// Codegen Phase - Emit bytecode from resolved ANF AST
// Responsibility: Mechanical bytecode emission, no semantic decisions.

let lib = import "src/lib.lx"
let types = import "src/types.lx"
let object = import "src/object.lx"

let OP = types.OP
let ValueType = types.ValueType
let ObjType = object.ObjType

let UINT16_MAX = 256 * 256

fn Value(kind, value) {.{
  kind: kind,
  value: value,
}}

fn Chunk(filename) {.{
  filename: filename,
  bytecode: [],
  constants: [],
  lines: [],
  nodeIds: [],
  constantsCache: .{},
  importConstCache: .{},
}}

fn Function(name, arity, chunk) {.{
  name: name,
  arity: arity,
  chunk: chunk,
  upvalueCount: 0,
}}

fn NUMBER_VAL(value) { Value(ValueType.NUMBER, value) }
fn OBJ_VAL(value) { Value(ValueType.OBJ, value) }

fn ObjectFunction(func) { OBJ_VAL(object.ObjectFunction(func)) }
fn ObjectString(string) { OBJ_VAL(object.ObjectString(string)) }

fn addError(gen, node, message) {
  push(gen.errors, .{
    nodeId: node and node.id or 0,
    message: message,
    severity: "error",
  })
}

// Primitive emit functions - do not call each other to avoid overhead
// Store bytes as numbers, not hex strings (objbuilder will convert)
fn emit1(gen, b, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 1
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, int(b))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

fn emit2(gen, b1, b2, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 2
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, int(b1))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, int(b2))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

fn emit3(gen, b1, b2, b3, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 3
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, int(b1))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, int(b2))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, int(b3))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

// Backwards compatibility wrappers
fn emitByte(gen, byte, line) { emit1(gen, byte, line) }
fn emitBytes(gen, byte1, byte2, line) { emit2(gen, byte1, byte2, line) }

fn emitLoop(gen, loopStart, line) {
  emit1(gen, OP.LOOP, line)
  let offset = len(gen.currentFunction.chunk.bytecode) - loopStart + 2
  emit2(gen, int(offset / 256), offset % 256, line)
}

fn emitJump(gen, instruction, line) {
  emit3(gen, instruction, 255, 255, line)
  return len(gen.currentFunction.chunk.bytecode) - 2
}

fn patchJump(gen, offset) {
  gen.metrics.patchCount = gen.metrics.patchCount + 1
  let jump = len(gen.currentFunction.chunk.bytecode) - offset - 2
  if jump > UINT16_MAX {
    addError(gen, gen.currentNode, "Too much code to jump over.")
  }
  gen.currentFunction.chunk.bytecode[offset] = int(jump / 256)
  gen.currentFunction.chunk.bytecode[offset + 1] = jump % 256
}

fn calcValueKey(value) {
  let k = str(value.kind) + ":"
  if value.kind == ValueType.NUMBER {
    k = k + str(value.value)
  } else if value.kind == ValueType.OBJ {
    let obj = value.value
    k = k + str(obj.kind) + ":"
    if obj.kind == ObjType.STRING {
      k = k + obj.value
    } else {
      return "nocache"
    }
  } else {
    return "nocache"
  }
  k
}

fn addConstant(chunk, value, gen) {
  gen.metrics.constLookups = gen.metrics.constLookups + 1
  let k = calcValueKey(value)
  if k == "nocache" {
    gen.metrics.constAdds = gen.metrics.constAdds + 1
    push(chunk.constants, value)
    return len(chunk.constants) - 1
  }
  let index = chunk.constantsCache[k]
  if index {
    gen.metrics.constHits = gen.metrics.constHits + 1
    return index
  }
  gen.metrics.constAdds = gen.metrics.constAdds + 1
  push(chunk.constants, value)
  index = len(chunk.constants) - 1
  chunk.constantsCache[k] = index
  index
}

fn makeConstant(gen, value) {
  let constant = addConstant(gen.currentFunction.chunk, value, gen)
  if constant > 256 {
    addError(gen, gen.currentNode, "Too many constants in one chunk.")
    return 0
  }
  constant
}

fn emitConstant(gen, value, line) {
  emitBytes(gen, OP.CONSTANT, makeConstant(gen, value), line)
}

fn identifierConstant(gen, name) {
  makeConstant(gen, ObjectString(name))
}

fn buildDeclMap(scopeInfo) {
  let map = .{}
  let scopeIds = keys(scopeInfo or .{})
  for let i = 0; i < len(scopeIds); i = i + 1 {
    let id = scopeIds[i]
    let scope = scopeInfo[id]
    let locals = scope and scope.locals or []
    for let j = 0; j < len(locals); j = j + 1 {
      let local = locals[j]
      if local.nodeId {
        map[local.nodeId] = local
      }
    }
  }
  map
}

fn localSlot(slot) {
  slot + 1
}

fn computeAbsoluteSlot(gen, binding) {
  // Look up the absolute slot that was recorded when this local was emitted
  let absoluteSlot = gen.emittedLocals[binding.declaredAt]
  if absoluteSlot or absoluteSlot == 0 {
    return absoluteSlot
  }

  // If not found, this is an error - the local should have been emitted
  addError(gen, gen.currentNode, "Internal error: local not emitted for binding")
  0
}

fn computeAbsoluteSlotForUpvalue(gen, scopeRelativeSlot) {
  // Compute absolute position for an upvalue that captures from parent scope
  // The scopeRelativeSlot is relative to the immediate parent scope (top of scopeStack)
  // We need to compute its absolute position by summing locals from all ancestor scopes

  let absoluteSlot = 0
  let stackLen = len(gen.scopeStack)

  // Sum up locals from all scopes except the last one
  for let i = 0; i < stackLen - 1; i = i + 1 {
    let scope = gen.scopeStack[i]
    let locals = scope.locals or []
    absoluteSlot = absoluteSlot + len(locals)
  }

  // Add the scope-relative slot from the parent scope (last scope in stack)
  absoluteSlot = absoluteSlot + scopeRelativeSlot

  absoluteSlot
}

fn pushScope(gen, node) {
  let info = gen.scopeInfo[node.id]
  if info {
    push(gen.scopeStack, info)
  }
  push(gen.scopeBaseSlots, gen.nextLocalSlot)
}

fn popScope(gen) {
  if len(gen.scopeStack) > 0 {
    pop(gen.scopeStack)
  }
  if len(gen.scopeBaseSlots) > 0 {
    pop(gen.scopeBaseSlots)
  }
}

fn endScope(gen, node) {
  let scope = gen.scopeInfo[node.id]
  if !scope { return }
  let locals = scope.locals or []
  for let i = len(locals) - 1; i >= 0; i = i - 1 {
    let local = locals[i]
    if local.isCaptured {
      emitByte(gen, OP.CLOSE_UPVALUE, gen.currentLine)
    } else {
      emitByte(gen, OP.POP, gen.currentLine)
    }
    // Decrement the local slot counter as we pop locals
    gen.nextLocalSlot = gen.nextLocalSlot - 1
  }
}

fn unwindToSlot(gen, targetSlot) {
  // Emit OP_UNWIND for non-local exits (break/continue)
  // NOTE: We do NOT decrement gen.nextLocalSlot here because:
  // 1. This emits code for the break/continue path (which jumps away)
  // 2. endScope will handle nextLocalSlot bookkeeping for the normal path
  // 3. After emitting the jump, we never emit more code on this path, so out-of-sync nextLocalSlot is fine

  let toPop = gen.nextLocalSlot - targetSlot
  if toPop <= 0 { return }

  // Emit UNWIND with keep=0 (break/continue don't preserve a value)
  emitByte(gen, OP.UNWIND, gen.currentLine)
  emitByte(gen, toPop, gen.currentLine)  // count
  emitByte(gen, 0, gen.currentLine)      // keep=0
}

fn patchBreaks(gen) {
  let breaker = gen.breakOffsets[len(gen.breakOffsets) - 1]
  let currentAddr = len(gen.currentFunction.chunk.bytecode)
  for let i = 0; i < len(breaker); i = i + 1 {
    let addr = breaker[i]
    let jump = currentAddr - addr - 2
    if jump > UINT16_MAX {
      addError(gen, gen.currentNode, "Too much code to jump over.")
    }
    gen.currentFunction.chunk.bytecode[addr] = int(jump / 256)
    gen.currentFunction.chunk.bytecode[addr + 1] = jump % 256
  }
}

fn patchContinues(gen) {
  let continues = gen.continueOffsets[len(gen.continueOffsets) - 1]
  let currentAddr = len(gen.currentFunction.chunk.bytecode)
  for let i = 0; i < len(continues); i = i + 1 {
    let addr = continues[i]
    let jump = currentAddr - addr - 2
    if jump > UINT16_MAX {
      addError(gen, gen.currentNode, "Loop body too large.")
    }
    gen.currentFunction.chunk.bytecode[addr] = int(jump / 256)
    gen.currentFunction.chunk.bytecode[addr + 1] = jump % 256
  }
}

let MODE = .{ VALUE: 1, STMT: 2 }


fn compileValue(gen, node) { compileExpr(gen, node, MODE.VALUE) }
fn compileStmt(gen, node) { compileExpr(gen, node, MODE.STMT) }

fn compileLiteral(gen, node) {
  if node.type == "Nil" {
    emitByte(gen, OP.NIL, node.line)
  } else if node.type == "Bool" {
    emitByte(gen, node.value and OP.TRUE or OP.FALSE, node.line)
  } else if node.type == "Number" {
    let value = node.value
    if value >= 0 and value < 256 and int(value) == value {
      emitBytes(gen, OP.CONST_BYTE, value, node.line)
    } else {
      emitConstant(gen, NUMBER_VAL(value), node.line)
    }
  } else if node.type == "String" {
    emitConstant(gen, ObjectString(node.value), node.line)
  }
}

fn compileIdentifier(gen, node) {
  let binding = gen.resolvedNames[node.id]
  if !binding {
    addError(gen, node, "Unresolved identifier: " + node.name)
    return
  }
  if binding.kind == "local" {
    let absoluteSlot = computeAbsoluteSlot(gen, binding)
    emitBytes(gen, binding.getOp, localSlot(absoluteSlot), node.line)
  } else if binding.kind == "upvalue" {
    emitBytes(gen, binding.getOp, binding.upvalueIndex, node.line)
  } else {
    let idx = identifierConstant(gen, binding.name)
    emitBytes(gen, binding.getOp, idx, node.line)
  }
}

fn compileLet(gen, node, mode) {
  if node.init {
    compileValue(gen, node.init)
  } else {
    emitByte(gen, OP.NIL, node.line)
  }

  let local = gen.localsByDecl[node.name.id]
  if local {
    // Record the absolute slot for this local
    gen.emittedLocals[local.nodeId] = gen.nextLocalSlot
    let slot = gen.nextLocalSlot
    gen.nextLocalSlot = gen.nextLocalSlot + 1

    if mode == MODE.VALUE {
      // GET_LOCAL to read the local as expression result (not DUP)
      emitBytes(gen, OP.GET_LOCAL, localSlot(slot), node.line)
    }
    // STMT mode: local stays on stack, no extra value needed
  } else {
    let idx = identifierConstant(gen, node.name.name)
    if mode == MODE.VALUE {
      emitByte(gen, OP.DUP, node.line)
      emitBytes(gen, OP.DEFINE_GLOBAL, idx, node.line)
    } else {
      emitBytes(gen, OP.DEFINE_GLOBAL, idx, node.line)
    }
  }
}

fn compileBlock(gen, node) {
  pushScope(gen, node)

  // CRITICAL FIX: Pre-emit hoisted function locals to match resolver's slot allocation
  // Resolver allocates slots for hoisted functions during prescan (before expressions)
  // Codegen must do the same to keep slot numbering consistent
  let scope = gen.scopeInfo[node.id]
  if scope and scope.hoistedFns {
    let hoistedNames = keys(scope.hoistedFns)

    // Collect hoisted functions with their declaration indices
    let hoistedList = []
    for let i = 0; i < len(hoistedNames); i = i + 1 {
      let name = hoistedNames[i]
      let hoisted = scope.hoistedFns[name]
      push(hoistedList, hoisted)
    }

    // Sort by declIndex to match resolver's prescan order
    // Simple bubble sort (sufficient for small lists)
    for let i = 0; i < len(hoistedList); i = i + 1 {
      for let j = i + 1; j < len(hoistedList); j = j + 1 {
        if hoistedList[j].declIndex < hoistedList[i].declIndex {
          let temp = hoistedList[i]
          hoistedList[i] = hoistedList[j]
          hoistedList[j] = temp
        }
      }
    }

    // Pre-allocate locals for hoisted functions
    for let i = 0; i < len(hoistedList); i = i + 1 {
      let hoisted = hoistedList[i]
      gen.emittedLocals[hoisted.declNodeId] = gen.nextLocalSlot
      gen.nextLocalSlot = gen.nextLocalSlot + 1

      emitByte(gen, OP.NIL, node.line)
      // NIL stays on stack until endScope - this IS the reserved slot
    }
  }

  let exprs = node.expressions or []
  if len(exprs) == 0 {
    emitByte(gen, OP.NIL, node.line)
  } else {
    for let i = 0; i < len(exprs); i = i + 1 {
      let expr = exprs[i]
      if i < len(exprs) - 1 {
        compileStmt(gen, expr)
      } else {
        compileValue(gen, expr)
      }
    }
  }

  // block exit - UNWIND pops locals under result
  // At this point: value stack has [... locals... result]
  // UNWIND <toPop> 1 pops/closes locals while preserving result
  let baseSlot = gen.scopeBaseSlots[len(gen.scopeBaseSlots) - 1]
  let toPop = gen.nextLocalSlot - baseSlot
  emitByte(gen, OP.UNWIND, node.line)
  emitByte(gen, toPop, node.line)  // count = actual stack slots to pop
  emitByte(gen, 1, node.line)  // keep=1: preserve block result

  // Update slot counter - locals are now popped
  gen.nextLocalSlot = baseSlot

  // No endScope() - UNWIND handled closing/popping locals
  popScope(gen)
}

fn compileUnary(gen, node) {
  compileValue(gen, node.operand)
  let op = node.operator and node.operator.lexeme or ""
  if op == "!" {
    emitByte(gen, OP.NOT, node.line)
  } else if op == "-" {
    emitByte(gen, OP.NEGATE, node.line)
  } else {
    addError(gen, node, "Unsupported unary op: " + op)
  }
}

fn compileBinary(gen, node) {
  compileValue(gen, node.left)
  compileValue(gen, node.right)
  let op = node.operator and node.operator.lexeme or ""
  let opCodes = .{
    ["+"]: OP.ADD,
    ["-"]: OP.SUBTRACT,
    ["*"]: OP.MULTIPLY,
    ["/"]: OP.DIVIDE,
    ["%"]: OP.MOD,
    ["=="]: OP.EQUAL,
    ["!="]: [OP.EQUAL, OP.NOT],
    [">"]: OP.GREATER,
    [">="]: [OP.LESS, OP.NOT],
    ["<"]: OP.LESS,
    ["<="]: [OP.GREATER, OP.NOT],
    ["|"]: OP.BIT_OR,
    ["^"]: OP.BIT_XOR,
    ["&"]: OP.BIT_AND,
    ["<<"]: OP.BIT_LSHIFT,
    [">>"]: OP.BIT_RSHIFT,
  }
  let code = opCodes[op]
  if !code {
    addError(gen, node, "Unsupported binary op: " + op)
    return
  }
  if type(code) == "array" {
    emitBytes(gen, code[0], code[1], node.line)
  } else {
    emitByte(gen, code, node.line)
  }
}

fn compileLogical(gen, node) {
  compileValue(gen, node.left)
  let op = node.operator and node.operator.lexeme or ""
  if op == "and" {
    emitByte(gen, OP.DUP, node.line)
    let endJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
    emitByte(gen, OP.POP, node.line)
    compileValue(gen, node.right)
    patchJump(gen, endJump)
  } else if op == "or" {
    emitByte(gen, OP.DUP, node.line)
    let endJump = emitJump(gen, OP.JUMP_IF_TRUE, node.line)
    emitByte(gen, OP.POP, node.line)
    compileValue(gen, node.right)
    patchJump(gen, endJump)
  } else {
    addError(gen, node, "Unsupported logical op: " + op)
  }
}

fn compileIf(gen, node) {
  compileValue(gen, node.condition)
  let thenJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
  compileValue(gen, node.then)
  let elseJump = emitJump(gen, OP.JUMP, node.line)
  patchJump(gen, thenJump)
  if node.else {
    compileValue(gen, node.else)
  } else {
    emitByte(gen, OP.NIL, node.line)
  }
  patchJump(gen, elseJump)
}

fn compileCall(gen, node) {
  compileValue(gen, node.callee)
  let args = node.args or []
  for let i = 0; i < len(args); i = i + 1 {
    compileValue(gen, args[i])
  }
  emitBytes(gen, OP.CALL, len(args), node.line)
}

fn compileIntrinsicCall(gen, node) {
  // Compile intrinsic operations that map directly to opcodes
  // IMPORTANT: This is called from expression position, so must leave
  // exactly one value on stack on ALL paths (including errors).
  let args = node.args or []

  if node.intrinsic == "array_new" {
    // array_new expects 0 args
    if len(args) != 0 {
      addError(gen, node, "Internal error: array_new expects 0 args, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    // Create empty array
    emitByte(gen, OP.ARRAY, node.line)
  } else if node.intrinsic == "array_append" {
    // array_append expects 2 args: array, value
    if len(args) != 2 {
      addError(gen, node, "Internal error: array_append expects 2 args, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    // Compile args: array, value
    for let i = 0; i < len(args); i = i + 1 {
      compileValue(gen, args[i])
    }
    emitByte(gen, OP.APPEND, node.line)
  } else {
    addError(gen, node, "Unknown intrinsic: " + node.intrinsic)
    emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
  }
}

fn compileFunctionExpr(gen, node, mode) {
  let name = node.name and node.name.name or "fn"
  let func = Function(name, len(node.params or []), Chunk(node.filename))

  let enclosing = gen.currentFunction
  gen.currentFunction = func

  // Save the local counter (we're entering a new function scope)
  let enclosingLocalSlot = gen.nextLocalSlot
  let enclosingEmittedLocals = gen.emittedLocals
  gen.nextLocalSlot = 0
  gen.emittedLocals = .{}  // Fresh map for this function

  // Record function name and parameters
  // Function name is at slot -1 (VM slot 0 via localSlot(-1) = 0, the closure)
  // Parameters are at slots 0, 1, 2, ... (which map to VM slots 1, 2, 3, ... with localSlot)
  let fnScope = gen.scopeInfo[node.id]
  if fnScope {
    let locals = fnScope.locals or []
    let slot = 0
    for let i = 0; i < len(locals); i = i + 1 {
      let local = locals[i]
      if local.kind == "fn" {
        // Function name: record at slot -1 so localSlot(-1) = 0 (the closure)
        gen.emittedLocals[local.nodeId] = -1
      } else {
        // Parameters: record at slots 0, 1, 2, ...
        gen.emittedLocals[local.nodeId] = slot
        slot = slot + 1
      }
    }
    gen.nextLocalSlot = slot
  }

  pushScope(gen, node)
  compileBlock(gen, node.body)
  popScope(gen)

  emitByte(gen, OP.RETURN, node.line)

  // Restore the local counter and emittedLocals map
  gen.currentFunction = enclosing
  gen.nextLocalSlot = enclosingLocalSlot
  gen.emittedLocals = enclosingEmittedLocals

  let scope = fnScope
  if scope {
    func.upvalueCount = len(scope.upvalues or [])
  }

  let constIndex = makeConstant(gen, ObjectFunction(func))
  emitBytes(gen, OP.CLOSURE, constIndex, node.line)

  let upvalues = scope and scope.upvalues or []
  for let i = 0; i < len(upvalues); i = i + 1 {
    let uv = upvalues[i]

    // CRITICAL FIX: Translate upvalue captures correctly
    // For isLocal=true: uv.captured is nodeId, need to look up runtime slot
    // For isLocal=false: uv.captured is upvalue index, use directly
    emitByte(gen, uv.isLocal and 1 or 0, node.line)
    if uv.isLocal {
      // Look up the enclosing function's runtime slot for this captured local
      // uv.captured is the nodeId of the declaration in the enclosing function
      let capturedSlot = enclosingEmittedLocals[uv.captured]
      if capturedSlot or capturedSlot == 0 {
        emitByte(gen, localSlot(capturedSlot), node.line)
      } else {
        addError(gen, node, "Internal error: captured local not found in enclosing emittedLocals")
        emitByte(gen, 0, node.line)
      }
    } else {
      // Indirect capture: uv.captured is already an upvalue index
      emitByte(gen, uv.captured, node.line)
    }
  }

  let local = gen.localsByDecl[node.id]
  if local {
    // Check if this function was already pre-allocated (hoisted)
    let preallocatedSlot = gen.emittedLocals[node.id]
    if preallocatedSlot or preallocatedSlot == 0 {
      // Function was hoisted - assign closure into existing slot
      // SET_LOCAL leaves value on stack, so we POP it after assignment
      emitBytes(gen, OP.SET_LOCAL, localSlot(preallocatedSlot), node.line)
      emitByte(gen, OP.POP, node.line)

      if mode == MODE.VALUE {
        // Read the slot back as expression result
        emitBytes(gen, OP.GET_LOCAL, localSlot(preallocatedSlot), node.line)
      }
    } else {
      // Not preallocated - closure value IS the local slot (stays on stack)
      let slot = gen.nextLocalSlot
      gen.emittedLocals[node.id] = slot
      gen.nextLocalSlot = gen.nextLocalSlot + 1

      if mode == MODE.VALUE {
        // GET_LOCAL to read the local as expression result (not DUP)
        emitBytes(gen, OP.GET_LOCAL, localSlot(slot), node.line)
      }
      // STMT mode: closure stays on stack as local, no extra value needed
    }
  }
}

fn compileAssignment(gen, node, mode) {
  if node.target.type == "Identifier" {
    compileValue(gen, node.value)
    let info = gen.assignmentInfo[node.id]
    if !info {
      addError(gen, node, "Missing assignment info.")
      return
    }
    if info.kind == "local" {
      // Get the binding to compute absolute slot
      let targetBinding = gen.resolvedNames[node.target.id]
      let absoluteSlot = computeAbsoluteSlot(gen, targetBinding)
      emitBytes(gen, OP.SET_LOCAL, localSlot(absoluteSlot), node.line)
    } else if info.kind == "upvalue" {
      emitBytes(gen, OP.SET_UPVALUE, info.upvalueIndex, node.line)
    } else {
      addError(gen, node, "Invalid assignment target.")
      return
    }
    if mode == MODE.STMT {
      emitByte(gen, OP.POP, node.line)
    }
    return
  }

  if node.target.type == "Index" {
    compileValue(gen, node.target.object)
    compileValue(gen, node.target.index)
    compileValue(gen, node.value)
    emitByte(gen, OP.SET_BY_INDEX, node.line)
    if mode == MODE.STMT {
      emitByte(gen, OP.POP, node.line)
    }
    return
  }

  if node.target.type == "Dot" {
    compileValue(gen, node.target.object)
    emitConstant(gen, ObjectString(node.target.property.value), node.line)
    compileValue(gen, node.value)
    emitByte(gen, OP.SET_BY_INDEX, node.line)
    if mode == MODE.STMT {
      emitByte(gen, OP.POP, node.line)
    }
    return
  }

  addError(gen, node, "Unsupported assignment target: " + node.target.type)
}

fn compileIndex(gen, node) {
  compileValue(gen, node.object)
  compileValue(gen, node.index)
  emitByte(gen, OP.GET_BY_INDEX, node.line)
}

fn compileDot(gen, node) {
  compileValue(gen, node.object)
  emitConstant(gen, ObjectString(node.property.value), node.line)
  emitByte(gen, OP.GET_BY_INDEX, node.line)
}

fn compileArray(gen, node) {
  emitByte(gen, OP.ARRAY, node.line)
  let elems = node.elements or []
  for let i = 0; i < len(elems); i = i + 1 {
    compileValue(gen, elems[i])
    emitByte(gen, OP.APPEND, node.line)
  }
}

fn compileHashmap(gen, node) {
  emitByte(gen, OP.HASHMAP, node.line)
  let pairs = node.pairs or []
  for let i = 0; i < len(pairs); i = i + 1 {
    let pair = pairs[i]
    compileValue(gen, pair.key)
    compileValue(gen, pair.value)
    emitByte(gen, OP.ASSOC, node.line)
  }
}

fn compileReturn(gen, node) {
  if node.value {
    compileValue(gen, node.value)
  } else {
    emitByte(gen, OP.NIL, node.line)
  }
  emitByte(gen, OP.RETURN, node.line)
}

fn compileBreak(gen, node) {
  if len(gen.breakOffsets) == 0 {
    addError(gen, node, "Break used outside loop.")
    return
  }
  // Unwind to loop base slot (the slot height after loop result slot)
  let loopBaseSlot = gen.loopBaseSlots[len(gen.loopBaseSlots) - 1]
  unwindToSlot(gen, loopBaseSlot)
  let jump = emitJump(gen, OP.JUMP, node.line)
  push(gen.breakOffsets[len(gen.breakOffsets) - 1], jump)
}

fn compileContinue(gen, node) {
  if len(gen.continueOffsets) == 0 {
    addError(gen, node, "Continue used outside loop.")
    return
  }
  // Unwind to loop continue slot (keeps loop var, pops body locals)
  let loopContinueSlot = gen.loopContinueSlots[len(gen.loopContinueSlots) - 1]
  unwindToSlot(gen, loopContinueSlot)
  let jump = emitJump(gen, OP.JUMP, node.line)
  push(gen.continueOffsets[len(gen.continueOffsets) - 1], jump)
}

fn compileFor(gen, node) {
  // Reserve loop result slot in the enclosing scope
  let loopResultSlot = gen.nextLocalSlot
  gen.nextLocalSlot = gen.nextLocalSlot + 1
  push(gen.loopResultSlots, loopResultSlot)

  // Push NIL to reserve slot, KEEP it on stack
  emitByte(gen, OP.NIL, node.line)
  // NIL stays on stack - this IS the loop result slot

  // Record the loop base slot for break - the slot height after loop result (before init)
  let loopBreakSlot = gen.nextLocalSlot
  push(gen.loopBaseSlots, loopBreakSlot)

  pushScope(gen, node)
  let prevScopeDepth = gen.loopScopeDepth
  gen.loopScopeDepth = gen.scopeInfo[node.id] and gen.scopeInfo[node.id].depth or 0

  push(gen.breakOffsets, [])
  push(gen.continueOffsets, [])

  if node.init {
    compileStmt(gen, node.init)
  }

  // Record the loop continue slot - the slot height after init (keeps loop var, pops body locals)
  let loopContinueSlot = gen.nextLocalSlot
  push(gen.loopContinueSlots, loopContinueSlot)

  let loopStart = len(gen.currentFunction.chunk.bytecode)
  let loopStartLine = node.line
  let exitJump = -1

  if node.condition {
    compileValue(gen, node.condition)
    exitJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
  }

  if node.update {
    let bodyJump = emitJump(gen, OP.JUMP, node.line)
    let incrementStart = len(gen.currentFunction.chunk.bytecode)
    compileStmt(gen, node.update)
    emitLoop(gen, loopStart, node.line)
    loopStart = incrementStart
    patchJump(gen, bodyJump)
  }

  compileStmt(gen, node.body)
  // For loops always return nil (the initial value in loopResultSlot)

  patchContinues(gen)
  emitLoop(gen, loopStart, loopStartLine)

  if exitJump != -1 {
    patchJump(gen, exitJump)
  }

  endScope(gen, node)
  patchBreaks(gen)

  gen.loopScopeDepth = prevScopeDepth
  pop(gen.breakOffsets)
  pop(gen.continueOffsets)
  pop(gen.loopBaseSlots)
  pop(gen.loopContinueSlots)

  popScope(gen)

  // Single-stack - the loopResultSlot IS the result value, leave it on stack
  // Decrement nextLocalSlot because we're "returning" it as a temporary value
  // (The caller's compileExpr will POP it if in STMT mode)
  gen.nextLocalSlot = gen.nextLocalSlot - 1
  pop(gen.loopResultSlots)
}

fn compileImport(gen, node) {
  if !gen.codegenModule {
    addError(gen, node, "Import requires codegenModule callback.")
    return
  }
  let path = node.path and node.path.value
  if !path {
    addError(gen, node, "Import path must be a string literal.")
    return
  }
  let const = gen.currentFunction.chunk.importConstCache[path]
  if !const {
    let func = gen.codegenModule(path)
    if !func {
      addError(gen, node, "Import failed: " + path)
      return
    }
    const = makeConstant(gen, ObjectFunction(func))
    gen.currentFunction.chunk.importConstCache[path] = const
  }
  emitBytes(gen, OP.CLOSURE, const, node.line)
  emitBytes(gen, OP.CALL, 0, node.line)
}

fn compileValueExpr(gen, node) {
  if !node { return }
  gen.metrics.nodesVisited = gen.metrics.nodesVisited + 1
  gen.currentNode = node
  gen.currentLine = node.line

  if node.type == "Block" {
    compileBlock(gen, node)
  } else if node.type == "Call" {
    compileCall(gen, node)
  } else if node.type == "If" {
    compileIf(gen, node)
  } else if node.type == "For" {
    compileFor(gen, node)
  } else if node.type == "Binary" {
    compileBinary(gen, node)
  } else if node.type == "Logical" {
    compileLogical(gen, node)
  } else if node.type == "Unary" {
    compileUnary(gen, node)
  } else if node.type == "Grouping" {
    compileValue(gen, node.expression)
  } else if node.type == "Identifier" {
    compileIdentifier(gen, node)
  } else if node.type == "Number" or node.type == "String" or
            node.type == "Bool" or node.type == "Nil" {
    compileLiteral(gen, node)
  } else if node.type == "Array" {
    compileArray(gen, node)
  } else if node.type == "Hashmap" {
    compileHashmap(gen, node)
  } else if node.type == "Index" {
    compileIndex(gen, node)
  } else if node.type == "Dot" {
    compileDot(gen, node)
  } else if node.type == "Import" {
    compileImport(gen, node)
  } else if node.type == "IntrinsicCall" {
    compileIntrinsicCall(gen, node)
  } else {
    addError(gen, node, "Codegen not implemented for: " + node.type)
  }
}

fn compileExpr(gen, node, mode) {
  if !node { return }
  gen.currentNode = node
  gen.currentLine = node.line

  // Control-flow nodes that don't produce values
  if node.type == "Return" {
    compileReturn(gen, node)
    return
  }
  if node.type == "Break" {
    compileBreak(gen, node)
    return
  }
  if node.type == "Continue" {
    compileContinue(gen, node)
    return
  }

  // Nodes that handle mode internally
  if node.type == "Let" {
    compileLet(gen, node, mode)
    return
  }
  if node.type == "Assignment" {
    compileAssignment(gen, node, mode)
    return
  }
  if node.type == "Function" {
    compileFunctionExpr(gen, node, mode)
    return
  }

  // All other nodes: compile as value expression, then discard if STMT
  compileValueExpr(gen, node)
  if mode == MODE.STMT {
    emitByte(gen, OP.POP, node.line)
  }
}

fn codegen(ast, resolveResult, opts) {
  let gen = .{
    currentFunction: Function("", 0, Chunk(ast.filename)),
    resolvedNames: resolveResult.resolvedNames or .{},
    assignmentInfo: resolveResult.assignmentInfo or .{},
    scopeInfo: resolveResult.scopeInfo or .{},
    nodes: resolveResult.nodes or .{},
    localsByDecl: buildDeclMap(resolveResult.scopeInfo),
    errors: [],
    currentLine: 1,
    currentNode: nil,
    scopeStack: [],
    scopeBaseSlots: [],  // Track baseline nextLocalSlot when entering each scope
    breakOffsets: [],
    continueOffsets: [],
    loopResultSlots: [],
    loopBaseSlots: [],  // Track loop base slots for break (pops everything)
    loopContinueSlots: [],  // Track loop continue slots (keeps loop var)
    loopScopeDepth: 0,
    codegenModule: opts and opts.codegenModule or nil,

    // Track actual emitted local positions (nodeId -> absolute slot)
    emittedLocals: .{},
    nextLocalSlot: 0,  // Counter for absolute local positions

    // Performance counters
    metrics: .{
      nodesVisited: 0,
      emitCalls: 0,
      patchCount: 0,
      constAdds: 0,
      constLookups: 0,
      constHits: 0,
    },
  }

  compileBlock(gen, ast)
  emitByte(gen, OP.RETURN, gen.currentLine)

  .{
    success: len(gen.errors) == 0,
    function: gen.currentFunction,
    errors: gen.errors,
    metrics: gen.metrics,
    bytesEmitted: len(gen.currentFunction.chunk.bytecode),
  }
}

codegen
