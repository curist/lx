// ========================================================
// Phase 1 Typechecker (Minimal Core)
// ========================================================
//
// GOAL:
//   - Monomorphic, eager type inference
//   - No flow sensitivity
//   - No Option, no narrowing, no polymorphism
//
// NON-GOALS (INTENTIONALLY REMOVED):
//   - Option / nil-joins
//   - Env cloning / branch refinement
//   - Tagged unions
//   - Map vs Record distinction
//   - Polymorphism (Scheme / generalize / instantiate)
//   - Two-pass inference
//   - Deferred constraints
//
// This file is the *stable foundation*.
// Later phases must build on top of this, not inside it.
//
// ========================================================


// ========================================================
// Type Constructors
// ========================================================

fn typeAny()     { .{ kind: "Any" } }
fn typeNil()     { .{ kind: "Nil" } }
fn typeNumber()  { .{ kind: "Number" } }
fn typeBool()    { .{ kind: "Bool" } }
fn typeString()  { .{ kind: "String" } }

fn typeVar(id) {
  .{ kind: "TypeVar", id: id }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params: params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem: elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields: fields }
}

// ========================================================
// Type Variable Management
// ========================================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = id + 1
  typeVar(id)
}

fn bindTypeVar(checker, id, type) {
  checker.typeVarBindings[id] = type
}

fn getTypeVarBinding(checker, id) {
  checker.typeVarBindings[id]
}

// Follow bindings until fixed point
fn deref(checker, type) {
  if type.kind == "TypeVar" {
    let bound = getTypeVarBinding(checker, type.id)
    if bound {
      return deref(checker, bound)
    }
  }
  type
}

// Occurs check: prevent infinite types
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for let i = 0; i < len(type.params); i = i + 1 {
      if occurs(checker, typeVarId, type.params[i]) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Record" {
    let ks = keys(type.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      if occurs(checker, typeVarId, type.fields[ks[i]]) {
        return true
      }
    }
  }

  false
}

fn derefAll(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Function" {
    let ps = []
    for let i = 0; i < len(t.params); i = i + 1 {
      push(ps, derefAll(checker, t.params[i]))
    }
    return typeFunction(ps, derefAll(checker, t.return))
  }

  if t.kind == "Array" {
    return typeArray(derefAll(checker, t.elem))
  }

  if t.kind == "Record" {
    let fields = .{}
    let ks = keys(t.fields)
    for let i = 0; i < len(ks); i = i + 1 {
      fields[ks[i]] = derefAll(checker, t.fields[ks[i]])
    }
    return typeRecord(fields)
  }

  t
}

// ========================================================
// Error Handling
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}


// ========================================================
// Unification (Eager, Structural)
// ========================================================

fn unify(checker, t1, t2) {
  t1 = deref(checker, t1)
  t2 = deref(checker, t2)

  // Fast path
  if t1.kind == t2.kind {
    if t1.kind == "TypeVar" {
      if t1.id == t2.id { return true }
      bindTypeVar(checker, t1.id, t2)
      return true
    }

    if t1.kind == "Function" {
      if len(t1.params) != len(t2.params) { return false }
      for let i = 0; i < len(t1.params); i = i + 1 {
        if !unify(checker, t1.params[i], t2.params[i]) {
          return false
        }
      }
      return unify(checker, t1.return, t2.return)
    }

    if t1.kind == "Array" {
      return unify(checker, t1.elem, t2.elem)
    }

    if t1.kind == "Record" {
      let k1 = keys(t1.fields)
      let k2 = keys(t2.fields)
      if len(k1) != len(k2) { return false }
      for let i = 0; i < len(k1); i = i + 1 {
        let k = k1[i]
        if !t2.fields[k] { return false }
        if !unify(checker, t1.fields[k], t2.fields[k]) {
          return false
        }
      }
      return true
    }

    // Primitive types
    return true
  }

  // Any absorbs everything
  if t1.kind == "Any" or t2.kind == "Any" {
    return true
  }

  // TypeVar binding
  if t1.kind == "TypeVar" {
    if occurs(checker, t1.id, t2) { return false }
    bindTypeVar(checker, t1.id, t2)
    return true
  }

  if t2.kind == "TypeVar" {
    if occurs(checker, t2.id, t1) { return false }
    bindTypeVar(checker, t2.id, t1)
    return true
  }

  false
}

fn constrain(checker, t1, t2, nodeId, msg) {
  if !unify(checker, t1, t2) {
    addError(checker, nodeId, msg)
    return typeAny()
  }
  t1
}

// ========================================================
// Constraints (Phase 2)
// ========================================================

fn emitEq(checker, t1, t2, nodeId, msg) {
  push(checker.constraints, .{
    kind: "Eq",
    t1: t1,
    t2: t2,
    nodeId: nodeId,
    msg: msg,
  })
  t2
}

fn emitHasField(checker, base, name, fieldType, nodeId, msg) {
  push(checker.constraints, .{
    kind: "HasField",
    base: base,
    fieldName: name,
    fieldType: fieldType,
    nodeId: nodeId,
    msg: msg,
  })
  fieldType
}

fn containEqFailure(checker, t1, t2) {
  if t1.kind == "TypeVar" { bindTypeVar(checker, t1.id, typeAny()) }
  if t2.kind == "TypeVar" { bindTypeVar(checker, t2.id, typeAny()) }
}

fn containHasFieldFailure(checker, fieldType) {
  if fieldType.kind == "TypeVar" {
    bindTypeVar(checker, fieldType.id, typeAny())
  }
}

fn trySolveConstraint(checker, c) {
  if c.kind == "Eq" {
    if !unify(checker, c.t1, c.t2) {
      addError(checker, c.nodeId, c.msg)
      containEqFailure(checker, deref(checker, c.t1), deref(checker, c.t2))
    }
    return true
  }

  if c.kind == "HasField" {
    let base = deref(checker, c.base)
    let ft = deref(checker, c.fieldType)

    if base.kind == "Any" {
      if ft.kind == "TypeVar" { bindTypeVar(checker, ft.id, typeAny()) }
      return true
    }

    if base.kind == "Record" {
      let field = base.fields[c.fieldName]
      if field {
        if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
      } else {
        addError(checker, c.nodeId, c.msg)
        containHasFieldFailure(checker, ft)
      }
      return true
    }

    if base.kind == "TypeVar" {
      let binding = getTypeVarBinding(checker, base.id)
      if !binding {
        let rec = typeRecord(.{ [c.fieldName]: ft })
        bindTypeVar(checker, base.id, rec)
        return true
      }
      if binding.kind == "Record" {
        let field = binding.fields[c.fieldName]
        if !field {
          binding.fields[c.fieldName] = ft
        } else if !unify(checker, field, ft) {
          addError(checker, c.nodeId, c.msg)
          containHasFieldFailure(checker, ft)
        }
        return true
      }
      addError(checker, c.nodeId, c.msg)
      containHasFieldFailure(checker, ft)
      return true
    }

    // Non-record base
    addError(checker, c.nodeId, c.msg)
    containHasFieldFailure(checker, ft)
    return true
  }

  false
}

fn solveConstraints(checker) {
  let work = checker.constraints
  let remaining = []

  for let i = 0; i < len(work); i = i + 1 {
    let c = work[i]
    if !trySolveConstraint(checker, c) {
      push(remaining, c)
    }
  }

  checker.constraints = remaining
}


// ========================================================
// Type Environment (Lexical, No Cloning)
// ========================================================

fn TypeEnv(parent) {
  .{
    parent: parent,
    bindings: .{}, // declNodeId -> TypeVar
  }
}

fn lookupDecl(checker, declNodeId) {
  let env = checker.currentEnv
  for env {
    let t = env.bindings[declNodeId]
    if t { return t }
    env = env.parent
  }
  nil
}

fn bindDecl(checker, declNodeId) {
  let tv = freshTypeVar(checker)
  checker.currentEnv.bindings[declNodeId] = tv
  tv
}

fn enterScope(checker) {
  checker.currentEnv = TypeEnv(checker.currentEnv)
}

fn exitScope(checker) {
  checker.currentEnv = checker.currentEnv.parent
}


// ========================================================
// Expression Checking (Pure Phase 1)
// ========================================================

let synthExpr

// Some lowers wrap expressions as statements.
fn checkExprStmt(checker, node) {
  // Lower often wraps top-level statements this way.
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

fn checkLiteral(checker, node) {
  let t =
    node.type == "Number" and typeNumber() or
    node.type == "String" and typeString() or
    node.type == "Bool"   and typeBool()   or
    typeNil()

  checker.types[node.id] = t
  t
}

fn checkIdentifier(checker, node) {
  let binding = checker.resolvedNames[node.id]
  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let declId = binding.declaredAt
  let tv = lookupDecl(checker, declId)
  if !tv {
    tv = bindDecl(checker, declId)
  }

  checker.types[node.id] = tv
  tv
}

fn checkBinary(checker, node) {
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "+" or op == "-" or op == "*" or op == "/" {
    emitEq(checker, lt, typeNumber(), node.left.id, "Expected number")
    emitEq(checker, rt, typeNumber(), node.right.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "==" or op == "!=" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  addError(checker, node.id, "Unsupported binary operator")
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkCall(checker, node) {
  let callee = synthExpr(checker, node.callee)
  let args = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(args, synthExpr(checker, node.args[i]))
  }

  let paramTvs = []
  for let i = 0; i < len(args); i = i + 1 {
    push(paramTvs, freshTypeVar(checker))
  }
  let ret = freshTypeVar(checker)
  let fnType = typeFunction(paramTvs, ret)

  emitEq(checker, callee, fnType, node.callee.id, "Call requires function")
  for let i = 0; i < len(args); i = i + 1 {
    emitEq(checker, args[i], paramTvs[i], node.args[i].id, "Argument mismatch")
  }

  checker.types[node.id] = ret
  ret
}

fn checkFunction(checker, node) {
  // If this function is named (hoisted), ensure its declaration binding exists.
  let fnBinding = nil
  if node.name {
    fnBinding = lookupDecl(checker, node.id)
    if !fnBinding {
      fnBinding = bindDecl(checker, node.id)
    }
  }

  enterScope(checker)

  let params = []
  for let i = 0; i < len(node.params); i = i + 1 {
    let tv = bindDecl(checker, node.params[i].id)
    checker.types[node.params[i].id] = tv
    push(params, tv)
  }

  let ret = freshTypeVar(checker)
  let bodyT = synthExpr(checker, node.body)
  emitEq(checker, bodyT, ret, node.body.id, "Return mismatch")

  exitScope(checker)

  // Store the function type with current bindings resolved.
  let resolvedParams = []
  for let i = 0; i < len(params); i = i + 1 {
    push(resolvedParams, deref(checker, params[i]))
  }
  let fnT = typeFunction(resolvedParams, deref(checker, ret))
  checker.types[node.id] = fnT
  if fnBinding {
    emitEq(checker, fnBinding, fnT, node.id, "Function declaration mismatch")
    checker.types[node.name.id] = fnBinding
  }

  // Track for second-pass refinement
  push(checker.functionInfos, .{
    node: node,
    params: params,
    ret: ret,
    fnType: fnT,
  })
  fnT
}

fn checkLet(checker, node) {
  let tv = bindDecl(checker, node.name.id)
  checker.types[node.name.id] = tv

  if node.init {
    let it = synthExpr(checker, node.init)
    emitEq(checker, tv, it, node.init.id, "Initializer mismatch")
  }

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkIf(checker, node) {
  synthExpr(checker, node.condition)
  let thenT = synthExpr(checker, node.then)

  if node.else {
    let elseT = synthExpr(checker, node.else)
    emitEq(checker, thenT, elseT, node.id, "Branch mismatch")
    checker.types[node.id] = thenT
    return thenT
  }

  // Phase 1: no Option semantics
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkBlock(checker, node) {
  enterScope(checker)

  let lastT = typeNil()
  if node.expressions {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      lastT = synthExpr(checker, node.expressions[i])
    }
  }

  exitScope(checker)

  checker.types[node.id] = lastT
  lastT
}

fn checkGrouping(checker, node) {
  let t = synthExpr(checker, node.expression)
  checker.types[node.id] = t
  t
}

fn checkUnary(checker, node) {
  let ot = synthExpr(checker, node.operand)
  let op = node.operator.lexeme

  // Minimal Phase-1 semantics
  if op == "-" {
    emitEq(checker, ot, typeNumber(), node.operand.id, "Expected number")
    let t = typeNumber()
    checker.types[node.id] = t
    return t
  }

  if op == "!" {
    emitEq(checker, ot, typeBool(), node.operand.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  // Unknown unary -> Any, but still traversed operand
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkLogical(checker, node) {
  // NOTE: pick semantics. If Lx is Lua-like and returns operands,
  // you cannot type it as Bool in general.
  // For Phase 1, simplest is to require bool operands and return bool.
  let lt = synthExpr(checker, node.left)
  let rt = synthExpr(checker, node.right)
  let op = node.operator.lexeme

  if op == "and" or op == "or" {
    emitEq(checker, lt, typeBool(), node.left.id, "Expected bool")
    emitEq(checker, rt, typeBool(), node.right.id, "Expected bool")
    let t = typeBool()
    checker.types[node.id] = t
    return t
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkFor(checker, node) {
  enterScope(checker)

  if node.init      { synthExpr(checker, node.init) }
  if node.condition {
    let ct = synthExpr(checker, node.condition)
    // If you want: constrain condition to Bool
    emitEq(checker, ct, typeBool(), node.condition.id, "Expected bool")
  }
  if node.update    { synthExpr(checker, node.update) }

  // Body can be Block or any stmt/expr
  if node.body      { synthExpr(checker, node.body) }

  exitScope(checker)

  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkReturn(checker, node) {
  if node.value { synthExpr(checker, node.value) }
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkBreak(checker, node) {
  if node.value { synthExpr(checker, node.value) }
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkContinue(checker, node) {
  checker.types[node.id] = typeNil()
  typeNil()
}

fn checkArray(checker, node) {
  // Phase 1: no Array element inference (yet). Still traverse elements.
  if node.elements {
    for let i = 0; i < len(node.elements); i = i + 1 {
      synthExpr(checker, node.elements[i])
    }
  }
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkHashmap(checker, node) {
  // Phase 1: treat hashmap literal as closed record when keys are string-like.
  let fields = .{}
  if node.pairs {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let p = node.pairs[i]
      // Prefer string keys (parser lowers dot keys to String nodes)
      if p.key and p.key.type == "String" {
        let vType = synthExpr(checker, p.value)
        fields[p.key.value] = vType
        continue
      }
      // Assuming pairs are like .{ key: <node>, value: <node> } OR a 2-tuple
      if p.key   { synthExpr(checker, p.key) }
      if p.value { synthExpr(checker, p.value) }
      // If your lower uses p[0], p[1], adjust accordingly.
    }
  }
  // If we collected any string keys, expose a Record type; otherwise fall back to Any.
  let t =
    len(keys(fields)) > 0 and typeRecord(fields) or
    typeAny()
  checker.types[node.id] = t
  t
}

fn checkIndex(checker, node) {
  synthExpr(checker, node.object)
  synthExpr(checker, node.index)
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkDot(checker, node) {
  let objT = synthExpr(checker, node.object)
  // property is a Node (Identifier or StringKey)
  let propName = nil
  if node.property and node.property.type == "Identifier" {
    propName = node.property.name
  } else if node.property and node.property.type == "String" {
    propName = node.property.value
  } else {
    if node.property { synthExpr(checker, node.property) }
  }

  if !propName {
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  let fieldT = freshTypeVar(checker)
  emitHasField(checker, objT, propName, fieldT, node.id, "Missing field: " + propName)
  checker.types[node.id] = fieldT
  fieldT
}

fn checkAssignment(checker, node) {
  let vt = synthExpr(checker, node.value)

  // Minimal: only support assignment to Identifier in Phase 1
  if node.target and node.target.type == "Identifier" {
    let lt = synthExpr(checker, node.target)
    emitEq(checker, lt, vt, node.id, "Assignment mismatch")
    checker.types[node.id] = vt
    return vt
  }

  // Traverse target anyway
  if node.target { synthExpr(checker, node.target) }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkImport(checker, node) {
  // Path is usually String or Identifier
  if node.path { synthExpr(checker, node.path) }
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn checkArrow(checker, node) {
  // If Arrow is pipeline/bind, you probably want semantics later.
  // Phase 1: traverse both sides and return Any.
  synthExpr(checker, node.left)
  synthExpr(checker, node.right)
  let t = typeAny()
  checker.types[node.id] = t
  t
}

fn refineFunctions(checker) {
  let root = checker.rootEnv
  for let i = 0; i < len(checker.functionInfos); i = i + 1 {
    let info = checker.functionInfos[i]
    checker.currentEnv = root
    enterScope(checker)

    if info.node.name {
      checker.currentEnv.bindings[info.node.id] = lookupDecl(checker, info.node.id) or info.fnType
    }

    for let p = 0; p < len(info.params); p = p + 1 {
      let paramNode = info.node.params[p]
      checker.currentEnv.bindings[paramNode.id] = info.params[p]
      checker.types[paramNode.id] = info.params[p]
    }

    let bodyT = synthExpr(checker, info.node.body)
    emitEq(checker, bodyT, info.ret, info.node.body.id, "Return mismatch")

    exitScope(checker)
  }
}


// ========================================================
// Dispatcher
// ========================================================

synthExpr = fn(checker, node) {
  if !node { return typeNil() }

  if node.type == "Identifier" { return checkIdentifier(checker, node) }

  if node.type == "Number" or node.type == "String" or
     node.type == "Bool" or node.type == "Nil" {
    return checkLiteral(checker, node)
  }

  if node.type == "Binary"     { return checkBinary(checker, node) }
  if node.type == "Call"       { return checkCall(checker, node) }
  if node.type == "Function"   { return checkFunction(checker, node) }
  if node.type == "If"         { return checkIf(checker, node) }
  if node.type == "Let"        { return checkLet(checker, node) }
  if node.type == "Block"      { return checkBlock(checker, node) }
  if node.type == "Grouping"   { return checkGrouping(checker, node) }
  if node.type == "Unary"      { return checkUnary(checker, node) }
  if node.type == "Logical"    { return checkLogical(checker, node) }
  if node.type == "For"        { return checkFor(checker, node) }
  if node.type == "Return"     { return checkReturn(checker, node) }
  if node.type == "Break"      { return checkBreak(checker, node) }
  if node.type == "Continue"   { return checkContinue(checker, node) }
  if node.type == "Array"      { return checkArray(checker, node) }
  if node.type == "Hashmap"    { return checkHashmap(checker, node) }
  if node.type == "Index"      { return checkIndex(checker, node) }
  if node.type == "Dot"        { return checkDot(checker, node) }
  if node.type == "Assignment" { return checkAssignment(checker, node) }
  if node.type == "Import"     { return checkImport(checker, node) }
  if node.type == "Arrow"      { return checkArrow(checker, node) }
  if node.type == "ExprStmt"   { return checkExprStmt(checker, node) }

  addError(checker, node.id, "Unsupported node in Phase 1: " + node.type)
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// ========================================================
// Public API
// ========================================================

fn makeChecker(resolveResult, opts) {
  let root = TypeEnv(nil)
  .{
    types: .{},
    typeVarBindings: .{},
    errors: [],
    hadError: false,

    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,

    nextTypeVarId: 1,
    currentEnv: root,
    rootEnv: root,

    constraints: [],
    functionInfos: [],
  }
}

fn predeclareTopLevel(checker, ast) {
  if !ast or ast.type != "Block" or !ast.expressions { return }

  for let i = 0; i < len(ast.expressions); i = i + 1 {
    let node = ast.expressions[i]
    if node.type == "Let" and node.name {
      if !lookupDecl(checker, node.name.id) {
        bindDecl(checker, node.name.id)
      }
    } else if node.type == "Function" and node.name {
      if !lookupDecl(checker, node.id) {
        bindDecl(checker, node.id)
      }
    }
  }
}

fn typecheck(ast, resolveResult, opts) {
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      typeVarBindings: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  let checker = makeChecker(resolveResult, opts)

  if !ast {
    return .{ success: true, types: .{}, typeVarBindings: .{}, errors: [] }
  }

  // Predeclare top-level lets/functions for forward references (Phase 2)
  predeclareTopLevel(checker, ast)

  // Prefer: drive from the root node if it is a node
  if ast.type {
    synthExpr(checker, ast)
  } else if ast.body {
    for let i = 0; i < len(ast.body); i = i + 1 {
      synthExpr(checker, ast.body[i])
    }
  }

  // Solve constraints and refine functions once more
  solveConstraints(checker)
  refineFunctions(checker)
  solveConstraints(checker)

  let outTypes = .{}
  let typeKeys = keys(checker.types)
  for let i = 0; i < len(typeKeys); i = i + 1 {
    let k = typeKeys[i]
    outTypes[k] = derefAll(checker, checker.types[k])
  }

  let outBindings = .{}
  let bindKeys = keys(checker.typeVarBindings)
  for let i = 0; i < len(bindKeys); i = i + 1 {
    let k = bindKeys[i]
    outBindings[k] = derefAll(checker, checker.typeVarBindings[k])
  }

  .{
    success: !checker.hadError,
    types: outTypes,
    typeVarBindings: outBindings,
    errors: checker.errors,
  }
}

typecheck
