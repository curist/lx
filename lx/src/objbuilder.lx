let .{ ValueType } = import "src/types.lx"
let .{ ObjType } = import "src/object.lx"

let VERSION = 2

let ChunkType = .{
  REF: 0,
  ACTUAL: 1,
}

// lxobj layout v2
//
// HEADER (32 bytes):
//   MAGIC:               2  ('L','X')
//   VERSION:             1  (2)
//   FLAGS:               1
//     bit0 (0x01): debug sections present
//     bit1 (0x02): payload is zlib-compressed
//   OBJSIZE:             4  u32 LE (total file size: header + stored payload)
//   CHUNKS:              4  u32 LE (number of chunks)
//   MAIN_ID:             4  u32 LE (entry chunk id)
//   CRC32:               4  u32 LE (CRC32 of *uncompressed* payload bytes)
//   FILEPATH_TABLE_SIZE: 4  u32 LE (bytes of filepath table; 0 if !debug)
//   RESERVED:            8
//
// PAYLOAD (immediately after header; may be compressed):
//   FILEPATH_TABLE (present iff debug && FILEPATH_TABLE_SIZE > 0):
//     COUNT:             2  u16 LE
//     repeated COUNT times:
//       LENGTH:          2  u16 LE
//       STRING:          LENGTH bytes (utf-8 / raw bytes)
//   CHUNK_STREAM:
//     repeated CHUNKS times:
//       CHUNK_SIZE:      4  u32 LE (bytes following this field)
//       CHUNK_TYPE:      1  (0=REF, 1=ACTUAL)
//       CHUNK_ID:        4  u32 LE
//       if REF:
//         REF_TARGET:    4  u32 LE (chunk id)
//       if ACTUAL:
//         ARITY:         1  u8
//         UPVALUE_COUNT: 1  u8
//         NAME_LEN:      2  u16 LE
//         NAME:          NAME_LEN bytes
//         CODE_SIZE:     4  u32 LE
//         CODE:          CODE_SIZE bytes
//         CONST_SEC_SIZE:4  u32 LE
//         CONST_COUNT:   2  u16 LE
//         CONSTS:        variable (tagged values)
//         if debug:
//           DEBUG_SIZE:  4  u32 LE
//           FILEPATH_INDEX: 2 u16 LE (index into filepath table)
//           LINE_RLE:    repeated records of (REPEAT:1 u8, LINE:2 u16 LE)

fn int32ToBytes(num) {
  // always return 4 bytes as numbers
  let bytes = [0, 0, 0, 0]
  bytes[0] = num & 255
  num = num >> 8
  bytes[1] = num & 255
  num = num >> 8
  bytes[2] = num & 255
  num = num >> 8
  bytes[3] = num & 255
  return bytes
}

fn uint32ToBytes(num) {
  let n = Math.floor(num)

  // if you ever allow negative inputs, normalize into [0, 2^32)
  if n < 0 {
    n = n + 4294967296
  }

  let bytes = [0, 0, 0, 0]
  bytes[0] = n % 256
  n = Math.floor(n / 256)
  bytes[1] = n % 256
  n = Math.floor(n / 256)
  bytes[2] = n % 256
  n = Math.floor(n / 256)
  bytes[3] = n % 256
  return bytes
}

// Convert uint16 to 2-byte little-endian representation
fn uint16ToLEBytes(num) {
  if num > 65535 { return [255, 255] }
  return [num & 255, (num >> 8) & 255]
}

fn doubleToBytes(num) {
  Lx.doubleToUint8Array(num)
}

fn stringToBytes(s) {
  fold(range(s), [], fn(bytes, c) {
    if len(c) > 1 {
      concat(bytes, collect i in range(len(c)) { ord(c[i]) })
    } else {
      push(bytes, ord(c))
    }
  })
}

fn writeBytesAt(arr1, arr2, index) {
  for let i = 0; i < len(arr2) and i + index < len(arr1); i = i + 1 {
    arr1[index + i] = arr2[i]
  }
}

fn setFlags(options) {
  let flags = 0
  if options.debug {
    flags = flags + 1
  }
  if options.compress {
    flags = flags + 2  // bit 1
  }
  return flags
}

fn buildChunkObj(func, funcId, flags, builtModuleCache, ensureFunctionId, filepathIndex) {
  let chunk = func.chunk
  let funcName = func.name
  let filename = chunk.filename
  let isModule = funcName == ""

  let obj = []
  let debug = flags.debug

  // reserve chunk size
  obj = concat(obj, int32ToBytes(0))

  // chunk type
  let moduleBuilt = nil
  if isModule and builtModuleCache[filename] != nil {
    moduleBuilt = builtModuleCache[filename]
  }
  if moduleBuilt {
    push(obj, ChunkType.REF)
    obj = concat(obj, int32ToBytes(funcId))
    obj = concat(obj, int32ToBytes(moduleBuilt))

    // update chunk total size
    writeBytesAt(obj, int32ToBytes(len(obj) - 4), 0)

    return .{ obj }
  }

  push(obj, ChunkType.ACTUAL)
  obj = concat(obj, int32ToBytes(funcId))

  push(obj, func.arity)
  push(obj, func.upvalueCount)

  // chunk name info
  obj = concat(obj, uint16ToLEBytes(len(funcName)))
  obj = concat(obj, stringToBytes(funcName))

  let codeSize = len(chunk.bytecode)
  obj = concat(obj, int32ToBytes(codeSize))
  // Bytecode already stored as numbers
  obj = concat(obj, chunk.bytecode)

  // save start index, we will update this to actual constants size
  let constSectionStart = len(obj)
  // reserve constants section size
  obj = concat(obj, int32ToBytes(1))

  let constantsSize = len(chunk.constants)
  obj = concat(obj, uint16ToLEBytes(constantsSize))

  let constants = []
  if constantsSize > 0 {
    let objTypeHandlers = .{
      [ObjType.STRING]: fn(value) {
        constants = concat(constants, int32ToBytes(len(value)))
        constants = concat(constants, stringToBytes(value))
      },
      [ObjType.FUNCTION]: fn(value) {
        let targetId = ensureFunctionId(value)
        constants = concat(constants, int32ToBytes(targetId))
      },
    }
    let constTypeHandlers = .{
      // NOTE: not having nil or bool handlers here,
      // since those are represented directly as byte codes
      [ValueType.NUMBER]: fn(value) {
        let double = doubleToBytes(value)
        constants = concat(constants, double)
      },
      [ValueType.OBJ]: fn(val) {
        if let handler = objTypeHandlers[val.kind] {
          push(constants, val.kind)
          handler(val.value)
        } else {
          // should be unreachable
          Lx.stderr.println("Invalid obj handler type: ", val.kind)
          Lx.exit(55)
        }
      },
    }
    for val in chunk.constants {
      if let handler = constTypeHandlers[val.kind] {
        push(constants, val.kind)
        handler(val.value)
      } else {
        // should be unreachable
        Lx.stderr.println("Invalid value handler type: ", val.kind)
        Lx.exit(55)
      }
    }
  }

  // update constants section size (2 bytes for count + constants data)
  writeBytesAt(obj, int32ToBytes(len(constants) + 2), constSectionStart)
  obj = concat(obj, constants)

  if debug {
    // save start index, we will update this to actual debug size
    let debugSectionStart = len(obj)
    // reserve debug section size
    obj = concat(obj, int32ToBytes(0))
    let debugLines = []

    // Store filepath index instead of full path
    debugLines = concat(debugLines, uint16ToLEBytes(filepathIndex))

    let lastLineNumber = -1
    let runningLength = 0
    fn emitDebugLines(line) {
      if line == -1 or runningLength == 0 { return }
      push(debugLines, runningLength)
      debugLines = concat(debugLines, uint16ToLEBytes(line))
      lastLineNumber = -1
      runningLength = 0
    }
    for line in chunk.lines {
      if line == lastLineNumber {
        runningLength = runningLength + 1
      } else {
        emitDebugLines(lastLineNumber)
        lastLineNumber = line
        runningLength = 1
      }
      if runningLength == 255 {
        emitDebugLines(line)
      }
    }
    // emit remaing lines
    emitDebugLines(lastLineNumber)

    // update debug section size
    writeBytesAt(obj, int32ToBytes(len(debugLines)), debugSectionStart)
    obj = concat(obj, debugLines)
  }

  // update chunk total size
  writeBytesAt(obj, int32ToBytes(len(obj) - 4), 0)

  return .{ obj }
}

fn objbuilder(main, debug, compress) {
  let flags = .{ debug, compress }
  let functions = []
  fn ensureFunctionId(func) {
    for func_, i in functions {
      if func_ == func { return i }
    }
    push(functions, func)
    len(functions) - 1
  }

  let mainId = ensureFunctionId(main)

  // Magic bytes: "LX" in ASCII (76, 88)
  let header = [76, 88, VERSION, setFlags(flags)]
  header = concat(header, int32ToBytes(0))  // size placeholder (offset 4)
  header = concat(header, int32ToBytes(0))  // chunks placeholder (offset 8)
  header = concat(header, int32ToBytes(mainId))  // main ID (offset 12)
  header = concat(header, int32ToBytes(0))  // CRC32 placeholder (offset 16)
  header = concat(header, int32ToBytes(0))  // filepath table size placeholder (offset 20)

  // Reserved space (8 bytes)
  for _ in range(8) { push(header, 0) }

  // Filepath indexing (lazy, stable)
  let filepathMap = .{}    // filename -> index
  let filepathList = []    // index -> filename

  fn ensureFilepathIndex(filename) {
    if !debug { return 0 }
    let idx = filepathMap[filename]
    if idx == nil {
      idx = len(filepathList)
      filepathMap[filename] = idx
      push(filepathList, filename)
    }
    return idx
  }

  // Build chunks first (functions may grow here)
  let chunksBytes = []
  let builtModuleCache = .{}

  for let i = 0; i < len(functions); i = i + 1 {
    let func = functions[i]
    let filename = func.chunk.filename
    let fpIndex = ensureFilepathIndex(filename)

    let chunkObj = buildChunkObj(func, i, flags, builtModuleCache, ensureFunctionId, fpIndex)
    chunksBytes = concat(chunksBytes, chunkObj.obj)

    let isModule = func.name == ""
    if isModule and builtModuleCache[filename] == nil {
      builtModuleCache[filename] = i
    }
  }

  // Now build filepath table (index order)
  let filepathTable = []
  if debug {
    filepathTable = concat(filepathTable, uint16ToLEBytes(len(filepathList)))
    for let i = 0; i < len(filepathList); i = i + 1 {
      let filename = filepathList[i]
      filepathTable = concat(filepathTable, uint16ToLEBytes(len(filename)))
      filepathTable = concat(filepathTable, stringToBytes(filename))
    }
  }

  // Payload = table + chunks
  let payload = concat(filepathTable, chunksBytes)

  // Calculate CRC32 of uncompressed payload (if zlib available)
  let crc32 = Lx.zlib.crc32(payload)
  writeBytesAt(header, uint32ToBytes(crc32), 16)

  // Update filepath table size
  writeBytesAt(header, int32ToBytes(len(filepathTable)), 20)

  // Update chunks count
  writeBytesAt(header, int32ToBytes(len(functions)), 8)

  // Compress payload if requested (and zlib available)
  if compress {
    payload = Lx.zlib.deflate(payload)
  }

  // Combine header and payload
  let obj = concat(header, payload)

  // Update total obj size
  writeBytesAt(obj, int32ToBytes(len(obj)), 4)

  return .{
    dump: fn() {
      let putc = Lx.stdout.putc
      for b in obj { putc(b) }
    },
    bytes: fn() { obj },
  }
}
