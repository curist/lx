let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

test("concat", fn(assert) {
  let arr1 = [1]
  let arr2 = [2]
  assert.equal(len(arr1), 1)
  // concat shouldn't affect original arr
  concat(arr1, arr2)
  assert.equal(len(arr1), 1)
  arr1 = concat(arr1, arr2)
  assert.equal(len(arr1), 2)

  arr2 = []
  arr1 = concat(arr1, arr2)
  assert.equal(len(arr1), 2)
})

test("unicode", fn(assert) {
  assert.equal(len("你好世界"), 12)
  assert.equal(len("やれやれだぜ"), 18)
  assert.equal(len(range("やれやれだぜ")), 6)
})

test("->", fn(assert) {
  fn add(a, b) { a + b }
  fn mul(a, b) { a * b }
  let result = 2->{fn(x) { x->add(3) }}()->mul(4)
  assert.equal(result, 20)
})

test("keyword as hashmap key", fn(assert) {
  let x = .{ and: 1, if: 2 }
  assert.equal(x.and, 1)
  assert.equal(x.if, 2)
})

test("else expression", fn(assert) {
  assert.equal(if false {0} else {1}, 1)
  assert.equal((if true {0} else {1} + 10) + 10, 20)
})

test("split", fn(assert) {
  let splitted = "a\nb\nc"->split("\n")
  assert.equal(len(splitted), 3)
  assert.equal(splitted[0], "a")
  assert.equal(splitted[1], "b")
  assert.equal(splitted[2], "c")
})

test("join preserves NUL", fn(assert) {
  let s = join([chr(0), chr(1), "a"], "")
  assert.equal(len(s), 3)

  assert.equal(s[0], chr(0))
  assert.equal(s[1], chr(1))
  assert.equal(s[2], "a")

  assert.equal(len(str(chr(0))), 1)
})

test("nameOf", fn(assert) {
  let Color = enum { Red, Green = 3, Blue }
  assert.equal(nameOf(Color, Color.Red), "Red")
  assert.equal(Color->nameOf(Color.Blue), "Blue")
  assert.equal(nameOf(Color, 999), nil)
})

test("reverse", fn(assert) {
  // Basic reversal
  let arr = [1, 2, 3, 4, 5]
  let rev = reverse(arr)
  assert.equal(len(rev), 5)
  assert.equal(rev[0], 5)
  assert.equal(rev[4], 1)

  // Non-mutating
  assert.equal(arr[0], 1)
  assert.equal(arr[4], 5)

  // Empty array
  assert.equal(len(reverse([])), 0)

  // Single element
  let single = reverse([42])
  assert.equal(len(single), 1)
  assert.equal(single[0], 42)

  // Strings and mixed types
  let mixed = reverse(["a", 1, true])
  assert.equal(mixed[0], true)
  assert.equal(mixed[1], 1)
  assert.equal(mixed[2], "a")
})

test("substr", fn(assert) {
  let s = "hello world"

  // Basic slicing
  assert.equal(substr(s, 0, 5), "hello")
  assert.equal(substr(s, 6, 11), "world")
  assert.equal(substr(s, 6), "world")

  // Negative indices
  assert.equal(substr(s, 0, -1), "hello worl")
  assert.equal(substr(s, -5, -1), "worl")
  assert.equal(substr(s, -5), "world")
  assert.equal(substr(s, 1, -1), "ello worl")

  // Empty results
  assert.equal(substr(s, 5, 5), "")
  assert.equal(substr(s, 5, 3), "")

  // Out of bounds
  assert.equal(substr(s, 100), "")
  assert.equal(substr(s, 6, 100), "world")
  assert.equal(substr(s, -100, 5), "hello")
})

test("slice", fn(assert) {
  let arr = [10, 20, 30, 40, 50]

  // Basic slice with end
  let s1 = slice(arr, 1, 3)
  assert.equal(len(s1), 2)
  assert.equal(s1[0], 20)
  assert.equal(s1[1], 30)

  // Slice to end
  let s2 = slice(arr, 2)
  assert.equal(len(s2), 3)
  assert.equal(s2[0], 30)
  assert.equal(s2[2], 50)

  // Full copy
  let s3 = slice(arr, 0, 5)
  assert.equal(len(s3), 5)
  assert.equal(s3[0], 10)

  // Non-mutating
  assert.equal(arr[0], 10)
  assert.equal(len(arr), 5)

  // Empty slices
  assert.equal(len(slice(arr, 3, 3)), 0)
  assert.equal(len(slice(arr, 2, 1)), 0)

  // Negative indices
  let s4 = slice(arr, 0, -1)
  assert.equal(len(s4), 4)
  assert.equal(s4[0], 10)
  assert.equal(s4[3], 40)

  let s5 = slice(arr, 1, -2)
  assert.equal(len(s5), 2)
  assert.equal(s5[0], 20)
  assert.equal(s5[1], 30)

  let s6 = slice(arr, -3, -1)
  assert.equal(len(s6), 2)
  assert.equal(s6[0], 30)
  assert.equal(s6[1], 40)

  let s7 = slice(arr, -2)
  assert.equal(len(s7), 2)
  assert.equal(s7[0], 40)
  assert.equal(s7[1], 50)

  // Negative out of bounds clamping
  let s8 = slice(arr, -10, -1)
  assert.equal(len(s8), 4)
  assert.equal(s8[0], 10)

  let s9 = slice(arr, 1, -10)
  assert.equal(len(s9), 0)

  // Positive boundary clamping
  let s10 = slice(arr, 1, 100)
  assert.equal(len(s10), 4)
  assert.equal(s10[3], 50)

  // Out of bounds
  assert.equal(len(slice(arr, 10)), 0)
  assert.equal(len(slice(arr, 10, 20)), 0)

  // Empty array
  assert.equal(len(slice([], 0)), 0)
  assert.equal(len(slice([], 0, 5)), 0)
})

suite.run()
