// Lower Phase - Desugar syntax into canonical AST
// Responsibility: Pure syntactic transformations
//   - Arrow operator: x->f(a) → f(x, a)
//   - Future: spread, destructuring, for-loops, etc.
//
// IMPORTANT: Lower MUST NOT introduce synthetic nodes.
// Missing else branches remain as nil (not normalized to empty blocks).

let types = import "src/types.lx"
let TOKEN = types.TOKEN

// ========================================
// Error handling
// ========================================

fn addError(lowerer, nodeId, message) {
  push(lowerer.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Node Creation Helpers
// ========================================

fn allocNodeId(lowerer) {
  let id = lowerer.nextId
  lowerer.nextId = lowerer.nextId + 1
  id
}

fn copyNodeShallow(lowerer, node) {
  // Copy all fields from node (shallow copy)
  let newNode = .{}
  // Copy all properties
  let node_keys = keys(node)
  for let i = 0; i < len(node_keys); i = i + 1 {
    let key = node_keys[i]
    newNode[key] = node[key]
  }

  // Assign new ID and track provenance
  let newId = allocNodeId(lowerer)
  lowerer.origin[newId] = node.id
  newNode.id = newId

  newNode
}

// ========================================
// Node Type Lowering Functions
// ========================================


// Leaf nodes - just copy with new ID
fn lowerLeaf(lowerer, node) {
  copyNodeShallow(lowerer, node)
}

fn lowerBinary(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.left = lowerExpr(lowerer, node.left)
  newNode.right = lowerExpr(lowerer, node.right)
  newNode
}

fn lowerUnary(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.operand = lowerExpr(lowerer, node.operand)
  newNode
}

fn lowerLogical(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.left = lowerExpr(lowerer, node.left)
  newNode.right = lowerExpr(lowerer, node.right)
  newNode
}

fn lowerGrouping(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.expression = lowerExpr(lowerer, node.expression)
  newNode
}

fn lowerLet(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  // Lower the name (Identifier node)
  newNode.name = lowerExpr(lowerer, node.name)

  if node.init {
    newNode.init = lowerExpr(lowerer, node.init)
  }
  newNode
}

fn lowerBlock(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredExprs = []
  for let i = 0; i < len(node.expressions); i = i + 1 {
    push(loweredExprs, lowerExpr(lowerer, node.expressions[i]))
  }
  newNode.expressions = loweredExprs

  newNode
}

fn lowerFunction(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  // Lower name (Identifier node or nil for anonymous functions)
  if node.name {
    newNode.name = lowerExpr(lowerer, node.name)
  }

  // Lower params (array of Identifier nodes)
  let loweredParams = []
  for let i = 0; i < len(node.params); i = i + 1 {
    push(loweredParams, lowerExpr(lowerer, node.params[i]))
  }
  newNode.params = loweredParams

  // Lower body
  newNode.body = lowerExpr(lowerer, node.body)

  newNode
}

fn lowerCall(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  newNode.callee = lowerExpr(lowerer, node.callee)

  let loweredArgs = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(loweredArgs, lowerExpr(lowerer, node.args[i]))
  }
  newNode.args = loweredArgs

  newNode
}

fn lowerArrow(lowerer, node) {
  // Arrow: left->right
  // Transform to: right with left prepended to args

  let left = lowerExpr(lowerer, node.left)
  let right = lowerExpr(lowerer, node.right)

  // Validate RHS is Call
  if right.type != "Call" {
    addError(lowerer, node.id, "Arrow operator requires function call on right side")
    return left  // Error recovery: return left side
  }

  // Create new Call node with left prepended to args
  // Need to manually build the prepended args array
  let newArgs = [left]
  for let i = 0; i < len(right.args); i = i + 1 {
    push(newArgs, right.args[i])
  }

  let newCall = .{
    type: "Call",
    filename: right.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    callee: right.callee,
    args: newArgs,
  }

  // Track provenance - this new Call came from the Arrow node
  lowerer.origin[newCall.id] = node.id

  newCall
}

fn lowerIf(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  newNode.condition = lowerExpr(lowerer, node.condition)
  newNode.then = lowerExpr(lowerer, node.then)

  // Keep else as-is: nil if missing, or lower if present
  if node.else {
    newNode.else = lowerExpr(lowerer, node.else)
  }
  // else remains nil (no normalization)

  newNode
}

fn lowerFor(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  if node.init {
    newNode.init = lowerExpr(lowerer, node.init)
  }
  if node.condition {
    newNode.condition = lowerExpr(lowerer, node.condition)
  }
  if node.update {
    newNode.update = lowerExpr(lowerer, node.update)
  }
  newNode.body = lowerExpr(lowerer, node.body)

  newNode
}

fn lowerForIn(lowerer, node) {
  // Desugar: for x, i in arrExpr { body }
  // Into: {
  //   let $arr = arrExpr
  //   let $len = len($arr)
  //   for let $i = 0; $i < $len; $i = $i + 1 {
  //     let x = $arr[$i]
  //     let i = $i
  //     body
  //   }
  // }

  // First, lower the iterable expression
  let loweredIterable = lowerExpr(lowerer, node.iterable)
  let loweredBody = lowerExpr(lowerer, node.body)

  // Generate hygienic names with $ prefix to avoid user conflicts
  let arrName = "$arr_" + str(node.id)
  let lenName = "$len_" + str(node.id)
  let idxName = "$i_" + str(node.id)

  // Helper to create an Identifier node
  fn makeIdent(name) {
    .{
      type: "Identifier",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  // Helper to create a Number node
  fn makeNumber(value) {
    .{
      type: "Number",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      value: value,
      lexeme: str(value),
    }
  }

  // Create: let __arr = arrExpr
  let arrLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(arrName),
    init: loweredIterable,
  }
  lowerer.origin[arrLetNode.id] = node.id

  // Create: len(__arr)
  let lenCallNode = .{
    type: "Call",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    callee: makeIdent("len"),
    args: [makeIdent(arrName)],
  }
  lowerer.origin[lenCallNode.id] = node.id

  // Create: let __len = len(__arr)
  let lenLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(lenName),
    init: lenCallNode,
  }
  lowerer.origin[lenLetNode.id] = node.id

  // Create: let __i = 0
  let initNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(idxName),
    init: makeNumber(0),
  }
  lowerer.origin[initNode.id] = node.id

  // Create: __i < __len
  let conditionNode = .{
    type: "Binary",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.LESS,
      lexeme: "<",
      line: node.line,
      col: node.col,
    },
    right: makeIdent(lenName),
  }
  lowerer.origin[conditionNode.id] = node.id

  // Create: __i = __i + 1
  let updateNode = .{
    type: "Assignment",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    target: makeIdent(idxName),
    value: .{
      type: "Binary",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      left: makeIdent(idxName),
      operator: .{
        type: TOKEN.PLUS,
        lexeme: "+",
        line: node.line,
        col: node.col,
      },
      right: makeNumber(1),
    },
  }
  lowerer.origin[updateNode.id] = node.id

  // Build the inner loop body statements
  let innerBodyExprs = []

  // Add: let x = __arr[__i] (if valueBinder is not "_")
  if node.valueBinder != "_" {
    let indexExpr = .{
      type: "Index",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      object: makeIdent(arrName),
      index: makeIdent(idxName),
    }
    lowerer.origin[indexExpr.id] = node.id

    let valueLetNode = .{
      type: "Let",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.valueBinder),
      init: indexExpr,
    }
    lowerer.origin[valueLetNode.id] = node.id
    push(innerBodyExprs, valueLetNode)
  }

  // Add: let i = __i (if indexBinder is present and not "_")
  if node.indexBinder and node.indexBinder != "_" {
    let indexLetNode = .{
      type: "Let",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.indexBinder),
      init: makeIdent(idxName),
    }
    lowerer.origin[indexLetNode.id] = node.id
    push(innerBodyExprs, indexLetNode)
  }

  // Add original body expressions to inner body
  if loweredBody.type == "Block" {
    for let i = 0; i < len(loweredBody.expressions); i = i + 1 {
      push(innerBodyExprs, loweredBody.expressions[i])
    }
  } else {
    push(innerBodyExprs, loweredBody)
  }

  // Create the inner block for the for loop body
  let innerBlockNode = .{
    type: "Block",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: innerBodyExprs,
  }
  lowerer.origin[innerBlockNode.id] = node.id

  // Create the for loop
  let forNode = .{
    type: "For",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: initNode,
    condition: conditionNode,
    update: updateNode,
    body: innerBlockNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Wrap everything in a block
  let outerBlockNode = .{
    type: "Block",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [arrLetNode, lenLetNode, forNode],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerCollect(lowerer, node) {
  // Desugar: collect <for-syntax> { body }
  // Into: {
  //   let $result = []
  //   for <for-syntax> { array_append($result, body) }
  //   $result
  // }

  let loweredBody = lowerExpr(lowerer, node.body)

  // Generate hygienic name
  let resultName = "$result_" + str(node.id)

  // Helper to create an Identifier node
  fn makeIdent(name) {
    .{
      type: "Identifier",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  // Create: let $result = [] (using array_new intrinsic)
  let arrayNewNode = .{
    type: "IntrinsicCall",
    intrinsic: "array_new",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [],
  }
  lowerer.origin[arrayNewNode.id] = node.id

  let resultLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(resultName),
    init: arrayNewNode,
  }
  lowerer.origin[resultLetNode.id] = node.id

  // Create: array_append($result, body) intrinsic
  let arrayAppendNode = .{
    type: "IntrinsicCall",
    intrinsic: "array_append",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    args: [makeIdent(resultName), loweredBody],
  }
  lowerer.origin[arrayAppendNode.id] = node.id

  // Lower the init, condition, update (if present)
  let loweredInit = node.init and lowerExpr(lowerer, node.init) or nil
  let loweredCondition = node.condition and lowerExpr(lowerer, node.condition) or nil
  let loweredUpdate = node.update and lowerExpr(lowerer, node.update) or nil

  // Create the for loop
  let forNode = .{
    type: "For",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: loweredInit,
    condition: loweredCondition,
    update: loweredUpdate,
    body: arrayAppendNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Create the outer block: { let $result = []; for ...; $result }
  let outerBlockNode = .{
    type: "Block",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [resultLetNode, forNode, makeIdent(resultName)],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerCollectIn(lowerer, node) {
  // Desugar collect-in directly to For loop structure
  // This avoids creating a ForIn node and lowering it, which causes infinite recursion

  let loweredIterable = lowerExpr(lowerer, node.iterable)
  let loweredBody = lowerExpr(lowerer, node.body)

  let resultName = "$result_" + str(node.id)
  let arrName = "$arr_" + str(node.id)
  let lenName = "$len_" + str(node.id)
  let idxName = "$i_" + str(node.id)

  fn makeIdent(name) {
    .{
      type: "Identifier",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  fn makeEmptyArray() {
    .{
      type: "Array",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      elements: [],
    }
  }

  fn makeNil() {
    .{
      type: "Nil",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      lexeme: "nil",
    }
  }

  fn makeNumber(val) {
    .{
      type: "Number",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      value: val,
      lexeme: str(val),
    }
  }

  // Create: let $result = [] (using array_new intrinsic)
  let arrayNewNode = .{
    type: "IntrinsicCall",
    intrinsic: "array_new",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [],
  }
  lowerer.origin[arrayNewNode.id] = node.id

  let resultLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(resultName),
    init: arrayNewNode,
  }
  lowerer.origin[resultLetNode.id] = node.id

  // Create: let $arr = iterable
  let arrLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(arrName),
    init: loweredIterable,
  }
  lowerer.origin[arrLetNode.id] = node.id

  // Create: len($arr)
  let lenCallNode = .{
    type: "Call",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    callee: makeIdent("len"),
    args: [makeIdent(arrName)],
  }
  lowerer.origin[lenCallNode.id] = node.id

  // Create: let $len = len($arr)
  let lenLetNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(lenName),
    init: lenCallNode,
  }
  lowerer.origin[lenLetNode.id] = node.id

  // Build the inner loop body expressions
  let innerBodyExprs = []

  // Add: let valueBinder = $arr[$i] (if valueBinder is not "_")
  if node.valueBinder != "_" {
    let indexExpr = .{
      type: "Index",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      object: makeIdent(arrName),
      index: makeIdent(idxName),
    }
    lowerer.origin[indexExpr.id] = node.id

    let valueLetNode = .{
      type: "Let",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.valueBinder),
      init: indexExpr,
    }
    lowerer.origin[valueLetNode.id] = node.id
    push(innerBodyExprs, valueLetNode)
  }

  // Add: let indexBinder = $i (if indexBinder is present and not "_")
  if node.indexBinder and node.indexBinder != "_" {
    let indexLetNode = .{
      type: "Let",
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.indexBinder),
      init: makeIdent(idxName),
    }
    lowerer.origin[indexLetNode.id] = node.id
    push(innerBodyExprs, indexLetNode)
  }

  // Create: array_append($result, body) intrinsic
  let arrayAppendNode = .{
    type: "IntrinsicCall",
    intrinsic: "array_append",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [makeIdent(resultName), loweredBody],
  }
  lowerer.origin[arrayAppendNode.id] = node.id
  push(innerBodyExprs, arrayAppendNode)

  // Create the inner block for the for loop body
  let innerBlockNode = .{
    type: "Block",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: innerBodyExprs,
  }
  lowerer.origin[innerBlockNode.id] = node.id

  // Create: let $i = 0
  let initNode = .{
    type: "Let",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(idxName),
    init: makeNumber(0),
  }
  lowerer.origin[initNode.id] = node.id

  // Create: $i < $len
  let conditionNode = .{
    type: "Binary",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.LESS,
      lexeme: "<",
      line: node.line,
      col: node.col,
    },
    right: makeIdent(lenName),
  }
  lowerer.origin[conditionNode.id] = node.id

  // Create: $i = $i + 1
  let addNode = .{
    type: "Binary",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.PLUS,
      lexeme: "+",
      line: node.line,
      col: node.col,
    },
    right: makeNumber(1),
  }
  lowerer.origin[addNode.id] = node.id

  let updateNode = .{
    type: "Assignment",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    target: makeIdent(idxName),
    value: addNode,
  }
  lowerer.origin[updateNode.id] = node.id

  // Create the for loop
  let forNode = .{
    type: "For",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: initNode,
    condition: conditionNode,
    update: updateNode,
    body: innerBlockNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Create the outer block: { let $result = []; let $arr = ...; let $len = ...; for ...; $result }
  let outerBlockNode = .{
    type: "Block",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [resultLetNode, arrLetNode, lenLetNode, forNode, makeIdent(resultName)],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerReturn(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  if node.value {
    newNode.value = lowerExpr(lowerer, node.value)
  }
  newNode
}

fn lowerBreak(lowerer, node) {
  copyNodeShallow(lowerer, node)
}

fn lowerContinue(lowerer, node) {
  // Continue has no children, just copy
  copyNodeShallow(lowerer, node)
}

fn lowerArray(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredElements = []
  for let i = 0; i < len(node.elements); i = i + 1 {
    push(loweredElements, lowerExpr(lowerer, node.elements[i]))
  }
  newNode.elements = loweredElements

  newNode
}

fn lowerHashmap(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredPairs = []
  for let i = 0; i < len(node.pairs); i = i + 1 {
    let pair = node.pairs[i]
    let loweredPair = .{
      key: lowerExpr(lowerer, pair.key),
      value: lowerExpr(lowerer, pair.value),
    }
    push(loweredPairs, loweredPair)
  }
  newNode.pairs = loweredPairs

  newNode
}

fn lowerIndex(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.object = lowerExpr(lowerer, node.object)
  newNode.index = lowerExpr(lowerer, node.index)
  newNode
}

fn lowerDot(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.object = lowerExpr(lowerer, node.object)
  // property is a StringKey node, needs lowering
  newNode.property = lowerExpr(lowerer, node.property)
  newNode
}

fn lowerAssignment(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.target = lowerExpr(lowerer, node.target)
  newNode.value = lowerExpr(lowerer, node.value)
  newNode
}

fn lowerImport(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  // Lower the path (String node)
  newNode.path = lowerExpr(lowerer, node.path)
  // Preserve resolver-attached module info for downstream phases
  if node.importResult {
    newNode.importResult = node.importResult
  }
  newNode
}

// ========================================
// Main Expression Dispatcher
// ========================================

fn lowerExpr(lowerer, node) {
  if !node { return nil }

  if node.type == "Arrow" {
    return lowerArrow(lowerer, node)
  } else if node.type == "If" {
    return lowerIf(lowerer, node)
  } else if node.type == "Binary" {
    return lowerBinary(lowerer, node)
  } else if node.type == "Unary" {
    return lowerUnary(lowerer, node)
  } else if node.type == "Logical" {
    return lowerLogical(lowerer, node)
  } else if node.type == "Grouping" {
    return lowerGrouping(lowerer, node)
  } else if node.type == "Let" {
    return lowerLet(lowerer, node)
  } else if node.type == "Block" {
    return lowerBlock(lowerer, node)
  } else if node.type == "Function" {
    return lowerFunction(lowerer, node)
  } else if node.type == "Call" {
    return lowerCall(lowerer, node)
  } else if node.type == "For" {
    return lowerFor(lowerer, node)
  } else if node.type == "ForIn" {
    return lowerForIn(lowerer, node)
  } else if node.type == "Collect" {
    return lowerCollect(lowerer, node)
  } else if node.type == "CollectIn" {
    return lowerCollectIn(lowerer, node)
  } else if node.type == "Return" {
    return lowerReturn(lowerer, node)
  } else if node.type == "Break" {
    return lowerBreak(lowerer, node)
  } else if node.type == "Continue" {
    return lowerContinue(lowerer, node)
  } else if node.type == "Array" {
    return lowerArray(lowerer, node)
  } else if node.type == "Hashmap" {
    return lowerHashmap(lowerer, node)
  } else if node.type == "Index" {
    return lowerIndex(lowerer, node)
  } else if node.type == "Dot" {
    return lowerDot(lowerer, node)
  } else if node.type == "Assignment" {
    return lowerAssignment(lowerer, node)
  } else if node.type == "Import" {
    return lowerImport(lowerer, node)
  } else if node.type == "Number" or node.type == "String" or
            node.type == "Bool" or node.type == "Nil" or
            node.type == "Identifier" {
    return lowerLeaf(lowerer, node)
  } else {
    // Unknown node type - this should never happen if parser is correct
    addError(lowerer, node.id, "Unknown node type in lowering: " + node.type)
    return node
  }
}

// ========================================
// Main API
// ========================================
// lower(ast, opts) → {
//   success: bool,
//   ast: BlockNode,             // Lowered AST (no Arrow nodes)
//   origin: { newId → oldId },  // Provenance map
//   errors: [{ nodeId, message, severity }],
//   nextNodeId: number,         // For next phase to continue
// }
//
// opts: {
//   startNodeId: number,  // Where to start fresh IDs (from parseResult.nextNodeId)
// }
fn lower(ast, opts) {
  let lowerer = .{
    nextId: opts.startNodeId or 1,  // Continue module ID sequence
    origin: .{},                     // newId → oldId mapping
    errors: [],                      // Lowering errors
    filename: ast.filename,          // For creating new nodes
  }

  let loweredAst = lowerExpr(lowerer, ast)

  .{
    success: len(lowerer.errors) == 0,
    ast: loweredAst,
    origin: lowerer.origin,
    errors: lowerer.errors,
    nextNodeId: lowerer.nextId,
  }
}

lower
