let suite = (import "test/makeTestSuite.lx")()
fn test(name, cb) { suite.defineTest("globals - " + name, cb) }

test("each", fn(assert) {
  let a = 0
  range(10)->each(fn() { a = a + 1 })
  assert.equal(a, 10)
})

test("contains", fn(assert) {
  assert.equal(contains([], "foo"), false)
  assert.equal(contains(["foo"], "foo"), true)
  assert.equal(contains(range(10), 9), true)
  assert.equal(contains(range(10), 10), false)
  assert.equal(contains("asdf", "d"), true)
  assert.equal(contains("1234", 1), false)
  assert.equal(contains("kkthx", nil), false)
  assert.equal(contains("asdf", ""), true)
  assert.equal(contains("asdf", "as"), true)
  assert.equal(contains("asdf", "sd"), true)

  let helloWorldZh = "你好世界"
  assert.equal(contains(helloWorldZh, ""), true)
  assert.equal(contains(helloWorldZh, "好"), true)
  assert.equal(contains(helloWorldZh, "好世"), true)
  assert.equal(contains(helloWorldZh, "我"), false)
  each(helloWorldZh, fn(c) {
    assert.equal(contains(helloWorldZh, c), false)
  })
})

test("startsWith", fn(assert) {
  assert.truthy(startsWith("asdf", "as"))
  assert.truthy(startsWith("asdf", ""))
  assert.truthy(startsWith("asdf", "asdf"))
  assert.truthy(!startsWith("asdf", "asdfx"))
  assert.truthy(!startsWith("asdf", "1"))
  assert.truthy(!startsWith("asdf", "1"))
  // no implicitly conversion
  assert.truthy(!startsWith(0, nil))
  assert.truthy(!startsWith(1, nil))
  assert.truthy(!startsWith(123, 123))
})

test("Date", fn(assert) {
  let now = Date.now()
  assert.equal(type(Date.RFC3339), "string")
  assert.equal(Date.format(now, Date.RFC3339)->type(), "string")

  let format = "%Y-%m-%d %H:%M"
  let y2ks = "2000-01-01 00:00"
  let y2k = Date.parse(y2ks, format)
  assert.equal(Date.format(y2k, format), y2ks)
})

test("Date.format optional format", fn(assert) {
  let now = Date.now()
  assert.equal(Date.format(now, Date.RFC3339), Date.format(now))
})

test("min/max", fn(assert) {
  assert.equal(min(1, 2), 1)
  assert.equal(min(2, 2), 2)
  assert.equal(min(2, 1), 1)

  assert.equal(max(1, 2), 2)
  assert.equal(max(2, 2), 2)
  assert.equal(max(2, 1), 2)
})

test("sort", fn(assert) {
  let arr = [4, 1, 3, 0, 2]
  let sorted = arr->sort(fn(a, b) { return a < b })
  range(5)->each(fn(i) {
    assert.equal(sorted[i], i)
  })
})

test("split", fn(assert) {
  let s = "okay\nfoo\nbar"
  // handle empty string
  assert.equal(split(s, "")->len(), 12)
  assert.equal(split(s, "")->join(""), s)

  // handle 1 char sep
  assert.equal(split(s, "\n")->len(), 3)
  assert.equal(split(s, "\n")[0], "okay")

  // handle multiple chars sep
  assert.equal(split(s, "foo")->len(), 2)
  assert.equal(split(s, "foo")[0], "okay\n")
})

test("substr", fn(assert) {
  assert.equal(substr("abcdef", 0, 3), "abc")
  assert.equal(substr("abcdef", 2, 10), "cdef")
  assert.equal(substr("abcdef", 100, 3), "")
  assert.equal(substr("abcdef", 2, 0), "")
  assert.equal(substr("abcdef", 2, -1), "")
  // Out-of-bounds indices clamp/truncate instead of erroring.
  assert.equal(substr("abcdef", 1000000000000, 3), "")
  assert.equal(substr("abcdef", 2, 1000000000000), "cdef")
})

suite.run()
