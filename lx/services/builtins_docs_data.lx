// Generated by scripts/gen-builtin-docs.lx. Do not edit by hand.

let DOCS = .{
  ["Lx.pcall"]: .{
    name: "Lx.pcall",
    signature: "Lx.pcall(fn: fn, ...args) -> {ok,value,error}",
    description: "calls a function and captures runtime errors instead of aborting.",
    markdown: "`Lx.pcall(fn: fn, ...args) -> {ok,value,error}`\ncalls a function and captures runtime errors instead of aborting.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readAll"]: .{
    name: "Lx.stdin.readAll",
    signature: "Lx.stdin.readAll() -> string",
    description: nil,
    markdown: "`Lx.stdin.readAll() -> string`",
    source: "lx/README.md",
  },
  ["Lx.path.join"]: .{
    name: "Lx.path.join",
    signature: "Lx.path.join(...segments: string) -> string",
    description: nil,
    markdown: "`Lx.path.join(...segments: string) -> string`",
    source: "lx/README.md",
  },
  ["Lx.fs.exists"]: .{
    name: "Lx.fs.exists",
    signature: "Lx.fs.exists(path: string) -> bool",
    description: nil,
    markdown: "`Lx.fs.exists(path: string) -> bool`",
    source: "lx/README.md",
  },
  ["Lx.fs"]: .{
    name: "Lx.fs",
    signature: "Lx.fs",
    description: ": filesystem helpers:",
    markdown: "`Lx.fs`\n: filesystem helpers:",
    source: "lx/README.md",
  },
  ["Lx.stdout"]: .{
    name: "Lx.stdout",
    signature: "Lx.stdout",
    description: ": stdout helpers (native builds):",
    markdown: "`Lx.stdout`\n: stdout helpers (native builds):",
    source: "lx/README.md",
  },
  ["Lx.fs.cwd"]: .{
    name: "Lx.fs.cwd",
    signature: "Lx.fs.cwd() -> string",
    description: nil,
    markdown: "`Lx.fs.cwd() -> string`",
    source: "lx/README.md",
  },
  ["spit"]: .{
    name: "spit",
    signature: "spit(path: string, content: string) -> true",
    description: "writes a file.",
    markdown: "`spit(path: string, content: string) -> true`\nwrites a file.",
    source: "lx/README.md",
  },
  ["Lx.stdin"]: .{
    name: "Lx.stdin",
    signature: "Lx.stdin",
    description: ": stdin helpers (native builds):",
    markdown: "`Lx.stdin`\n: stdin helpers (native builds):",
    source: "lx/README.md",
  },
  ["Lx.path.dirname"]: .{
    name: "Lx.path.dirname",
    signature: "Lx.path.dirname(path: string) -> string",
    description: nil,
    markdown: "`Lx.path.dirname(path: string) -> string`",
    source: "lx/README.md",
  },
  ["Lx.fs.realpath"]: .{
    name: "Lx.fs.realpath",
    signature: "Lx.fs.realpath(path: string) -> string | nil",
    description: nil,
    markdown: "`Lx.fs.realpath(path: string) -> string | nil`",
    source: "lx/README.md",
  },
  ["Lx.fs.stat"]: .{
    name: "Lx.fs.stat",
    signature: "Lx.fs.stat(path: string) -> map | nil",
    description: "(e.g. `.{type,size,mtime,mode}`)",
    markdown: "`Lx.fs.stat(path: string) -> map | nil`\n(e.g. `.{type,size,mtime,mode}`)",
    source: "lx/README.md",
  },
  ["Lx.version"]: .{
    name: "Lx.version",
    signature: "Lx.version: string",
    description: "runtime version string.",
    markdown: "`Lx.version: string`\nruntime version string.",
    source: "lx/README.md",
  },
  ["Lx.env"]: .{
    name: "Lx.env",
    signature: "Lx.env: map[string]string",
    description: "environment variables.",
    markdown: "`Lx.env: map[string]string`\nenvironment variables.",
    source: "lx/README.md",
  },
  ["Lx.loadObj"]: .{
    name: "Lx.loadObj",
    signature: "Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn",
    description: "loads an lxobj and returns a callable closure.",
    markdown: "`Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn`\nloads an lxobj and returns a callable closure.",
    source: "lx/README.md",
  },
  ["Lx.stdout.flush"]: .{
    name: "Lx.stdout.flush",
    signature: "Lx.stdout.flush() -> nil",
    description: nil,
    markdown: "`Lx.stdout.flush() -> nil`",
    source: "lx/README.md",
  },
  ["Lx.isLxObj"]: .{
    name: "Lx.isLxObj",
    signature: "Lx.isLxObj(bytes: string | array[number]) -> bool",
    description: "checks whether a byte buffer looks like an lxobj.",
    markdown: "`Lx.isLxObj(bytes: string | array[number]) -> bool`\nchecks whether a byte buffer looks like an lxobj.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readLine"]: .{
    name: "Lx.stdin.readLine",
    signature: "Lx.stdin.readLine(prompt?: string) -> string | nil",
    description: nil,
    markdown: "`Lx.stdin.readLine(prompt?: string) -> string | nil`",
    source: "lx/README.md",
  },
  ["Lx"]: .{
    name: "Lx",
    signature: "Lx",
    description: "namespace.",
    markdown: "`Lx`\nnamespace.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readBytes"]: .{
    name: "Lx.stdin.readBytes",
    signature: "Lx.stdin.readBytes(n: number) -> string | nil",
    description: nil,
    markdown: "`Lx.stdin.readBytes(n: number) -> string | nil`",
    source: "lx/README.md",
  },
  ["Lx.path"]: .{
    name: "Lx.path",
    signature: "Lx.path",
    description: ": path helpers:",
    markdown: "`Lx.path`\n: path helpers:",
    source: "lx/README.md",
  },
  ["slurp"]: .{
    name: "slurp",
    signature: "slurp(path: string) -> string",
    description: "reads a file.",
    markdown: "`slurp(path: string) -> string`\nreads a file.",
    source: "lx/README.md",
  },
  ["Lx.error"]: .{
    name: "Lx.error",
    signature: "Lx.error(message: string) -> never",
    description: "raises a runtime error (caught by `Lx.pcall`).",
    markdown: "`Lx.error(message: string) -> never`\nraises a runtime error (caught by `Lx.pcall`).",
    source: "lx/README.md",
  },
  ["Lx.args"]: .{
    name: "Lx.args",
    signature: "Lx.args: array[string]",
    description: "CLI args.",
    markdown: "`Lx.args: array[string]`\nCLI args.",
    source: "lx/README.md",
  },
}

let NATIVE_NAMES = .{
  ["int"]: true,
  ["Lx.pcall"]: true,
  ["Lx.stdin.readAll"]: true,
  ["Lx.path.join"]: true,
  ["Lx.fs.exists"]: true,
  ["spit"]: true,
  ["chr"]: true,
  ["read"]: true,
  ["lines"]: true,
  ["split"]: true,
  ["groanln"]: true,
  ["Lx.fs.realpath"]: true,
  ["Lx.fs.stat"]: true,
  ["str"]: true,
  ["Lx.loadObj"]: true,
  ["Lx.stdout.flush"]: true,
  ["type"]: true,
  ["toupper"]: true,
  ["Lx.isLxObj"]: true,
  ["Lx.doubleToUint8Array"]: true,
  ["slurp"]: true,
  ["push"]: true,
  ["print"]: true,
  ["Date.parse"]: true,
  ["range"]: true,
  ["join"]: true,
  ["len"]: true,
  ["tonumber"]: true,
  ["Lx.error"]: true,
  ["groan"]: true,
  ["println"]: true,
  ["Date.time"]: true,
  ["Lx.fs.cwd"]: true,
  ["exec"]: true,
  ["getline"]: true,
  ["keys"]: true,
  ["sqrt"]: true,
  ["Date.format"]: true,
  ["Lx.path.dirname"]: true,
  ["concat"]: true,
  ["nameOf"]: true,
  ["Lx.globals"]: true,
  ["ord"]: true,
  ["tolower"]: true,
  ["Lx.stdin.readLine"]: true,
  ["putc"]: true,
  ["Lx.stdin.readBytes"]: true,
  ["system"]: true,
  ["Lx.exit"]: true,
  ["pop"]: true,
  ["random"]: true,
}

.{
  DOCS,
  NATIVE_NAMES,
}
