// Query Service - Position-based IDE queries over compiler artifacts
//
// Provides hover (type at position) and goto definition (jump to declaration)
// for editor tooling integration.
//
// Read-only: no inference, no unification, just table lookups + span selection.

// ========================================
// Helpers
// ========================================

fn rangeOf(n) {
  .{
    filename: n.filename,
    line: n.line,
    col: n.col,
    endLine: n.endLine,
    endCol: n.endCol,
  }
}

// ========================================
// Indexing
// ========================================

fn collectAllNodes(node, nodes) {
  if type(node) != "map" { return }

  nodes[node.id] = node

  // Traverse common node fields
  if node.name { collectAllNodes(node.name, nodes) }
  if node.init { collectAllNodes(node.init, nodes) }
  if node.value { collectAllNodes(node.value, nodes) }
  if node.left { collectAllNodes(node.left, nodes) }
  if node.right { collectAllNodes(node.right, nodes) }
  if node.operand { collectAllNodes(node.operand, nodes) }
  if node.callee { collectAllNodes(node.callee, nodes) }
  if node.object { collectAllNodes(node.object, nodes) }
  if node.property { collectAllNodes(node.property, nodes) }
  if node.index { collectAllNodes(node.index, nodes) }
  if node.target { collectAllNodes(node.target, nodes) }
  if node.test { collectAllNodes(node.test, nodes) }
  if node.then { collectAllNodes(node.then, nodes) }
  if node.else { collectAllNodes(node.else, nodes) }
  if node.condition { collectAllNodes(node.condition, nodes) }

  // Traverse arrays
  if node.params and type(node.params) == "array" {
    for let i = 0; i < len(node.params); i = i + 1 {
      collectAllNodes(node.params[i], nodes)
    }
  }
  if node.args and type(node.args) == "array" {
    for let i = 0; i < len(node.args); i = i + 1 {
      collectAllNodes(node.args[i], nodes)
    }
  }
  if node.elements and type(node.elements) == "array" {
    for let i = 0; i < len(node.elements); i = i + 1 {
      collectAllNodes(node.elements[i], nodes)
    }
  }
  if node.pairs and type(node.pairs) == "array" {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let pair = node.pairs[i]
      collectAllNodes(pair.key, nodes)
      collectAllNodes(pair.value, nodes)
    }
  }
  if node.expressions and type(node.expressions) == "array" {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      collectAllNodes(node.expressions[i], nodes)
    }
  }
  if node.body and type(node.body) == "array" {
    for let i = 0; i < len(node.body); i = i + 1 {
      collectAllNodes(node.body[i], nodes)
    }
  }
}

fn buildFileIndex(ctx) {
  each(keys(ctx.nodes), fn(id) {
    let n = ctx.nodes[id]
    if !n or !n.filename {
      return
    }

    let fname = n.filename
    if !ctx.fileNodeIds[fname] {
      ctx.fileNodeIds[fname] = []
    }
    push(ctx.fileNodeIds[fname], id)
  })
}

// ========================================
// Node Selection
// ========================================

fn contains(n, line, col) {
  if line < n.line or line > n.endLine {
    return false
  }
  if line == n.line and col < n.col {
    return false
  }
  if line == n.endLine and col >= n.endCol {
    return false
  }
  true
}

fn spanScore(n) {
  (n.endLine - n.line) * 100000 + (n.endCol - n.col)
}

fn nodeAtPos(ctx, filename, line, col) {
  let ids = ctx.fileNodeIds[filename] or keys(ctx.nodes)

  let best = nil
  let bestScore = nil

  each(ids, fn(id) {
    let n = ctx.nodes[id]
    if !n or n.filename != filename {
      return
    }
    if !contains(n, line, col) {
      return
    }

    let s = spanScore(n)
    // Prefer smaller span, or if tied, prefer larger ID (more specific/nested node)
    // Also skip Program nodes if we have alternatives
    if !best or s < bestScore or (s == bestScore and n.id > best.id) {
      best = n
      bestScore = s
    }
  })

  best
}

// ========================================
// Goto Definition Normalization
// ========================================

fn normalizeDeclTarget(ctx, declNodeId) {
  let decl = ctx.nodes[declNodeId]
  if !decl {
    return nil
  }

  // If resolver stored the Function node id for named functions,
  // prefer jumping to the name identifier span when available.
  if decl.type == "Function" and decl.name and decl.name.id {
    let nameNode = ctx.nodes[decl.name.id]
    if nameNode {
      return nameNode
    }
  }

  // Otherwise use the node itself (Identifier bindings already land perfectly)
  decl
}

// ========================================
// Type Formatting
// ========================================

fn formatType(ty) {
  if !ty {
    return "Unknown"
  }

  let kind = ty.kind

  // Primitives
  if kind == "Number" { return "Number" }
  if kind == "String" { return "String" }
  if kind == "Bool" { return "Bool" }
  if kind == "Nil" { return "Nil" }
  if kind == "Any" { return "Any" }
  if kind == "Unknown" { return "Unknown" }

  // TypeVar - show as T<id> for now
  if kind == "TypeVar" {
    return "T" + str(ty.id)
  }

  // Array
  if kind == "Array" {
    return "Array<" + formatType(ty.elem) + ">"
  }

  // Option
  if kind == "Option" {
    return "Option<" + formatType(ty.inner) + ">"
  }

  // Map
  if kind == "Map" {
    return "Map<" + formatType(ty.key) + ", " + formatType(ty.value) + ">"
  }

  // Function
  if kind == "Function" {
    let params = ty.params
    let paramStrs = []
    for let i = 0; i < len(params); i = i + 1 {
      push(paramStrs, formatType(params[i]))
    }
    let paramStr = join(paramStrs, ", ")
    return "fn(" + paramStr + ") -> " + formatType(ty.return)
  }

  // Record - check field count for expansion
  if kind == "Record" {
    let fields = ty.fields
    let fieldNames = keys(fields)
    let fieldCount = len(fieldNames)

    // Small records: expand inline
    if fieldCount <= 6 {
      let fieldStrs = []
      for let i = 0; i < fieldCount; i = i + 1 {
        let fname = fieldNames[i]
        push(fieldStrs, fname + ": " + formatType(fields[fname]))
      }
      return ".{ " + join(fieldStrs, ", ") + " }"
    }

    // Large records: collapse
    return ".{ ... }"
  }

  // Tagged unions
  if kind == "Tagged" {
    let tagField = ty.tagField
    let cases = ty.cases
    let caseNames = keys(cases)
    return tagField + "(" + join(caseNames, " | ") + ")"
  }

  // RecordTop, LenableTop (constraint types)
  if kind == "RecordTop" { return "Record" }
  if kind == "LenableTop" { return "Lenable" }

  // Scheme (polymorphic type schemes)
  if kind == "Scheme" {
    return formatType(ty.type)
  }

  // Fallback
  "(" + kind + ")"
}

fn formatTypeWithBindings(ctx, ty) {
  fn fmt(t, seen) {
    if !t {
      return "Unknown"
    }

    let kind = t.kind

    if kind == "TypeVar" {
      let id = t.id
      if ctx.typeVarBindings and id and !seen[id] {
        let binding = ctx.typeVarBindings[id]
        if binding {
          seen[id] = true
          return fmt(binding, seen)
        }
      }
      // Unbound type var
      return "Unbound T" + str(id)
    }

    if kind == "Array" {
      return "Array<" + fmt(t.elem, seen) + ">"
    }
    if kind == "Option" {
      return "Option<" + fmt(t.inner, seen) + ">"
    }
    if kind == "Map" {
      return "Map<" + fmt(t.key, seen) + ", " + fmt(t.value, seen) + ">"
    }
    if kind == "Function" {
      let params = t.params
      let paramStrs = []
      for let i = 0; i < len(params); i = i + 1 {
        push(paramStrs, fmt(params[i], seen))
      }
      return "fn(" + join(paramStrs, ", ") + ") -> " + fmt(t.return, seen)
    }
    if kind == "Record" {
      let fields = t.fields
      let fieldNames = keys(fields)
      let fieldCount = len(fieldNames)

      if fieldCount <= 6 {
        let fieldStrs = []
        for let i = 0; i < fieldCount; i = i + 1 {
          let fname = fieldNames[i]
          push(fieldStrs, fname + ": " + fmt(fields[fname], seen))
        }
        return ".{ " + join(fieldStrs, ", ") + " }"
      }
      return ".{ ... }"
    }
    if kind == "Tagged" {
      let tagField = t.tagField
      let cases = t.cases
      let caseNames = keys(cases)
      return tagField + "(" + join(caseNames, " | ") + ")"
    }
    if kind == "RecordTop" { return "Record" }
    if kind == "LenableTop" { return "Lenable" }
    if kind == "Scheme" { return fmt(t.type, seen) }
    if kind == "Number" { return "Number" }
    if kind == "String" { return "String" }
    if kind == "Bool" { return "Bool" }
    if kind == "Nil" { return "Nil" }
    if kind == "Any" { return "Any" }
    if kind == "Unknown" { return "Unknown" }

    "(" + kind + ")"
  }

  fmt(ty, .{})
}

// Given a string key node inside a record literal, return the value's type if known.
fn valueTypeForRecordKey(ctx, keyNode) {
  if !keyNode or !keyNode.id {
    return nil
  }

  let fname = keyNode.filename
  let ids = ctx.fileNodeIds[fname] or keys(ctx.nodes)

  for let i = 0; i < len(ids); i = i + 1 {
    let cand = ctx.nodes[ids[i]]
    if !cand or cand.type != "Hashmap" or cand.filename != fname {
      continue
    }

    if !cand.pairs or type(cand.pairs) != "array" {
      continue
    }

    for let j = 0; j < len(cand.pairs); j = j + 1 {
      let pair = cand.pairs[j]
      if pair.key and pair.key.id == keyNode.id {
        if pair.value {
          return ctx.types[pair.value.id]
        }
      }
    }
  }

  nil
}

// Build richer hover payload: always include formatted type, and when possible,
// attach symbol resolution + declaration info for identifiers.
fn buildSymbolInfo(ctx, n) {
  if !n or n.type != "Identifier" {
    return nil
  }

  let info = .{ name: n.name or n.lexeme or "(anonymous)" }
  let r = ctx.resolvedNames[n.id]

  if !r {
    info.kind = "unresolved"
    return info
  }

  info.kind = r.kind

  if r.kind == "global" and r.name {
    info.globalName = r.name
  }

  if r.declaredAt {
    let declNode = ctx.nodes[r.declaredAt]
    if declNode {
      info.declaration = rangeOf(declNode)
      info.declarationNodeType = declNode.type

      let declType = ctx.types[declNode.id]
      if declType {
        info.declarationType = formatTypeWithBindings(ctx, declType)
      }
    }
  }

  info
}

fn buildHoverContents(ctx, n, ty) {
  // If hovering a record key, prefer the field's value type over the literal String type.
  if n.type == "String" {
    let fieldType = valueTypeForRecordKey(ctx, n)
    if fieldType {
      ty = fieldType
    }
  }

  let contents = .{ type: formatTypeWithBindings(ctx, ty) }
  let symbol = buildSymbolInfo(ctx, n)
  if symbol {
    contents.symbol = symbol
  }
  contents
}

// ========================================
// Public API
// ========================================

fn queryInit(ast, resolveResult, typecheckResult, opts) {
  // Start with resolver's nodes, then collect any missing nodes from AST
  let nodes = resolveResult.nodes
  collectAllNodes(ast, nodes)

  let ctx = .{
    ast: ast,
    nodes: nodes,
    resolvedNames: resolveResult.resolvedNames,
    types: typecheckResult.types,
    typeVarBindings: typecheckResult.typeVarBindings,
    fileNodeIds: .{},
  }

  let buildIndex = !(opts and opts.buildIndex == false)
  if buildIndex {
    buildFileIndex(ctx)
  }

  .{ success: true, ctx: ctx }
}

fn queryHover(ctx, filename, line, col) {
  let n = nodeAtPos(ctx, filename, line, col)
  if !n {
    return .{ success: false, kind: "hover", message: "No node at position" }
  }

  let ty = ctx.types[n.id]
  let contents = buildHoverContents(ctx, n, ty)

  let details = .{ nodeType: n.type, nodeId: n.id }

  if n.type == "Identifier" {
    let r = ctx.resolvedNames[n.id]
    if r {
      details.resolved = r
    }
  }

  .{
    success: true,
    kind: "hover",
    range: rangeOf(n),
    contents: contents,
    details: details,
  }
}

fn queryGotoDefinition(ctx, filename, line, col) {
  let n = nodeAtPos(ctx, filename, line, col)
  if !n {
    return .{ success: false, kind: "goto", message: "No node at position" }
  }

  if n.type != "Identifier" {
    return .{ success: false, kind: "goto", message: "Not an identifier" }
  }

  let r = ctx.resolvedNames[n.id]
  if !r {
    return .{ success: false, kind: "goto", message: "Unresolved identifier" }
  }

  if r.kind == "global" {
    return .{ success: false, kind: "goto", message: "Global has no tracked definition" }
  }

  let declNodeId = r.declaredAt
  if !declNodeId {
    return .{ success: false, kind: "goto", message: "Missing declaredAt (compiler bug)" }
  }

  let targetNode = normalizeDeclTarget(ctx, declNodeId)
  if !targetNode {
    return .{ success: false, kind: "goto", message: "Declaration node missing (compiler bug)" }
  }

  .{
    success: true,
    kind: "goto",
    target: rangeOf(targetNode),
  }
}

// ========================================
// High-Level API
// ========================================

let Driver = import "src/driver.lx"

// Compile file and create query context in one step
// This is the recommended API for IDE/LSP tooling
fn compile(filepath) {
  // Create driver that loads from filesystem
  let driver = Driver.make(.{
    loadSource: fn(path) { slurp(path) },
    withTypecheck: true,
  })

  // Compile module through full pipeline
  let result = driver.compileModule(filepath)

  // Check for compilation failure
  if result.status != "done" {
    let phase = "unknown"
    let errors = []

    if result.parseErrors {
      phase = "parse"
      errors = result.parseErrors
    } else if result.lowerErrors {
      phase = "lower"
      errors = result.lowerErrors
    } else if result.resolveResult and !result.resolveResult.success {
      phase = "resolve"
      errors = result.resolveResult.errors
    } else if result.typecheckResult and !result.typecheckResult.success {
      phase = "typecheck"
      errors = result.typecheckResult.errors
    }

    return .{
      success: false,
      phase: phase,
      errors: errors,
      compileResult: result,
    }
  }

  // Initialize query context
  let initResult = queryInit(
    result.lowerResult.ast,
    result.resolveResult,
    result.typecheckResult,
    .{ buildIndex: true }
  )

  if !initResult.success {
    return .{
      success: false,
      phase: "query",
      errors: ["Failed to initialize query context"],
      compileResult: result,
    }
  }

  // Return query context ready to use
  .{
    success: true,
    ctx: initResult.ctx,
    compileResult: result,
  }
}

// ========================================
// Module Exports
// ========================================

.{
  // High-level API (recommended)
  compile: compile,

  // Low-level API (for advanced use cases)
  queryInit: queryInit,
  queryHover: queryHover,
  queryGotoDefinition: queryGotoDefinition,
}
