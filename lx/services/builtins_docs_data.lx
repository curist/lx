// Generated by scripts/gen-builtin-docs.lx. Do not edit by hand.

let DOCS_TSV = "Date\tDate\truntime date/time namespace.\tlx/README.md\nDate.RFC3339\tDate.RFC3339: string\tDefault RFC3339 format string.\tlx/README.md\nDate.format\tDate.format(unix: number, format?: string) -> string\tFormat unix timestamp (milliseconds).\tlx/README.md\nDate.nanotime\tDate.nanotime() -> number\tCurrent unix timestamp (nanoseconds).\tlx/README.md\nDate.now\tDate.now() -> number\tCurrent unix timestamp (milliseconds).\tlx/README.md\nDate.parse\tDate.parse(s: string, format: string) -> number\tParse a date string, returns unix timestamp (milliseconds).\tlx/README.md\nLx\tLx\truntime namespace.\tlx/README.md\nLx.args\tLx.args: array[string]\tCLI args.\tlx/README.md\nLx.doubleToUint8Array\tLx.doubleToUint8Array(x: number) -> array[number]\tConvert a float64 to 8 bytes (little-endian).\tlx/README.md\nLx.env\tLx.env: map[string]string\tenvironment variables.\tlx/README.md\nLx.error\tLx.error(message: string) -> never\traises a runtime error (caught by `Lx.pcall`).\tlx/README.md\nLx.exit\tLx.exit(code?: number) -> never\tExit the process.\tlx/README.md\nLx.fs\tLx.fs\tfilesystem helpers namespace.\tlx/README.md\nLx.fs.cwd\tLx.fs.cwd() -> string\tCurrent working directory.\tlx/README.md\nLx.fs.exists\tLx.fs.exists(path: string) -> bool\tWhether a path exists.\tlx/README.md\nLx.fs.realpath\tLx.fs.realpath(path: string) -> string | nil\tResolve symlinks, or `nil` on failure.\tlx/README.md\nLx.fs.stat\tLx.fs.stat(path: string) -> map | nil\tFile metadata (e.g. `.{type,size,mtime,mode}`).\tlx/README.md\nLx.globals\tLx.globals() -> array[string | number]\tList current global keys.\tlx/README.md\nLx.isLxObj\tLx.isLxObj(bytes: string | array[number]) -> bool\tchecks whether a byte buffer looks like an lxobj.\tlx/README.md\nLx.loadObj\tLx.loadObj(bytes: string | array[number], printCode?: bool) -> fn\tloads an lxobj and returns a callable closure.\tlx/README.md\nLx.path\tLx.path\tpath helpers namespace.\tlx/README.md\nLx.path.dirname\tLx.path.dirname(path: string) -> string\tParent directory.\tlx/README.md\nLx.path.join\tLx.path.join(...segments: string) -> string\tJoin path segments.\tlx/README.md\nLx.pcall\tLx.pcall(fn: fn, ...args) -> {ok,value,error}\tcalls a function and captures runtime errors instead of aborting.\tlx/README.md\nLx.stdin\tLx.stdin\tstdin helpers namespace.\tlx/README.md\nLx.stdin.readAll\tLx.stdin.readAll() -> string\tRead all stdin.\tlx/README.md\nLx.stdin.readBytes\tLx.stdin.readBytes(n: number) -> string | nil\tRead up to `n` bytes from stdin.\tlx/README.md\nLx.stdin.readLine\tLx.stdin.readLine(prompt?: string) -> string | nil\tRead one line from stdin.\tlx/README.md\nLx.stdout\tLx.stdout\tstdout helpers namespace.\tlx/README.md\nLx.stdout.flush\tLx.stdout.flush() -> nil\tFlush stdout.\tlx/README.md\nLx.version\tLx.version: string\truntime version string.\tlx/README.md\n_1\t_1(cb: fn) -> fn\tWrap a callback as a unary function (ignores extra args).\tlx/README.md\n_2\t_2(cb: fn) -> fn\tWrap a callback as a binary function (ignores extra args).\tlx/README.md\nchr\tchr(code: number) -> string\tConvert a byte (0–255) to a 1-byte string.\tlx/README.md\nconcat\tconcat(a: array, b: array) -> array\tNew array with elements of `a` followed by `b`.\tlx/README.md\ncontains\tcontains(haystack: array | string, needle) -> bool\tMembership test for arrays/strings.\tlx/README.md\ndrop\tdrop(arr: array, n: number) -> array\tSuffix.\tlx/README.md\neach\teach(arr: array, cb: fn(x, i, arr, abort)) -> nil\tIterate; call `abort()` to stop early.\tlx/README.md\nendsWith\tendsWith(s: string, suffix: string) -> bool\tString suffix test.\tlx/README.md\nexec\texec(cmd: string) -> {code,out}\tRun a shell command and capture stdout.\tlx/README.md\nfilter\tfilter(arr: array, cb: fn(x, i, arr) -> bool) -> array\tFilter into a new array.\tlx/README.md\nfirst\tfirst(coll: array | string) -> any\tFirst element/char.\tlx/README.md\nfold\tfold(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any\tLeft fold.\tlx/README.md\nfoldr\tfoldr(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any\tRight fold.\tlx/README.md\ngetline\tgetline() -> string | nil\tRead one line from stdin (without trailing `\\n`), or `nil` on EOF.\tlx/README.md\ngroan\tgroan(...values) -> nil\tPrint values to stderr separated by spaces.\tlx/README.md\ngroanln\tgroanln(...values) -> nil\tPrint values to stderr separated by spaces and a trailing newline.\tlx/README.md\nint\tint(n: number) -> number\tTruncate a number toward zero.\tlx/README.md\njoin\tjoin(values: array, sep: string) -> string\tJoin stringified values with a separator.\tlx/README.md\nkeys\tkeys(x: map | enum) -> array[string]\tKeys/names.\tlx/README.md\nlast\tlast(coll: array | string) -> any\tLast element/char.\tlx/README.md\nlen\tlen(x: string | array) -> number\tLength of a string/array.\tlx/README.md\nlines\tlines(s: string) -> array[string]\tSplit by `\\n` (newline not included in lines).\tlx/README.md\nmap\tmap(arr: array, cb: fn(x, i, arr) -> y) -> array\tMap to a new array.\tlx/README.md\nmax\tmax(a, b) -> any\tMaximum of two values.\tlx/README.md\nmin\tmin(a, b) -> any\tMinimum of two values.\tlx/README.md\nnameOf\tnameOf(enum: enum, value: number | string) -> string | nil\tReverse lookup (value → name).\tlx/README.md\nord\tord(ch: string) -> number\tConvert a 1-character string to its byte value.\tlx/README.md\npop\tpop(arr: array) -> value | nil\tMutates `arr` by removing and returning the last element.\tlx/README.md\nprint\tprint(...values) -> nil\tPrint values to stdout separated by spaces.\tlx/README.md\nprintln\tprintln(...values) -> nil\tPrint values to stdout separated by spaces and a trailing newline.\tlx/README.md\npush\tpush(arr: array, value) -> array\tMutates `arr` by appending `value`.\tlx/README.md\nputc\tputc(...codes: number) -> nil\tWrite bytes/chars to stdout.\tlx/README.md\nrandom\trandom() -> number\tRandom float in `[0, 1)`.\tlx/README.md\nrange\trange(x: number | string | array | map | enum) -> array\tFor number: `[0..n-1]`; for string: chars; for map/enum: keys.\tlx/README.md\nread\tread(n: number) -> string | nil\tRead up to `n` bytes from stdin, or `nil` on EOF.\tlx/README.md\nslurp\tslurp(path: string) -> string\tRead a file.\tlx/README.md\nsort\tsort(arr: array, less: fn(a, b) -> bool) -> array\tStable-ish merge sort returning a new array.\tlx/README.md\nspit\tspit(path: string, content: string) -> true\tWrite a file.\tlx/README.md\nsplit\tsplit(s: string, sep: string) -> array[string]\tSplit by substring; when `sep == \"\"`, splits into chars.\tlx/README.md\nsqrt\tsqrt(n: number) -> number\tSquare root.\tlx/README.md\nstartsWith\tstartsWith(s: string, prefix: string) -> bool\tString prefix test.\tlx/README.md\nstr\tstr(value) -> string\tConvert a value to a string (uses runtime formatting).\tlx/README.md\nsubstr\tsubstr(s: string, start: number, length: number) -> string\tSubstring by byte offset; if `length <= 0`, returns `\"\"`.\tlx/README.md\nsystem\tsystem(cmd: string) -> number\tRun a shell command (inherits stdio), returning exit code.\tlx/README.md\ntake\ttake(arr: array, n: number) -> array\tPrefix.\tlx/README.md\ntolower\ttolower(s: string) -> string\tLowercase ASCII.\tlx/README.md\ntonumber\ttonumber(s: string) -> number\tParse a string to a number (float).\tlx/README.md\ntoupper\ttoupper(s: string) -> string\tUppercase ASCII.\tlx/README.md\ntype\ttype(x) -> string\tOne of `nil|boolean|number|fn|string|enum|map|array`.\tlx/README.md"
let NATIVE_NAMES_LIST = "Date.format\nDate.nanotime\nDate.now\nDate.parse\nLx.doubleToUint8Array\nLx.error\nLx.exit\nLx.fs.cwd\nLx.fs.exists\nLx.fs.realpath\nLx.fs.stat\nLx.globals\nLx.isLxObj\nLx.loadObj\nLx.path.dirname\nLx.path.join\nLx.pcall\nLx.stdin.readAll\nLx.stdin.readBytes\nLx.stdin.readLine\nLx.stdout.flush\nchr\nconcat\nexec\ngetline\ngroan\ngroanln\nint\njoin\nkeys\nlen\nlines\nnameOf\nord\npop\nprint\nprintln\npush\nputc\nrandom\nrange\nread\nslurp\nspit\nsplit\nsqrt\nstr\nsubstr\nsystem\ntolower\ntonumber\ntoupper\ntype"
let PRELUDE_NAMES_LIST = "_1\n_2\ncontains\ndrop\neach\nendsWith\nfilter\nfirst\nfold\nfoldr\nlast\nmap\nmax\nmin\nsort\nstartsWith\ntake"

.{
  DOCS_TSV,
  NATIVE_NAMES_LIST,
  PRELUDE_NAMES_LIST,
}
