// Typecheck Phase Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"
let typecheck = import "src/typecheck.lx"
let Driver = import "src/driver.lx"

// Type helpers
fn deref(result, t) {
  if t and t.kind == "TypeVar" {
    let bindings = result.typeVarBindings or .{}
    let bound = bindings[t.id]
    if bound { return deref(result, bound) }
  }
  t
}

fn hasError(result, needle) {
  for let i = 0; i < len(result.errors); i = i + 1 {
    if result.errors[i].message == needle { return true }
  }
  false
}

// Helper: parse → lower → resolve → typecheck
fn parseAndTypecheck(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, phase: "parse", parseErrors: parseResult.errors }
  }

  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, phase: "lower", lowerErrors: lowerResult.errors }
  }

  let resolveResult = resolve(lowerResult.ast, .{})
  if !resolveResult.success {
    return .{ success: false, phase: "resolve", resolveErrors: resolveResult.errors }
  }

  let typecheckResult = typecheck(lowerResult.ast, resolveResult, .{})
  .{
    success: typecheckResult.success,
    phase: "typecheck",
    types: typecheckResult.types,
    typeVarBindings: typecheckResult.typeVarBindings,
    errors: typecheckResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}
fn normalizeExprList(ast) {
  if !ast { return nil }

  // Program → Block → expressions
  if ast.type == "Program" and ast.body {
    if len(ast.body) == 1 and ast.body[0].type == "Block" and ast.body[0].expressions {
      return ast.body[0].expressions
    }
    return ast.body
  }

  // Block → expressions
  if ast.type == "Block" and ast.expressions {
    return ast.expressions
  }

  // Legacy container
  if ast.body {
    return ast.body
  }

  if ast.type {
    return [ast]
  }

  nil
}

// Helper: Get type of expression in test block
fn getExprType(result, exprIndex) {
  let ast = result.lowerResult.ast
  let exprs = normalizeExprList(ast)
  if !exprs or exprIndex >= len(exprs) { return nil }

  let node = exprs[exprIndex]

  if node.type == "ExprStmt" and node.expr { node = node.expr }

  if node.type == "Let" and node.name {
    return result.types[node.name.id]
  }

  result.types[node.id]
}

// Helper: Get the actual AST node at an index
fn getExprNode(result, exprIndex) {
  let ast = result.lowerResult.ast
  let exprs = normalizeExprList(ast)
  if !exprs or exprIndex >= len(exprs) { return nil }

  let node = exprs[exprIndex]
  if node.type == "ExprStmt" and node.expr { return node.expr }
  node
}

// Find the first Import node in a program AST (simple helper for tests)
fn findFirstImport(ast) {
  for let i = 0; i < len(ast.body); i = i + 1 {
    let expr = ast.body[i]
    if expr.type == "Import" {
      return expr
    }
    if expr.type == "Let" and expr.init and expr.init.type == "Import" {
      return expr.init
    }
  }
  nil
}

test("typecheck - let with number (phase1)", fn(assert) {
  let result = parseAndTypecheck("let x = 42")
  let ty = getExprType(result, 0)
  assert.truthy(ty)
  // If Phase 1 binds init type to name, keep:
  assert.equal(ty.kind, "TypeVar")
  // assert.equal(ty.kind, "Number")
})

test("typecheck - variable reference (phase1)", fn(assert) {
  let result = parseAndTypecheck("{ let x = 42\nx }")
  let ty = getExprType(result, 1)
  assert.truthy(ty)
})

test("phase1 - literals and arithmetic", fn(assert) {
  let result = parseAndTypecheck("{ 1 \"s\" 1 + 2 }")
  let numT = deref(result, getExprType(result, 0))
  let strT = deref(result, getExprType(result, 1))
  let addT = deref(result, getExprType(result, 2))
  assert.equal(numT.kind, "Number")
  assert.equal(strT.kind, "String")
  assert.equal(addT.kind, "Number")
})

test("phase1 - invalid arithmetic reports error", fn(assert) {
  let result = parseAndTypecheck("1 + \"x\"")
  assert.truthy(hasError(result, "Expected number"))
})

test("phase1 - let without initializer stays unknown", fn(assert) {
  let result = parseAndTypecheck("{ let x\nx }")
  let t = getExprType(result, 1)
  assert.truthy(t)
  assert.equal(deref(result, t).kind, "TypeVar")
})

test("phase1 - function definition only remains unknown", fn(assert) {
  let result = parseAndTypecheck("fn f(x) { x }")
  let fnT = deref(result, getExprType(result, 0))
  assert.equal(fnT.kind, "Function")
  assert.equal(deref(result, fnT.params[0]).kind, "TypeVar")
  assert.equal(deref(result, fnT.return).kind, "TypeVar")
})

test("phase1 - function constrained by call", fn(assert) {
  let result = parseAndTypecheck("{ fn add(a, b) { a + b }\nadd(1, 2) }")
  let fnT = deref(result, getExprType(result, 0))
  let callT = deref(result, getExprType(result, 1))
  assert.equal(fnT.kind, "Function")
  assert.equal(deref(result, fnT.params[0]).kind, "Number")
  assert.equal(deref(result, fnT.params[1]).kind, "Number")
  assert.equal(deref(result, fnT.return).kind, "Number")
  assert.equal(callT.kind, "Number")
})

test("phase1 - wrong argument type surfaces error", fn(assert) {
  let result = parseAndTypecheck("{ fn add(a, b) { a + b }\nadd(1, \"x\") }")
  assert.truthy(hasError(result, "Argument mismatch"))
})

test("phase1 - if expressions", fn(assert) {
  let resultOk = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { 2 } }")
  assert.equal(deref(resultOk, getExprType(resultOk, 1)).kind, "Number")

  let resultMismatch = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { \"x\" } }")
  assert.truthy(hasError(resultMismatch, "Branch mismatch"))

  let resultNoElse = parseAndTypecheck("{ let cond = true\nif cond { 1 } }")
  assert.equal(deref(resultNoElse, getExprType(resultNoElse, 1)).kind, "Nil")
})

test("phase1 - no narrowing on nil check", fn(assert) {
  let result = parseAndTypecheck("{ let x = 1\nif x == nil { }\nx }")
  assert.equal(deref(result, getExprType(result, 2)).kind, "Number")
})

test("phase1 - record literal and field access", fn(assert) {
  let result = parseAndTypecheck("{ let r = .{ a: 1, b: 2 }\nr.a }")
  let recordT = deref(result, getExprType(result, 0))
  assert.equal(recordT.kind, "Record")
  assert.equal(deref(result, recordT.fields["a"]).kind, "Number")
  assert.equal(deref(result, recordT.fields["b"]).kind, "Number")
  let fieldT = deref(result, getExprType(result, 1))
  assert.equal(fieldT.kind, "Number")
})

test("phase1 - missing record field reports error", fn(assert) {
  let result = parseAndTypecheck("{ let r = .{ a: 1 }\nr.b }")
  assert.truthy(hasError(result, "Missing field: b"))
})

test("phase1 - recursive function does not hang", fn(assert) {
  let result = parseAndTypecheck("fn f(x) { f(x) }")
  let fnT = getExprType(result, 0)
  assert.truthy(fnT)
})

test("phase1 - occurs check on self application", fn(assert) {
  let result = parseAndTypecheck("fn f(x) { x(x) }")
  assert.truthy(hasError(result, "Call requires function"))
})

suite.run()
