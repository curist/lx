// Generated by scripts/gen-builtin-docs.lx. Do not edit by hand.

let DOCS = .{
  ["Date"]: .{
    name: "Date",
    signature: "Date",
    description: "runtime date/time namespace.",
    markdown: "`Date`\nruntime date/time namespace.",
    source: "lx/README.md",
  },
  ["Date.RFC3339"]: .{
    name: "Date.RFC3339",
    signature: "Date.RFC3339: string",
    description: "Default RFC3339 format string.",
    markdown: "`Date.RFC3339: string`\nDefault RFC3339 format string.",
    source: "lx/README.md",
  },
  ["Date.format"]: .{
    name: "Date.format",
    signature: "Date.format(unix: number, format?: string) -> string",
    description: "Format unix timestamp (milliseconds).",
    markdown: "`Date.format(unix: number, format?: string) -> string`\nFormat unix timestamp (milliseconds).",
    source: "lx/README.md",
  },
  ["Date.nanotime"]: .{
    name: "Date.nanotime",
    signature: "Date.nanotime() -> number",
    description: "Current unix timestamp (nanoseconds).",
    markdown: "`Date.nanotime() -> number`\nCurrent unix timestamp (nanoseconds).",
    source: "lx/README.md",
  },
  ["Date.now"]: .{
    name: "Date.now",
    signature: "Date.now() -> number",
    description: "Current unix timestamp (milliseconds).",
    markdown: "`Date.now() -> number`\nCurrent unix timestamp (milliseconds).",
    source: "lx/README.md",
  },
  ["Date.parse"]: .{
    name: "Date.parse",
    signature: "Date.parse(s: string, format: string) -> number",
    description: "Parse a date string, returns unix timestamp (milliseconds).",
    markdown: "`Date.parse(s: string, format: string) -> number`\nParse a date string, returns unix timestamp (milliseconds).",
    source: "lx/README.md",
  },
  ["Lx"]: .{
    name: "Lx",
    signature: "Lx",
    description: "runtime namespace.",
    markdown: "`Lx`\nruntime namespace.",
    source: "lx/README.md",
  },
  ["Lx.args"]: .{
    name: "Lx.args",
    signature: "Lx.args: array[string]",
    description: "CLI args.",
    markdown: "`Lx.args: array[string]`\nCLI args.",
    source: "lx/README.md",
  },
  ["Lx.doubleToUint8Array"]: .{
    name: "Lx.doubleToUint8Array",
    signature: "Lx.doubleToUint8Array(x: number) -> array[number]",
    description: "Convert a float64 to 8 bytes (little-endian).",
    markdown: "`Lx.doubleToUint8Array(x: number) -> array[number]`\nConvert a float64 to 8 bytes (little-endian).",
    source: "lx/README.md",
  },
  ["Lx.env"]: .{
    name: "Lx.env",
    signature: "Lx.env: map[string]string",
    description: "environment variables.",
    markdown: "`Lx.env: map[string]string`\nenvironment variables.",
    source: "lx/README.md",
  },
  ["Lx.error"]: .{
    name: "Lx.error",
    signature: "Lx.error(message: string) -> never",
    description: "raises a runtime error (caught by `Lx.pcall`).",
    markdown: "`Lx.error(message: string) -> never`\nraises a runtime error (caught by `Lx.pcall`).",
    source: "lx/README.md",
  },
  ["Lx.exit"]: .{
    name: "Lx.exit",
    signature: "Lx.exit(code?: number) -> never",
    description: "Exit the process.",
    markdown: "`Lx.exit(code?: number) -> never`\nExit the process.",
    source: "lx/README.md",
  },
  ["Lx.fs"]: .{
    name: "Lx.fs",
    signature: "Lx.fs",
    description: "filesystem helpers namespace.",
    markdown: "`Lx.fs`\nfilesystem helpers namespace.",
    source: "lx/README.md",
  },
  ["Lx.fs.cwd"]: .{
    name: "Lx.fs.cwd",
    signature: "Lx.fs.cwd() -> string",
    description: "Current working directory.",
    markdown: "`Lx.fs.cwd() -> string`\nCurrent working directory.",
    source: "lx/README.md",
  },
  ["Lx.fs.exists"]: .{
    name: "Lx.fs.exists",
    signature: "Lx.fs.exists(path: string) -> bool",
    description: "Whether a path exists.",
    markdown: "`Lx.fs.exists(path: string) -> bool`\nWhether a path exists.",
    source: "lx/README.md",
  },
  ["Lx.fs.realpath"]: .{
    name: "Lx.fs.realpath",
    signature: "Lx.fs.realpath(path: string) -> string | nil",
    description: "Resolve symlinks, or `nil` on failure.",
    markdown: "`Lx.fs.realpath(path: string) -> string | nil`\nResolve symlinks, or `nil` on failure.",
    source: "lx/README.md",
  },
  ["Lx.fs.stat"]: .{
    name: "Lx.fs.stat",
    signature: "Lx.fs.stat(path: string) -> map | nil",
    description: "File metadata (e.g. `.{type,size,mtime,mode}`).",
    markdown: "`Lx.fs.stat(path: string) -> map | nil`\nFile metadata (e.g. `.{type,size,mtime,mode}`).",
    source: "lx/README.md",
  },
  ["Lx.globals"]: .{
    name: "Lx.globals",
    signature: "Lx.globals() -> array[string | number]",
    description: "List current global keys.",
    markdown: "`Lx.globals() -> array[string | number]`\nList current global keys.",
    source: "lx/README.md",
  },
  ["Lx.isLxObj"]: .{
    name: "Lx.isLxObj",
    signature: "Lx.isLxObj(bytes: string | array[number]) -> bool",
    description: "checks whether a byte buffer looks like an lxobj.",
    markdown: "`Lx.isLxObj(bytes: string | array[number]) -> bool`\nchecks whether a byte buffer looks like an lxobj.",
    source: "lx/README.md",
  },
  ["Lx.loadObj"]: .{
    name: "Lx.loadObj",
    signature: "Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn",
    description: "loads an lxobj and returns a callable closure.",
    markdown: "`Lx.loadObj(bytes: string | array[number], printCode?: bool) -> fn`\nloads an lxobj and returns a callable closure.",
    source: "lx/README.md",
  },
  ["Lx.path"]: .{
    name: "Lx.path",
    signature: "Lx.path",
    description: "path helpers namespace.",
    markdown: "`Lx.path`\npath helpers namespace.",
    source: "lx/README.md",
  },
  ["Lx.path.basename"]: .{
    name: "Lx.path.basename",
    signature: "Lx.path.basename(path: string) -> string",
    description: "Filename component (last segment after final `/`).",
    markdown: "`Lx.path.basename(path: string) -> string`\nFilename component (last segment after final `/`).",
    source: "lx/README.md",
  },
  ["Lx.path.dirname"]: .{
    name: "Lx.path.dirname",
    signature: "Lx.path.dirname(path: string) -> string",
    description: "Parent directory.",
    markdown: "`Lx.path.dirname(path: string) -> string`\nParent directory.",
    source: "lx/README.md",
  },
  ["Lx.path.join"]: .{
    name: "Lx.path.join",
    signature: "Lx.path.join(...segments: string) -> string",
    description: "Join path segments.",
    markdown: "`Lx.path.join(...segments: string) -> string`\nJoin path segments.",
    source: "lx/README.md",
  },
  ["Lx.pcall"]: .{
    name: "Lx.pcall",
    signature: "Lx.pcall(fn: fn, ...args) -> {ok,value,error}",
    description: "calls a function and captures runtime errors instead of aborting.",
    markdown: "`Lx.pcall(fn: fn, ...args) -> {ok,value,error}`\ncalls a function and captures runtime errors instead of aborting.",
    source: "lx/README.md",
  },
  ["Lx.stdin"]: .{
    name: "Lx.stdin",
    signature: "Lx.stdin",
    description: "stdin helpers namespace.",
    markdown: "`Lx.stdin`\nstdin helpers namespace.",
    source: "lx/README.md",
  },
  ["Lx.stdin.poll"]: .{
    name: "Lx.stdin.poll",
    signature: "Lx.stdin.poll(timeoutMs: number) -> bool",
    description: "Whether stdin is readable within `timeoutMs` (ms). Use `0` to poll and `-1` to wait forever.",
    markdown: "`Lx.stdin.poll(timeoutMs: number) -> bool`\nWhether stdin is readable within `timeoutMs` (ms). Use `0` to poll and `-1` to wait forever.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readAll"]: .{
    name: "Lx.stdin.readAll",
    signature: "Lx.stdin.readAll() -> string",
    description: "Read all stdin.",
    markdown: "`Lx.stdin.readAll() -> string`\nRead all stdin.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readBytes"]: .{
    name: "Lx.stdin.readBytes",
    signature: "Lx.stdin.readBytes(n: number) -> string | nil",
    description: "Read up to `n` bytes from stdin.",
    markdown: "`Lx.stdin.readBytes(n: number) -> string | nil`\nRead up to `n` bytes from stdin.",
    source: "lx/README.md",
  },
  ["Lx.stdin.readFd"]: .{
    name: "Lx.stdin.readFd",
    signature: "Lx.stdin.readFd(n: number) -> string | nil",
    description: "Read up to `n` bytes from stdin using fd I/O (works with `poll`).",
    markdown: "`Lx.stdin.readFd(n: number) -> string | nil`\nRead up to `n` bytes from stdin using fd I/O (works with `poll`).",
    source: "lx/README.md",
  },
  ["Lx.stdin.readLine"]: .{
    name: "Lx.stdin.readLine",
    signature: "Lx.stdin.readLine(prompt?: string) -> string | nil",
    description: "Read one line from stdin.",
    markdown: "`Lx.stdin.readLine(prompt?: string) -> string | nil`\nRead one line from stdin.",
    source: "lx/README.md",
  },
  ["Lx.stdin.unbuffered"]: .{
    name: "Lx.stdin.unbuffered",
    signature: "Lx.stdin.unbuffered() -> nil",
    description: "Disable stdin stdio buffering (recommended if mixing `poll` with `readLine`/`readBytes`).",
    markdown: "`Lx.stdin.unbuffered() -> nil`\nDisable stdin stdio buffering (recommended if mixing `poll` with `readLine`/`readBytes`).",
    source: "lx/README.md",
  },
  ["Lx.stdout"]: .{
    name: "Lx.stdout",
    signature: "Lx.stdout",
    description: "stdout helpers namespace.",
    markdown: "`Lx.stdout`\nstdout helpers namespace.",
    source: "lx/README.md",
  },
  ["Lx.stdout.flush"]: .{
    name: "Lx.stdout.flush",
    signature: "Lx.stdout.flush() -> nil",
    description: "Flush stdout.",
    markdown: "`Lx.stdout.flush() -> nil`\nFlush stdout.",
    source: "lx/README.md",
  },
  ["Lx.version"]: .{
    name: "Lx.version",
    signature: "Lx.version: string",
    description: "runtime version string.",
    markdown: "`Lx.version: string`\nruntime version string.",
    source: "lx/README.md",
  },
  ["_1"]: .{
    name: "_1",
    signature: "_1(cb: fn) -> fn",
    description: "Wrap a callback as a unary function (ignores extra args).",
    markdown: "`_1(cb: fn) -> fn`\nWrap a callback as a unary function (ignores extra args).",
    source: "lx/README.md",
  },
  ["_2"]: .{
    name: "_2",
    signature: "_2(cb: fn) -> fn",
    description: "Wrap a callback as a binary function (ignores extra args).",
    markdown: "`_2(cb: fn) -> fn`\nWrap a callback as a binary function (ignores extra args).",
    source: "lx/README.md",
  },
  ["chr"]: .{
    name: "chr",
    signature: "chr(code: number) -> string",
    description: "Convert a byte (0–255) to a 1-byte string.",
    markdown: "`chr(code: number) -> string`\nConvert a byte (0–255) to a 1-byte string.",
    source: "lx/README.md",
  },
  ["concat"]: .{
    name: "concat",
    signature: "concat(a: array, b: array) -> array",
    description: "New array with elements of `a` followed by `b`.",
    markdown: "`concat(a: array, b: array) -> array`\nNew array with elements of `a` followed by `b`.",
    source: "lx/README.md",
  },
  ["contains"]: .{
    name: "contains",
    signature: "contains(haystack: array | string, needle) -> bool",
    description: "Membership test for arrays/strings.",
    markdown: "`contains(haystack: array | string, needle) -> bool`\nMembership test for arrays/strings.",
    source: "lx/README.md",
  },
  ["drop"]: .{
    name: "drop",
    signature: "drop(arr: array, n: number) -> array",
    description: "Suffix.",
    markdown: "`drop(arr: array, n: number) -> array`\nSuffix.",
    source: "lx/README.md",
  },
  ["each"]: .{
    name: "each",
    signature: "each(arr: array, cb: fn(x, i, arr, abort)) -> nil",
    description: "Iterate; call `abort()` to stop early.",
    markdown: "`each(arr: array, cb: fn(x, i, arr, abort)) -> nil`\nIterate; call `abort()` to stop early.",
    source: "lx/README.md",
  },
  ["endsWith"]: .{
    name: "endsWith",
    signature: "endsWith(s: string, suffix: string) -> bool",
    description: "String suffix test.",
    markdown: "`endsWith(s: string, suffix: string) -> bool`\nString suffix test.",
    source: "lx/README.md",
  },
  ["exec"]: .{
    name: "exec",
    signature: "exec(cmd: string) -> {code,out}",
    description: "Run a shell command and capture stdout.",
    markdown: "`exec(cmd: string) -> {code,out}`\nRun a shell command and capture stdout.",
    source: "lx/README.md",
  },
  ["filter"]: .{
    name: "filter",
    signature: "filter(arr: array, cb: fn(x, i, arr) -> bool) -> array",
    description: "Filter into a new array.",
    markdown: "`filter(arr: array, cb: fn(x, i, arr) -> bool) -> array`\nFilter into a new array.",
    source: "lx/README.md",
  },
  ["first"]: .{
    name: "first",
    signature: "first(coll: array | string) -> any",
    description: "First element/char.",
    markdown: "`first(coll: array | string) -> any`\nFirst element/char.",
    source: "lx/README.md",
  },
  ["fold"]: .{
    name: "fold",
    signature: "fold(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any",
    description: "Left fold.",
    markdown: "`fold(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any`\nLeft fold.",
    source: "lx/README.md",
  },
  ["foldr"]: .{
    name: "foldr",
    signature: "foldr(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any",
    description: "Right fold.",
    markdown: "`foldr(arr: array, acc, cb: fn(acc, x, i, abort) -> acc) -> any`\nRight fold.",
    source: "lx/README.md",
  },
  ["getline"]: .{
    name: "getline",
    signature: "getline() -> string | nil",
    description: "Read one line from stdin (without trailing `\\n`), or `nil` on EOF.",
    markdown: "`getline() -> string | nil`\nRead one line from stdin (without trailing `\\n`), or `nil` on EOF.",
    source: "lx/README.md",
  },
  ["groan"]: .{
    name: "groan",
    signature: "groan(...values) -> nil",
    description: "Print values to stderr separated by spaces.",
    markdown: "`groan(...values) -> nil`\nPrint values to stderr separated by spaces.",
    source: "lx/README.md",
  },
  ["groanln"]: .{
    name: "groanln",
    signature: "groanln(...values) -> nil",
    description: "Print values to stderr separated by spaces and a trailing newline.",
    markdown: "`groanln(...values) -> nil`\nPrint values to stderr separated by spaces and a trailing newline.",
    source: "lx/README.md",
  },
  ["int"]: .{
    name: "int",
    signature: "int(n: number) -> number",
    description: "Truncate a number toward zero.",
    markdown: "`int(n: number) -> number`\nTruncate a number toward zero.",
    source: "lx/README.md",
  },
  ["join"]: .{
    name: "join",
    signature: "join(values: array, sep: string) -> string",
    description: "Join stringified values with a separator.",
    markdown: "`join(values: array, sep: string) -> string`\nJoin stringified values with a separator.",
    source: "lx/README.md",
  },
  ["keys"]: .{
    name: "keys",
    signature: "keys(x: map | enum) -> array[string]",
    description: "Keys/names.",
    markdown: "`keys(x: map | enum) -> array[string]`\nKeys/names.",
    source: "lx/README.md",
  },
  ["last"]: .{
    name: "last",
    signature: "last(coll: array | string) -> any",
    description: "Last element/char.",
    markdown: "`last(coll: array | string) -> any`\nLast element/char.",
    source: "lx/README.md",
  },
  ["len"]: .{
    name: "len",
    signature: "len(x: string | array) -> number",
    description: "Length of a string/array.",
    markdown: "`len(x: string | array) -> number`\nLength of a string/array.",
    source: "lx/README.md",
  },
  ["lines"]: .{
    name: "lines",
    signature: "lines(s: string) -> array[string]",
    description: "Split by `\\n` (newline not included in lines).",
    markdown: "`lines(s: string) -> array[string]`\nSplit by `\\n` (newline not included in lines).",
    source: "lx/README.md",
  },
  ["map"]: .{
    name: "map",
    signature: "map(arr: array, cb: fn(x, i, arr) -> y) -> array",
    description: "Map to a new array.",
    markdown: "`map(arr: array, cb: fn(x, i, arr) -> y) -> array`\nMap to a new array.",
    source: "lx/README.md",
  },
  ["max"]: .{
    name: "max",
    signature: "max(a, b) -> any",
    description: "Maximum of two values.",
    markdown: "`max(a, b) -> any`\nMaximum of two values.",
    source: "lx/README.md",
  },
  ["min"]: .{
    name: "min",
    signature: "min(a, b) -> any",
    description: "Minimum of two values.",
    markdown: "`min(a, b) -> any`\nMinimum of two values.",
    source: "lx/README.md",
  },
  ["nameOf"]: .{
    name: "nameOf",
    signature: "nameOf(enum: enum, value: number | string) -> string | nil",
    description: "Reverse lookup (value → name).",
    markdown: "`nameOf(enum: enum, value: number | string) -> string | nil`\nReverse lookup (value → name).",
    source: "lx/README.md",
  },
  ["ord"]: .{
    name: "ord",
    signature: "ord(ch: string) -> number",
    description: "Convert a 1-character string to its byte value.",
    markdown: "`ord(ch: string) -> number`\nConvert a 1-character string to its byte value.",
    source: "lx/README.md",
  },
  ["pop"]: .{
    name: "pop",
    signature: "pop(arr: array) -> value | nil",
    description: "Mutates `arr` by removing and returning the last element.",
    markdown: "`pop(arr: array) -> value | nil`\nMutates `arr` by removing and returning the last element.",
    source: "lx/README.md",
  },
  ["print"]: .{
    name: "print",
    signature: "print(...values) -> nil",
    description: "Print values to stdout separated by spaces.",
    markdown: "`print(...values) -> nil`\nPrint values to stdout separated by spaces.",
    source: "lx/README.md",
  },
  ["println"]: .{
    name: "println",
    signature: "println(...values) -> nil",
    description: "Print values to stdout separated by spaces and a trailing newline.",
    markdown: "`println(...values) -> nil`\nPrint values to stdout separated by spaces and a trailing newline.",
    source: "lx/README.md",
  },
  ["push"]: .{
    name: "push",
    signature: "push(arr: array, value) -> array",
    description: "Mutates `arr` by appending `value`.",
    markdown: "`push(arr: array, value) -> array`\nMutates `arr` by appending `value`.",
    source: "lx/README.md",
  },
  ["putc"]: .{
    name: "putc",
    signature: "putc(...codes: number) -> nil",
    description: "Write bytes/chars to stdout.",
    markdown: "`putc(...codes: number) -> nil`\nWrite bytes/chars to stdout.",
    source: "lx/README.md",
  },
  ["random"]: .{
    name: "random",
    signature: "random() -> number",
    description: "Random float in `[0, 1)`.",
    markdown: "`random() -> number`\nRandom float in `[0, 1)`.",
    source: "lx/README.md",
  },
  ["range"]: .{
    name: "range",
    signature: "range(x: number | string | array | map | enum) -> array",
    description: "For number: `[0..n-1]`; for string: chars; for map/enum: keys.",
    markdown: "`range(x: number | string | array | map | enum) -> array`\nFor number: `[0..n-1]`; for string: chars; for map/enum: keys.",
    source: "lx/README.md",
  },
  ["read"]: .{
    name: "read",
    signature: "read(n: number) -> string | nil",
    description: "Read up to `n` bytes from stdin, or `nil` on EOF.",
    markdown: "`read(n: number) -> string | nil`\nRead up to `n` bytes from stdin, or `nil` on EOF.",
    source: "lx/README.md",
  },
  ["slurp"]: .{
    name: "slurp",
    signature: "slurp(path: string) -> string",
    description: "Read a file.",
    markdown: "`slurp(path: string) -> string`\nRead a file.",
    source: "lx/README.md",
  },
  ["sort"]: .{
    name: "sort",
    signature: "sort(arr: array, less: fn(a, b) -> bool) -> array",
    description: "Stable-ish merge sort returning a new array.",
    markdown: "`sort(arr: array, less: fn(a, b) -> bool) -> array`\nStable-ish merge sort returning a new array.",
    source: "lx/README.md",
  },
  ["spit"]: .{
    name: "spit",
    signature: "spit(path: string, content: string) -> true",
    description: "Write a file.",
    markdown: "`spit(path: string, content: string) -> true`\nWrite a file.",
    source: "lx/README.md",
  },
  ["split"]: .{
    name: "split",
    signature: "split(s: string, sep: string) -> array[string]",
    description: "Split by substring; when `sep == \"\"`, splits into chars.",
    markdown: "`split(s: string, sep: string) -> array[string]`\nSplit by substring; when `sep == \"\"`, splits into chars.",
    source: "lx/README.md",
  },
  ["sqrt"]: .{
    name: "sqrt",
    signature: "sqrt(n: number) -> number",
    description: "Square root.",
    markdown: "`sqrt(n: number) -> number`\nSquare root.",
    source: "lx/README.md",
  },
  ["startsWith"]: .{
    name: "startsWith",
    signature: "startsWith(s: string, prefix: string) -> bool",
    description: "String prefix test.",
    markdown: "`startsWith(s: string, prefix: string) -> bool`\nString prefix test.",
    source: "lx/README.md",
  },
  ["str"]: .{
    name: "str",
    signature: "str(value) -> string",
    description: "Convert a value to a string (uses runtime formatting).",
    markdown: "`str(value) -> string`\nConvert a value to a string (uses runtime formatting).",
    source: "lx/README.md",
  },
  ["substr"]: .{
    name: "substr",
    signature: "substr(s: string, start: number, length: number) -> string",
    description: "Substring by byte offset; if `length <= 0`, returns `\"\"`.",
    markdown: "`substr(s: string, start: number, length: number) -> string`\nSubstring by byte offset; if `length <= 0`, returns `\"\"`.",
    source: "lx/README.md",
  },
  ["system"]: .{
    name: "system",
    signature: "system(cmd: string) -> number",
    description: "Run a shell command (inherits stdio), returning exit code.",
    markdown: "`system(cmd: string) -> number`\nRun a shell command (inherits stdio), returning exit code.",
    source: "lx/README.md",
  },
  ["take"]: .{
    name: "take",
    signature: "take(arr: array, n: number) -> array",
    description: "Prefix.",
    markdown: "`take(arr: array, n: number) -> array`\nPrefix.",
    source: "lx/README.md",
  },
  ["tolower"]: .{
    name: "tolower",
    signature: "tolower(s: string) -> string",
    description: "Lowercase ASCII.",
    markdown: "`tolower(s: string) -> string`\nLowercase ASCII.",
    source: "lx/README.md",
  },
  ["tonumber"]: .{
    name: "tonumber",
    signature: "tonumber(s: string) -> number",
    description: "Parse a string to a number (float).",
    markdown: "`tonumber(s: string) -> number`\nParse a string to a number (float).",
    source: "lx/README.md",
  },
  ["toupper"]: .{
    name: "toupper",
    signature: "toupper(s: string) -> string",
    description: "Uppercase ASCII.",
    markdown: "`toupper(s: string) -> string`\nUppercase ASCII.",
    source: "lx/README.md",
  },
  ["type"]: .{
    name: "type",
    signature: "type(x) -> string",
    description: "One of `nil|boolean|number|fn|string|enum|map|array`.",
    markdown: "`type(x) -> string`\nOne of `nil|boolean|number|fn|string|enum|map|array`.",
    source: "lx/README.md",
  },
}

let NATIVE_NAMES = .{
  ["Date.format"]: true,
  ["Date.nanotime"]: true,
  ["Date.now"]: true,
  ["Date.parse"]: true,
  ["Lx.doubleToUint8Array"]: true,
  ["Lx.error"]: true,
  ["Lx.exit"]: true,
  ["Lx.fs.cwd"]: true,
  ["Lx.fs.exists"]: true,
  ["Lx.fs.realpath"]: true,
  ["Lx.fs.stat"]: true,
  ["Lx.globals"]: true,
  ["Lx.isLxObj"]: true,
  ["Lx.loadObj"]: true,
  ["Lx.path.basename"]: true,
  ["Lx.path.dirname"]: true,
  ["Lx.path.join"]: true,
  ["Lx.pcall"]: true,
  ["Lx.stdin.poll"]: true,
  ["Lx.stdin.readAll"]: true,
  ["Lx.stdin.readBytes"]: true,
  ["Lx.stdin.readFd"]: true,
  ["Lx.stdin.readLine"]: true,
  ["Lx.stdin.unbuffered"]: true,
  ["Lx.stdout.flush"]: true,
  ["chr"]: true,
  ["concat"]: true,
  ["exec"]: true,
  ["getline"]: true,
  ["groan"]: true,
  ["groanln"]: true,
  ["int"]: true,
  ["join"]: true,
  ["keys"]: true,
  ["len"]: true,
  ["lines"]: true,
  ["nameOf"]: true,
  ["ord"]: true,
  ["pop"]: true,
  ["print"]: true,
  ["println"]: true,
  ["push"]: true,
  ["putc"]: true,
  ["random"]: true,
  ["range"]: true,
  ["read"]: true,
  ["slurp"]: true,
  ["spit"]: true,
  ["split"]: true,
  ["sqrt"]: true,
  ["str"]: true,
  ["substr"]: true,
  ["system"]: true,
  ["tolower"]: true,
  ["tonumber"]: true,
  ["toupper"]: true,
  ["type"]: true,
}

let PRELUDE_NAMES = .{
  ["_1"]: true,
  ["_2"]: true,
  ["contains"]: true,
  ["drop"]: true,
  ["each"]: true,
  ["endsWith"]: true,
  ["filter"]: true,
  ["first"]: true,
  ["fold"]: true,
  ["foldr"]: true,
  ["last"]: true,
  ["map"]: true,
  ["max"]: true,
  ["min"]: true,
  ["sort"]: true,
  ["startsWith"]: true,
  ["take"]: true,
}

.{
  DOCS,
  NATIVE_NAMES,
  PRELUDE_NAMES,
}
