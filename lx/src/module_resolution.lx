// Module resolution helpers.
//
// The compiler driver passes import specifiers through unchanged; this module
// maps those specifiers to concrete filesystem paths.
//
// Resolution strategy:
// - Given an entry file, start searching for `.lxroot` from the entry file's
//   directory, walking up the parent directories.
// - If found, use that as the project root.
// - Otherwise, if `Lx.env["LX_ROOT"]` is set, use it as the project root.
// - Otherwise, use the entry file's directory as the project root.
//
// Paths are kept simple:
// - No tilde expansion, no shell expansion.
// - Non-absolute paths are resolved relative to the project root.
//
// Usage:
//   let resolver = ModuleResolution.forEntry("src/main.lx")
//   resolver.slurpPath("utils/helpers.lx")

let _cache = .{}  // Map of baseDir -> {projectRoot}

fn _isAbs(path) {
  path and len(path) > 0 and path[0] == "/"
}

fn _computeRoots(baseDir) {
  // Check cache first
  if _cache[baseDir] {
    return _cache[baseDir]
  }

  let dir = baseDir
  let found = nil
  for true {
    if Lx.fs.exists(Lx.path.join(dir, ".lxroot")) {
      found = dir
      break
    }
    let parent = Lx.path.dirname(dir)
    if parent == dir { break }
    dir = parent
  }

  if !found and Lx.env and Lx.env["LX_ROOT"] {
    let envRoot = Lx.env["LX_ROOT"]
    if envRoot and envRoot != "" {
      if !_isAbs(envRoot) {
        envRoot = Lx.path.join(baseDir, envRoot)
      }

      // Only accept if it looks like an existing directory (when stat is available).
      if Lx.fs.stat {
        let st = Lx.fs.stat(envRoot)
        if st and st.type == "dir" {
          found = envRoot
        }
      } else if Lx.fs.exists(envRoot) {
        found = envRoot
      }
    }
  }

  let projectRoot = found or baseDir

  let roots = .{
    projectRoot: projectRoot,
  }

  _cache[baseDir] = roots
  roots
}

fn forEntry(entryPath) {
  // Resolve entry path to absolute
  let absEntry = entryPath
  if !_isAbs(absEntry) {
    absEntry = Lx.path.join(Lx.fs.cwd(), absEntry)
  }

  // Get the directory of the entry file
  let baseDir = Lx.path.dirname(absEntry)

  // Compute roots for this entry
  let roots = _computeRoots(baseDir)

  // Return a resolver instance
  let resolver = .{}

  resolver.resolvePath = fn(path) {
    if !path {
      return path
    }
    if _isAbs(path) {
      return path
    }
    if !roots or !roots.projectRoot {
      return path
    }

    // Resolve relative to project root
    Lx.path.join(roots.projectRoot, path)
  }

  resolver.slurpPath = fn(path) {
    slurp(resolver.resolvePath(path))
  }

  resolver.roots = fn() { roots }

  resolver
}

// Backward compatibility: use the path itself to determine project root
fn resolvePath(path) {
  if !path {
    return path
  }
  if _isAbs(path) {
    return path
  }

  // Use the path itself to find the project root
  let resolver = forEntry(path)
  resolver.resolvePath(path)
}

fn slurpPath(path) {
  if !path {
    return nil
  }
  if _isAbs(path) {
    return slurp(path)
  }

  // Use the path itself to find the project root
  let resolver = forEntry(path)
  resolver.slurpPath(path)
}

fn roots() {
  // For backward compatibility, use cwd
  let cwd = Lx.fs.cwd()
  _computeRoots(cwd)
}

fn makeLoadSource(sourceOverride, overridePath) {
  fn(path) {
    if sourceOverride and path == overridePath {
      return sourceOverride
    }
    slurpPath(path)
  }
}

.{
  forEntry: forEntry,
  roots: roots,
  resolvePath: resolvePath,
  slurpPath: slurpPath,
  makeLoadSource: makeLoadSource,
}
