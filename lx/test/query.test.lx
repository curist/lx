// Query Service Tests

let suite = (import "test/makeTestSuite.lx")()
// let test = suite.defineTest

fn test(name, body) { println(name, "disabled") }

let Driver = import "src/driver.lx"
let query = import "services/query.lx"

// Helper: compile source through full pipeline and create query context
// Tests use lower-level APIs for flexibility (inline source, not filesystem)
fn compileAndQuery(source, filename) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == filename { return source }
      return slurp(path)
    },
    withTypecheck: true,
  })

  let result = driver.compileModule(filename)

  if result.status != "done" {
    let phase = "unknown"
    let errors = []

    if result.parseErrors {
      phase = "parse"
      errors = result.parseErrors
    } else if result.lowerErrors {
      phase = "lower"
      errors = result.lowerErrors
    } else if result.resolveResult and !result.resolveResult.success {
      phase = "resolve"
      errors = result.resolveResult.errors
    }

    return .{ success: false, phase: phase, errors: errors }
  }

  let initResult = query.queryInit(
    result.lowerResult.ast,
    result.resolveResult,
    result.typecheckResult,
    .{ buildIndex: true }
  )

  .{
    success: initResult.success,
    ctx: initResult.ctx,
    parseResult: result.parseResult,
    lowerResult: result.lowerResult,
    resolveResult: result.resolveResult,
    typecheckResult: result.typecheckResult,
  }
}

// ========================================
// Core Tests (5 minimum)
// ========================================

test("query - hover on number literal", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
})

test("query - hover on variable shows inferred type", fn(assert) {
  let result = compileAndQuery("let x = 42\nx", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'x' usage (line 2, col 1)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 2, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
  assert.truthy(hoverResult.contents.symbol, "Should include symbol info")
  assert.equal(hoverResult.contents.symbol.name, "x", "Should include symbol name")
  assert.equal(hoverResult.contents.symbol.kind, "local", "Should classify symbol kind")
  assert.truthy(hoverResult.details, "Should have details")
  assert.equal(hoverResult.details.nodeType, "Identifier", "Should identify as Identifier node")
})

test("query - hover resolves bound type variables via bindings", fn(assert) {
  // Manual context with a bound type variable to ensure hover formats binding
  let node = .{
    id: 1,
    type: "Identifier",
    filename: "test.lx",
    line: 1, col: 0,
    endLine: 1, endCol: 1,
  }

  let ctx = .{
    nodes: .{[1]: node},
    resolvedNames: .{},
    types: .{[1]: .{ kind: "TypeVar", id: 123 }},
    typeVarBindings: .{[123]: .{ kind: "Number" }},
    fileNodeIds: .{ ["test.lx"]: [1] },
  }

  let hoverResult = query.queryHover(ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should format bound TypeVar as its binding type")
})

test("query - hover on record key shows field value type", fn(assert) {
  let source = ".{ DEBUG: false }"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'DEBUG' key (line 1, col 3)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 3)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Bool", "Should show field value type when hovering key")
})

test("query - goto local variable", fn(assert) {
  let result = compileAndQuery("let x = 1\nx + 1", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'x' usage (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.filename, "test.lx", "Should target same file")
  assert.equal(gotoResult.target.line, 1, "Should target declaration line")
})

test("query - goto function parameter", fn(assert) {
  let result = compileAndQuery("fn f(a) { a + 1 }", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'a' in body (line 1, col 10)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 10)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target parameter declaration")
})

test("query - goto named function normalized to name", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'foo' call (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target function declaration line")
  // The target should be the function name, not the entire function
  // We can verify it's normalized by checking the span is small
  let spanSize = (gotoResult.target.endLine - gotoResult.target.line) * 1000 +
                 (gotoResult.target.endCol - gotoResult.target.col)
  assert.truthy(spanSize < 100, "Should target function name, not entire function body")
})

test("query - goto global has no definition", fn(assert) {
  let result = compileAndQuery("println(42)", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'println' (line 1, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail for global")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
})

// ========================================
// Edge Case Tests (2 additional)
// ========================================

test("query - hover on empty position returns no node", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Position far beyond code
  let hoverResult = query.queryHover(result.ctx, "test.lx", 100, 100)

  assert.equal(hoverResult.success, false, "Hover should fail")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
})

test("query - goto on non-identifier fails gracefully", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on number literal
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail on non-identifier")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
})

// ========================================
// Multi-Module Import Tests
// ========================================

test("query - hover on imported symbol shows type", fn(assert) {
  // Use proper fixture file - showcases real API usage
  let result = query.compile("test/fixtures/imports/test-hover.lx")

  if !result.success {
    println("Hover test compilation failed!")
    println("Phase:", result.phase)
    if result.errors { println("Errors:", result.errors) }
  }

  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'config.version' (line 5, col 20 - dot expression)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 20)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show imported field type")
})

test("query - hover on imported binding identifier shows type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on local binding 'version' (line 5, col 5)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 5)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show type propagated from import")
})

test("query - hover on imported function value shows function type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover-fn.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on imported function binding 'greet' (line 1, col 4)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover-fn.lx", 1, 4)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "fn(String) -> String", "Should surface imported function type")
})

test("query - goto definition to imported module", fn(assert) {
  // Use proper fixture file
  let result = query.compile("test/fixtures/imports/test-goto.lx")

  if !result.success {
    println("Compilation failed:", result.phase)
    println("Errors:", result.errors)
  }

  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'config' usage (line 7, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-goto.lx", 7, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target location")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-goto.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 2, "Should point to line 2 (let config = ...)")
})

test("query - query works across diamond import structure", fn(assert) {
  // Use proper fixture file with diamond pattern
  let result = query.compile("test/fixtures/imports/test-diamond.lx")

  assert.truthy(result.success, "Should compile with diamond imports")

  // Hover on 'app.start' (line 8, col 4 - the 'start' part)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 4)

  assert.truthy(hoverResult.success, "Hover should work across imports")
  assert.truthy(hoverResult.contents, "Should have type information")

  // Goto on 'app' usage (line 8, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 0)

  assert.truthy(gotoResult.success, "Goto should work across imports")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-diamond.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 4, "Should point to line 4 (let app = ...)")
})

suite.run()
