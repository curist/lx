// Typecheck: collections (array/map/hashmap/index)
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let getExprNode = helpers.getExprNode
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - non-empty computed-key hashmap yields Record", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{ [1]: \"a\", [2]: \"b\" }\nm }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 0))
    assert.equal(t.kind, "Record")
    assert.equal(deref(result, t.fields[1]).kind, "String")
    assert.equal(deref(result, t.fields[2]).kind, "String")
  })

  test("typecheck - indexing a Record yields field type", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{ [1]: \"a\" }\nm[1] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "String")
  })

  test("typecheck - mixed bare/computed keys yields Record", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{ a: 1, [\"b\"]: 2 }\nm }")
    assert.truthy(result.success)
    if !result.success { return }
    let t = deref(result, getExprType(result, 0))
    assert.equal(t.kind, "Record")
    assert.equal(deref(result, t.fields["a"]).kind, "Number")
    assert.equal(deref(result, t.fields["b"]).kind, "Number")
  })

  test("typecheck - record literal rejects non-literal computed key", fn(assert) {
    let result = parseAndTypecheck("{ let k = \"a\"\nlet m = .{ [k]: 1 }\nm }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Record literal computed key must be a literal string, number, or enum member."))
  })

  test("typecheck - enum member key can form Record", fn(assert) {
    let result = parseAndTypecheck("{ let E = enum { A, B }\nlet m = .{ [E.A]: 1, [E.B]: 2 }\nm }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Record")
    assert.equal(deref(result, t.fields[0]).kind, "Number")
    assert.equal(deref(result, t.fields[1]).kind, "Number")

    let mDecl = getExprNode(result, 1)
    let origins = result.recordEnumKeyOrigins and result.recordEnumKeyOrigins[mDecl.init.id]
    assert.truthy(origins != nil)
    assert.equal(origins[0].member, "A")
    assert.equal(origins[1].member, "B")
    assert.equal(origins[0].enumName, "E")
    assert.equal(origins[1].enumName, "E")
  })

  test("typecheck - enum member key with nested groupings", fn(assert) {
    let result = parseAndTypecheck("{ let E = enum { A }\nlet m = .{ [((E.A))]: 1 }\nm }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Record")
    assert.equal(deref(result, t.fields[0]).kind, "Number")

    let mDecl = getExprNode(result, 1)
    let origins = result.recordEnumKeyOrigins and result.recordEnumKeyOrigins[mDecl.init.id]
    assert.truthy(origins != nil)
    assert.equal(origins[0].member, "A")
    assert.equal(origins[0].enumName, "E")
  })

  test("typecheck - enum member in value position", fn(assert) {
    let result = parseAndTypecheck("{ let E = enum { Active, Inactive }\nlet m = .{ a: E.Active }\nm }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Record")
    assert.equal(deref(result, t.fields["a"]).kind, "Number")
  })

  test("typecheck - non-enum Dot key is rejected", fn(assert) {
    let result = parseAndTypecheck("{ let obj = .{ x: \"foo\" }\nlet m = .{ [obj.x]: 1 }\nm }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Record literal computed key must be a literal string, number, or enum member."))
  })

  test("typecheck - shadowed enum name is not treated as enum", fn(assert) {
    let result = parseAndTypecheck("{ let E = enum { A }\n{ let E = \"not an enum\"\n  let m = .{ [E.A]: 1 }\n  m\n}\n}")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Record literal computed key must be a literal string, number, or enum member."))
  })

  test("typecheck - index assignment recognizes enum member literal key", fn(assert) {
    let result = parseAndTypecheck("{ let E = enum { A, B }\nlet m = .{ [E.A]: 1 }\nm[E.B] = 2 }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Missing field: 1"))
    assert.truthy(!hasError(result, "Record index assignment must use a literal string or number key"))
  })

  test("typecheck - string indexing yields String", fn(assert) {
    let result = parseAndTypecheck("\"asdf\"[2]")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
  })

  test("typecheck - record string indexing works", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1 }\nr[\"a\"] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - record index supports variable key", fn(assert) {
    let result = parseAndTypecheck("{ let k = \"a\"\nlet r = .{ a: 1 }\nr[k] }")
    assert.truthy(result.success)
    if !result.success { return }
    let t = deref(result, getExprType(result, 2))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - record index set requires existing key", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1 }\nr[\"b\"] = 2 }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Missing field: b"))
    assert.truthy(!hasError(result, "Unresolved index assignment"))
  })

  test("typecheck - IndexSet infers Map from empty literal", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{}\nm[\"a\"] = 1\nm[\"a\"] }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")
    let mt = deref(result, getExprType(result, 0))
    assert.equal(mt.kind, "Map")
    assert.equal(deref(result, mt.key).kind, "String")
    assert.equal(deref(result, mt.elem).kind, "Number")
  })

  test("typecheck - index key must be number or string", fn(assert) {
    let result = parseAndTypecheck("{ let m = .{}\nm[true] = 1 }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Hashmap key type must be number or string."))
  })

  test("typecheck - string index must be number", fn(assert) {
    let result = parseAndTypecheck("\"asdf\"[\"x\"]")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "String index must be a number"))
  })

  test("typecheck - array index must be number", fn(assert) {
    let result = parseAndTypecheck("{ let a = [1]\na[\"x\"] }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Array index must be a number"))
  })

  test("typecheck - Indexable defaults to Array with numeric evidence", fn(assert) {
    let result = parseAndTypecheck("{
      fn f(xs) {
        xs[0] = 123
        xs[1] = 456
        xs[0]
      }
      f
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Ambiguous indexed container; defaulting to Map"))

    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    let xsT = deref(result, ft.params[0])
    assert.equal(xsT.kind, "Array")
    assert.equal(deref(result, xsT.elem).kind, "Number")
  })

  test("typecheck - Indexable numeric evidence from index var", fn(assert) {
    let result = parseAndTypecheck("{
      fn f(xs) {
        let i = 0
        xs[i] = 123
        xs[i]
      }
      f
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.truthy(!hasError(result, "Ambiguous indexed container; defaulting to Map"))

    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    let xsT = deref(result, ft.params[0])
    assert.equal(xsT.kind, "Array")
    assert.equal(deref(result, xsT.elem).kind, "Number")
  })

  test("typecheck - Indexable commits to Map with string key evidence", fn(assert) {
    let result = parseAndTypecheck("{
      fn f(xs, k) {
        xs[k]
        xs[\"a\"] = 1
        xs[k]
      }
      f
    }")
    assert.truthy(result.success)
    if !result.success { return }

    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    let xsT = deref(result, ft.params[0])
    assert.equal(xsT.kind, "Map")
    assert.equal(deref(result, xsT.key).kind, "String")
    assert.equal(deref(result, xsT.elem).kind, "Number")
  })

  test("typecheck - Indexable commits to Map when key becomes String", fn(assert) {
    let result = parseAndTypecheck("{
      fn f(xs, k) {
        xs[k]
        k = \"a\"
        xs[k]
      }
      f
    }")
    assert.truthy(result.success)
    if !result.success { return }

    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    let xsT = deref(result, ft.params[0])
    assert.equal(xsT.kind, "Map")
    assert.equal(deref(result, xsT.key).kind, "String")
  })

  test("typecheck - collect infers Array[Number] from numeric body", fn(assert) {
    let result = parseAndTypecheck("collect let i = 0; i < 3; i = i + 1 { i * 2 }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 0))
    assert.equal(t.kind, "Array")
    assert.equal(deref(result, t.elem).kind, "Number")
  })

  test("typecheck - collect infers Array[String] from string body", fn(assert) {
    let result = parseAndTypecheck("collect i in range(3) { str(i) }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 0))
    assert.equal(t.kind, "Array")
    assert.equal(deref(result, t.elem).kind, "String")
  })

  test("typecheck - collect rejects mixed element types", fn(assert) {
    let result = parseAndTypecheck("collect let i = 0; i < 3; i = i + 1 { if i == 0 { \"hello\" } else { 42 } }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Branch mismatch"))
  })
}

.{ register }
