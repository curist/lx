// Resolve Phase Tests
// Tests for semantic validation (resolve.lx)

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"

// Helper to parse from fixture file
fn parseFixture(path) {
  let src = slurp(path)
  parse(src, path)
}

// ===== Semantic Validation Tests =====
// These tests verify that resolve.lx enforces contextual legality rules

test("resolve - return outside function should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-outside-function.lx")
  // Parser should accept (structural only)
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
  // assert.truthy(len(resolved.errors) > 0)
  // assert.truthy(resolved.errors[0].message contains "return only allowed in function")
})

test("resolve - break outside loop should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-outside-loop.lx")
  // Parser should accept
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
  // assert.truthy(resolved.errors[0].message contains "break only allowed inside loop")
})

test("resolve - continue outside loop should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/continue-outside-loop.lx")
  // Parser should accept
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
  // assert.truthy(resolved.errors[0].message contains "continue only allowed inside loop")
})

test("resolve - return not at end of block should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-not-at-end.lx")
  // Parser should accept
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
  // assert.truthy(resolved.errors[0].message contains "return must be at end of block")
})

test("resolve - break not at end of block should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-not-at-end.lx")
  // Parser should accept
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
  // assert.truthy(resolved.errors[0].message contains "break must be at end of block")
})

test("resolve - return not at end should be rejected", fn(assert) {
  // { return 1; 2 } - return followed by another expression
  let result = parse("{ return 1\n2 }", "test.lx")
  // Parser should accept
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(!resolved.success)
})

// ===== Valid Cases =====
// These should pass both parser and resolve

test("resolve - valid control flow should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/control-flow.lx")
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(resolved.success)
  // assert.equal(len(resolved.errors), 0)
})

test("resolve - valid loop control should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/loop-control.lx")
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(resolved.success)
})

test("resolve - return at end of function should be accepted", fn(assert) {
  let result = parse("fn f() { return 1 }", "test.lx")
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(resolved.success)
})

test("resolve - break at end of loop should be accepted", fn(assert) {
  let result = parse("for true { break }", "test.lx")
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(resolved.success)
})

test("resolve - multiple returns in different branches should be accepted", fn(assert) {
  let result = parse("fn f() { if x { return 1 } return 2 }", "test.lx")
  assert.truthy(result.success)

  // TODO: Run resolve phase
  // let resolved = resolve(result.ast)
  // assert.truthy(resolved.success)
})

// suite.run()
