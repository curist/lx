// Typecheck: control flow
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - if branches must match", fn(assert) {
    let resultMismatch = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { \"x\" } }")
    assert.truthy(hasError(resultMismatch, "Branch mismatch"))
  })

  test("typecheck - no narrowing on nil check", fn(assert) {
    let result = parseAndTypecheck("{ let x = 1\nif x == nil { }\nx }")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")
  })

  test("typecheck - forward reference via predeclare", fn(assert) {
    // Resolve rejects use-before-declare hoisted calls, so assert the resolve error.
    let bad = parseAndTypecheck("{ use(1)\nfn use(x) { x + 1 } }")
    assert.truthy(bad.resolveErrors)

    let good = parseAndTypecheck("{ fn use(x) { x + 1 }\nuse(1) }")
    let callT = deref(good, getExprType(good, 1))
    assert.equal(callT.kind, "Number")
  })

  test("typecheck - logical and/or returns operands", fn(assert) {
    let result = parseAndTypecheck("{ \"a\" or 1\nnil or 1\nfalse and 1\nnil and 1 }")
    assert.truthy(result.success)
    if !result.success { return }

    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Bool")
    assert.equal(deref(result, getExprType(result, 3)).kind, "Nil")
  })

  test("typecheck - ternary-ish pattern: cond and X or Y", fn(assert) {
    // Common idiom: (bool_cond and X) or Y acts like a ternary
    // Result type should be join(X, Y), not join(Bool, X, Y)
    let result = parseAndTypecheck("{
      fn match(x) { true }
      let TOKEN = .{ DOT: 1, DOT_BRACE: 2 }
      match(\"{\") and TOKEN.DOT_BRACE or TOKEN.DOT
    }")
    assert.truthy(result.success)
    if !result.success { return }

    // The result type should be Number (unified from both branches)
    // not Bool | Number (which would happen without the special case)
    let exprType = deref(result, getExprType(result, 2))
    assert.equal(exprType.kind, "Number")
  })

  test("typecheck - ternary-ish pattern with different types", fn(assert) {
    // When X and Y have different types, result should still be join(X, Y)
    let result = parseAndTypecheck("{
      fn check() { true }
      check() and \"yes\" or 42
    }")
    assert.truthy(result.success)
    if !result.success { return }

    // The result can be either String or Number, but not Bool
    let exprType = deref(result, getExprType(result, 1))
    // This will be a TypeVar with String and Number as lower bounds
    // The key is that Bool should NOT pollute the type
    assert.truthy(exprType.kind == "TypeVar" or exprType.kind == "String" or exprType.kind == "Number")
  })

  test("typecheck - ternary-ish pattern in function call", fn(assert) {
    // Using the pattern as a function argument should work
    let result = parseAndTypecheck("{
      fn Token(type) { .{ type: type } }
      fn match(x) { true }
      let DOT = 1
      let DOT_BRACE = 2
      Token(match(\"{\") and DOT_BRACE or DOT)
    }")
    assert.truthy(result.success)
  })

  test("typecheck - regular and/or still works without pattern", fn(assert) {
    // Make sure we didn't break regular and/or behavior
    // Without the special pattern, regular and/or should work normally
    let result = parseAndTypecheck("{
      let x = 1
      let y = x or \"default\"
      y
    }")
    assert.truthy(result.success)
    if !result.success { return }

    // x or "default": returns x if truthy (Number), else "default" (String)
    // Result should be Number | String unified in a TypeVar
    let yType = deref(result, getExprType(result, 2))
    // Just verify it typechecks successfully; the exact representation may vary
    assert.truthy(yType.kind == "TypeVar" or yType.kind == "Number" or yType.kind == "String")
  })

  // Nil guard narrowing tests
  test("typecheck - nil guard does not narrow unknown param", fn(assert) {
    // Without nil evidence, the guard should not narrow x.
    // This keeps unknown params from being treated as optional by default.
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard with grouped condition does not narrow unknown", fn(assert) {
    // Groupings like ((!x)) should not change the evidence rule
    let result = parseAndTypecheck("{
      fn f(x) {
        if ((!x)) { return }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard only narrows in same block", fn(assert) {
    // Narrowing should not leak into closures
    // inner() captures x with original type (Option), not narrowed type
    // So inner() + 1 should FAIL because inner() returns Option
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        fn inner() { x }
        inner() + 1
      }
      f(nil)
    }")
    // This should fail because closure captures un-narrowed x (Option)
    // and inner() + 1 is Option + Number which is invalid
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard with block body does not narrow unknown", fn(assert) {
    // Block body { return } should not change the evidence rule
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { { return } }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(!result.success)
  })

  test("typecheck - no narrowing when guard has else branch", fn(assert) {
    // if !x { return } else { ... } should NOT narrow after the if
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return } else { 0 }
        x + 1
      }
      f(nil)
    }")
    // This should fail because x is still Option after an if-else
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard preserves non-Nil lower bounds", fn(assert) {
    // f(true) constrains x to have Bool as lower bound
    // After nil guard, x + 1 should still fail because x could be Bool
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return }
        x + 1
      }
      f(true)
    }")
    // This should fail: Bool is not compatible with Number for +
    assert.truthy(!result.success)
  })

  test("typecheck - guard without evidence does not narrow across closures", fn(assert) {
    // Without nil evidence, the guard should not allow x + 1 after the return.
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        let y = x + 1
        fn inner() { 0 }
        x + 2
      }
      f(nil)
    }")
    assert.truthy(!result.success)
  })

  test("typecheck - narrowing only when x has Nil bound", fn(assert) {
    // f(1) constrains x to Number only (no Nil bound)
    // The nil guard shouldn't narrow x since it's not optional
    // x + 1 should still work because x is Number
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        x + 1
      }
      f(1)
    }")
    assert.truthy(result.success)
  })

  // Statement position tests - if-else used for side effects only
  test("typecheck - if-else in statement position allows mismatched branches", fn(assert) {
    // When if-else result is discarded (not last expression), branches can have different types
    let result = parseAndTypecheck("{
      let x = true
      if x { 1 } else { \"string\" }
      42
    }")
    // Should succeed - the if-else is in statement position, result discarded
    assert.truthy(result.success)
  })

  test("typecheck - if-else in expression position still requires matching branches", fn(assert) {
    // When if-else is the last expression (return value), branches must match
    let result = parseAndTypecheck("{
      let x = true
      if x { 1 } else { \"string\" }
    }")
    // Should fail - the if-else is in expression position (last expr in block)
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - if-else-if chain in statement position allows mismatched branches", fn(assert) {
    // Chained if-else with different types in each branch, result discarded
    let result = parseAndTypecheck("{
      let x = 1
      if x == 1 {
        \"one\"
      } else if x == 2 {
        2
      } else {
        true
      }
      nil
    }")
    // Should succeed - the entire if chain is in statement position
    assert.truthy(result.success)
  })

  test("typecheck - nested if in statement position allows mismatch", fn(assert) {
    // Nested ifs, outer one in statement position
    let result = parseAndTypecheck("{
      let a = true
      let b = false
      if a {
        if b { 1 } else { \"inner\" }
      } else {
        nil
      }
      42
    }")
    // Should succeed - outer if is in statement position
    assert.truthy(result.success)
  })

  test("typecheck - function return still checks branch mismatch", fn(assert) {
    // Function body's last expression is always in expression position
    let result = parseAndTypecheck("{
      fn f(x) {
        if x { 1 } else { \"string\" }
      }
      f(true)
    }")
    // Should fail - function return is always used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - let binding still checks branch mismatch", fn(assert) {
    // Assigned if-else is in expression position
    let result = parseAndTypecheck("{
      let x = true
      let y = if x { 1 } else { \"string\" }
      42
    }")
    // Should fail - assigned value is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - if-else as function argument still checks branch mismatch", fn(assert) {
    // if-else passed as argument is in expression position
    let result = parseAndTypecheck("{
      fn f(x) { x }
      let cond = true
      f(if cond { 1 } else { \"string\" })
    }")
    // Should fail - argument value is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - assignment RHS checks branch mismatch even in statement position", fn(assert) {
    // assignment in non-last position, but RHS value is used
    let result = parseAndTypecheck("{
      let x = nil
      x = if true { 1 } else { \"string\" }
      42
    }")
    // Should fail - assignment RHS is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - array element checks branch mismatch even in statement position", fn(assert) {
    // array literal in non-last position, but elements are used
    let result = parseAndTypecheck("{
      [if true { 1 } else { \"string\" }]
      42
    }")
    // Should fail - array elements are used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - hashmap value checks branch mismatch even in statement position", fn(assert) {
    // hashmap literal in non-last position, but values are used
    let result = parseAndTypecheck("{
      .{ x: if true { 1 } else { \"string\" } }
      42
    }")
    // Should fail - hashmap values are used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  // if-let pattern tests (truthy guard narrowing)
  test("typecheck - if-let pattern allows narrowing to non-nil", fn(assert) {
    // After lowering, `if let x = expr` becomes `let x = expr; if x { ... }`
    // The then branch should see x narrowed to non-nil
    let result = parseAndTypecheck("{
      let handlers = .{ a: fn() { 1 } }
      let handler = handlers.a
      if handler {
        handler()
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - if-let pattern with index access", fn(assert) {
    // Common pattern: get optional value from map, then use it
    let result = parseAndTypecheck("{
      let map = .{ key: 42 }
      let value = map.key
      if value {
        value + 1
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - truthy guard only narrows in then branch", fn(assert) {
    // The else branch should NOT see narrowed type
    // This test verifies narrowing doesn't leak to else
    let result = parseAndTypecheck("{
      let handlers = .{ a: fn() { 1 } }
      let handler = handlers.a
      if handler {
        handler()
      } else {
        42
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - truthy guard narrowing doesn't leak out of if", fn(assert) {
    // After the if, x should still be optional (not narrowed)
    let result = parseAndTypecheck("{
      let handlers = .{ a: fn() { 1 } }
      let handler = handlers.a
      if handler {
        handler()
      }
      // handler is still optional here - cannot call directly
      handler
    }")
    // Should succeed - handler is still optional after if
    assert.truthy(result.success)
  })

  test("typecheck - no narrowing when variable is not optional", fn(assert) {
    // If x is already non-nil (e.g., Number), no narrowing needed
    let result = parseAndTypecheck("{
      let x = 42
      if x {
        x + 1
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - truthy guard with nested if", fn(assert) {
    // Nested if should see outer narrowing
    let result = parseAndTypecheck("{
      let handlers = .{ a: fn() { 1 } }
      let handler = handlers.a
      if handler {
        if true {
          handler()
        }
      }
    }")
    assert.truthy(result.success)
  })
}

.{ register }
