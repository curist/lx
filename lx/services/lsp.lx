let query = import "services/query.lx"
let builtinsDocs = import "services/builtins_docs.lx"
let Driver = import "src/driver.lx"
let ModuleResolution = import "src/module_resolution.lx"
let CompilerFiber = import "src/compiler-fiber.lx"
let Events = import "src/events.lx"

fn stringLess(a, b) {
  if !a and b { return true }
  if a and !b { return false }
  if !a and !b { return false }

  let alen = len(a)
  let blen = len(b)
  let n = alen < blen and alen or blen
  for let i = 0; i < n; i = i + 1 {
    let ca = ord(a[i])
    let cb = ord(b[i])
    if ca < cb { return true }
    if ca > cb { return false }
  }
  alen < blen
}

fn sliceFrom(s, start) {
  if !s { return s }
  let n = len(s)
  if start <= 0 { return s }
  if start >= n { return "" }
  let chars = []
  for let i = start; i < n; i = i + 1 {
    push(chars, s[i])
  }
  join(chars, "")
}

fn dropLastChar(s) {
  if !s { return s }
  let n = len(s)
  if n <= 0 { return s }
  let chars = []
  for let i = 0; i < n - 1; i = i + 1 {
    push(chars, s[i])
  }
  join(chars, "")
}

fn trimLineEnd(s) {
  if !s { return s }
  let out = s
  if len(out) > 0 and out[len(out) - 1] == "\n" {
    out = dropLastChar(out)
  }
  if len(out) > 0 and out[len(out) - 1] == "\r" {
    out = dropLastChar(out)
  }
  out
}

fn trimSpaces(s) {
  if !s { return s }
  let n = len(s)
  let i = 0
  for i < n and (s[i] == " " or s[i] == "\t") { i = i + 1 }
  let j = n
  for j > i and (s[j - 1] == " " or s[j - 1] == "\t") { j = j - 1 }
  let chars = []
  for let k = i; k < j; k = k + 1 {
    push(chars, s[k])
  }
  join(chars, "")
}

// ------------------------------------------------------------
// URI helpers (file://)
// ------------------------------------------------------------

fn hexVal(ch) {
  let c = ord(ch)
  if c >= ord("0") and c <= ord("9") { return c - ord("0") }
  if c >= ord("a") and c <= ord("f") { return c - ord("a") + 10 }
  if c >= ord("A") and c <= ord("F") { return c - ord("A") + 10 }
  nil
}

fn uriDecode(s) {
  if !s { return s }
  let out = []
  let i = 0
  for i < len(s) {
    if s[i] == "%" and i + 2 < len(s) {
      let a = hexVal(s[i + 1])
      let b = hexVal(s[i + 2])
      if a != nil and b != nil {
        push(out, chr(a * 16 + b))
        i = i + 3
        continue
      }
    }
    push(out, s[i])
    i = i + 1
  }
  join(out, "")
}

fn uriEncodePath(path) {
  if !path { return path }
  fn hexDigit(n) {
    n < 10 and chr(ord("0") + n) or chr(ord("A") + (n - 10))
  }
  let out = []
  for let i = 0; i < len(path); i = i + 1 {
    let ch = path[i]
    let c = ord(ch)
    let isSafe = (c >= ord("a") and c <= ord("z")) or
      (c >= ord("A") and c <= ord("Z")) or
      (c >= ord("0") and c <= ord("9")) or
      ch == "-" or ch == "_" or ch == "." or ch == "~" or ch == "/" // path separator

    if isSafe {
      push(out, ch)
    } else {
      let hi = Math.floor(c / 16)
      let lo = c - hi * 16
      push(out, "%")
      push(out, hexDigit(hi))
      push(out, hexDigit(lo))
    }
  }
  join(out, "")
}

fn uriToPath(uri) {
  if !uri { return uri }
  if !startsWith(uri, "file://") {
    return uri
  }

  let rest = sliceFrom(uri, len("file://"))
  if startsWith(rest, "localhost") {
    rest = sliceFrom(rest, len("localhost"))
  }
  uriDecode(rest)
}

fn pathToUri(path) {
  if !path { return path }
  startsWith(path, "file://") and path or ("file://" + uriEncodePath(path))
}

// ------------------------------------------------------------
// Caching + invalidation
// ------------------------------------------------------------

fn depsFromCompileResult(result) {
  let passes = result and result.passes or nil
  let resolve = passes and passes.resolve or nil
  let importInfo = resolve and resolve.importInfoByNodeId or nil
  if !importInfo or type(importInfo) != "map" {
    return []
  }

  let seen = .{}
  let out = []
  let ks = keys(importInfo)
  for let i = 0; i < len(ks); i = i + 1 {
    let k = ks[i]
    let info = importInfo[k]
    let r = info and info.importResult or nil
    let dep = r and r.path or nil
    if dep and !seen[dep] {
      seen[dep] = true
      push(out, dep)
    }
  }
  out
}

fn updateGraphForModule(state, path, result) {
  if !path { return }

  // If compilation didn't succeed, keep the previous dep graph. This is both
  // more stable during mid-edit parse errors and more conservative for
  // subsequent invalidations.
  if !result or result.status != "done" {
    return
  }

  // Remove old outgoing edges first
  let old = state.deps and state.deps[path] or nil
  if old and type(old) == "array" {
    for let i = 0; i < len(old); i = i + 1 {
      let dep = old[i]
      if state.rdeps and state.rdeps[dep] {
        state.rdeps[dep][path] = nil
      }
    }
  }

  let deps = depsFromCompileResult(result)
  state.deps[path] = deps
  for let i = 0; i < len(deps); i = i + 1 {
    let dep = deps[i]
    if !state.rdeps[dep] { state.rdeps[dep] = .{} }
    state.rdeps[dep][path] = true
  }
}

fn updateDepGraphFromDriver(state) {
  let driver = state.driver
  if !driver { return }

  let mods = driver.compiledModules or []
  let i = state.graphIndex or 0
  for i < len(mods) {
    let path = mods[i]
    let r = driver.cache and driver.cache[path] or nil
    updateGraphForModule(state, path, r)
    i = i + 1
  }
  state.graphIndex = i
}

// ------------------------------------------------------------
// Warmup queue (best-effort background work)
// ------------------------------------------------------------

fn enqueueWarmup(state, spec) {
  if !spec or !state or !state.warmupQueue or !state.warmupSeen { return }
  if state.warmupSeen[spec] { return }
  state.warmupSeen[spec] = true
  push(state.warmupQueue, spec)
}

fn runWarmupStep(state) {
  if !state or !state.warmupQueue or len(state.warmupQueue) == 0 { return }

  let spec = pop(state.warmupQueue)
  if !spec { return nil }
  state.warmupSeen[spec] = nil

  let cached = state.ctxCache and state.ctxCache[spec] or nil
  if cached and cached.epoch == state.epoch {
    return spec
  }

  let r = query.compileWithDriver(state.driver, spec, .{
    withTypecheck: false,
    mergeScope: "reachable",
  })
  if r and r.success {
    state.ctxCache[spec] = .{ epoch: state.epoch, result: r }
    updateDepGraphFromDriver(state)
  }
  if state.openDocs and state.openDocs[spec] != nil {
    publishDiagnosticsFromCache(state, spec)
  }
  spec
}

fn runWarmupSlice(state) {
  // Keep this small so the server remains responsive; warmup accumulates across
  // messages and will fully populate the cache quickly during normal editing.
  runWarmupStep(state)
}

fn isStaticModule(state, path) {
  // Static modules are generated data that shouldn't be invalidated during editing
  if !path or !state or !state.staticModulePaths { return false }
  state.staticModulePaths[path] == true
}

fn invalidateSingle(state, path) {
  // Invalidate just this single file (not its dependents).
  //
  // Keep the dep graph intact here; it will be updated when this module is
  // recompiled (via updateDepGraphFromDriver/updateGraphForModule). This keeps
  // invalidation fast on keystroke-level changes.
  if !path { return }

  // Skip invalidation for static modules
  if isStaticModule(state, path) { return }

  // Drop compiled module cache entry (forces driver to reload from openDocs)
  if state.driver and state.driver.cache and state.driver.cache[path] {
    state.driver.cache[path] = nil
  }

  // Clear from query ctx cache; keep a stale copy for best-effort fallback
  // (e.g. while the user is mid-edit and the file doesn't parse).
  if state.ctxCache and state.ctxCache[path] {
    if !state.staleCtxCache { state.staleCtxCache = .{} }
    state.staleCtxCache[path] = state.ctxCache[path]
    state.ctxCache[path] = nil
  }
}

fn invalidate(state, path) {
  // Invalidate path + all reverse-deps (modules that import it), transitively.
  let work = [path]
  let seen = .{}

  for len(work) > 0 {
    let p = pop(work)
    if !p or seen[p] { continue }
    seen[p] = true

    let parents = state.rdeps and state.rdeps[p] or nil
    if parents {
      let ks = keys(parents)
      for let i = 0; i < len(ks); i = i + 1 {
        push(work, ks[i])
      }
    }
  }

  let ks = keys(seen)
  for let i = 0; i < len(ks); i = i + 1 {
    let p = ks[i]

    // Skip invalidation for static modules
    if isStaticModule(state, p) { continue }

    // Remove outgoing edges p -> dep
    let deps = state.deps and state.deps[p] or nil
    if deps and type(deps) == "array" {
      for let j = 0; j < len(deps); j = j + 1 {
        let dep = deps[j]
        if state.rdeps and state.rdeps[dep] {
          state.rdeps[dep][p] = nil
        }
      }
    }

    // Remove incoming edges (parents) for p
    if state.rdeps and state.rdeps[p] {
      state.rdeps[p] = nil
    }
    if state.deps and state.deps[p] {
      state.deps[p] = nil
    }

    // Drop compiled module cache entry
    if state.driver and state.driver.cache and state.driver.cache[p] {
      state.driver.cache[p] = nil
    }
  }

  state.epoch = (state.epoch or 0) + 1
  state.staleCtxCache = state.ctxCache
  state.ctxCache = .{}
  keys(seen)
}

// ------------------------------------------------------------
// Minimal JSON (enough for LSP)
// ------------------------------------------------------------

fn jsonStringEscape(s) {
  let out = []
  for let i = 0; i < len(s); i = i + 1 {
    let ch = s[i]
    if ch == "\"" { push(out, "\\\""); continue }
    if ch == "\\" { push(out, "\\\\"); continue }
    if ch == "\n" { push(out, "\\n"); continue }
    if ch == "\r" { push(out, "\\r"); continue }
    if ch == "\t" { push(out, "\\t"); continue }
    push(out, ch)
  }
  join(out, "")
}

fn jsonStringify(v) {
  let t = type(v)
  if t == "nil" { return "null" }
  if t == "boolean" { return v and "true" or "false" }
  if t == "number" { return str(v) }
  if t == "string" { return "\"" + jsonStringEscape(v) + "\"" }

  if t == "array" {
    let parts = []
    for let i = 0; i < len(v); i = i + 1 {
      push(parts, jsonStringify(v[i]))
    }
    return "[" + join(parts, ",") + "]"
  }

  if t == "map" {
    let ks = keys(v)
    ks->sort(stringLess)
    let parts = []
    for let i = 0; i < len(ks); i = i + 1 {
      let k = ks[i]
      let keyStr = type(k) == "string" and k or str(k)
      push(parts, jsonStringify(keyStr) + ":" + jsonStringify(v[k]))
    }
    return "{" + join(parts, ",") + "}"
  }

  // Fallback: stringify as string.
  jsonStringify(str(v))
}

fn jsonParse(s) {
  let st = .{ s: s, i: 0, n: len(s) }

  fn isWs(ch) { ch == " " or ch == "\n" or ch == "\r" or ch == "\t" }
  fn skipWs() { for st.i < st.n and isWs(st.s[st.i]) { st.i = st.i + 1 } }
  fn peek() { st.i < st.n and st.s[st.i] or nil }
  fn take() { let ch = peek(); st.i = st.i + 1; ch }

  fn fail(msg) { .{ ok: false, message: msg, index: st.i } }

  fn parseString() {
    if take() != "\"" { return fail("expected string") }
    let out = []
    for st.i < st.n {
      let ch = take()
      if ch == "\"" {
        return .{ ok: true, value: join(out, "") }
      }
      if ch == "\\" {
        if st.i >= st.n { return fail("unterminated escape") }
        let esc = take()
        if esc == "\"" { push(out, "\""); continue }
        if esc == "\\" { push(out, "\\"); continue }
        if esc == "/" { push(out, "/"); continue }
        if esc == "b" { push(out, chr(8)); continue }
        if esc == "f" { push(out, chr(12)); continue }
        if esc == "n" { push(out, "\n"); continue }
        if esc == "r" { push(out, "\r"); continue }
        if esc == "t" { push(out, "\t"); continue }
        if esc == "u" {
          if st.i + 3 >= st.n { return fail("bad \\u escape") }
          let a = hexVal(take())
          let b = hexVal(take())
          let c = hexVal(take())
          let d = hexVal(take())
          if a == nil or b == nil or c == nil or d == nil { return fail("bad \\u escape") }
          let code = a * 4096 + b * 256 + c * 16 + d
          // Best-effort: only map BMP values we can represent.
          push(out, code <= 255 and chr(code) or "?")
          continue
        }
        return fail("unknown escape")
      }
      push(out, ch)
    }
    fail("unterminated string")
  }

  fn parseNumber() {
    let out = []
    let ch = peek()
    if ch == "-" { push(out, take()) }
    for st.i < st.n {
      let c = peek()
      let o = ord(c)
      if o >= ord("0") and o <= ord("9") { push(out, take()); continue }
      break
    }
    if peek() == "." {
      push(out, take())
      for st.i < st.n {
        let c = peek()
        let o = ord(c)
        if o >= ord("0") and o <= ord("9") { push(out, take()); continue }
        break
      }
    }
    let e = peek()
    if e == "e" or e == "E" {
      push(out, take())
      let sgn = peek()
      if sgn == "+" or sgn == "-" { push(out, take()) }
      for st.i < st.n {
        let c = peek()
        let o = ord(c)
        if o >= ord("0") and o <= ord("9") { push(out, take()); continue }
        break
      }
    }
    let numStr = join(out, "")
    let n = tonumber(numStr)
    n == nil and fail("invalid number") or .{ ok: true, value: n }
  }

  fn parseLiteral(lit, value) {
    for let j = 0; j < len(lit); j = j + 1 {
      if st.i + j >= st.n or st.s[st.i + j] != lit[j] {
        return fail("expected " + lit)
      }
    }
    st.i = st.i + len(lit)
    .{ ok: true, value: value }
  }

  fn parseArray() {
    if take() != "[" { return fail("expected [") }
    skipWs()
    let arr = []
    if peek() == "]" { take(); return .{ ok: true, value: arr } }
    for true {
      skipWs()
      let v = parseValue()
      if !v.ok { return v }
      push(arr, v.value)
      skipWs()
      let ch = peek()
      if ch == "," { take(); continue }
      if ch == "]" { take(); break }
      return fail("expected , or ]")
    }
    .{ ok: true, value: arr }
  }

  fn parseObject() {
    if take() != "{" { return fail("expected {") }
    skipWs()
    let obj = .{}
    if peek() == "}" { take(); return .{ ok: true, value: obj } }
    for true {
      skipWs()
      if peek() != "\"" { return fail("expected object key string") }
      let k = parseString()
      if !k.ok { return k }
      skipWs()
      if take() != ":" { return fail("expected :") }
      skipWs()
      let v = parseValue()
      if !v.ok { return v }
      obj[k.value] = v.value
      skipWs()
      let ch = peek()
      if ch == "," { take(); continue }
      if ch == "}" { take(); break }
      return fail("expected , or }")
    }
    .{ ok: true, value: obj }
  }

  fn parseValue() {
    skipWs()
    let ch = peek()
    if ch == nil { return fail("unexpected eof") }
    if ch == "\"" { return parseString() }
    if ch == "[" { return parseArray() }
    if ch == "{" { return parseObject() }
    if ch == "t" { return parseLiteral("true", true) }
    if ch == "f" { return parseLiteral("false", false) }
    if ch == "n" { return parseLiteral("null", nil) }
    let o = ord(ch)
    if ch == "-" or (o >= ord("0") and o <= ord("9")) {
      return parseNumber()
    }
    fail("unexpected token")
  }

  let v = parseValue()
  if !v.ok { return v }
  skipWs()
  if st.i != st.n { return .{ ok: false, message: "trailing input", index: st.i } }
  v
}

// ------------------------------------------------------------
// LSP framing + server loop
// ------------------------------------------------------------

fn readExact(n) {
  if n <= 0 { return "" }
  let chunks = []
  let remaining = n
  for remaining > 0 {
    let chunk = Lx.stdin.readBytes(remaining)
    if !chunk { return nil }
    if len(chunk) == 0 { return nil }
    push(chunks, chunk)
    remaining = remaining - len(chunk)
  }
  join(chunks, "")
}

fn readMessage() {
  let contentLength = nil
  for true {
    let line = Lx.stdin.readLine()
    if !line { return nil }
    line = trimLineEnd(line)
    if line == "" {
      break
    }
    let parts = split(line, ":")
    if len(parts) >= 2 {
      let k = tolower(trimSpaces(parts[0]))
      if k == "content-length" {
        let n = tonumber(trimSpaces(parts[1]))
        if n != nil {
          contentLength = Math.floor(n)
        }
      }
    }
  }

  if contentLength == nil {
    return nil
  }

  readExact(contentLength)
}

fn sendJson(obj) {
  let body = jsonStringify(obj)
  let header = "Content-Length: " + str(len(body)) + "\r\n\r\n"
  print(header)
  print(body)
  Lx.stdout.flush()
}

fn sendNotification(method, params) {
  sendJson(.{
    jsonrpc: "2.0",
    method: method,
    params: params,
  })
}

fn sendResponse(id, result) {
  sendJson(.{
    jsonrpc: "2.0",
    id: id,
    result: result,
  })
}

fn sendError(id, code, message) {
  sendJson(.{
    jsonrpc: "2.0",
    id: id,
    error: .{
      code: code,
      message: message,
    },
  })
}

fn sendRequest(state, method, params) {
  let id = state.nextRequestId or 1
  state.nextRequestId = id + 1
  if !state.pendingRequests { state.pendingRequests = .{} }
  state.pendingRequests[id] = .{ method: method }
  sendJson(.{
    jsonrpc: "2.0",
    id: id,
    method: method,
    params: params,
  })
  id
}

fn noteResponse(state, msg) {
  if !state or !state.pendingRequests or msg.id == nil { return }
  state.pendingRequests[msg.id] = nil
}

fn compileForSpec(state, spec) {
  if !spec {
    return nil
  }

  let cached = state.ctxCache and state.ctxCache[spec] or nil
  let ctxResult = cached and cached.epoch == state.epoch and cached.result or nil
  if ctxResult {
    return ctxResult
  }

  ctxResult = query.compileWithDriver(state.driver, spec, .{
    withTypecheck: false,
    mergeScope: "reachable",
  })

  if ctxResult and ctxResult.success {
    state.ctxCache[spec] = .{ epoch: state.epoch, result: ctxResult }
    updateDepGraphFromDriver(state)
    ctxResult
  } else {
    // Compilation failed; fall back to stale cache if available
    let stale = state.staleCtxCache and state.staleCtxCache[spec] or nil
    let staleResult = stale and stale.result or nil
    if staleResult and staleResult.success {
      staleResult
    } else {
      ctxResult
    }
  }
}

fn toLspRange(r) {
  if !r {
    return nil
  }
  .{
    start: .{
      line: (r.line or 1) - 1,
      character: r.col or 0,
    },
    end: .{
      line: (r.endLine or r.line or 1) - 1,
      character: r.endCol or r.col or 0,
    },
  }
}

fn diagSeverityToLsp(sev) {
  if sev == "error" { return 1 }
  if sev == "warning" { return 2 }
  if sev == "info" { return 3 }
  if sev == "hint" { return 4 }
  nil
}

fn toLspDiagnostic(d) {
  if !d {
    return nil
  }

  let range = toLspRange(.{
    line: d.line or 1,
    col: d.col or 0,
    endLine: d.endLine or d.line or 1,
    endCol: d.endCol or d.col or 0,
  })

  let sev = diagSeverityToLsp(d.severity)
  let msg =
    (d.phase and ("[" + d.phase + "] " + (d.message or ""))) or (d.message or "")

  let out = .{
    range: range,
    message: msg,
    source: "lx",
  }
  if sev != nil { out.severity = sev }
  out
}

fn publishDiagnosticsForSpec(state, spec, diags) {
  if !state or !spec {
    return
  }
  if state.openDocs and state.openDocs[spec] == nil and diags and len(diags) > 0 {
    return
  }

  let out = []
  for let i = 0; i < len(diags); i = i + 1 {
    let ld = toLspDiagnostic(diags[i])
    if ld { push(out, ld) }
  }

  let uri = if state.resolver {
    pathToUri(state.resolver.resolve(spec))
  } else {
    pathToUri(spec)
  }

  sendNotification("textDocument/publishDiagnostics", .{
    uri: uri,
    diagnostics: out,
  })
}

fn publishDiagnosticsFromCache(state, spec) {
  if !state or !spec {
    return
  }
  if state.openDocs and state.openDocs[spec] == nil {
    return
  }

  let mod = state.driver and state.driver.cache and state.driver.cache[spec] or nil
  if !mod {
    return
  }

  let diags = query.queryDiagnostics(mod)
  // LSP mode is intentionally fast: no constraint-solver diagnostics.
  let out = []
  for let i = 0; i < len(diags); i = i + 1 {
    let d = diags[i]
    if d and d.phase == "typecheck" {
      continue
    }
    push(out, d)
  }
  publishDiagnosticsForSpec(state, spec, out)
}

fn handleDefinition(state, msg) {
  let params = msg.params or .{}
  let td = params.textDocument or .{}
  let uri = td.uri
  let pos = params.position or .{}

  let absPath = uriToPath(uri)
  if !absPath {
    return nil
  }

  let spec = if state.resolver {
    let roots = state.resolver.roots()
    let base = roots and roots.projectRoot or nil
    if base {
      let prefix = base + "/"
      if startsWith(absPath, prefix) {
        sliceFrom(absPath, len(prefix))
      } else {
        absPath
      }
    } else {
      absPath
    }
  } else {
    absPath
  }

  let ctxResult = compileForSpec(state, spec)
  if !ctxResult or !ctxResult.success or !ctxResult.ctx {
    return nil
  }

  let ln = (pos.line or 0) + 1
  let col = (pos.character or 0)
  let r = query.queryGotoDefinition(ctxResult.ctx, spec, ln, col)
  if !r or !r.success or !r.target {
    return nil
  }

  let target = r.target
  let targetUri = if state.resolver {
    pathToUri(state.resolver.resolve(target.filename))
  } else {
    pathToUri(target.filename)
  }
  .{ uri: targetUri, range: toLspRange(target) }
}

fn handleHover(state, msg) {
  let params = msg.params or .{}
  let td = params.textDocument or .{}
  let uri = td.uri
  let pos = params.position or .{}

  let absPath = uriToPath(uri)
  if !absPath {
    return nil
  }

  let spec = if state.resolver {
    let roots = state.resolver.roots()
    let base = roots and roots.projectRoot or nil
    if base {
      let prefix = base + "/"
      if startsWith(absPath, prefix) {
        sliceFrom(absPath, len(prefix))
      } else {
        absPath
      }
    } else {
      absPath
    }
  } else {
    absPath
  }
  let ctxResult = compileForSpec(state, spec)
  if !ctxResult or !ctxResult.success or !ctxResult.ctx {
    return nil
  }

  let ln = (pos.line or 0) + 1
  let col = pos.character or 0

  let r = query.queryHover(ctxResult.ctx, spec, ln, col)
  if !r or !r.success {
    return nil
  }

  let lines = []
  let sym = r.contents and r.contents.symbol or nil
  let dot = r.contents and r.contents.dot or nil
  let header = nil
  if sym and sym.name {
    let kind = sym.kind and (" (" + sym.kind + ")") or ""
    header = "**" + sym.name + "**" + kind
  } else if dot and dot.propertyName {
    if dot.objectName {
      header = "**" + dot.objectName + "." + dot.propertyName + "**"
    } else {
      header = "**." + dot.propertyName + "**"
    }
  }
  if header {
    push(lines, header)
  }
  let ty = r.contents and r.contents.type or nil
  if ty and ty != "Unknown" {
    push(lines, "`" + ty + "`")
  }
  let prop = r.contents and r.contents.property or nil
  if prop and prop.valueText {
    push(lines, "Value: `" + prop.valueText + "`")
  }
  if sym and sym.declaration and sym.declaration.filename {
    let decl = sym.declaration
    push(lines, "Defined at `" + decl.filename + ":" + str(decl.line or 0) + ":" + str(decl.col or 0) + "`")
  }

  let builtinName = nil
  if sym and sym.kind == "builtin" and (sym.builtinName or sym.name) {
    builtinName = sym.builtinName or sym.name
  } else if dot and dot.path {
    builtinName = dot.path
  }

  if builtinName {
    let doc = builtinsDocs.docFor(builtinName)
    if doc and doc.markdown {
      push(lines, "---")
      push(lines, doc.markdown)
    }
  }

  .{
    contents: .{ kind: "markdown", value: join(lines, "\n") },
    range: toLspRange(r.range),
  }
}

fn handleCompletion(state, msg) {
  let params = msg.params or .{}
  let td = params.textDocument or .{}
  let uri = td.uri
  let pos = params.position or .{}

  let absPath = uriToPath(uri)
  if !absPath {
    return nil
  }

  let spec = if state.resolver {
    let roots = state.resolver.roots()
    let base = roots and roots.projectRoot or nil
    if base {
      let prefix = base + "/"
      if startsWith(absPath, prefix) {
        sliceFrom(absPath, len(prefix))
      } else {
        absPath
      }
    } else {
      absPath
    }
  } else {
    absPath
  }

  let ctxResult = compileForSpec(state, spec)
  if !ctxResult or !ctxResult.success or !ctxResult.ctx {
    return nil
  }

  let ln = (pos.line or 0) + 1
  let col = pos.character or 0

  let r = query.queryCompletion(ctxResult.ctx, spec, ln, col)
  if !r or !r.success {
    return nil
  }

  // Map completion kinds to LSP CompletionItemKind values
  // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItemKind
  fn toLspCompletionKind(kind) {
    if kind == "function" { return 3 }
    if kind == "variable" { return 6 }
    if kind == "property" { return 10 }
    if kind == "enumMember" { return 20 }
    1  // Text fallback
  }

  let items = []
  let completions = r.completions or []
  for let i = 0; i < len(completions); i = i + 1 {
    let c = completions[i]
    let item = .{
      label: c.label,
      kind: toLspCompletionKind(c.kind),
    }
    if c.type {
      item.detail = c.type
    }
    push(items, item)
  }

  items
}

fn serve() {
  let openDocs = .{}

  let state = .{
    openDocs: openDocs,
    shutdown: false,
    epoch: 0,
    ctxCache: .{},
    staleCtxCache: .{},
    deps: .{},
    rdeps: .{},
    graphIndex: 0,
    warmupQueue: [],
    warmupSeen: .{},
    supportsWorkDoneProgress: false,
    warmupProgressToken: nil,
    nextProgressTokenId: 1,
    pendingRequests: .{},
    nextRequestId: 1,
    workspaceRoot: nil,
    driver: nil,
    resolver: nil,
    pendingCompile: .{},
    debounceMs: 100,
    staticModulePaths: .{},
    activeCompile: nil,  // .{ spec, fiber, cancel } - current compilation
  }

  // disable stdio buffering so `Lx.stdin.poll()` and the
  // line-based stdin readers stay consistent (no read-ahead buffering).
  Lx.stdin.unbuffered()

  fn nowMs() {
    Date.now()
  }

  fn scheduleCompile(state, spec) {
    if !state or !spec { return }
    if !state.pendingCompile { state.pendingCompile = .{} }
    state.pendingCompile[spec] = nowMs() + (state.debounceMs or 0)
  }

  fn flushCompileNow(state, spec) {
    if !state or !spec { return }
    if state.pendingCompile { state.pendingCompile[spec] = nil }
    if state.openDocs and state.openDocs[spec] == nil { return }
    if !state.driver { return }

    // Cancel any active compile
    if state.activeCompile and state.activeCompile.cancel {
      state.activeCompile.cancel()
      state.activeCompile = nil
    }

    // Start fiber-based compilation
    let handle = CompilerFiber.startModule(state.driver, spec, .{})
    state.activeCompile = .{ spec: spec, fiber: handle.fiber, cancel: handle.cancel }

    // Poll to completion
    let result = CompilerFiber.poll(handle.fiber, .{ maxEvents: 1000 })

    // Process DEPS events to update dependency graph
    for evt in result.events {
      if evt.kind == Events.EventKind.DEPS {
        updateDepsFromEvent(state, evt.file, evt.deps)
      }
    }

    state.activeCompile = nil
    publishDiagnosticsFromCache(state, spec)
  }

  fn updateDepsFromEvent(state, path, deps) {
    if !state or !path { return }

    // Remove old reverse deps
    let old = state.deps and state.deps[path] or nil
    if old {
      for dep in old {
        if state.rdeps and state.rdeps[dep] {
          state.rdeps[dep][path] = nil
        }
      }
    }

    // Set new deps
    if !state.deps { state.deps = .{} }
    state.deps[path] = deps

    // Add reverse deps
    if !state.rdeps { state.rdeps = .{} }
    for dep in deps {
      if !state.rdeps[dep] { state.rdeps[dep] = .{} }
      state.rdeps[dep][path] = true
    }
  }

  fn flushDueCompiles(state) {
    if !state or !state.pendingCompile { return }
    let ks = keys(state.pendingCompile)
    if !ks or len(ks) == 0 { return }
    let t = nowMs()
    for let i = 0; i < len(ks); i = i + 1 {
      let spec = ks[i]
      let deadline = state.pendingCompile[spec]
      if deadline != nil and deadline <= t {
        flushCompileNow(state, spec)
      }
    }
  }

  fn nextCompileTimeoutMs(state) {
    if !state or !state.pendingCompile { return nil }
    let ks = keys(state.pendingCompile)
    if !ks or len(ks) == 0 { return nil }
    let t = nowMs()
    let best = nil
    for let i = 0; i < len(ks); i = i + 1 {
      let spec = ks[i]
      let deadline = state.pendingCompile[spec]
      if deadline == nil { continue }
      let dt = Math.floor(deadline - t)
      if dt < 0 { dt = 0 }
      if best == nil or dt < best { best = dt }
    }
    best
  }

  fn ensureResolver(entryPath) {
    if !state.resolver and entryPath {
      state.resolver = ModuleResolution.forEntry(entryPath)
    }
  }

  fn pathToSpecifier(path) {
    if !state.resolver {
      return path
    }
    let roots = state.resolver.roots()
    let base = roots and roots.projectRoot or nil
    if !base {
      return path
    }

    let prefix = base + "/"
    if startsWith(path, prefix) {
      return sliceFrom(path, len(prefix))
    }
    path
  }

  fn specifierToUri(specifier) {
    if !state.resolver {
      return pathToUri(specifier)
    }
    pathToUri(state.resolver.resolve(specifier))
  }

  let loadSource = fn(path) {
    if openDocs[path] != nil {
      return openDocs[path]
    }
    if !state.resolver {
      Lx.stderr.println("LSP: No resolver initialized, cannot load:", path)
      return nil
    }
    state.resolver.slurp(path)
  }

  state.driver = Driver.make(.{
    profile: "query",
    loadSource: loadSource,
    withImportLower: false,
  })

  fn startWarmupProgressIfNeeded() {
    if !state.supportsWorkDoneProgress { return }
    if state.warmupProgressToken { return }
    if !state.warmupQueue or len(state.warmupQueue) == 0 { return }

    let token = "lx-warmup-" + str(state.nextProgressTokenId)
    state.nextProgressTokenId = state.nextProgressTokenId + 1
    state.warmupProgressToken = token

    sendRequest(state, "window/workDoneProgress/create", .{ token: token })
    sendNotification("$/progress", .{
      token: token,
      value: .{
        kind: "begin",
        title: "Indexing lx",
        cancellable: false,
        message: "Warming cachesâ€¦",
      },
    })
  }

  fn reportWarmupProgress(message) {
    let token = state.warmupProgressToken
    if !token { return }
    sendNotification("$/progress", .{
      token: token,
      value: .{
        kind: "report",
        cancellable: false,
        message: message,
      },
    })
  }

  fn endWarmupProgress() {
    let token = state.warmupProgressToken
    if !token { return }
    state.warmupProgressToken = nil
    sendNotification("$/progress", .{
      token: token,
      value: .{
        kind: "end",
        message: "Warmup complete",
      },
    })
  }

  fn warmupTick() {
    if state.warmupQueue and len(state.warmupQueue) > 0 {
      startWarmupProgressIfNeeded()
      let before = len(state.warmupQueue)
      let warmed = runWarmupStep(state)
      let after = len(state.warmupQueue)
      if warmed and before >= after {
        reportWarmupProgress("Warmed " + warmed + " (" + str(after) + " remaining)")
      }
    }
    if state.warmupQueue and len(state.warmupQueue) == 0 {
      endWarmupProgress()
    }
  }

  for true {
    // Run any scheduled work before waiting for the next message.
    flushDueCompiles(state)

    // wait with a timeout so we can debounce didChange compilation without threads.
    let timeout = nextCompileTimeoutMs(state)
    let ready = Lx.stdin.poll(timeout == nil and -1 or timeout)
    if !ready {
      warmupTick()
      continue
    }

    let body = readMessage()
    if !body { break }

    let parsed = jsonParse(body)
    if !parsed.ok {
      // No request id available; best-effort log.
      Lx.stderr.println("lsp: json parse error:", parsed.message, "at", parsed.index)
      continue
    }

    let msg = parsed.value
    let method = msg.method
    let id = msg.id

    // Responses to server->client requests (e.g. workDoneProgress/create)
    if method == nil and id != nil {
      noteResponse(state, msg)
      warmupTick()
      continue
    }

    // Requests
    if method == "initialize" {
      // Capture client capabilities
      let caps = msg.params and msg.params.capabilities or .{}
      let win = caps and caps.window or .{}
      state.supportsWorkDoneProgress = win and win.workDoneProgress == true

      // Capture workspace root for module resolution
      let rootUri = msg.params and msg.params.rootUri or nil
      if rootUri {
        let rootPath = uriToPath(rootUri)
        if rootPath {
          state.workspaceRoot = rootPath
          // Create a resolver using a sentinel entry in the workspace
          // This allows module resolution to work before any file is opened
          ensureResolver(Lx.path.join(rootPath, "main.lx"))
        }
      }

      sendResponse(id, .{
        capabilities: .{
          definitionProvider: true,
          hoverProvider: true,
          completionProvider: .{
            triggerCharacters: ["."],
          },
          textDocumentSync: .{ openClose: true, change: 1, save: .{ includeText: true } },
        },
        serverInfo: .{ name: "lx", version: Lx.version },
      })
      continue
    }

    if method == "shutdown" {
      state.shutdown = true
      if id != nil { sendResponse(id, nil) }
      continue
    }

    // Notifications
    if method == "exit" {
      Lx.exit(state.shutdown and 0 or 1)
    }
    if method == "initialized" {
      // Pre-warm static modules (generated data that doesn't change during editing)
      if state.resolver and state.driver {
        let staticModules = ["services/builtins_docs_data.lx"]
        for let i = 0; i < len(staticModules); i = i + 1 {
          let modulePath = staticModules[i]
          let resolved = state.resolver.resolve(modulePath)
          if resolved {
            // Record the canonical resolved path as static
            state.staticModulePaths[resolved] = true
            // Pre-compile the static module immediately
            state.driver.compileModule(resolved)
          }
        }
      }
      warmupTick()
      continue
    }

    if method == "textDocument/didOpen" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      ensureResolver(abs)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec and td.text != nil {
        state.openDocs[spec] = td.text
        if state.pendingCompile { state.pendingCompile[spec] = nil }
        let invalidated = invalidate(state, spec)
        for let i = 0; i < len(invalidated); i = i + 1 {
          let p = invalidated[i]
          if state.openDocs[p] != nil {
            publishDiagnosticsForSpec(state, p, [])
          }
        }
        enqueueWarmup(state, spec)
        if state.supportsWorkDoneProgress {
          startWarmupProgressIfNeeded()
          reportWarmupProgress("Queued " + spec)
        }
        compileForSpec(state, spec)
        publishDiagnosticsFromCache(state, spec)
      }
      warmupTick()
      continue
    }

    if method == "textDocument/didChange" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      let changes = (msg.params and msg.params.contentChanges) or []
      if spec and len(changes) > 0 and changes[0].text != nil {
        state.openDocs[spec] = changes[0].text
        // Invalidate just this file (not dependents) and recompile the module.
        // Avoid rebuilding the merged query context on every keystroke; it will be
        // (re)built lazily on demand by hover/definition/completion.
        invalidateSingle(state, spec)
        scheduleCompile(state, spec)
      }
      warmupTick()
      continue
    }

    if method == "textDocument/didSave" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec {
        if state.pendingCompile { state.pendingCompile[spec] = nil }
        // Some clients include `text` with didSave; if present, keep it.
        if msg.params and msg.params.text != nil {
          state.openDocs[spec] = msg.params.text
        }
        // Invalidate this file + all dependents transitively
        let invalidated = invalidate(state, spec)
        for let i = 0; i < len(invalidated); i = i + 1 {
          let p = invalidated[i]
          if state.openDocs[p] != nil {
            publishDiagnosticsForSpec(state, p, [])
          }
        }
        // Recompile the saved file
        compileForSpec(state, spec)
        publishDiagnosticsFromCache(state, spec)
        // Recompile any open dependents (files that import this one)
        for let i = 0; i < len(invalidated); i = i + 1 {
          let p = invalidated[i]
          if p != spec and state.openDocs[p] != nil {
            compileForSpec(state, p)
            publishDiagnosticsFromCache(state, p)
          }
        }
        enqueueWarmup(state, spec)
        if state.supportsWorkDoneProgress {
          startWarmupProgressIfNeeded()
          reportWarmupProgress("Queued " + spec)
        }
      }
      warmupTick()
      continue
    }

    if method == "textDocument/didClose" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec {
        state.openDocs[spec] = nil
        if state.pendingCompile { state.pendingCompile[spec] = nil }
        invalidate(state, spec)
        publishDiagnosticsForSpec(state, spec, [])
      }
      continue
    }

    if method == "textDocument/definition" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec and state.pendingCompile and state.pendingCompile[spec] != nil {
        flushCompileNow(state, spec)
      }
      let loc = handleDefinition(state, msg)
      if id != nil {
        sendResponse(id, loc)
      }
      warmupTick()
      continue
    }

    if method == "textDocument/hover" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec and state.pendingCompile and state.pendingCompile[spec] != nil {
        flushCompileNow(state, spec)
      }
      let h = handleHover(state, msg)
      if id != nil {
        sendResponse(id, h)
      }
      warmupTick()
      continue
    }

    if method == "textDocument/completion" {
      let td = (msg.params and msg.params.textDocument) or .{}
      let abs = uriToPath(td.uri)
      let spec = abs and pathToSpecifier(abs) or nil
      if spec and state.pendingCompile and state.pendingCompile[spec] != nil {
        flushCompileNow(state, spec)
      }
      let items = handleCompletion(state, msg)
      if id != nil {
        sendResponse(id, items)
      }
      warmupTick()
      continue
    }

    if method == "window/workDoneProgress/cancel" {
      // We don't currently support cancel; ignore.
      warmupTick()
      continue
    }

    // Unknown request: respond with Method not found.
    if id != nil {
      sendError(id, -32601, "Method not found: " + str(method))
    }

    warmupTick()
  }
}

.{
  serve,
  jsonParse,
  jsonStringify,
  uriToPath,
  pathToUri,
}
