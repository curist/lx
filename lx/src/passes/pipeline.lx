// Pipeline Runner - Generic pass orchestration with unified error handling
//
// Provides:
// - runPasses: Execute a list of passes with state threading
// - normalizeErrors: Ensure errors have pass attribution
// - validatePassDependencies: Check requires/provides consistency

// ========================================
// Validate Pass Dependencies
// ========================================

fn validatePassDependencies(passList) {
  // Check that all enabled passes have their requirements satisfied by earlier passes
  // Returns .{ valid: true } or .{ valid: false, errors: [...] }

  let provided = .{}  // Track what capabilities are available
  let errors = []

  for p in passList {
    if !p or !p.name { continue }

    // Check requirements
    if p.requires {
      for req in p.requires {
        if !provided[req] {
          let msg = "Pass '" + p.name + "' requires '" + req + "', but no earlier pass provides it"
          push(errors, msg)
        }
      }
    }

    // Register what this pass provides
    if p.provides {
      for cap in p.provides {
        provided[cap] = true
      }
    }
  }

  if len(errors) > 0 {
    return .{ valid: false, errors }
  }

  .{ valid: true }
}

// ========================================
// Normalize Errors
// ========================================

fn normalizeErrors(passName, errors) {
  // Ensure errors is an array and tag object errors with pass name
  if !errors { return [] }

  // Ensure array
  let out = type(errors) == "array" and errors or [errors]

  // Tag objects with pass name if missing
  for e in out {
    if type(e) == "map" and !e.pass {
      e.pass = passName
    }
  }

  out
}

// ========================================
// Helper: Convert pass name to opt key
// ========================================

fn passNameToOptKey(passName) {
  // Convert pass name to opt key: "anf-inline" â†’ "withAnfInline"
  // Pattern: "with" + PascalCase(passName with dashes removed)

  if !passName { return nil }

  // Split by dash and capitalize each word
  let parts = []
  let current = ""
  for ch in range(passName) {
    if ch == "-" {
      if len(current) > 0 {
        push(parts, current)
        current = ""
      }
    } else {
      current = current + ch
    }
  }
  if len(current) > 0 {
    push(parts, current)
  }

  // Capitalize first letter of each part
  let result = "with"
  for part in parts {
    if len(part) > 0 {
      // Capitalize first letter
      let first = toupper(part[0])
      let rest = ""
      for ch, j in range(part) {
        if j > 0 { rest = rest + ch }
      }
      result = result + first + rest
    }
  }

  result
}

// ========================================
// Run Passes
// ========================================

fn runPasses(passList, ctx, state) {
  // Execute passes in order, threading state between them
  // Returns a pipeline result with pass outputs and final state

  let passesOut = .{}
  let passOrder = []
  let failedPass = nil

  // Ensure state.passes exists
  if !state.passes { state.passes = .{} }

  // Build enabled pass list for validation
  let enabledPasses = []
  let provided = .{}  // Track capabilities provided by enabled passes

  for p in passList {
    if !p or !p.name or !p.run { continue }

    // Check if pass is disabled via opts (e.g., ctx.opts.withAnf == false)
    let optKey = passNameToOptKey(p.name)
    let disabledByOpt = ctx and ctx.opts and optKey and ctx.opts[optKey] == false
    if disabledByOpt {
      continue
    }

    // Check if requirements are satisfied by earlier enabled passes
    let requirementsMet = true
    if p.requires {
      for req in p.requires {
        if !provided[req] {
          requirementsMet = false
          break
        }
      }
    }

    // Only check enabled if requirements are met
    let enabled = requirementsMet
    if enabled and p.enabled {
      enabled = p.enabled(ctx, state)
    }

    if enabled {
      push(enabledPasses, p)

      // Register capabilities this pass provides
      if p.provides {
        for cap in p.provides {
          provided[cap] = true
        }
      }
    }
  }

  // Validate dependencies (always on)
  let validation = validatePassDependencies(enabledPasses)
  if !validation.valid {
    // Dependency validation failed - return as synthetic failed pass
    // This ensures errors.collectErrors() can surface validation errors
    Lx.stderr.println("Pipeline dependency validation failed:")
    for err in validation.errors {
      Lx.stderr.println("  " + err)
    }
    return .{
      status: "failed",
      success: false,
      path: state.path,
      failedPass: "validate",
      passOrder: ["validate"],
      passes: .{
        validate: .{
          success: false,
          errors: validation.errors,
        },
      },
    }
  }

  // Execute enabled passes
  for p in enabledPasses {
    push(passOrder, p.name)

    // Optional mutation check (debug mode)
    let oldAst = state.ast
    let shouldCheckMutation = ctx and ctx.debug and ctx.debug.validatePasses and p.mutatesAst == false

    // Run the pass
    let raw = p.run(ctx, state) or .{ success: false, errors: ["Pass returned nil: " + p.name] }

    // Mutation check: if mutatesAst: false, verify AST wasn't mutated
    if shouldCheckMutation {
      let newAst = raw.ast or state.ast
      if oldAst and newAst and oldAst == newAst {
        // Same pointer - but could still be mutated fields (we can't deep-check cheaply)
        // This only catches passes that returned a new pointer when they shouldn't mutate
      } else if oldAst and newAst and oldAst != newAst {
        // Different pointer is OK for non-mutating passes (they return new AST)
      }
      // Note: We can't reliably detect in-place mutation without deep equality check
      // This is a best-effort pointer identity check
    }

    // Normalize errors with pass attribution
    raw.errors = normalizeErrors(p.name, raw.errors)

    // Record output
    passesOut[p.name] = raw
    state.passes[p.name] = raw

    // Thread state: update ast and nextNodeId if provided
    if raw.ast { state.ast = raw.ast }
    if raw.nextNodeId { state.nextNodeId = raw.nextNodeId }

    // Check for failure (unless pass is non-fatal)
    let isFatal = true  // Default: fatal=true
    if p.fatal == false {
      isFatal = false
    }
    if !raw.success and isFatal {
      failedPass = p.name
      break
    }

    // Debug: stop after specific pass
    if ctx and ctx.debug and ctx.debug.stopAfter and ctx.debug.stopAfter == p.name {
      break
    }
  }

  .{
    status: failedPass and "failed" or "done",
    success: failedPass == nil,
    path: state.path,
    failedPass: failedPass,
    passOrder: passOrder,
    passes: passesOut,
    ast: state.ast,
    nextNodeId: state.nextNodeId,
  }
}

// ========================================
// Module Exports
// ========================================

.{
  runPasses,
  normalizeErrors,
  validatePassDependencies,
}
