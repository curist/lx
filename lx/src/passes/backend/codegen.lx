// Codegen Phase - Emit bytecode from resolved ANF AST
// Responsibility: Mechanical bytecode emission, no semantic decisions.

let .{ OP, ValueType, NODE } = import "src/types.lx"
let object = import "src/object.lx"
let select = import "src/select.lx"

let ObjType = object.ObjType

let UINT16_MAX = 256 * 256

fn Value(kind, value) {.{
  kind,
  value,
}}

fn Chunk(filename) {.{
  filename,
  bytecode: [],
  constants: [],
  lines: [],
  nodeIds: [],
  constantsCache: .{},
  importConstCache: .{},
}}

fn Function(name, arity, chunk) {.{
  name,
  arity,
  chunk,
  upvalueCount: 0,
}}

fn NUMBER_VAL(value) { Value(ValueType.NUMBER, value) }
fn BOOL_VAL(value) { Value(ValueType.BOOL, value) }
fn OBJ_VAL(value) { Value(ValueType.OBJ, value) }

fn ObjectFunction(func) { OBJ_VAL(object.ObjectFunction(func)) }
fn ObjectString(string) { OBJ_VAL(object.ObjectString(string)) }

fn addError(gen, node, message) {
  push(gen.errors, .{
    nodeId: node and node.id or 0,
    message: message,
    severity: "error",
  })
}

// Primitive emit functions - do not call each other to avoid overhead
// Store bytes as numbers, not hex strings (objbuilder will convert)
fn emit1(gen, b, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 1
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, Math.floor(b))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

fn emit2(gen, b1, b2, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 2
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, Math.floor(b1))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, Math.floor(b2))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

fn emit3(gen, b1, b2, b3, line) {
  gen.metrics.emitCalls = gen.metrics.emitCalls + 3
  let chunk = gen.currentFunction.chunk
  let ln = line or gen.currentLine or 1
  let nodeId = gen.currentNode and gen.currentNode.id or 0

  push(chunk.bytecode, Math.floor(b1))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, Math.floor(b2))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
  push(chunk.bytecode, Math.floor(b3))
  push(chunk.lines, ln)
  push(chunk.nodeIds, nodeId)
}

// Backwards compatibility wrappers
fn emitByte(gen, byte, line) { emit1(gen, byte, line) }
fn emitBytes(gen, byte1, byte2, line) { emit2(gen, byte1, byte2, line) }

fn emitLoop(gen, loopStart, line) {
  emit1(gen, OP.LOOP, line)
  let offset = len(gen.currentFunction.chunk.bytecode) - loopStart + 2
  emit2(gen, Math.floor(offset / 256), offset % 256, line)
}

fn emitJump(gen, instruction, line) {
  emit3(gen, instruction, 255, 255, line)
  return len(gen.currentFunction.chunk.bytecode) - 2
}

fn patchJump(gen, offset) {
  gen.metrics.patchCount = gen.metrics.patchCount + 1
  let jump = len(gen.currentFunction.chunk.bytecode) - offset - 2
  if jump > UINT16_MAX {
    addError(gen, gen.currentNode, "Too much code to jump over.")
  }
  gen.currentFunction.chunk.bytecode[offset] = Math.floor(jump / 256)
  gen.currentFunction.chunk.bytecode[offset + 1] = jump % 256
}

fn calcValueKey(value) {
  let k = str(value.kind) + ":"
  if value.kind == ValueType.NUMBER {
    k = k + str(value.value)
  } else if value.kind == ValueType.OBJ {
    let obj = value.value
    k = k + str(obj.kind) + ":"
    if obj.kind == ObjType.STRING {
      k = k + obj.value
    } else {
      return "nocache"
    }
  } else {
    return "nocache"
  }
  k
}

fn addConstant(chunk, value, gen) {
  gen.metrics.constLookups = gen.metrics.constLookups + 1
  let k = calcValueKey(value)
  if k == "nocache" {
    gen.metrics.constAdds = gen.metrics.constAdds + 1
    push(chunk.constants, value)
    return len(chunk.constants) - 1
  }
  let index = chunk.constantsCache[k]
  if index {
    gen.metrics.constHits = gen.metrics.constHits + 1
    return index
  }
  gen.metrics.constAdds = gen.metrics.constAdds + 1
  push(chunk.constants, value)
  index = len(chunk.constants) - 1
  chunk.constantsCache[k] = index
  index
}

fn makeConstant(gen, value) {
  let constant = addConstant(gen.currentFunction.chunk, value, gen)
  if constant >= 65536 {
    addError(gen, gen.currentNode, "Too many constants in one chunk.")
    return 0
  }
  constant
}

fn emitConstant(gen, value, line) {
  let index = makeConstant(gen, value)
  if index >= 256 {
    // Use CONSTANT_LONG for indices 256-65535
    // Use bit shift to extract high byte
    emit3(gen, OP.CONSTANT_LONG, (index >> 8) & 255, index & 255, line)
  } else {
    emitBytes(gen, OP.CONSTANT, index, line)
  }
}

// Helper: emit global operation with automatic short/long selection
fn emitGlobalOp(gen, shortOp, longOp, name, line) {
  let idx = makeConstant(gen, ObjectString(name))
  if idx >= 256 {
    emit3(gen, longOp, (idx >> 8) & 255, idx & 255, line)
  } else {
    emitBytes(gen, shortOp, idx, line)
  }
}

// Helper: emit upvalue operation with automatic short/long selection
fn emitUpvalueOp(gen, shortOp, longOp, slot, line) {
  if slot >= 256 {
    emit3(gen, longOp, (slot >> 8) & 255, slot & 255, line)
  } else {
    emitBytes(gen, shortOp, slot, line)
  }
}

// Helper: emit closure with automatic short/long selection
fn emitClosure(gen, func, line) {
  let constIndex = makeConstant(gen, ObjectFunction(func))
  if constIndex >= 256 {
    emit3(gen, OP.CLOSURE_LONG, (constIndex >> 8) & 255, constIndex & 255, line)
  } else {
    emitBytes(gen, OP.CLOSURE, constIndex, line)
  }
  constIndex
}

fn identifierConstant(gen, name) {
  makeConstant(gen, ObjectString(name))
}

fn buildDeclMap(scopeInfo) {
  let map = .{}
  let scopeIds = keys(scopeInfo or .{})
  for id in scopeIds {
    let scope = scopeInfo[id]
    let locals = scope and scope.locals or []
    for local in locals {
      if local.nodeId {
        map[local.nodeId] = local
      }
    }
  }
  map
}

fn localSlot(slot) {
  slot + 1
}

fn computeAbsoluteSlot(gen, binding) {
  // Look up the absolute slot that was recorded when this local was emitted
  let absoluteSlot = gen.emittedLocals[binding.declaredAt]
  if absoluteSlot or absoluteSlot == 0 {
    return absoluteSlot
  }

  // If not found, this is an error - the local should have been emitted
  addError(gen, gen.currentNode, "Internal error: local not emitted for binding")
  0
}

fn computeAbsoluteSlotForUpvalue(gen, scopeRelativeSlot) {
  // Compute absolute position for an upvalue that captures from parent scope
  // The scopeRelativeSlot is relative to the immediate parent scope (top of scopeStack)
  // We need to compute its absolute position by summing locals from all ancestor scopes

  let absoluteSlot = 0
  let stackLen = len(gen.scopeStack)

  // Sum up locals from all scopes except the last one
  for let i = 0; i < stackLen - 1; i = i + 1 {
    let scope = gen.scopeStack[i]
    let locals = scope.locals or []
    absoluteSlot = absoluteSlot + len(locals)
  }

  // Add the scope-relative slot from the parent scope (last scope in stack)
  absoluteSlot = absoluteSlot + scopeRelativeSlot

  absoluteSlot
}

fn pushScope(gen, node) {
  let info = gen.scopeInfo[node.id]
  if info {
    push(gen.scopeStack, info)
  }
  push(gen.scopeBaseSlots, gen.nextLocalSlot)
}

fn popScope(gen) {
  if len(gen.scopeStack) > 0 {
    pop(gen.scopeStack)
  }
  if len(gen.scopeBaseSlots) > 0 {
    pop(gen.scopeBaseSlots)
  }
}

fn endScope(gen, node) {
  let scope = gen.scopeInfo[node.id]
  if !scope { return }
  let locals = scope.locals or []
  for let i = len(locals) - 1; i >= 0; i = i - 1 {
    let local = locals[i]
    if local.isCaptured {
      emitByte(gen, OP.CLOSE_UPVALUE, gen.currentLine)
    } else {
      emitByte(gen, OP.POP, gen.currentLine)
    }
    // Decrement the local slot counter as we pop locals
    gen.nextLocalSlot = gen.nextLocalSlot - 1
  }
}

fn unwindToSlot(gen, targetSlot) {
  // Emit OP_UNWIND for non-local exits (break/continue)
  // NOTE: We do NOT decrement gen.nextLocalSlot here because:
  // 1. This emits code for the break/continue path (which jumps away)
  // 2. endScope will handle nextLocalSlot bookkeeping for the normal path
  // 3. After emitting the jump, we never emit more code on this path, so out-of-sync nextLocalSlot is fine

  let toPop = gen.nextLocalSlot - targetSlot
  if toPop <= 0 { return }

  // Emit UNWIND with keep=0 (break/continue don't preserve a value)
  emitByte(gen, OP.UNWIND, gen.currentLine)
  emitByte(gen, toPop, gen.currentLine)  // count
  emitByte(gen, 0, gen.currentLine)      // keep=0
}

fn patchBreaks(gen) {
  let breaker = gen.breakOffsets[len(gen.breakOffsets) - 1]
  let currentAddr = len(gen.currentFunction.chunk.bytecode)
  for addr in breaker {
    let jump = currentAddr - addr - 2
    if jump > UINT16_MAX {
      addError(gen, gen.currentNode, "Too much code to jump over.")
    }
    gen.currentFunction.chunk.bytecode[addr] = Math.floor(jump / 256)
    gen.currentFunction.chunk.bytecode[addr + 1] = jump % 256
  }
}

fn patchContinues(gen) {
  let continues = gen.continueOffsets[len(gen.continueOffsets) - 1]
  let currentAddr = len(gen.currentFunction.chunk.bytecode)
  for addr in continues {
    let jump = currentAddr - addr - 2
    if jump > UINT16_MAX {
      addError(gen, gen.currentNode, "Loop body too large.")
    }
    gen.currentFunction.chunk.bytecode[addr] = Math.floor(jump / 256)
    gen.currentFunction.chunk.bytecode[addr + 1] = jump % 256
  }
}

let MODE = .{ VALUE: 1, STMT: 2 }


fn compileValue(gen, node) { compileExpr(gen, node, MODE.VALUE) }
fn compileStmt(gen, node) { compileExpr(gen, node, MODE.STMT) }

fn compileLiteral(gen, node) {
  if node.type == NODE.Nil {
    emitByte(gen, OP.NIL, node.line)
  } else if node.type == NODE.Bool {
    emitByte(gen, node.value and OP.TRUE or OP.FALSE, node.line)
  } else if node.type == NODE.Number {
    let value = node.value
    if value >= 0 and value < 256 and Math.floor(value) == value {
      emitBytes(gen, OP.CONST_BYTE, value, node.line)
    } else {
      emitConstant(gen, NUMBER_VAL(value), node.line)
    }
  } else if node.type == NODE.String {
    emitConstant(gen, ObjectString(node.value), node.line)
  }
}

fn compileIdentifier(gen, node) {
  let binding = gen.resolvedNames[node.id]
  if !binding {
    addError(gen, node, "Unresolved identifier: " + node.name)
    return
  }
  if binding.kind == "local" {
    let absoluteSlot = computeAbsoluteSlot(gen, binding)
    emitBytes(gen, binding.getOp, localSlot(absoluteSlot), node.line)
  } else if binding.kind == "upvalue" {
    emitUpvalueOp(gen, binding.getOp, OP.GET_UPVALUE_LONG, binding.upvalueIndex, node.line)
  } else {
    // Global variable - use long form if needed
    emitGlobalOp(gen, binding.getOp, OP.GET_GLOBAL_LONG, binding.name, node.line)
  }
}

fn compileLet(gen, node, mode) {
  let local = gen.localsByDecl[node.name.id]

  // DCE: Check if this Let is dead (unused local)
  // Still emit NIL to preserve slot indices, but skip compiling the init expression
  if gen.deadNodes[node.id] and local {
    emitByte(gen, OP.NIL, node.line)
    gen.emittedLocals[local.nodeId] = gen.nextLocalSlot
    let slot = gen.nextLocalSlot
    gen.nextLocalSlot = gen.nextLocalSlot + 1

    if mode == MODE.VALUE {
      emitBytes(gen, OP.GET_LOCAL, localSlot(slot), node.line)
    }
    return
  }

  if node.init {
    compileValue(gen, node.init)
  } else {
    emitByte(gen, OP.NIL, node.line)
  }

  if local {
    // Record the absolute slot for this local
    gen.emittedLocals[local.nodeId] = gen.nextLocalSlot
    let slot = gen.nextLocalSlot
    gen.nextLocalSlot = gen.nextLocalSlot + 1

    if mode == MODE.VALUE {
      // GET_LOCAL to read the local as expression result (not DUP)
      emitBytes(gen, OP.GET_LOCAL, localSlot(slot), node.line)
    }
    // STMT mode: local stays on stack, no extra value needed
  } else {
    if mode == MODE.VALUE {
      emitByte(gen, OP.DUP, node.line)
    }
    emitGlobalOp(gen, OP.DEFINE_GLOBAL, OP.DEFINE_GLOBAL_LONG, node.name.name, node.line)
  }
}

fn compileBlock(gen, node, mode) {
  pushScope(gen, node)

  // CRITICAL FIX: Pre-emit hoisted function locals to match resolver's slot allocation
  // Resolver allocates slots for hoisted functions during prescan (before expressions)
  // Codegen must do the same to keep slot numbering consistent
  let scope = gen.scopeInfo[node.id]
  if scope and scope.hoistedFns {
    let hoistedNames = keys(scope.hoistedFns)

    // Collect hoisted functions with their declaration indices
    let hoistedList = collect name in hoistedNames {
      scope.hoistedFns[name]
    }->sort(fn(a, b) { a.declIndex < b.declIndex })

    // Pre-allocate locals for hoisted functions
    for hoisted in hoistedList {
      gen.emittedLocals[hoisted.declNodeId] = gen.nextLocalSlot
      gen.nextLocalSlot = gen.nextLocalSlot + 1

      emitByte(gen, OP.NIL, node.line)
      // NIL stays on stack until endScope - this IS the reserved slot
    }
  }

  let exprs = node.expressions or []
  if len(exprs) == 0 {
    // Empty block: nil in VALUE mode, nothing in STMT mode
    if mode == MODE.VALUE {
      emitByte(gen, OP.NIL, node.line)
    }
  } else {
    for expr, i in exprs {
      if i < len(exprs) - 1 {
        compileStmt(gen, expr)
      } else {
        // Last expression: compile according to block's mode
        if mode == MODE.VALUE {
          compileValue(gen, expr)
        } else {
          compileStmt(gen, expr)
        }
      }
    }
  }

  // Block exit - UNWIND pops locals, optionally preserving result
  // VALUE mode: [... locals... result] → UNWIND toPop 1 → [... result]
  // STMT mode:  [... locals... ] → UNWIND toPop 0 → [... ]
  let baseSlot = gen.scopeBaseSlots[len(gen.scopeBaseSlots) - 1]
  let toPop = gen.nextLocalSlot - baseSlot

  // Optimize: skip UNWIND 0 K (no locals to pop = noop)
  if toPop > 0 {
    emitByte(gen, OP.UNWIND, node.line)
    emitByte(gen, toPop, node.line)  // count = actual stack slots to pop
    if mode == MODE.VALUE {
      emitByte(gen, 1, node.line)  // keep=1: preserve block result
    } else {
      emitByte(gen, 0, node.line)  // keep=0: statement mode, no result needed
    }
  }

  // Update slot counter - locals are now popped
  gen.nextLocalSlot = baseSlot

  // No endScope() - UNWIND handled closing/popping locals
  popScope(gen)
}

fn compileUnary(gen, node) {
  compileValue(gen, node.operand)
  let opcode = select.unaryOpcode(gen, node)
  if !opcode {
    addError(gen, node, "Unsupported unary op: " + (node.operator and node.operator.lexeme or ""))
    return
  }
  emitByte(gen, opcode, node.line)
}

fn compileBinary(gen, node) {
  // Note: Pattern optimizations (x % N → MOD_CONST_BYTE, x == M → EQ_CONST_BYTE)
  // are done in ANF phase, not here, to work correctly with ANF transformations

  compileValue(gen, node.left)
  compileValue(gen, node.right)

  let code = select.binaryCode(gen, node)
  if !code {
    addError(gen, node, "Unsupported binary op: " + (node.operator and node.operator.lexeme or ""))
    return
  }

  if type(code) == "array" {
    emitBytes(gen, code[0], code[1], node.line)
  } else {
    emitByte(gen, code, node.line)
  }
}

fn compileLogical(gen, node) {
  compileValue(gen, node.left)
  let op = node.operator and node.operator.lexeme or ""

  if op == "and" {
    emitByte(gen, OP.DUP, node.line)
    let endJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
    emitByte(gen, OP.POP, node.line)
    compileValue(gen, node.right)
    patchJump(gen, endJump)
    return
  }

  if op == "or" {
    // Try coalesce-const optimization first
    let plan = select.logicalOrCoalesceConst(gen, node)
    if plan and plan.kind == "coalesce_const" {
      // Build constant (this stays in codegen because it mutates chunk constants)
      let constValue = nil
      if plan.valueType == "Number" {
        constValue = NUMBER_VAL(plan.value)
      } else {
        constValue = ObjectString(plan.value)
      }
      let constIndex = makeConstant(gen, constValue)
      if constIndex >= 256 {
        emit3(gen, OP.COALESCE_CONST_LONG, (constIndex >> 8) & 255, constIndex & 255, node.line)
      } else {
        emitBytes(gen, OP.COALESCE_CONST, constIndex, node.line)
      }
      return
    }

    // General case: use jump-based implementation
    emitByte(gen, OP.DUP, node.line)
    let endJump = emitJump(gen, OP.JUMP_IF_TRUE, node.line)
    emitByte(gen, OP.POP, node.line)
    compileValue(gen, node.right)
    patchJump(gen, endJump)
    return
  }

  addError(gen, node, "Unsupported logical op: " + op)
}

fn compileIf(gen, node, mode) {
  compileValue(gen, node.condition)
  let thenJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
  compileExpr(gen, node.then, mode)
  let elseJump = emitJump(gen, OP.JUMP, node.line)
  patchJump(gen, thenJump)
  if node.else {
    compileExpr(gen, node.else, mode)
  } else if mode == MODE.VALUE {
    emitByte(gen, OP.NIL, node.line)
  }
  patchJump(gen, elseJump)
}

fn compileCall(gen, node) {
  compileValue(gen, node.callee)
  let args = node.args or []
  for arg in args {
    compileValue(gen, arg)
  }
  emitBytes(gen, OP.CALL, len(args), node.line)
}

fn compileIntrinsicCall(gen, node) {
  // Compile intrinsic operations that map directly to opcodes
  // IMPORTANT: This is called from expression position, so must leave
  // exactly one value on stack on ALL paths (including errors).
  let args = node.args or []

  if node.intrinsic == "array_new" {
    // array_new expects 0 args
    if len(args) != 0 {
      addError(gen, node, "Internal error: array_new expects 0 args, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    // Create empty array
    emitByte(gen, OP.ARRAY, node.line)
  } else if node.intrinsic == "array_append" {
    // array_append expects 2 args: array, value
    if len(args) != 2 {
      addError(gen, node, "Internal error: array_append expects 2 args, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    // Compile args: array, value
    for arg in args {
      compileValue(gen, arg)
    }
    emitByte(gen, OP.APPEND, node.line)
  } else if node.intrinsic == "mod_const" {
    // mod_const expects 1 arg: value, plus modulus field
    if len(args) != 1 {
      addError(gen, node, "Internal error: mod_const expects 1 arg, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    compileValue(gen, args[0])
    emitByte(gen, OP.MOD_CONST_BYTE, node.line)
    emitByte(gen, node.modulus, node.line)
  } else if node.intrinsic == "eq_const" {
    // eq_const expects 1 arg: value, plus compareTo field
    if len(args) != 1 {
      addError(gen, node, "Internal error: eq_const expects 1 arg, got " + str(len(args)))
      emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
      return
    }
    compileValue(gen, args[0])
    emitByte(gen, OP.EQ_CONST_BYTE, node.line)
    emitByte(gen, node.compareTo, node.line)
  } else {
    addError(gen, node, "Unknown intrinsic: " + node.intrinsic)
    emitByte(gen, OP.NIL, node.line)  // Preserve stack discipline
  }
}

fn compileFunctionExpr(gen, node, mode) {
  // DCE: Check if this is a dead HOISTED function (never called/referenced)
  // Only applies to named functions that have a pre-allocated slot
  // The slot contains NIL from pre-allocation, so we skip body compilation
  if node.name and node.name.name {
    let preallocatedSlot = gen.emittedLocals[node.id]
    if (preallocatedSlot or preallocatedSlot == 0) and gen.deadNodes[node.id] {
      // Hoisted dead function - slot already has NIL from pre-allocation
      if mode == MODE.VALUE {
        emitBytes(gen, OP.GET_LOCAL, localSlot(preallocatedSlot), node.line)
      }
      return
    }
  }

  let name = node.name and node.name.name or "fn"
  let func = Function(name, len(node.params or []), Chunk(node.filename))

  let enclosing = gen.currentFunction
  gen.currentFunction = func

  // Save the local counter (we're entering a new function scope)
  let enclosingLocalSlot = gen.nextLocalSlot
  let enclosingEmittedLocals = gen.emittedLocals
  gen.nextLocalSlot = 0
  gen.emittedLocals = .{}  // Fresh map for this function

  // Record function name and parameters
  // Function name is at slot -1 (VM slot 0 via localSlot(-1) = 0, the closure)
  // Parameters are at slots 0, 1, 2, ... (which map to VM slots 1, 2, 3, ... with localSlot)
  let fnScope = gen.scopeInfo[node.id]
  if fnScope {
    let locals = fnScope.locals or []
    let slot = 0
    for local in locals {
      if local.kind == "fn" {
        // Function name: record at slot -1 so localSlot(-1) = 0 (the closure)
        gen.emittedLocals[local.nodeId] = -1
      } else {
        // Parameters: record at slots 0, 1, 2, ...
        gen.emittedLocals[local.nodeId] = slot
        slot = slot + 1
      }
    }
    gen.nextLocalSlot = slot
  }

  pushScope(gen, node)
  compileBlock(gen, node.body, MODE.VALUE)
  popScope(gen)

  emitByte(gen, OP.RETURN, node.line)

  // Restore the local counter and emittedLocals map
  gen.currentFunction = enclosing
  gen.nextLocalSlot = enclosingLocalSlot
  gen.emittedLocals = enclosingEmittedLocals

  let scope = fnScope
  if scope {
    func.upvalueCount = len(scope.upvalues or [])
  }

  emitClosure(gen, func, node.line)

  let upvalues = scope and scope.upvalues or []
  for uv in upvalues {
    // CRITICAL FIX: Translate upvalue captures correctly
    // For isLocal=true: uv.captured is nodeId, need to look up runtime slot
    // For isLocal=false: uv.captured is upvalue index, use directly
    emitByte(gen, uv.isLocal and 1 or 0, node.line)
    if uv.isLocal {
      // Look up the enclosing function's runtime slot for this captured local
      // uv.captured is the nodeId of the declaration in the enclosing function
      let capturedSlot = enclosingEmittedLocals[uv.captured]
      if capturedSlot or capturedSlot == 0 {
        emitByte(gen, localSlot(capturedSlot), node.line)
      } else {
        addError(gen, node, "Internal error: captured local not found in enclosing emittedLocals")
        emitByte(gen, 0, node.line)
      }
    } else {
      // Indirect capture: uv.captured is already an upvalue index
      emitByte(gen, uv.captured, node.line)
    }
  }

  if let local = gen.localsByDecl[node.id] {
    // Check if this function was already pre-allocated (hoisted)
    if let preallocatedSlot = gen.emittedLocals[node.id] {
      // Function was hoisted - assign closure into existing slot
      // SET_LOCAL leaves value on stack, so we POP it after assignment
      emitBytes(gen, OP.SET_LOCAL, localSlot(preallocatedSlot), node.line)
      emitByte(gen, OP.POP, node.line)

      if mode == MODE.VALUE {
        // Read the slot back as expression result
        emitBytes(gen, OP.GET_LOCAL, localSlot(preallocatedSlot), node.line)
      }
    } else {
      // Not preallocated - closure value IS the local slot (stays on stack)
      let slot = gen.nextLocalSlot
      gen.emittedLocals[node.id] = slot
      gen.nextLocalSlot = gen.nextLocalSlot + 1

      if mode == MODE.VALUE {
        // GET_LOCAL to read the local as expression result (not DUP)
        emitBytes(gen, OP.GET_LOCAL, localSlot(slot), node.line)
      }
      // STMT mode: closure stays on stack as local, no extra value needed
    }
  }
}

fn compileAssignment(gen, node, mode) {
  if node.target.type == NODE.Identifier {
    let info = gen.assignmentInfo[node.id]
    if !info {
      addError(gen, node, "Missing assignment info.")
      return
    }

    // Try superinstruction first (pure structural match)
    let plan = select.assignmentSuper(gen, node, mode)
    if plan and plan.kind == "ADD_LOCAL_IMM" {
      // Verify it's actually a local (not upvalue/global)
      if info.kind == "local" {
        let targetBinding = gen.resolvedNames[node.target.id]
        let absoluteSlot = computeAbsoluteSlot(gen, targetBinding)
        emit3(gen, OP.ADD_LOCAL_IMM, localSlot(absoluteSlot), plan.imm, node.line)
        if mode == MODE.STMT {
          emitByte(gen, OP.POP, node.line)
        }
        return
      }
      // If not local, fall through to normal path
    }

    // Normal path: compile value and emit SET_LOCAL/SET_UPVALUE
    compileValue(gen, node.value)
    if info.kind == "local" {
      let targetBinding = gen.resolvedNames[node.target.id]
      let absoluteSlot = computeAbsoluteSlot(gen, targetBinding)
      if mode == MODE.STMT {
        // Emit STORE_LOCAL superinstruction (SET_LOCAL + POP)
        emitBytes(gen, OP.STORE_LOCAL, localSlot(absoluteSlot), node.line)
      } else {
        emitBytes(gen, OP.SET_LOCAL, localSlot(absoluteSlot), node.line)
      }
    } else if info.kind == "upvalue" {
      emitUpvalueOp(gen, OP.SET_UPVALUE, OP.SET_UPVALUE_LONG, info.upvalueIndex, node.line)
      if mode == MODE.STMT {
        emitByte(gen, OP.POP, node.line)
      }
    } else if info.kind == "global" {
      // Global assignment - use long form if needed
      emitGlobalOp(gen, OP.SET_GLOBAL, OP.SET_GLOBAL_LONG, node.target.name, node.line)
      if mode == MODE.STMT {
        emitByte(gen, OP.POP, node.line)
      }
    } else {
      addError(gen, node, "Invalid assignment target.")
      return
    }
    return
  }

  if node.target.type == NODE.Index {
    // Try to emit SETI for arr[i] = val where all are locals
    if node.target.object.type == NODE.Identifier and
       node.target.index.type == NODE.Identifier and
       node.value.type == NODE.Identifier {
      let objBinding = gen.resolvedNames[node.target.object.id]
      let idxBinding = gen.resolvedNames[node.target.index.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         idxBinding and idxBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        // Emit SETI superinstruction
        let objSlot = computeAbsoluteSlot(gen, objBinding)
        let idxSlot = computeAbsoluteSlot(gen, idxBinding)
        let valSlot = computeAbsoluteSlot(gen, valBinding)

        emitByte(gen, OP.SETI, node.line)
        emitByte(gen, localSlot(objSlot), node.line)
        emitByte(gen, localSlot(idxSlot), node.line)
        emitByte(gen, localSlot(valSlot), node.line)

        if mode == MODE.STMT {
          emitByte(gen, OP.POP, node.line)
        }
        return
      }
    }

    // Try to emit SET_PROPERTY for obj[key] = val where obj and val are locals, key is constant
    if node.target.object.type == NODE.Identifier and
       (node.target.index.type == NODE.String or node.target.index.type == NODE.Number) and
       node.value.type == NODE.Identifier {
      let objBinding = gen.resolvedNames[node.target.object.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        // Emit SET_PROPERTY superinstruction
        let objSlot = computeAbsoluteSlot(gen, objBinding)
        let valSlot = computeAbsoluteSlot(gen, valBinding)
        let keyValue = if node.target.index.type == NODE.String {
          ObjectString(node.target.index.value)
        } else {
          NUMBER_VAL(node.target.index.value)
        }
        let constIdx = makeConstant(gen, keyValue)

        if constIdx < 256 {
          emitByte(gen, OP.SET_PROPERTY, node.line)
          emitByte(gen, localSlot(objSlot), node.line)
          emitByte(gen, constIdx, node.line)
          emitByte(gen, localSlot(valSlot), node.line)

          if mode == MODE.STMT {
            emitByte(gen, OP.POP, node.line)
          }
          return
        }
      }
    }

    // Normal path
    // Emit SET_BY_CONST for constant indices (string or number literals)
    if node.target.index.type == NODE.String or node.target.index.type == NODE.Number {
      compileValue(gen, node.target.object)
      compileValue(gen, node.value)

      let keyValue = if node.target.index.type == NODE.String {
        ObjectString(node.target.index.value)
      } else {
        NUMBER_VAL(node.target.index.value)
      }
      let constIdx = makeConstant(gen, keyValue)

      if constIdx < 256 {
        emitByte(gen, OP.SET_BY_CONST, node.line)
        emitByte(gen, constIdx, node.line)
      } else {
        emitByte(gen, OP.SET_BY_CONST_LONG, node.line)
        emit2(gen, Math.floor(constIdx / 256), constIdx % 256, node.line)
      }
    } else {
      // Dynamic index: use original SET_BY_INDEX (object, index, value)
      compileValue(gen, node.target.object)
      compileValue(gen, node.target.index)
      compileValue(gen, node.value)
      emitByte(gen, OP.SET_BY_INDEX, node.line)
    }

    if mode == MODE.STMT {
      emitByte(gen, OP.POP, node.line)
    }
    return
  }

  if node.target.type == NODE.Dot {
    // Try to emit SET_PROPERTY for obj.field = val where obj and val are locals
    if node.target.object.type == NODE.Identifier and
       node.value.type == NODE.Identifier {
      let objBinding = gen.resolvedNames[node.target.object.id]
      let valBinding = gen.resolvedNames[node.value.id]

      if objBinding and objBinding.kind == "local" and
         valBinding and valBinding.kind == "local" {
        // Emit SET_PROPERTY superinstruction
        let objSlot = computeAbsoluteSlot(gen, objBinding)
        let valSlot = computeAbsoluteSlot(gen, valBinding)
        let constIdx = makeConstant(gen, ObjectString(node.target.property.value))

        if constIdx < 256 {
          emitByte(gen, OP.SET_PROPERTY, node.line)
          emitByte(gen, localSlot(objSlot), node.line)
          emitByte(gen, constIdx, node.line)
          emitByte(gen, localSlot(valSlot), node.line)

          if mode == MODE.STMT {
            emitByte(gen, OP.POP, node.line)
          }
          return
        }
      }
    }

    // Normal path: emit SET_BY_CONST
    compileValue(gen, node.target.object)
    compileValue(gen, node.value)
    let constIdx = makeConstant(gen, ObjectString(node.target.property.value))

    if constIdx < 256 {
      emitByte(gen, OP.SET_BY_CONST, node.line)
      emitByte(gen, constIdx, node.line)
    } else {
      emitByte(gen, OP.SET_BY_CONST_LONG, node.line)
      emit2(gen, Math.floor(constIdx / 256), constIdx % 256, node.line)
    }

    if mode == MODE.STMT {
      emitByte(gen, OP.POP, node.line)
    }
    return
  }

  addError(gen, node, "Unsupported assignment target: " + (nameOf(NODE, node.target.type) or str(node.target.type)))
}

fn compileIndex(gen, node) {
  // Try to emit GETI for arr[i] where both are locals
  if node.object.type == NODE.Identifier and
     node.index.type == NODE.Identifier {
    let objBinding = gen.resolvedNames[node.object.id]
    let idxBinding = gen.resolvedNames[node.index.id]

    if objBinding and objBinding.kind == "local" and
       idxBinding and idxBinding.kind == "local" {
      // Emit GETI superinstruction
      let objSlot = computeAbsoluteSlot(gen, objBinding)
      let idxSlot = computeAbsoluteSlot(gen, idxBinding)

      emitByte(gen, OP.GETI, node.line)
      emitByte(gen, localSlot(objSlot), node.line)
      emitByte(gen, localSlot(idxSlot), node.line)
      return
    }
  }

  // Try to emit GET_PROPERTY for obj[key] where obj is local and key is constant
  if node.object.type == NODE.Identifier and
     (node.index.type == NODE.String or node.index.type == NODE.Number) {
    let objBinding = gen.resolvedNames[node.object.id]

    if objBinding and objBinding.kind == "local" {
      // Emit GET_PROPERTY superinstruction
      let objSlot = computeAbsoluteSlot(gen, objBinding)
      let keyValue = if node.index.type == NODE.String {
        ObjectString(node.index.value)
      } else {
        NUMBER_VAL(node.index.value)
      }
      let constIdx = makeConstant(gen, keyValue)

      if constIdx < 256 {
        emitByte(gen, OP.GET_PROPERTY, node.line)
        emitByte(gen, localSlot(objSlot), node.line)
        emitByte(gen, constIdx, node.line)
        return
      }
    }
  }

  // Normal path
  compileValue(gen, node.object)

  // Emit GET_BY_CONST for constant indices (string or number literals)
  if node.index.type == NODE.String or node.index.type == NODE.Number {
    let keyValue = if node.index.type == NODE.String {
      ObjectString(node.index.value)
    } else {
      NUMBER_VAL(node.index.value)
    }
    let constIdx = makeConstant(gen, keyValue)

    if constIdx < 256 {
      emitByte(gen, OP.GET_BY_CONST, node.line)
      emitByte(gen, constIdx, node.line)
    } else {
      emitByte(gen, OP.GET_BY_CONST_LONG, node.line)
      emit2(gen, Math.floor(constIdx / 256), constIdx % 256, node.line)
    }
  } else {
    compileValue(gen, node.index)
    emitByte(gen, OP.GET_BY_INDEX, node.line)
  }
}

fn compileDot(gen, node) {
  // Try to emit GET_PROPERTY for obj.field where obj is local
  if node.object.type == NODE.Identifier {
    let objBinding = gen.resolvedNames[node.object.id]

    if objBinding and objBinding.kind == "local" {
      // Emit GET_PROPERTY superinstruction
      let objSlot = computeAbsoluteSlot(gen, objBinding)
      let constIdx = makeConstant(gen, ObjectString(node.property.value))

      if constIdx < 256 {
        emitByte(gen, OP.GET_PROPERTY, node.line)
        emitByte(gen, localSlot(objSlot), node.line)
        emitByte(gen, constIdx, node.line)
        return
      }
    }
  }

  // Normal path: emit GET_BY_CONST
  compileValue(gen, node.object)
  let constIdx = makeConstant(gen, ObjectString(node.property.value))

  if constIdx < 256 {
    emitByte(gen, OP.GET_BY_CONST, node.line)
    emitByte(gen, constIdx, node.line)
  } else {
    emitByte(gen, OP.GET_BY_CONST_LONG, node.line)
    emit2(gen, Math.floor(constIdx / 256), constIdx % 256, node.line)
  }
}

fn compileArray(gen, node) {
  emitByte(gen, OP.ARRAY, node.line)
  for el in node.elements or [] {
    compileValue(gen, el)
    emitByte(gen, OP.APPEND, node.line)
  }
}

fn compileHashmap(gen, node) {
  let isEnum = gen.enumInfo and gen.enumInfo[node.id]
  emitByte(gen, isEnum and OP.ENUM or OP.HASHMAP, node.line)
  for pair in node.pairs or [] {
    compileValue(gen, pair.key)
    compileValue(gen, pair.value)
    emitByte(gen, OP.ASSOC, node.line)
  }
}

fn compileReturn(gen, node) {
  if node.value {
    compileValue(gen, node.value)
  } else {
    emitByte(gen, OP.NIL, node.line)
  }
  emitByte(gen, OP.RETURN, node.line)
}

fn compileBreak(gen, node) {
  if len(gen.breakOffsets) == 0 {
    addError(gen, node, "Break used outside loop.")
    return
  }
  // Unwind to loop base slot (the slot height after loop result slot)
  let loopBaseSlot = gen.loopBaseSlots[len(gen.loopBaseSlots) - 1]
  unwindToSlot(gen, loopBaseSlot)
  let jump = emitJump(gen, OP.JUMP, node.line)
  push(gen.breakOffsets[len(gen.breakOffsets) - 1], jump)
}

fn compileContinue(gen, node) {
  if len(gen.continueOffsets) == 0 {
    addError(gen, node, "Continue used outside loop.")
    return
  }
  // Unwind to loop continue slot (keeps loop var, pops body locals)
  let loopContinueSlot = gen.loopContinueSlots[len(gen.loopContinueSlots) - 1]
  unwindToSlot(gen, loopContinueSlot)
  let jump = emitJump(gen, OP.JUMP, node.line)
  push(gen.continueOffsets[len(gen.continueOffsets) - 1], jump)
}

// Fused numeric loop pattern matching and codegen (Phase 1 MVP)
// Only fuses when limit is an Identifier (no temp allocation)
fn matchNumericForLoop(gen, node) {
  if !node.init or !node.condition or !node.update {
    return nil
  }

  // Match init: let i = <expr>
  if node.init.type != NODE.Let {
    return nil
  }
  if !node.init.name or node.init.name.type != NODE.Identifier {
    return nil
  }
  let i_name = node.init.name.value or node.init.name.name or node.init.name.lexeme

  // Phase 1 MVP: Init value must be a number literal (ensures fixnum at runtime)
  if !node.init.init or node.init.init.type != NODE.Number {
    return nil
  }
  // Verify it's an integer value (not a float)
  let init_value = node.init.init.value
  if init_value != Math.floor(init_value) {
    return nil
  }

  // Match condition: i < limit, i <= limit, i > limit, or i >= limit
  if node.condition.type != NODE.Binary { return nil }
  let cond = node.condition
  let cmp_kind = nil
  let op = cond.operator.lexeme or cond.operator
  if op == "<" {
    cmp_kind = 0
  } else if op == "<=" {
    cmp_kind = 1
  } else if op == ">" {
    cmp_kind = 2
  } else if op == ">=" {
    cmp_kind = 3
  } else {
    return nil
  }

  // Check left side is identifier i
  if cond.left.type != NODE.Identifier { return nil }
  let left_name = cond.left.value or cond.left.name or cond.left.lexeme
  if left_name != i_name { return nil }

  // Phase 1: Limit must be an Identifier
  if cond.right.type != NODE.Identifier { return nil }
  let limit_node = cond.right

  // Match update: i = i + 1
  if node.update.type != NODE.Assignment { return nil }
  if !node.update.target or node.update.target.type != NODE.Identifier { return nil }
  let update_target_name = node.update.target.value or node.update.target.name or node.update.target.lexeme
  if update_target_name != i_name { return nil }

  let update_value = node.update.value
  if update_value.type != NODE.Binary { return nil }
  let update_op = update_value.operator.lexeme or update_value.operator

  // Accept both + and - for step
  if update_op != "+" and update_op != "-" { return nil }

  if update_value.left.type != NODE.Identifier { return nil }
  let update_left_name = update_value.left.value or update_value.left.name or update_value.left.lexeme
  if update_left_name != i_name { return nil }

  // Extract step value (must be integer constant)
  if update_value.right.type != NODE.Number { return nil }
  let step_value = update_value.right.value
  if step_value != Math.floor(step_value) { return nil }

  let step_int = Math.floor(step_value)

  // Apply sign based on operator
  if update_op == "-" {
    step_int = 0 - step_int
  }

  // Validate step range for int8_t encoding
  if step_int < -128 or step_int > 127 { return nil }
  if step_int == 0 { return nil }  // Zero step would infinite loop

  // Validate step direction matches comparison direction
  if step_int < 0 and (cmp_kind == 0 or cmp_kind == 1) {
    return nil  // Negative step requires > or >= comparison
  }
  if step_int > 0 and (cmp_kind == 2 or cmp_kind == 3) {
    return nil  // Positive step requires < or <= comparison
  }

  // Determine if we can use optimized _1 opcodes
  let use_fast_path = (step_int == 1)

  .{ i_name, limit_node, cmp_kind, step: step_int, use_fast_path }
}

fn compileNumericForLoop(gen, node, match, mode) {
  // Setup loop tracking (same as regular compileFor)
  let loopBreakSlot = gen.nextLocalSlot
  push(gen.loopBaseSlots, loopBreakSlot)

  pushScope(gen, node)
  let prevScopeDepth = gen.loopScopeDepth
  gen.loopScopeDepth = gen.scopeInfo[node.id] and gen.scopeInfo[node.id].depth or 0

  push(gen.breakOffsets, [])
  push(gen.continueOffsets, [])

  // Compile init and derive i_slot from validated slot allocation
  // Phase 1 MVP: require init allocates exactly one local (the loop var)
  let slotBeforeInit = gen.nextLocalSlot
  compileStmt(gen, node.init)
  let slotAfterInit = gen.nextLocalSlot

  // Validate that init allocated exactly one local (the loop variable)
  if slotAfterInit != slotBeforeInit + 1 {
    // Init allocated 0 locals (error) or >1 locals (complex expr, not supported)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }
  let i_slot = slotBeforeInit

  // Record loop continue slot (right after init, before body)
  let loopContinueSlot = gen.nextLocalSlot
  push(gen.loopContinueSlots, loopContinueSlot)

  // Resolve limit slot from identifier (either user variable or ANF temp)
  // Strategy: use resolver binding to find the declaration node ID,
  // then look up that declaration in gen.emittedLocals
  let limit_binding = gen.resolvedNames[match.limit_node.id]
  if !limit_binding or limit_binding.kind != "local" or limit_binding.declaredAt == nil {
    // Cannot resolve limit variable, fall back
    pop(gen.loopContinueSlots)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }

  // Look up the declaration node ID in emittedLocals
  let limit_slot = gen.emittedLocals[limit_binding.declaredAt]
  if limit_slot == nil {
    // Cannot find slot for limit variable, fall back
    pop(gen.loopContinueSlots)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }

  // CRITICAL INVARIANT: For fused loops, both i and limit slots must be
  // below loopContinueSlot (live across iterations). Anything >= loopContinueSlot
  // can be overwritten by loop body locals.
  if i_slot >= loopContinueSlot or limit_slot >= loopContinueSlot {
    // Slots not stable across iterations, fall back to generic loop
    pop(gen.loopContinueSlots)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }

  // Additional safety: verify slots are in valid range
  if i_slot < 0 or i_slot >= 256 or limit_slot < 0 or limit_slot >= 256 {
    pop(gen.loopContinueSlots)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }

  // Sanity check: i and limit must not alias in bytecode space
  // (localSlot adds 1, so this checks bytecode slot collision)
  if localSlot(i_slot) == localSlot(limit_slot) {
    pop(gen.loopContinueSlots)
    pop(gen.continueOffsets)
    pop(gen.breakOffsets)
    gen.loopScopeDepth = prevScopeDepth
    pop(gen.loopBaseSlots)
    popScope(gen)
    return false
  }

  // Choose opcode based on step value
  let prep_opcode = match.use_fast_path and OP.FORPREP_1 or OP.FORPREP
  let loop_opcode = match.use_fast_path and OP.FORLOOP_1 or OP.FORLOOP

  // Emit FORPREP with placeholder for exit jump
  let prepOffset = len(gen.currentFunction.chunk.bytecode)
  emit1(gen, prep_opcode, node.line)
  emit1(gen, localSlot(i_slot), node.line)
  emit1(gen, localSlot(limit_slot), node.line)
  emit1(gen, match.cmp_kind, node.line)

  // Emit step byte only for non-fast-path
  if !match.use_fast_path {
    // Encode step as int8_t (two's complement for negative)
    let step_byte = match.step < 0 and (256 + match.step) or match.step
    emit1(gen, step_byte, node.line)
  }

  let exitJumpHi = len(gen.currentFunction.chunk.bytecode)
  emit2(gen, 0, 0, node.line)  // Placeholder for forward jump

  // Emit loop body
  let loopBodyStart = len(gen.currentFunction.chunk.bytecode)
  compileStmt(gen, node.body)

  // Patch continues to jump here (right before FORLOOP_1)
  patchContinues(gen)

  // Emit FORLOOP with backward jump to body start
  emit1(gen, loop_opcode, node.line)
  emit1(gen, localSlot(i_slot), node.line)
  emit1(gen, localSlot(limit_slot), node.line)
  emit1(gen, match.cmp_kind, node.line)

  // Emit step byte only for non-fast-path
  if !match.use_fast_path {
    let step_byte = match.step < 0 and (256 + match.step) or match.step
    emit1(gen, step_byte, node.line)
  }

  let backJump = len(gen.currentFunction.chunk.bytecode) + 2 - loopBodyStart
  emit2(gen, Math.floor(backJump / 256), backJump % 256, node.line)

  // Patch exit jump from FORPREP
  let instruction_length = match.use_fast_path and 6 or 7
  let exitOffset = len(gen.currentFunction.chunk.bytecode) - (prepOffset + instruction_length)
  gen.currentFunction.chunk.bytecode[exitJumpHi] = Math.floor(exitOffset / 256)
  gen.currentFunction.chunk.bytecode[exitJumpHi + 1] = exitOffset % 256

  // Cleanup (same as regular compileFor)
  // Note: ANF temps (if any) are in the loop scope and will be cleaned up by endScope
  endScope(gen, node)
  patchBreaks(gen)

  gen.loopScopeDepth = prevScopeDepth
  pop(gen.breakOffsets)
  pop(gen.continueOffsets)
  pop(gen.loopBaseSlots)
  pop(gen.loopContinueSlots)

  popScope(gen)

  // For loops always return nil
  if mode == MODE.VALUE {
    emitByte(gen, OP.NIL, node.line)
  }

  true
}

fn compileFor(gen, node, mode) {
  // Try to fuse numeric loops (Phase 1 MVP)
  // Only fuses when:
  // 1. Pattern matches: for let i = start; i <//<= limit; i = i + 1 { body }
  // 2. Both i and limit are Identifiers resolved to local slots
  // 3. Both slots < loopContinueSlot (stable across iterations)
  if let match = matchNumericForLoop(gen, node) {
    if let success = compileNumericForLoop(gen, node, match, mode) {
      return
    }
    // If fusion failed safety checks, fall through to generic loop
  }

  // Generic loop compilation (unchanged)
  // Record the loop base slot for break
  let loopBreakSlot = gen.nextLocalSlot
  push(gen.loopBaseSlots, loopBreakSlot)

  pushScope(gen, node)
  let prevScopeDepth = gen.loopScopeDepth
  gen.loopScopeDepth = gen.scopeInfo[node.id] and gen.scopeInfo[node.id].depth or 0

  push(gen.breakOffsets, [])
  push(gen.continueOffsets, [])

  if node.init {
    compileStmt(gen, node.init)
  }

  // Record the loop continue slot - the slot height after init (keeps loop var, pops body locals)
  let loopContinueSlot = gen.nextLocalSlot
  push(gen.loopContinueSlots, loopContinueSlot)

  let loopStart = len(gen.currentFunction.chunk.bytecode)
  let loopStartLine = node.line
  let exitJump = -1

  if node.condition {
    compileValue(gen, node.condition)
    exitJump = emitJump(gen, OP.JUMP_IF_FALSE, node.line)
  }

  if node.update {
    let bodyJump = emitJump(gen, OP.JUMP, node.line)
    let incrementStart = len(gen.currentFunction.chunk.bytecode)
    compileStmt(gen, node.update)
    emitLoop(gen, loopStart, node.line)
    loopStart = incrementStart
    patchJump(gen, bodyJump)
  }

  compileStmt(gen, node.body)

  patchContinues(gen)
  emitLoop(gen, loopStart, loopStartLine)

  if exitJump != -1 {
    patchJump(gen, exitJump)
  }

  endScope(gen, node)
  patchBreaks(gen)

  gen.loopScopeDepth = prevScopeDepth
  pop(gen.breakOffsets)
  pop(gen.continueOffsets)
  pop(gen.loopBaseSlots)
  pop(gen.loopContinueSlots)

  popScope(gen)

  // For loops always return nil (only emit in VALUE mode)
  if mode == MODE.VALUE {
    emitByte(gen, OP.NIL, node.line)
  }
}

fn compileImport(gen, node) {
  if !gen.codegenModule {
    addError(gen, node, "Import requires codegenModule callback.")
    return
  }
  let path = node.path and node.path.value
  if !path {
    addError(gen, node, "Import path must be a string literal.")
    return
  }
  let const = gen.currentFunction.chunk.importConstCache[path]
  if !const {
    let func = gen.codegenModule(path)
    if !func {
      addError(gen, node, "Import failed: " + path)
      return
    }
    const = makeConstant(gen, ObjectFunction(func))
    gen.currentFunction.chunk.importConstCache[path] = const
  }
  emitBytes(gen, OP.CLOSURE, const, node.line)
  emitBytes(gen, OP.CALL, 0, node.line)
}

let valueExprHandlers = .{
  [NODE.Call]: compileCall,
  [NODE.Binary]: compileBinary,
  [NODE.Logical]: compileLogical,
  [NODE.Unary]: compileUnary,
  [NODE.Grouping]: fn(gen, node) { compileValue(gen, node.expression) },
  [NODE.Identifier]: compileIdentifier,
  [NODE.Number]: compileLiteral,
  [NODE.String]: compileLiteral,
  [NODE.Bool]: compileLiteral,
  [NODE.Nil]: compileLiteral,
  [NODE.Array]: compileArray,
  [NODE.Hashmap]: compileHashmap,
  [NODE.Index]: compileIndex,
  [NODE.Dot]: compileDot,
  [NODE.Import]: compileImport,
  [NODE.IntrinsicCall]: compileIntrinsicCall,
}

fn compileValueExpr(gen, node) {
  if !node { return }
  gen.metrics.nodesVisited = gen.metrics.nodesVisited + 1
  gen.currentNode = node
  gen.currentLine = node.line

  if let handler = valueExprHandlers[node.type] {
    handler(gen, node)
  } else {
    addError(gen, node, "Codegen not implemented for: " + (nameOf(NODE, node.type) or str(node.type)))
  }
}

let controlFlowHandlers = .{
  [NODE.Return]: compileReturn,
  [NODE.Break]: compileBreak,
  [NODE.Continue]: compileContinue,
}

let modeAwareHandlers = .{
  [NODE.Let]: compileLet,
  [NODE.Assignment]: compileAssignment,
  [NODE.Function]: compileFunctionExpr,
  [NODE.Block]: compileBlock,
  [NODE.If]: compileIf,
  [NODE.For]: compileFor,
}

fn compileExpr(gen, node, mode) {
  if !node { return }
  gen.currentNode = node
  gen.currentLine = node.line

  // Control-flow nodes that don't produce values
  if let handler = controlFlowHandlers[node.type] {
    handler(gen, node)
    return
  }

  // Nodes that handle mode internally
  if let handler = modeAwareHandlers[node.type] {
    handler(gen, node, mode)
    return
  }

  // All other nodes: compile as value expression, then discard if STMT
  compileValueExpr(gen, node)
  if mode == MODE.STMT {
    emitByte(gen, OP.POP, node.line)
  }
}

fn codegen(ast, resolveResult, opts) {
  // Get DCE result if provided
  let dceResult = opts and opts.dceResult
  let deadNodes = dceResult and dceResult.deadNodes or .{}

  let gen = .{
    currentFunction: Function("", 0, Chunk(ast.filename)),
    resolvedNames: resolveResult.resolvedNames or .{},
    assignmentInfo: resolveResult.assignmentInfo or .{},
    scopeInfo: resolveResult.scopeInfo or .{},
    nodes: resolveResult.nodes or .{},
    localsByDecl: buildDeclMap(resolveResult.scopeInfo),
    enumInfo: opts and opts.enumInfo or .{},
    deadNodes,  // DCE dead node set
    errors: [],
    currentLine: 1,
    currentNode: nil,
    scopeStack: [],
    scopeBaseSlots: [],  // Track baseline nextLocalSlot when entering each scope
    breakOffsets: [],
    continueOffsets: [],
    loopBaseSlots: [],  // Track loop base slots for break (pops everything)
    loopContinueSlots: [],  // Track loop continue slots (keeps loop var)
    loopScopeDepth: 0,
    codegenModule: opts and opts.codegenModule or nil,
    fastcheck: opts and opts.fastcheck or nil,

    // Track actual emitted local positions (nodeId -> absolute slot)
    emittedLocals: .{},
    nextLocalSlot: 0,  // Counter for absolute local positions

    // Performance counters
    metrics: .{
      nodesVisited: 0,
      emitCalls: 0,
      patchCount: 0,
      constAdds: 0,
      constLookups: 0,
      constHits: 0,
    },
  }

  compileBlock(gen, ast, MODE.VALUE)
  emitByte(gen, OP.RETURN, gen.currentLine)

  .{
    success: len(gen.errors) == 0,
    function: gen.currentFunction,
    errors: gen.errors,
    metrics: gen.metrics,
    bytesEmitted: len(gen.currentFunction.chunk.bytecode),
  }
}

codegen
