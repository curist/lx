// Resolve Phase - Name resolution and semantic validation
// Responsibility: Binding analysis and contextual legality enforcement
//   - Name resolution (locals, upvalues, globals)
//   - Function hoisting for mutual recursion
//   - Semantic validation (return/break/continue placement, etc.)
//   - Build side tables for codegen
//
// IMPORTANT: Resolve MUST NOT mutate the AST.
// All information stored in side tables keyed by node ID.

let types = import "src/types.lx"
let OP = types.OP

// ========================================
// Data Structures
// ========================================

// Scope - represents a lexical scope
fn Scope(enclosing, type) {
  .{
    enclosing: enclosing,
    type: type,  // "global" | "function" | "block" | "loop"
    depth: enclosing and enclosing.depth + 1 or 0,

    localsByName: .{},       // name → Local
    localsArray: [],         // [Local] - preserve declaration order!
    hoistedFns: .{},         // name → HoistedFunction
    lastHoistedFunctionIndex: -1,
    upvalues: [],            // [Upvalue]
    nextSlot: 0,             // Monotonic slot counter
  }
}

// Local - represents a local variable
fn Local(name, depth, kind, slot, nodeId) {
  .{
    name: name,
    depth: depth,        // -1 = uninitialized, depth when initialized
    kind: kind,          // "var" | "fn" | "param"
    slot: slot,          // Stable slot ID
    nodeId: nodeId,      // Declaration node ID
    isCaptured: false,   // Set to true if captured by closure
  }
}

// Upvalue - represents a captured variable
fn Upvalue(index, isLocal, slot) {
  .{
    index: index,
    isLocal: isLocal,
    slot: slot,
  }
}

// HoistedFunction - metadata for hoisted functions
fn HoistedFunction(declNodeId, declIndex, slot) {
  .{
    declNodeId: declNodeId,   // AST node ID of function declaration
    declIndex: declIndex,     // Position in block.expressions
    slot: slot,               // Slot assigned
  }
}

// Resolver - main resolution state
fn makeResolver(opts) {
  .{
    // Side tables (output)
    resolvedNames: .{},    // nodeId → BindingInfo
    scopeInfo: .{},        // nodeId → ScopeInfo
    assignmentInfo: .{},   // nodeId → AssignmentInfo (for Assignment nodes)
    nodes: .{},            // nodeId → AST node (built during traversal)
    errors: [],            // [{ nodeId, message, severity }]
    hadError: false,

    // State
    currentScope: nil,     // Current scope object

    // Options
    importCache: opts.importCache or .{},
    compileModule: opts.compileModule,  // Callback: fn(path) → result
  }
}

// ========================================
// Error Handling
// ========================================

fn addError(resolver, nodeId, message) {
  // we only have error severity for now.
  // other severities are info & warning
  resolver.hadError = true
  push(resolver.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Scope Management
// ========================================

fn beginScope(resolver, type) {
  let newScope = Scope(resolver.currentScope, type)
  resolver.currentScope = newScope
  newScope
}

fn endScope(resolver, nodeId) {
  let scope = resolver.currentScope
  if !scope {
    return  // Compiler bug guard
  }

  // Record scope info in side table
  resolver.scopeInfo[nodeId] = .{
    scopeType: scope.type,
    depth: scope.depth,
    locals: scope.localsArray,
    upvalues: scope.upvalues,
    hoistedFns: scope.hoistedFns,  // Full map: name → { declNodeId, declIndex, slot }
    lastHoistedFunctionIndex: scope.lastHoistedFunctionIndex,
    nextSlot: scope.nextSlot,
  }

  // Pop to enclosing scope
  resolver.currentScope = scope.enclosing
}

// ========================================
// Local Declaration
// ========================================

fn declareLocal(resolver, name, kind, nodeId) {
  let scope = resolver.currentScope
  if !scope {
    return nil  // Global scope - no local
  }

  // Check for duplicate in current scope
  if scope.localsByName[name] {
    addError(resolver, nodeId, "Variable '" + name + "' already declared in this scope")
    return nil
  }

  // Allocate slot
  let slot = scope.nextSlot
  scope.nextSlot = scope.nextSlot + 1

  // Create local (uninitialized: depth = -1)
  let local = Local(name, -1, kind, slot, nodeId)

  // Add to scope
  scope.localsByName[name] = local
  push(scope.localsArray, local)

  local
}

fn markInitialized(resolver, local) {
  if local {
    let scope = resolver.currentScope
    local.depth = scope.depth
  }
}

// ========================================
// Upvalue Handling
// ========================================

fn addUpvalue(resolver, scope, isLocal, slot) {
  // Check if upvalue already exists
  for let i = 0; i < len(scope.upvalues); i = i + 1 {
    let uv = scope.upvalues[i]
    if uv.isLocal == isLocal and uv.slot == slot {
      return i  // Already have this upvalue
    }
  }

  // Add new upvalue
  let index = len(scope.upvalues)
  push(scope.upvalues, Upvalue(index, isLocal, slot))
  index
}

fn markCaptured(local) {
  if local {
    local.isCaptured = true
  }
}

fn resolveUpvalue(resolver, scope, name, nodeId) {
  if !scope.enclosing { return }  // At global scope

  // Look in enclosing scope
  let enclosing = scope.enclosing
  let local = enclosing.localsByName[name]

  if local {
    // Check read-before-init (same as resolveName)
    if local.depth == -1 {
      addError(resolver, nodeId, "Can't read local variable '" + name + "' in its own initializer")
      return nil
    }

    // Found in immediate parent - capture as local upvalue
    markCaptured(local)
    return .{
      index: addUpvalue(resolver, scope, true, local.slot),
      isLocal: true,
    }
  }

  // Not in immediate parent - recurse
  let upvalue = resolveUpvalue(resolver, enclosing, name, nodeId)
  if upvalue {
    // Captured from further up - capture as non-local upvalue
    return .{
      index: addUpvalue(resolver, scope, false, upvalue.index),
      isLocal: false,
    }
  }

  nil
}

// ========================================
// Name Resolution
// ========================================

fn resolveName(resolver, name, nodeId) {
  let scope = resolver.currentScope

  // Walk up scope chain
  let current = scope
  for current {
    // Check locals
    let local = current.localsByName[name]
    if local {
      // Check read-before-init
      if local.depth == -1 {
        addError(resolver, nodeId, "Can't read local variable '" + name + "' in its own initializer")
        return
      }

      // Local found
      if current == scope {
        // Same scope - direct local access
        resolver.resolvedNames[nodeId] = .{
          kind: "local",
          getOp: OP.GET_LOCAL,
          setOp: OP.SET_LOCAL,
          slot: local.slot,
          declaredAt: local.nodeId,
          depth: current.depth,
          // Note: isCaptured is NOT stored here - codegen should read it from scopeInfo.locals
        }
      } else {
        // Different scope - need upvalue
        let upvalue = resolveUpvalue(resolver, scope, name, nodeId)
        if upvalue {
          resolver.resolvedNames[nodeId] = .{
            kind: "upvalue",
            getOp: OP.GET_UPVALUE,
            setOp: OP.SET_UPVALUE,
            upvalueIndex: upvalue.index,
            declaredAt: local.nodeId,
            depth: current.depth,
          }
        }
      }
      return
    }

    current = current.enclosing
  }

  // Not found in any local scope - assume global
  resolver.resolvedNames[nodeId] = .{
    kind: "global",
    getOp: OP.GET_GLOBAL,
    setOp: OP.SET_GLOBAL,
    name: name,
  }
}

fn resolveIdentifier(resolver, node, context) {
  let name = node.name
  let scope = resolver.currentScope

  // Check if this is a hoisted function in current block scope
  if scope and scope.hoistedFns[name] {
    let hoisted = scope.hoistedFns[name]

    // Block-level calls require exprIndex >= function's own declIndex
    // This allows calling a function after its declaration, even if later functions exist
    // (Permits mutual recursion while preventing use-before-declaration)
    if context and !context.inFunctionBody {
      if context.exprIndex < hoisted.declIndex {
        addError(resolver, node.id,
          "Cannot use hoisted function '" + name + "' before it is declared")
        return
      }
    }

    // Valid hoisted function reference
    resolver.resolvedNames[node.id] = .{
      kind: "local",
      getOp: OP.GET_LOCAL,
      setOp: OP.SET_LOCAL,
      slot: hoisted.slot,
      declaredAt: hoisted.declNodeId,
      depth: scope.depth,
    }
    return
  }

  // Regular name resolution
  resolveName(resolver, name, node.id)
}

// ========================================
// Semantic Validation Helpers
// ========================================

fn isInLoop(scope) {
  let current = scope
  for current {
    if current.type == "loop" { return true }
    current = current.enclosing
  }
  false
}

fn isInFunction(scope) {
  let current = scope
  for current {
    if current.type == "function" { return true }
    current = current.enclosing
  }
  false
}

// ========================================
// Function and Block Resolution
// ========================================

fn resolveFunction(resolver, node, context) {
  // Create function scope
  beginScope(resolver, "function")

  // Declare parameters as locals
  for let i = 0; i < len(node.params); i = i + 1 {
    let param = node.params[i]
    let local = declareLocal(resolver, param.name, "param", param.id)
    markInitialized(resolver, local)
  }

  // Resolve function body (with inFunctionBody = true)
  let bodyContext = .{
    exprIndex: 0,
    inFunctionBody: true,  // Disable hoisting ordering check in function bodies
  }
  resolveExpr(resolver, node.body, bodyContext)

  endScope(resolver, node.id)
}

fn resolveBlockWithHoisting(resolver, node, context) {
  // Two-phase block resolution for hoisting
  let scope = resolver.currentScope

  // PHASE 1: Prescan for hoisted functions
  let lastHoistedIndex = -1
  for let i = 0; i < len(node.expressions); i = i + 1 {
    let expr = node.expressions[i]
    if expr.type == "Function" and expr.name {
      // Named function declaration - hoist it
      let fnName = expr.name.name
      let local = declareLocal(resolver, fnName, "fn", expr.name.id)

      // Mark as initialized immediately (hoisting!)
      // This allows mutual recursion in function bodies
      markInitialized(resolver, local)

      // Store hoisting metadata
      scope.hoistedFns[fnName] = HoistedFunction(
        expr.id,     // declNodeId
        i,           // declIndex
        local.slot   // slot
      )

      lastHoistedIndex = i
    }
  }

  scope.lastHoistedFunctionIndex = lastHoistedIndex

  // PHASE 2: Resolve all expressions
  let exprCount = len(node.expressions)
  for let i = 0; i < exprCount; i = i + 1 {
    let expr = node.expressions[i]
    let blockContext = .{
      exprIndex: i,
      inFunctionBody: context and context.inFunctionBody or false,
      isLastExpr: i == exprCount - 1,  // Track if this is the last expression
      parentBlock: node,
    }

    resolveExpr(resolver, expr, blockContext)
  }
}

// ========================================
// Expression Resolution
// ========================================

fn resolveExpr(resolver, node, context) {
  if !node { return }

  // Build node map as we traverse
  if node.id {
    resolver.nodes[node.id] = node
  }

  // Dispatch based on type
  if node.type == "Identifier" {
    resolveIdentifier(resolver, node, context)
  } else if node.type == "Number" or node.type == "String" or
            node.type == "Bool" or node.type == "Nil" {
    // Literals - nothing to resolve
  } else if node.type == "Binary" or node.type == "Logical" {
    // Binary/Logical: resolve both operands
    resolveExpr(resolver, node.left, context)
    resolveExpr(resolver, node.right, context)
  } else if node.type == "Unary" {
    // Unary: resolve operand
    resolveExpr(resolver, node.operand, context)
  } else if node.type == "Grouping" {
    // Grouping: resolve inner expression
    resolveExpr(resolver, node.expression, context)
  } else if node.type == "Let" {
    // Let declaration
    let name = node.name.name

    // Declare local (uninitialized)
    let local = declareLocal(resolver, name, "var", node.name.id)

    // Resolve initializer if present
    if node.init {
      resolveExpr(resolver, node.init, context)
    }

    // Mark as initialized
    markInitialized(resolver, local)
  } else if node.type == "Block" {
    // Block - create new scope and use hoisting-aware resolution
    beginScope(resolver, "block")
    resolveBlockWithHoisting(resolver, node, context)
    endScope(resolver, node.id)
  } else if node.type == "Call" {
    // Call: resolve callee and all arguments
    resolveExpr(resolver, node.callee, context)
    for let i = 0; i < len(node.args); i = i + 1 {
      resolveExpr(resolver, node.args[i], context)
    }
  } else if node.type == "If" {
    // If: resolve condition, then, and else branches
    resolveExpr(resolver, node.condition, context)
    resolveExpr(resolver, node.then, context)
    if node.else {
      resolveExpr(resolver, node.else, context)
    }
  } else if node.type == "Assignment" {
    // Assignment: validate target and resolve binding
    let target = node.target

    // Validate target type
    if target.type == "Identifier" {
      // Resolve the identifier to get binding info
      resolveExpr(resolver, target, context)

      // Check that identifier has a setOp (can be assigned to)
      let binding = resolver.resolvedNames[target.id]
      if binding and binding.setOp {
        // Store discriminated binding info (only relevant fields per kind)
        if binding.kind == "local" {
          resolver.assignmentInfo[node.id] = .{
            kind: "local",
            slot: binding.slot,
          }
        } else if binding.kind == "upvalue" {
          resolver.assignmentInfo[node.id] = .{
            kind: "upvalue",
            upvalueIndex: binding.upvalueIndex,
          }
        } else if binding.kind == "global" {
          resolver.assignmentInfo[node.id] = .{
            kind: "global",
            name: binding.name,
          }
        }
      } else {
        addError(resolver, node.id, "Cannot assign to identifier (no setOp)")
      }
    } else if target.type == "Index" {
      // Index assignment: arr[idx] = value
      // Codegen reads object/index from node.target AST
      resolveExpr(resolver, target.object, context)
      resolveExpr(resolver, target.index, context)
      resolver.assignmentInfo[node.id] = .{
        kind: "index",
      }
    } else if target.type == "Dot" {
      // Dot assignment: obj.prop = value
      // Codegen reads property from node.target.property AST
      resolveExpr(resolver, target.object, context)
      resolver.assignmentInfo[node.id] = .{
        kind: "dot",
      }
    } else {
      addError(resolver, node.id, "Invalid assignment target")
    }

    // Resolve value
    resolveExpr(resolver, node.value, context)
  } else if node.type == "Array" {
    // Array: resolve all elements
    for let i = 0; i < len(node.elements); i = i + 1 {
      resolveExpr(resolver, node.elements[i], context)
    }
  } else if node.type == "Hashmap" {
    // Hashmap: resolve all keys and values
    for let i = 0; i < len(node.pairs); i = i + 1 {
      resolveExpr(resolver, node.pairs[i].key, context)
      resolveExpr(resolver, node.pairs[i].value, context)
    }
  } else if node.type == "Index" {
    // Index: resolve object and index
    resolveExpr(resolver, node.object, context)
    resolveExpr(resolver, node.index, context)
  } else if node.type == "Dot" {
    // Dot: resolve object (property is just an identifier, not resolved)
    resolveExpr(resolver, node.object, context)
  } else if node.type == "Function" {
    // Function: create scope, declare params, resolve body
    resolveFunction(resolver, node, context)
  } else if node.type == "For" {
    // For loop: create loop scope, resolve init/condition/update/body
    beginScope(resolver, "loop")

    // Resolve init (if present) - can declare variables
    if node.init {
      resolveExpr(resolver, node.init, context)
    }

    // Resolve condition (if present)
    if node.condition {
      resolveExpr(resolver, node.condition, context)
    }

    // Resolve update (if present)
    if node.update {
      resolveExpr(resolver, node.update, context)
    }

    // Resolve body
    resolveExpr(resolver, node.body, context)

    endScope(resolver, node.id)
  } else if node.type == "Return" {
    // Return: validate placement
    let scope = resolver.currentScope

    // Check if in function or at top level
    if !isInFunction(scope) {
      // Outside function: only allow at top-level end, not in nested blocks
      if !context or !context.atTopLevel {
        addError(resolver, node.id, "Return is only allowed in functions or at top level")
      } else if !context.isLastExpr {
        addError(resolver, node.id, "Can only return at end of file when not in function")
      }
    } else {
      // In function - must be at end of block
      if context and !context.isLastExpr {
        addError(resolver, node.id, "Return must be at end of block")
      }
    }

    // Resolve return value if present
    if node.value {
      resolveExpr(resolver, node.value, context)
    }
  } else if node.type == "Break" {
    // Break: must be inside loop and at end of block
    if !isInLoop(resolver.currentScope) {
      addError(resolver, node.id, "Can only break inside a loop")
    }

    if context and !context.isLastExpr {
      addError(resolver, node.id, "Break must be at end of block")
    }

    // Resolve break value if present
    if node.value {
      resolveExpr(resolver, node.value, context)
    }
  } else if node.type == "Continue" {
    // Continue: must be inside loop
    if !isInLoop(resolver.currentScope) {
      addError(resolver, node.id, "Can only continue inside a loop")
    }

    if context and !context.isLastExpr {
      addError(resolver, node.id, "Continue must be at end of block")
    }
  } else if node.type == "Import" {
    // Import: track the node and traverse path for completeness
    // Actual module loading happens during evaluation
    if node.path {
      resolveExpr(resolver, node.path, context)
    }
  } else {
    // TODO: Implement other node types
    addError(resolver, node.id, "Resolution not yet implemented for: " + node.type)
  }
}

fn resolveProgram(resolver, ast) {
  // Program has global scope
  beginScope(resolver, "global")
  let scope = resolver.currentScope

  // Note: nodes map is built implicitly during resolveExpr traversal
  // (no need for explicit buildNodeMap call)

  // PHASE 1: Prescan for top-level hoisted functions
  let lastHoistedIndex = -1
  for let i = 0; i < len(ast.body); i = i + 1 {
    let expr = ast.body[i]
    if expr.type == "Function" and expr.name {
      // Named function declaration - hoist it
      let fnName = expr.name.name
      let local = declareLocal(resolver, fnName, "fn", expr.name.id)

      // Mark as initialized immediately (hoisting!)
      markInitialized(resolver, local)

      // Store hoisting metadata
      scope.hoistedFns[fnName] = HoistedFunction(
        expr.id,     // declNodeId
        i,           // declIndex
        local.slot   // slot
      )

      lastHoistedIndex = i
    }
  }

  scope.lastHoistedFunctionIndex = lastHoistedIndex

  // PHASE 2: Resolve all expressions in program body
  let bodyCount = len(ast.body)
  for let i = 0; i < bodyCount; i = i + 1 {
    let expr = ast.body[i]
    resolveExpr(resolver, expr, .{
      exprIndex: i,
      inFunctionBody: false,
      isLastExpr: i == bodyCount - 1,
      parentBlock: nil,  // Top level has no parent block
      atTopLevel: true,  // Mark as top-level context
    })
  }

  endScope(resolver, ast.id)
}

// ========================================
// Main API
// ========================================

fn resolve(ast, opts) {
  let resolver = makeResolver(opts or .{})

  resolveProgram(resolver, ast)

  .{
    success: !resolver.hadError,
    ast: ast,
    nodes: resolver.nodes,
    resolvedNames: resolver.resolvedNames,
    scopeInfo: resolver.scopeInfo,
    assignmentInfo: resolver.assignmentInfo,
    errors: resolver.errors,
  }
}

resolve
