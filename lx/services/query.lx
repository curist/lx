// Query Service - Position-based IDE queries over compiler artifacts
//
// Provides hover (type at position) and goto definition (jump to declaration)
// for editor tooling integration.
//
// Read-only: no inference, no unification, just table lookups + span selection.

let types = import "src/types.lx"
let builtinsData = import "services/builtins_docs_data.lx"
let queryNilCheck = import "services/nilcheck.lx"

let NODE = types.NODE

// ========================================
// Helpers
// ========================================

fn stringLess(a, b) {
  if !a and b { return true }
  if a and !b { return false }
  if !a and !b { return false }

  let alen = len(a)
  let blen = len(b)
  let n = alen < blen and alen or blen
  for let i = 0; i < n; i = i + 1 {
    let ca = ord(a[i])
    let cb = ord(b[i])
    if ca < cb { return true }
    if ca > cb { return false }
  }
  alen < blen
}

fn keyLess(a, b) {
  let ta = type(a)
  let tb = type(b)
  if ta == "Number" and tb == "Number" {
    return a < b
  }
  stringLess(str(a), str(b))
}

fn idMapGet(map, id) {
  if map[id] {
    return map[id]
  }
  let sid = str(id)
  if map[sid] {
    return map[sid]
  }
  nil
}

fn rangeOf(n) {
  .{
    filename: n.filename,
    line: n.line,
    col: n.col,
    endLine: n.endLine,
    endCol: n.endCol,
  }
}

fn nodeKeyFromParts(filename, id) {
  join([filename or "", ":", id], "")
}

fn nodeKeyFor(ctx, node) {
  if !node { return nil }
  if ctx and ctx.nodes and ctx.nodes[node.id] {
    return node.id
  }
  nodeKeyFromParts(node.filename, node.id)
}

// ========================================
// Indexing
// ========================================

fn collectAllNodes(node, nodes) {
  if type(node) != "map" { return }

  if !nodes[node.id] {
    nodes[node.id] = node
  }

  // Traverse common node fields (as maps)
  if node.name { collectAllNodes(node.name, nodes) }
  if node.init { collectAllNodes(node.init, nodes) }
  if node.value { collectAllNodes(node.value, nodes) }
  if node.left { collectAllNodes(node.left, nodes) }
  if node.right { collectAllNodes(node.right, nodes) }
  if node.operand { collectAllNodes(node.operand, nodes) }
  if node.callee { collectAllNodes(node.callee, nodes) }
  if node.object { collectAllNodes(node.object, nodes) }
  if node.property { collectAllNodes(node.property, nodes) }
  if node.index { collectAllNodes(node.index, nodes) }
  if node.target { collectAllNodes(node.target, nodes) }
  if node.test { collectAllNodes(node.test, nodes) }
  if node.then { collectAllNodes(node.then, nodes) }
  if node.else { collectAllNodes(node.else, nodes) }
  if node.condition { collectAllNodes(node.condition, nodes) }
  // body can be either a Block (map) or an array of statements
  if node.body and type(node.body) == "map" {
    collectAllNodes(node.body, nodes)
  }

  // Traverse arrays
  if node.params and type(node.params) == "array" {
    for let i = 0; i < len(node.params); i = i + 1 {
      collectAllNodes(node.params[i], nodes)
    }
  }
  if node.args and type(node.args) == "array" {
    for let i = 0; i < len(node.args); i = i + 1 {
      collectAllNodes(node.args[i], nodes)
    }
  }
  if node.elements and type(node.elements) == "array" {
    for let i = 0; i < len(node.elements); i = i + 1 {
      collectAllNodes(node.elements[i], nodes)
    }
  }
  if node.pairs and type(node.pairs) == "array" {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let pair = node.pairs[i]
      collectAllNodes(pair.key, nodes)
      collectAllNodes(pair.value, nodes)
    }
  }
  if node.expressions and type(node.expressions) == "array" {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      collectAllNodes(node.expressions[i], nodes)
    }
  }
  if node.body and type(node.body) == "array" {
    for let i = 0; i < len(node.body); i = i + 1 {
      collectAllNodes(node.body[i], nodes)
    }
  }
}

fn propNameFromNode(n) {
  if !n { return nil }
  if n.type == NODE.Identifier { return n.name }
  if n.type == NODE.String { return n.value }
  nil
}

fn dotPathFromNode(n) {
  if !n { return nil }
  if n.type == NODE.Identifier {
    return n.name
  }
  if n.type == NODE.Dot {
    let base = dotPathFromNode(n.object)
    let prop = propNameFromNode(n.property)
    if base and prop {
      return base + "." + prop
    }
    if prop {
      return "." + prop
    }
  }
  nil
}

fn spanKeyFromNode(n) {
  if !n {
    return nil
  }
  join([
    n.filename or "",
    ":",
    n.line or 0,
    ":",
    n.col or 0,
    ":",
    n.endLine or 0,
    ":",
    n.endCol or 0,
  ], "")
}

fn buildFileIndex(ctx) {
  if !ctx.fileNodeIds { ctx.fileNodeIds = .{} }
  ctx.letsByNameSpan = .{}
  ctx.dotsByPropertySpan = .{}
  ctx.hashmapsByFilename = .{}
  ctx.assignmentsByObjectProp = .{}

  each(keys(ctx.nodes), fn(id) {
    let n = ctx.nodes[id]
    if !n or !n.filename {
      return
    }

    let fname = n.filename
    if !ctx.fileNodeIds[fname] {
      ctx.fileNodeIds[fname] = []
    }
    push(ctx.fileNodeIds[fname], id)

    if n.type == NODE.Let and n.name {
      let key = spanKeyFromNode(n.name)
      if key {
        ctx.letsByNameSpan[key] = n
      }
    }

    if n.type == NODE.Dot and n.property {
      let key = spanKeyFromNode(n.property)
      if key and !ctx.dotsByPropertySpan[key] {
        ctx.dotsByPropertySpan[key] = n
      }
    }

    if n.type == NODE.Hashmap {
      if !ctx.hashmapsByFilename[fname] {
        ctx.hashmapsByFilename[fname] = []
      }
      push(ctx.hashmapsByFilename[fname], n)
    }

    if n.type == NODE.Assignment and n.target and n.target.type == NODE.Dot {
      let target = n.target
      let obj = target.object
      let prop = target.property
      if obj and obj.type == NODE.Identifier and prop {
        let propName = propNameFromNode(prop)
        if propName {
          let key = obj.name + "." + propName
          if !ctx.assignmentsByObjectProp[fname] {
            ctx.assignmentsByObjectProp[fname] = .{}
          }
          if !ctx.assignmentsByObjectProp[fname][key] {
            ctx.assignmentsByObjectProp[fname][key] = n.value
          }
        }
      }
    }
  })
}

fn findImportByPathNode(ctx, pathNode) {
  if !ctx or !ctx.nodes or !pathNode or !pathNode.id or !pathNode.filename {
    return nil
  }

  let ids = ctx.fileNodeIds and ctx.fileNodeIds[pathNode.filename] or nil
  if !ids {
    ids = keys(ctx.nodes)
  }

  for let i = 0; i < len(ids); i = i + 1 {
    let cand = ctx.nodes[ids[i]]
    if cand and cand.type == NODE.Import and cand.path and cand.path.id == pathNode.id {
      return cand
    }
  }
  nil
}

// ========================================
// Node Selection
// ========================================

fn contains(n, line, col) {
  if line < n.line or line > n.endLine {
    return false
  }
  if line == n.line and col < n.col {
    return false
  }
  if line == n.endLine and col >= n.endCol {
    return false
  }
  true
}

fn spanScore(n) {
  (n.endLine - n.line) * 100000 + (n.endCol - n.col)
}

fn nodeAtPos(ctx, filename, line, col) {
  if !ctx or !ctx.nodes {
    return nil
  }

  let ids = nil
  if ctx.fileNodeIds and type(ctx.fileNodeIds) == "map" and ctx.fileNodeIds[filename] {
    ids = ctx.fileNodeIds[filename]
  } else {
    ids = keys(ctx.nodes)
  }

  let best = nil
  let bestScore = nil

  each(ids, fn(id) {
    let n = ctx.nodes[id]
    if !n or n.filename != filename {
      return
    }
    if !contains(n, line, col) {
      return
    }

    let s = spanScore(n)
    // Prefer smaller span, or if tied, prefer larger ID (more specific/nested node)
    // Also skip Program nodes if we have alternatives
    if !best or s < bestScore or (s == bestScore and n.id > best.id) {
      best = n
      bestScore = s
    }
  })

  best
}

fn nodeAtPosWithTies(ctx, filename, line, col) {
  if !ctx or !ctx.nodes {
    return .{ node: nil, ties: [] }
  }

  let ids = nil
  if ctx.fileNodeIds and type(ctx.fileNodeIds) == "map" and ctx.fileNodeIds[filename] {
    ids = ctx.fileNodeIds[filename]
  } else {
    ids = keys(ctx.nodes)
  }

  let best = nil
  let bestScore = nil
  let candidates = []

  each(ids, fn(id) {
    let n = ctx.nodes[id]
    if !n or n.filename != filename {
      return
    }
    if !contains(n, line, col) {
      return
    }

    let s = spanScore(n)
    if !best or s < bestScore {
      best = n
      bestScore = s
      candidates = [n]
      return
    }

    if s == bestScore {
      push(candidates, n)
      if n.id > best.id {
        best = n
      }
    }
  })

  let ties = []
  for let i = 0; i < len(candidates); i = i + 1 {
    let cand = candidates[i]
    if best and cand.id != best.id {
      push(ties, cand)
    }
  }

  .{ node: best, ties }
}

fn lastExprFromAst(ast) {
  if ast and ast.expressions and len(ast.expressions) > 0 {
    return ast.expressions[len(ast.expressions) - 1]
  }
  if ast and ast.body and len(ast.body) > 0 {
    return ast.body[len(ast.body) - 1]
  }
  nil
}

fn findLetByNameNode(ctx, nameNode) {
  // Early return if no context
  if !ctx {
    return nil
  }

  let key = spanKeyFromNode(nameNode)

  // Check primary index first
  if ctx.letsByNameSpan and key and ctx.letsByNameSpan[key] {
    return ctx.letsByNameSpan[key]
  }

  // Initialize query cache if needed
  if !ctx._queryCache { ctx._queryCache = .{} }
  if !ctx._queryCache.letByNameId { ctx._queryCache.letByNameId = .{} }
  if !ctx._queryCache.letMiss { ctx._queryCache.letMiss = .{} }

  let cacheKey = key or (nameNode and nameNode.id and str(nameNode.id)) or nil

  // Check cache hit
  if cacheKey and ctx._queryCache.letByNameId[cacheKey] {
    return ctx._queryCache.letByNameId[cacheKey]
  }

  // Check cache miss
  if cacheKey and ctx._queryCache.letMiss[cacheKey] {
    return nil
  }

  // Not found - record cache miss and return nil
  // (Removed linear scan fallback for performance)
  if cacheKey {
    ctx._queryCache.letMiss[cacheKey] = true
  }
  nil
}

fn propNodeCacheKey(propNode) {
  spanKeyFromNode(propNode)
}

fn findDotByPropertyNode(ctx, propNode) {
  // Early return if no context
  if !ctx {
    return nil
  }

  let key = spanKeyFromNode(propNode)

  // Check primary index first
  if ctx.dotsByPropertySpan and key and ctx.dotsByPropertySpan[key] {
    return ctx.dotsByPropertySpan[key]
  }

  // Initialize query cache if needed
  if !ctx._queryCache { ctx._queryCache = .{} }
  if !ctx._queryCache.dotByProp { ctx._queryCache.dotByProp = .{} }
  if !ctx._queryCache.dotMiss { ctx._queryCache.dotMiss = .{} }

  let cacheKey = propNodeCacheKey(propNode)

  // Check cache hit
  if cacheKey and ctx._queryCache.dotByProp[cacheKey] {
    return ctx._queryCache.dotByProp[cacheKey]
  }

  // Check cache miss
  if cacheKey and ctx._queryCache.dotMiss[cacheKey] {
    return nil
  }

  // Not found - record cache miss and return nil
  // (Removed linear scan fallback for performance)
  if cacheKey {
    ctx._queryCache.dotMiss[cacheKey] = true
  }
  nil
}

fn findRecordField(recordNode, fieldName) {
  if !recordNode or recordNode.type != NODE.Hashmap or !recordNode.pairs {
    return nil
  }

  // Build field index lazily on first access
  if !recordNode._fieldIndex {
    recordNode._fieldIndex = .{}
    for let i = 0; i < len(recordNode.pairs); i = i + 1 {
      let pair = recordNode.pairs[i]
      let key = pair and pair.key
      if key and key.type == NODE.String and key.value {
        recordNode._fieldIndex[key.value] = .{ key, value: pair.value }
      }
    }
  }

  // O(1) lookup instead of O(N) scan
  recordNode._fieldIndex[fieldName]
}

fn gotoTargetForRecordField(ctx, field) {
  if !field {
    return nil
  }

  // Default: jump to the field key in the record literal.
  let target = field.key

  // If the field value is a named identifier, prefer jumping to the identifier's declaration.
  // This makes `A.foo()` land on `fn foo` (or `let foo`) rather than on the export record key.
  let value = field.value
  if value and value.type == NODE.Identifier {
    let r = ctx.resolvedNames and ctx.resolvedNames[nodeKeyFor(ctx, value)]
    if r and r.kind != "builtin" and r.declaredAt {
      let declKey = r.declaredAtKey or r.declaredAt
      let declNode = normalizeDeclTarget(ctx, declKey)
      if declNode {
        target = declNode
      }
    }
  } else if value and value.type == NODE.Function {
    // Inline function literal in record: jump to its name when available.
    if value.name { target = value.name } else { target = value }
  }

  target
}

fn findDotAssignmentValue(ctx, filename, objectName, propName) {
  if ctx and ctx.assignmentsByObjectProp and ctx.assignmentsByObjectProp[filename] {
    let key = objectName + "." + propName
    let value = ctx.assignmentsByObjectProp[filename][key]
    if value {
      return value
    }
  }
  let ids = ctx.fileNodeIds and ctx.fileNodeIds[filename] or keys(ctx.nodes)
  for let i = 0; i < len(ids); i = i + 1 {
    let n = ctx.nodes[ids[i]]
    if n and n.type == NODE.Assignment and n.target and n.target.type == NODE.Dot {
      let target = n.target
      let obj = target.object
      let prop = target.property
      if obj and obj.type == NODE.Identifier and obj.name == objectName {
        let tProp = propNameFromNode(prop)
        if tProp == propName {
          return n.value
        }
      }
    }
  }
  nil
}

fn resolveExprToRecord(ctx, expr, seen) {
  if !expr {
    return nil
  }
  if ctx and expr.id {
    if !ctx._queryCache { ctx._queryCache = .{} }
    if !ctx._queryCache.recordByNodeId { ctx._queryCache.recordByNodeId = .{} }
    if !ctx._queryCache.recordMiss { ctx._queryCache.recordMiss = .{} }
    if ctx._queryCache.recordByNodeId[expr.id] {
      return ctx._queryCache.recordByNodeId[expr.id]
    }
    if ctx._queryCache.recordMiss[expr.id] {
      return nil
    }
  }
  if expr.id and seen and seen[expr.id] {
    return nil
  }
  if expr.id and seen {
    seen[expr.id] = true
  }

  if expr.type == NODE.Hashmap {
    if ctx and expr.id {
      ctx._queryCache.recordByNodeId[expr.id] = expr
    }
    return expr
  }

  if expr.type == NODE.Block {
    let last = lastExprFromAst(expr)
    let rec = resolveExprToRecord(ctx, last, seen)
    if ctx and expr.id {
      if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
      else { ctx._queryCache.recordMiss[expr.id] = true }
    }
    return rec
  }

  if expr.type == NODE.Grouping {
    let rec = resolveExprToRecord(ctx, expr.expression, seen)
    if ctx and expr.id {
      if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
      else { ctx._queryCache.recordMiss[expr.id] = true }
    }
    return rec
  }

  if expr.type == NODE.Identifier {
    let r = ctx.resolvedNames[nodeKeyFor(ctx, expr)]
    if !r or !r.declaredAt {
      return nil
    }
    let declKey = r.declaredAtKey or r.declaredAt
    let decl = ctx.nodes[declKey]
    if !decl {
      return nil
    }
    let letNode = findLetByNameNode(ctx, decl)
    if !letNode or !letNode.init {
      return nil
    }
    if letNode.init.type == NODE.Import and letNode.init.path {
      let modulePath = letNode.init.path.value
      let moduleAst = ctx.moduleAsts and ctx.moduleAsts[modulePath]
      let moduleReturn = moduleAst and lastExprFromAst(moduleAst)
      if moduleReturn {
        let rec = resolveExprToRecord(ctx, moduleReturn, seen)
        if ctx and expr.id {
          if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
          else { ctx._queryCache.recordMiss[expr.id] = true }
        }
        return rec
      }
    }
    let rec = resolveExprToRecord(ctx, letNode.init, seen)
    if ctx and expr.id {
      if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
      else { ctx._queryCache.recordMiss[expr.id] = true }
    }
    return rec
  }

  if expr.type == NODE.Dot {
    let propName = propNameFromNode(expr.property)
    if !propName {
      return nil
    }

    // If base is an imported module, look for assignments in the module file.
    if expr.object and expr.object.type == NODE.Identifier {
      let r = ctx.resolvedNames[nodeKeyFor(ctx, expr.object)]
      if r and r.declaredAt {
        let declKey = r.declaredAtKey or r.declaredAt
        let decl = ctx.nodes[declKey]
        let letNode = decl and findLetByNameNode(ctx, decl)
        if letNode and letNode.init and letNode.init.type == NODE.Import and letNode.init.path {
          let modulePath = letNode.init.path.value
          let moduleAst = ctx.moduleAsts and ctx.moduleAsts[modulePath]
          let moduleReturn = moduleAst and lastExprFromAst(moduleAst)
          if moduleReturn and moduleReturn.type == NODE.Identifier {
            let rootName = moduleReturn.name
            let assignedValue = findDotAssignmentValue(ctx, modulePath, rootName, propName)
            if assignedValue {
              let rec = resolveExprToRecord(ctx, assignedValue, seen)
              if ctx and expr.id {
                if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
                else { ctx._queryCache.recordMiss[expr.id] = true }
              }
              return rec
            }
          }
          // Fall back to module return record literal, if any.
          if moduleReturn {
            let moduleRecord = resolveExprToRecord(ctx, moduleReturn, seen)
            if moduleRecord {
              let field = findRecordField(moduleRecord, propName)
              if field and field.value {
                let rec = resolveExprToRecord(ctx, field.value, seen)
                if ctx and expr.id {
                  if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
                  else { ctx._queryCache.recordMiss[expr.id] = true }
                }
                return rec
              }
            }
          }
        }
      }
    }

    let baseRecord = resolveExprToRecord(ctx, expr.object, seen)
    if !baseRecord {
      if ctx and expr.id {
        ctx._queryCache.recordMiss[expr.id] = true
      }
      return nil
    }
    let field = findRecordField(baseRecord, propName)
    if field and field.value {
      let rec = resolveExprToRecord(ctx, field.value, seen)
      if ctx and expr.id {
        if rec { ctx._queryCache.recordByNodeId[expr.id] = rec }
        else { ctx._queryCache.recordMiss[expr.id] = true }
      }
      return rec
    }
  }

  if ctx and expr.id {
    ctx._queryCache.recordMiss[expr.id] = true
  }
  nil
}

fn posLabel(filename, line, col) {
  join([filename, ":", line, ":", col], "")
}

fn candidatesForNodes(nodes) {
  if !nodes or len(nodes) == 0 {
    return nil
  }
  let out = []
  for let i = 0; i < len(nodes); i = i + 1 {
    let n = nodes[i]
    if n {
      push(out, .{
        range: rangeOf(n),
        nodeType: nameOf(NODE, n.type) or str(n.type),
        nodeId: n.id,
      })
    }
  }
  out
}

fn isCompositeKey(key) {
  if type(key) != "String" {
    return false
  }
  len(split(key, ":")) > 1
}

fn validateCtxOnce(ctx) {
  if !ctx or ctx._validated {
    return
  }
  ctx._validated = true
  if !ctx.warnings {
    ctx.warnings = []
  }

  let missing = []

  let nodeKeys = keys(ctx.nodes)
  let composite = len(nodeKeys) > 0 and isCompositeKey(nodeKeys[0])

  if ctx.resolvedNames {
    let ids = keys(ctx.resolvedNames)
    for let i = 0; i < len(ids); i = i + 1 {
      let id = ids[i]
      if composite {
        if !ctx.nodes[id] {
          push(missing, id)
        }
      } else if !idMapGet(ctx.nodes, id) {
        push(missing, id)
      }
    }
  }

  if ctx.types {
    let ids = keys(ctx.types)
    for let i = 0; i < len(ids); i = i + 1 {
      let id = ids[i]
      if composite {
        if !ctx.nodes[id] {
          push(missing, id)
        }
      } else if !idMapGet(ctx.nodes, id) {
        push(missing, id)
      }
    }
  }

  if ctx.fileNodeIds {
    let files = keys(ctx.fileNodeIds)
    for let i = 0; i < len(files); i = i + 1 {
      let ids = ctx.fileNodeIds[files[i]]
      if ids {
        for let j = 0; j < len(ids); j = j + 1 {
          let id = ids[j]
          if composite {
            if !ctx.nodes[id] {
              push(missing, id)
            }
          } else if !idMapGet(ctx.nodes, id) {
            push(missing, id)
          }
        }
      }
    }
  }

  if len(missing) > 0 {
    let sample = []
    let limit = len(missing) < 5 and len(missing) or 5
    for let i = 0; i < limit; i = i + 1 {
      push(sample, missing[i])
    }
    push(ctx.warnings, .{
      kind: "missing-nodes",
      message: "Query ctx missing node ids",
      count: len(missing),
      sampleIds: sample,
    })
  }
}

// ========================================
// Goto Definition Normalization
// ========================================

fn normalizeDeclTarget(ctx, declNodeId) {
  let decl = ctx.nodes[declNodeId]
  if !decl {
    return nil
  }

  // If resolver stored the Function node id for named functions,
  // prefer jumping to the name identifier span when available.
  if decl.type == NODE.Function and decl.name and decl.name.id {
    // `ctx.nodes` may be keyed by either raw node ids (single-module)
    // or composite keys `filename:id` (merged multi-module query ctx).
    let nameNode = ctx.nodes[decl.name.id] or ctx.nodes[nodeKeyFromParts(decl.filename, decl.name.id)]
    if nameNode {
      return nameNode
    }
  }

  // Otherwise use the node itself (Identifier bindings already land perfectly)
  decl
}

// ========================================
// Type Formatting
// ========================================

fn formatType(ty) {
  if !ty {
    return "Unknown"
  }

  let kind = ty.kind

  // Primitives
  if kind == "Number" { return "Number" }
  if kind == "String" { return "String" }
  if kind == "Bool" { return "Bool" }
  if kind == "Nil" { return "Nil" }
  if kind == "Any" { return "Any" }
  if kind == "Unknown" { return "Unknown" }

  // TypeVar - show as T<id> for now
  if kind == "TypeVar" {
    return "T" + str(ty.id)
  }

  // Array
  if kind == "Array" {
    return "Array<" + formatType(ty.elem) + ">"
  }

  // Option
  if kind == "Option" {
    return "Option<" + formatType(ty.value) + ">"
  }

  // Map
  if kind == "Map" {
    return "Map<" + formatType(ty.key) + ", " + formatType(ty.elem) + ">"
  }

  // Function
  if kind == "Function" {
    let params = ty.params
    let paramStrs = []
    for let i = 0; i < len(params); i = i + 1 {
      push(paramStrs, formatType(params[i]))
    }
    let paramStr = join(paramStrs, ", ")
    return "fn(" + paramStr + ") -> " + formatType(ty.return)
  }

  // Record - check field count for expansion
  if kind == "Record" {
    let fields = ty.fields
    let fieldNames = keys(fields)
    fieldNames->sort(keyLess)
    let fieldCount = len(fieldNames)

    // Small records: expand inline
    if fieldCount <= 6 {
      let fieldStrs = []
      for let i = 0; i < fieldCount; i = i + 1 {
        let fname = fieldNames[i]
        push(fieldStrs, fname + ": " + formatType(fields[fname]))
      }
      return ".{ " + join(fieldStrs, ", ") + " }"
    }

    // Large records: collapse
    return ".{ ... }"
  }

  // Tagged unions
  if kind == "Tagged" {
    let tagField = ty.tagField
    let cases = ty.cases
    let caseNames = keys(cases)
    return tagField + "(" + join(caseNames, " | ") + ")"
  }

  // RecordTop, LenableTop (constraint types)
  if kind == "RecordTop" { return "Record" }
  if kind == "LenableTop" { return "Lenable" }

  // Scheme (polymorphic type schemes)
  if kind == "Scheme" {
    return formatType(ty.type)
  }

  // Fallback
  "(" + kind + ")"
}

fn formatTypeWithBindings(ctx, ty) {
  fn fmt(t, seen) {
    if !t {
      return "Unknown"
    }

    let kind = t.kind

    if kind == "TypeVar" {
      let id = t.id
      if ctx.typeVarBindings and id and !seen[id] {
        let binding = ctx.typeVarBindings[id]
        if binding {
          seen[id] = true
          return fmt(binding, seen)
        }
      }
      // Unbound type var
      return "'T" + str(id)
    }

    if kind == "Array" {
      return "Array<" + fmt(t.elem, seen) + ">"
    }
    if kind == "Option" {
      return "Option<" + fmt(t.value, seen) + ">"
    }
    if kind == "Map" {
      return "Map<" + fmt(t.key, seen) + ", " + fmt(t.elem, seen) + ">"
    }
    if kind == "Function" {
      let params = t.params
      let paramStrs = []
      for let i = 0; i < len(params); i = i + 1 {
        push(paramStrs, fmt(params[i], seen))
      }
      return "fn(" + join(paramStrs, ", ") + ") -> " + fmt(t.return, seen)
    }
    if kind == "Record" {
      let fields = t.fields
      let fieldNames = keys(fields)
      fieldNames->sort(keyLess)
      let fieldCount = len(fieldNames)

      if fieldCount <= 6 {
        let fieldStrs = []
        for let i = 0; i < fieldCount; i = i + 1 {
          let fname = fieldNames[i]
          push(fieldStrs, fname + ": " + fmt(fields[fname], seen))
        }
        return ".{ " + join(fieldStrs, ", ") + " }"
      }
      return ".{ ... }"
    }
    if kind == "Tagged" {
      let tagField = t.tagField
      let cases = t.cases
      let caseNames = keys(cases)
      return tagField + "(" + join(caseNames, " | ") + ")"
    }
    if kind == "RecordTop" { return "Record" }
    if kind == "LenableTop" { return "Lenable" }
    if kind == "Scheme" { return fmt(t.type, seen) }
    if kind == "Number" { return "Number" }
    if kind == "String" { return "String" }
    if kind == "Bool" { return "Bool" }
    if kind == "Nil" { return "Nil" }
    if kind == "Any" { return "Any" }
    if kind == "Unknown" { return "Unknown" }

    "(" + kind + ")"
  }

  fmt(ty, .{})
}

// Check if a name is a valid builtin (either native or prelude)
fn isValidBuiltin(name) {
  if !name { return false }
  // Check if name or its root (for dotted names like "Lx.fs") is a builtin
  if builtinsData.NATIVE_NAMES[name] { return true }
  if builtinsData.PRELUDE_NAMES[name] { return true }
  // For root-level names like "Lx", "Math", "Date", check if they're known namespaces
  let root = split(name, ".")[0]
  if builtinsData.NATIVE_NAMES[root] { return true }
  false
}

// Get documentation for a builtin name
fn getBuiltinDoc(name) {
  builtinsData.DOCS[name]
}

// Given a string key node inside a record literal, return the value's type if known.
fn valueTypeForRecordKey(ctx, keyNode) {
  if !keyNode or !keyNode.id {
    return nil
  }

  let fname = keyNode.filename
  let hashmaps = ctx.hashmapsByFilename and ctx.hashmapsByFilename[fname] or nil
  let ids = nil
  if hashmaps {
    ids = hashmaps
  } else {
    ids = ctx.fileNodeIds[fname] or keys(ctx.nodes)
  }

  for let i = 0; i < len(ids); i = i + 1 {
    let cand = hashmaps and ids[i] or ctx.nodes[ids[i]]
    if !cand or cand.type != NODE.Hashmap or cand.filename != fname {
      continue
    }

    if !cand.pairs or type(cand.pairs) != "array" {
      continue
    }

    for let j = 0; j < len(cand.pairs); j = j + 1 {
      let pair = cand.pairs[j]
      if pair.key and pair.key.id == keyNode.id {
        if pair.value {
          return ctx.types[nodeKeyFor(ctx, pair.value)]
        }
      }
    }
  }

  nil
}

// Build richer hover payload: always include formatted type, and when possible,
// attach symbol resolution + declaration info for identifiers.
fn buildSymbolInfo(ctx, n) {
  if !n or n.type != NODE.Identifier {
    return nil
  }

  let info = .{ name: n.name or n.lexeme or "(anonymous)" }
  let r = ctx.resolvedNames[nodeKeyFor(ctx, n)]

  if !r {
    info.kind = "unresolved"
    return info
  }

  info.kind = r.kind

  // Provide binding category for hover display
  if r.kind == "local" {
    info.bindingKind = "local"
    if r.slot != nil {
      info.slot = r.slot
    }
  } else if r.kind == "upvalue" {
    info.bindingKind = "upvalue"
    if r.upvalueIndex != nil {
      info.upvalueIndex = r.upvalueIndex
    }
  } else if r.kind == "builtin" {
    // Check if this is an actual builtin or an undefined variable
    let name = r.name or n.name
    if isValidBuiltin(name) {
      info.bindingKind = "global"
      info.builtinName = name
      // Include documentation if available
      let doc = getBuiltinDoc(name)
      if doc {
        info.documentation = doc.markdown
        info.signature = doc.signature
      }
    } else {
      // Not a valid builtin - this is an undefined variable
      info.bindingKind = "undefined"
      info.isUndefined = true
    }
  }

  if r.declaredAt {
    let declKey = r.declaredAtKey or r.declaredAt
    let declNode = ctx.nodes[declKey]
    if declNode {
      info.declaration = rangeOf(declNode)
      info.declarationNodeType = nameOf(NODE, declNode.type) or str(declNode.type)

      let declType = ctx.types[nodeKeyFor(ctx, declNode)]
      if declType {
        info.declarationType = formatTypeWithBindings(ctx, declType)
      }
    }
  }

  info
}

fn buildHoverContents(ctx, n, ty) {
  // If hovering a record key, prefer the field's value type over the literal String type.
  if n.type == NODE.String {
    let fieldType = valueTypeForRecordKey(ctx, n)
    if fieldType {
      ty = fieldType
    }
  }

  let contents = .{ type: formatTypeWithBindings(ctx, ty) }
  let symbol = buildSymbolInfo(ctx, n)
  if symbol {
    contents.symbol = symbol
    // For builtins with signatures, use the signature as the type instead of "Unknown"
    // and remove it from symbol to avoid duplication
    if contents.type == "Unknown" and symbol.signature {
      contents.type = nil
    }
  }
  contents
}

// ========================================
// Public API
// ========================================

fn queryInit(ast, resolveResult, typecheckResult, opts) {
  // Start with resolver's nodes, then collect any missing nodes from AST
  let nodes = resolveResult.nodes
  collectAllNodes(ast, nodes)

  let tc = typecheckResult or .{}
  let ctx = .{
    ast: ast,
    nodes: nodes,
    resolvedNames: resolveResult.resolvedNames,
    types: tc.types or .{},
    typeVarBindings: tc.typeVarBindings or .{},
    fileNodeIds: .{},
  }

  let buildIndex = !(opts and opts.buildIndex == false)
  if buildIndex {
    buildFileIndex(ctx)
  }

  .{ success: true, ctx }
}

fn queryHover(ctx, filename, line, col) {
  validateCtxOnce(ctx)
  let sel = nodeAtPosWithTies(ctx, filename, line, col)
  let n = sel.node
  if n and n.type == NODE.String {
    let dotNode = findDotByPropertyNode(ctx, n)
    if dotNode {
      n = dotNode
    }
  }
  if n and n.type == NODE.Identifier {
    let dotNode = findDotByPropertyNode(ctx, n)
    if dotNode {
      n = dotNode
    }
  }
  // If we landed on a Let node but the cursor is within the name span,
  // prefer the identifier (some resolvers omit name nodes from the index).
  if n and n.type == NODE.Let and n.name and contains(n.name, line, col) {
    n = n.name
  }
  // If cursor is on a named function's identifier, prefer the name node.
  if n and n.type == NODE.Function and n.name and contains(n.name, line, col) {
    n = n.name
  }
  if !n {
    return .{ success: false, kind: "hover", message: "No node at position: " + posLabel(filename, line, col) }
  }

  let ty = ctx.types[nodeKeyFor(ctx, n)]
  let contents = buildHoverContents(ctx, n, ty)
  if n.type == NODE.Dot {
    let propName = propNameFromNode(n.property)
    contents.dot = .{
      objectName: (n.object and n.object.type == NODE.Identifier and n.object.name) or nil,
      objectPath: dotPathFromNode(n.object),
      path: dotPathFromNode(n),
      propertyName: propName,
    }

    if propName {
      let record = resolveExprToRecord(ctx, n.object, .{})
      if record {
        let field = findRecordField(record, propName)
        if field and field.key {
          contents.property = .{
            name: propName,
            definedAt: rangeOf(field.key),
          }
          if field.value {
            let v = field.value
            if v.type == NODE.Number {
              contents.property.valueText = join([v.value], "")
            } else if v.type == NODE.String {
              contents.property.valueText = "\"" + (v.value or "") + "\""
            } else if v.type == NODE.Bool {
              contents.property.valueText = v.value and "true" or "false"
            } else if v.type == NODE.Nil {
              contents.property.valueText = "nil"
            } else if v.type == NODE.Identifier {
              contents.property.valueText = v.name
            }
          }
        }
      }
    }
  }

  let details = .{ nodeType: (nameOf(NODE, n.type) or str(n.type)), nodeId: n.id }

  if n.type == NODE.Identifier {
    let r = ctx.resolvedNames[nodeKeyFor(ctx, n)]
    if r {
      details.resolved = r
    }
  }

  let candidates = candidatesForNodes(sel.ties)

  .{
    success: true,
    kind: "hover",
    range: rangeOf(n),
    contents,
    details,
    candidates,
  }
}

fn queryGotoDefinition(ctx, filename, line, col) {
  validateCtxOnce(ctx)
  let sel = nodeAtPosWithTies(ctx, filename, line, col)
  let n = sel.node
  if !n {
    return .{ success: false, kind: "goto", message: "No node at position: " + posLabel(filename, line, col) }
  }

  if n.type == NODE.String {
    // Import path string literal: jump to the imported file itself.
    let importNode = findImportByPathNode(ctx, n)
    if importNode and importNode.path and importNode.path.value {
      return .{
        success: true,
        kind: "goto",
        target: .{
          filename: importNode.path.value,
          line: 1,
          col: 0,
          endLine: 1,
          endCol: 0,
        },
        candidates: candidatesForNodes(sel.ties),
      }
    }

    let dotNode = findDotByPropertyNode(ctx, n)
    let propName = propNameFromNode(n)
    if dotNode and propName {
      let record = resolveExprToRecord(ctx, dotNode.object, .{})
      if record {
        let field = findRecordField(record, propName)
        if field and field.key {
          let targetNode = gotoTargetForRecordField(ctx, field) or field.key
          return .{
            success: true,
            kind: "goto",
            target: rangeOf(targetNode),
            candidates: candidatesForNodes(sel.ties),
          }
        }
      }
    }
  }

  if n.type == NODE.Dot {
    let propName = propNameFromNode(n.property)
    if propName {
      let record = resolveExprToRecord(ctx, n.object, .{})
      if record {
        let field = findRecordField(record, propName)
        if field and field.key {
          let targetNode = gotoTargetForRecordField(ctx, field) or field.key
          return .{
            success: true,
            kind: "goto",
            target: rangeOf(targetNode),
            candidates: candidatesForNodes(sel.ties),
          }
        }
      }
    }
  }

  if n.type != NODE.Identifier {
    return .{ success: false, kind: "goto", message: "Not an identifier at " + posLabel(filename, line, col) }
  }

  let r = ctx.resolvedNames[nodeKeyFor(ctx, n)]
  if !r {
    return .{ success: false, kind: "goto", message: "Unresolved identifier" }
  }

  if r.kind == "builtin" {
    return .{ success: false, kind: "goto", message: "Builtin has no tracked definition" }
  }

  let declNodeId = r.declaredAtKey or r.declaredAt
  if !declNodeId {
    return .{ success: false, kind: "goto", message: "Missing declaredAt (compiler bug)" }
  }

  let targetNode = normalizeDeclTarget(ctx, declNodeId)
  if !targetNode {
    return .{ success: false, kind: "goto", message: "Declaration node missing (compiler bug)" }
  }

  .{
    success: true,
    kind: "goto",
    target: rangeOf(targetNode),
    candidates: candidatesForNodes(sel.ties),
  }
}

fn buildNodeIndexFromAst(ast) {
  let nodes = .{}
  if ast {
    collectAllNodes(ast, nodes)
  }
  nodes
}

fn parseParseError(err) {
  if !err {
    return nil
  }

  let parts = split(err, "] ")
  let header = parts[0] or ""
  let msg = (len(parts) > 1 and parts[1]) or err

  let headerParts = split(header, ":L")
  if len(headerParts) < 2 {
    return .{ message: msg, severity: "error" }
  }

  let fileParts = split(headerParts[0], "[")
  let filename = fileParts[len(fileParts) - 1]
  let lcParts = split(headerParts[1], ":C")
  let line = (len(lcParts) > 0 and tonumber(lcParts[0])) or 0
  let col = (len(lcParts) > 1 and tonumber(lcParts[1])) or 0

  .{
    message: msg,
    severity: "error",
    filename,
    line,
    col,
  }
}

fn diagFromNodeId(nodes, nodeId, err, phase) {
  let n = nodes and nodeId and nodes[nodeId]
  let diag = .{
    message: err.message or err,
    severity: err.severity or "error",
    phase,
  }
  if n {
    diag.filename = n.filename
    diag.line = n.line
    diag.col = n.col
    diag.endLine = n.endLine
    diag.endCol = n.endCol
    diag.nodeId = nodeId
  }
  diag
}

// Normalize compiler errors into a diagnostics list.
// Accepts a query.compile result or raw driver compile result.
fn queryDiagnostics(result) {
  let compileResult = result and result.compileResult or result
  let ctx = result and result.ctx or nil
  let diags = []
  if !compileResult {
    return diags
  }

  // Guard against early failures (e.g., source load failure) that may not have passes
  let passes = compileResult.passes or .{}

  if passes.parse and passes.parse.errors {
    for let i = 0; i < len(passes.parse.errors); i = i + 1 {
      let d = parseParseError(passes.parse.errors[i])
      if d { push(diags, d) }
    }
  }

  if passes.lower and passes.lower.errors {
    let nodes = buildNodeIndexFromAst((passes.lower and passes.lower.ast) or (passes.parse and passes.parse.ast))
    for let i = 0; i < len(passes.lower.errors); i = i + 1 {
      let err = passes.lower.errors[i]
      let nodeId = err.nodeId
      push(diags, diagFromNodeId(nodes, nodeId, err, "lower"))
    }
  }

  if passes.resolve and !passes.resolve.success {
    let nodes = passes.resolve.nodes
    for let i = 0; i < len(passes.resolve.errors); i = i + 1 {
      let err = passes.resolve.errors[i]
      let nodeId = err.nodeId
      push(diags, diagFromNodeId(nodes, nodeId, err, "resolve"))
    }
  }

  if passes.typecheck and !passes.typecheck.success {
    // Start with resolver nodes if available, otherwise use ctx.nodes or empty map
    let nodes = (passes.resolve and passes.resolve.nodes) or (ctx and ctx.nodes)
    if !nodes {
      nodes = .{}
    }
    // Always merge in nodes from lowered AST to ensure completeness
    // (resolver.nodes may be incomplete, missing some AST nodes)
    let ast = (passes.lower and passes.lower.ast) or (passes.parse and passes.parse.ast)
    if ast {
      collectAllNodes(ast, nodes)
    }
    for let i = 0; i < len(passes.typecheck.errors); i = i + 1 {
      let err = passes.typecheck.errors[i]
      let nodeId = err.nodeId
      push(diags, diagFromNodeId(nodes, nodeId, err, "typecheck"))
    }
  }

  // Detect undefined variables: names resolved as "builtin" but not in NATIVE_NAMES or PRELUDE_NAMES
  if passes.resolve and passes.resolve.resolvedNames {
    let nodes = passes.resolve.nodes or .{}
    let resolvedIds = keys(passes.resolve.resolvedNames)
    for let i = 0; i < len(resolvedIds); i = i + 1 {
      let nodeId = resolvedIds[i]
      let r = passes.resolve.resolvedNames[nodeId]
      if r and r.kind == "builtin" and r.name {
        if !isValidBuiltin(r.name) {
          let node = nodes[nodeId]
          push(diags, .{
            message: "Undefined variable '" + r.name + "'",
            severity: "error",
            phase: "resolve",
            filename: node and node.filename or nil,
            line: node and node.line or nil,
            col: node and node.col or nil,
            endLine: node and node.endLine or nil,
            endCol: node and node.endCol or nil,
            nodeId: nodeId,
          })
        }
      }
    }
  }

  // Run nil-check analysis if we have a valid context with resolve info
  if ctx and ctx.ast and ctx.resolvedNames {
    let nilCheckDiags = queryNilCheck(ctx)
    if nilCheckDiags {
      for let i = 0; i < len(nilCheckDiags); i = i + 1 {
        push(diags, nilCheckDiags[i])
      }
    }
  }

  diags
}

// ========================================
// High-Level API
// ========================================

let Driver = import "src/driver.lx"
let ModuleResolution = import "src/module_resolution.lx"

// Remap type vars and node ids for merged query context.
fn remapType(t, typeVarMap, nextTypeVarIdRef) {
  if !t {
    return nil
  }

  let out = .{}
  let ks = keys(t)
  for let i = 0; i < len(ks); i = i + 1 {
    let k = ks[i]
    out[k] = t[k]
  }

  if t.kind == "TypeVar" {
    let oldId = t.id
    let newId = idMapGet(typeVarMap, oldId)
    if !newId {
      newId = nextTypeVarIdRef.value
      nextTypeVarIdRef.value = newId + 1
      typeVarMap[oldId] = newId
      typeVarMap[str(oldId)] = newId
    }
    out.id = newId
    return out
  }

  if t.kind == "Function" {
    if t.params {
      let params = []
      for let i = 0; i < len(t.params); i = i + 1 {
        push(params, remapType(t.params[i], typeVarMap, nextTypeVarIdRef))
      }
      out.params = params
    }
    out.return = remapType(t.return, typeVarMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Array" {
    out.elem = remapType(t.elem, typeVarMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Map" {
    out.key = remapType(t.key, typeVarMap, nextTypeVarIdRef)
    out.elem = remapType(t.elem, typeVarMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Record" {
    let fields = .{}
    let fieldKeys = t.fields and keys(t.fields) or []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      fields[k] = remapType(t.fields[k], typeVarMap, nextTypeVarIdRef)
    }
    out.fields = fields
    return out
  }

  if t.kind == "Option" {
    out.value = remapType(t.value, typeVarMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Indexable" {
    out.elem = remapType(t.elem, typeVarMap, nextTypeVarIdRef)
    out.key = remapType(t.key, typeVarMap, nextTypeVarIdRef)
    return out
  }

  out
}

fn collectReachable(driver, entry) {
  let seen = .{}
  let work = [entry]

  for len(work) > 0 {
    let p = pop(work)
    if !p or seen[p] { continue }
    seen[p] = true

    let mod = driver and driver.cache and driver.cache[p] or nil
    if !mod or mod.status != "done" or !mod.passes or !mod.passes.resolve {
      continue
    }

    let importInfo = mod.passes.resolve.importInfoByNodeId or nil
    if !importInfo or type(importInfo) != "map" {
      continue
    }

    let ks = keys(importInfo)
    for let i = 0; i < len(ks); i = i + 1 {
      let info = importInfo[ks[i]]
      let dep = info and info.importResult and info.importResult.path or nil
      if dep and !seen[dep] {
        push(work, dep)
      }
    }
  }

  let out = keys(seen)
  out->sort(keyLess)
  out
}

// Compile file and create query context in one step
// This is the recommended API for IDE/LSP tooling
fn compileWithDriver(driver, filepath, opts) {
  let withTypecheck = !(opts and opts.withTypecheck == false)
  let effectiveWithTypecheck = withTypecheck and driver and driver.withTypecheck != false
  let mergeScope = opts and opts.mergeScope or "all"

  // Compile module through full pipeline
  let result = driver.compileModule(filepath)

  // Check for compilation failure
  if result.status != "done" {
    let phase = "unknown"
    let errors = []
    let passes = result.passes or .{}

    if passes.parse and passes.parse.errors {
      phase = "parse"
      errors = passes.parse.errors
    } else if passes.lower and passes.lower.errors {
      phase = "lower"
      errors = passes.lower.errors
    } else if passes.resolve and !passes.resolve.success {
      phase = "resolve"
      errors = passes.resolve.errors
    } else if effectiveWithTypecheck and passes.typecheck and !passes.typecheck.success {
      phase = "typecheck"
      errors = passes.typecheck.errors
    }

    return .{
      success: false,
      phase,
      errors,
      compileResult: result,
    }
  }

  // Merge all compiled modules into a single query context with global IDs.
  let merged = .{
    ast: (result.passes.lower and result.passes.lower.ast) or (result.passes.parse and result.passes.parse.ast),
    nodes: .{},
    resolvedNames: .{},
    types: .{},
    typeVarBindings: .{},
    fileNodeIds: .{},
    moduleAsts: .{},
  }

  let nextTypeVarId = .{ value: 1 }
  let mergeKeys =
    mergeScope == "reachable" and collectReachable(driver, filepath) or keys(driver.cache)
  mergeKeys->sort(keyLess)
  for let i = 0; i < len(mergeKeys); i = i + 1 {
    let k = mergeKeys[i]
    let mod = driver.cache[k]
    if mod and mod.status == "done" and mod.passes.resolve {
      let moduleNodes = .{}
      let baseNodeKeys = keys(mod.passes.resolve.nodes)
      for let j = 0; j < len(baseNodeKeys); j = j + 1 {
        let id = baseNodeKeys[j]
        moduleNodes[id] = mod.passes.resolve.nodes[id]
      }
      // Always merge in nodes from AST to ensure completeness (resolver.nodes may be incomplete).
      let ast = (mod.passes.lower and mod.passes.lower.ast) or (mod.passes.parse and mod.passes.parse.ast)
      if ast { collectAllNodes(ast, moduleNodes) }

      let nodeKeys = keys(moduleNodes)
      nodeKeys->sort(keyLess)
      for let j = 0; j < len(nodeKeys); j = j + 1 {
        let oldId = nodeKeys[j]
        let node = moduleNodes[oldId]
        if node and node.filename {
          let key = nodeKeyFromParts(node.filename, node.id)
          merged.nodes[key] = node
        }
      }

      if mod.path {
        let ast = (mod.passes.lower and mod.passes.lower.ast) or (mod.passes.parse and mod.passes.parse.ast)
        if ast {
          merged.moduleAsts[mod.path] = ast
        }
      }

      // Remap and merge resolved names
      let resKeys = keys(mod.passes.resolve.resolvedNames)
      resKeys->sort(keyLess)
      for let j = 0; j < len(resKeys); j = j + 1 {
        let oldId = resKeys[j]
        let r = mod.passes.resolve.resolvedNames[oldId]
        if r {
          let node = moduleNodes[oldId]
          let newId = node and node.filename and nodeKeyFromParts(node.filename, oldId) or nil
          if !newId { continue }
          let r2 = .{}
          let rks = keys(r)
          for let k = 0; k < len(rks); k = k + 1 {
            let rk = rks[k]
            r2[rk] = r[rk]
          }
          if r2.declaredAt {
            let declNode = moduleNodes[r2.declaredAt]
            if declNode and declNode.filename {
              r2.declaredAtKey = nodeKeyFromParts(declNode.filename, declNode.id)
            }
          }
          merged.resolvedNames[newId] = r2
        }
      }

      // Remap and merge types + bindings (optional)
      if effectiveWithTypecheck and mod.passes.typecheck {
        let typeVarMap = .{}
        let typeKeys = keys(mod.passes.typecheck.types or .{})
        typeKeys->sort(keyLess)
        for let j = 0; j < len(typeKeys); j = j + 1 {
          let oldId = typeKeys[j]
          let node = moduleNodes[oldId]
          let newId = node and node.filename and nodeKeyFromParts(node.filename, oldId) or nil
          if newId {
            merged.types[newId] = remapType(
              mod.passes.typecheck.types[oldId],
              typeVarMap,
              nextTypeVarId
            )
          }
        }

        let bindKeys = keys(mod.passes.typecheck.typeVarBindings or .{})
        bindKeys->sort(keyLess)
        for let j = 0; j < len(bindKeys); j = j + 1 {
          let oldTid = bindKeys[j]
          let newTid = idMapGet(typeVarMap, oldTid)
          if !newTid {
            newTid = nextTypeVarId.value
            nextTypeVarId.value = newTid + 1
            typeVarMap[oldTid] = newTid
            typeVarMap[str(oldTid)] = newTid
          }
          merged.typeVarBindings[newTid] = remapType(
            mod.passes.typecheck.typeVarBindings[oldTid],
            typeVarMap,
            nextTypeVarId
          )
        }
      }
    }
  }

  buildFileIndex(merged)

  // Return query context ready to use
  .{
    success: true,
    ctx: merged,
    compileResult: result,
  }
}

fn compileWithOpts(filepath, opts) {
  let withTypecheck = !(opts and opts.withTypecheck == false)
  let loadSource = (opts and opts.loadSource) or fn(path) {
    let resolver = ModuleResolution.forEntry(filepath)
    resolver.slurp(path)
  }

  // Create driver that loads from filesystem
  let driver = Driver.make(.{
    profile: "query",
    loadSource: loadSource,
    withTypecheck: withTypecheck,
  })

  compileWithDriver(driver, filepath, opts)
}

fn compile(filepath) {
  compileWithOpts(filepath, nil)
}

fn compileFast(filepath) {
  compileWithOpts(filepath, .{ withTypecheck: false })
}

// ========================================
// Completion Support
// ========================================

fn buildCompletionIndex(ctx) {
  if !ctx or !ctx.nodes {
    return .{ declarationsByFile: .{}, builtins: .{} }
  }

  if ctx._completionIndex {
    return ctx._completionIndex
  }

  let index = .{
    declarationsByFile: .{},
    builtins: .{},
  }

  // O(n) scan through all nodes
  let nodeKeys = keys(ctx.nodes)
  for let i = 0; i < len(nodeKeys); i = i + 1 {
    let nodeId = nodeKeys[i]
    let n = ctx.nodes[nodeId]
    if !n or type(n) != "map" { continue }

    let fname = n.filename or ""

    // Collect let declarations
    if n.type == NODE.Let and n.name and n.name.name {
      if !index.declarationsByFile[fname] {
        index.declarationsByFile[fname] = []
      }
      push(index.declarationsByFile[fname], .{
        name: n.name.name,
        kind: "variable",
        declNode: n,
      })
    }

    // Collect named functions
    if n.type == NODE.Function and n.name and n.name.name {
      if !index.declarationsByFile[fname] {
        index.declarationsByFile[fname] = []
      }
      push(index.declarationsByFile[fname], .{
        name: n.name.name,
        kind: "function",
        declNode: n,
      })
    }
  }

  // Collect builtins from builtins data
  if builtinsData {
    // Add native builtins
    if builtinsData.NATIVE_NAMES {
      let nativeKeys = keys(builtinsData.NATIVE_NAMES)
      for let i = 0; i < len(nativeKeys); i = i + 1 {
        index.builtins[nativeKeys[i]] = true
      }
    }
    // Add prelude builtins
    if builtinsData.PRELUDE_NAMES {
      let preludeKeys = keys(builtinsData.PRELUDE_NAMES)
      for let i = 0; i < len(preludeKeys); i = i + 1 {
        index.builtins[preludeKeys[i]] = true
      }
    }
  }

  ctx._completionIndex = index
  index
}

fn isEnumType(ty) {
  ty and ty.kind == "Enum"
}

fn completeDotProperties(ctx, dotNode, filename, line, col) {
  let completions = []

  // Resolve the object expression
  let record = resolveExprToRecord(ctx, dotNode.object, .{})

  if record and record.pairs {
    // Check if it's an enum by looking at the type
    let recordType = ctx.types[nodeKeyFor(ctx, record)]
    let kind = isEnumType(recordType) and "enumMember" or "property"

    // Extract field names from pairs
    for let i = 0; i < len(record.pairs); i = i + 1 {
      let pair = record.pairs[i]
      let fieldName = propNameFromNode(pair.key)
      if fieldName {
        // Get type info if available
        let ty = pair.value and ctx.types[nodeKeyFor(ctx, pair.value)]
        push(completions, .{
          label: fieldName,
          kind: kind,
          type: ty and formatTypeWithBindings(ctx, ty) or nil,
        })
      }
    }
  }

  .{ success: true, completions }
}

fn completeIdentifiers(ctx, filename, line, col) {
  let index = buildCompletionIndex(ctx)
  let completions = []
  let seen = .{}  // Track seen labels for deduplication

  // 1. Add declarations from current file (highest priority)
  let fileDecls = index.declarationsByFile[filename] or []
  for let i = 0; i < len(fileDecls); i = i + 1 {
    let decl = fileDecls[i]
    if !seen[decl.name] {
      seen[decl.name] = true
      // Get type info if available
      let ty = decl.declNode and ctx.types[nodeKeyFor(ctx, decl.declNode)]
      push(completions, .{
        label: decl.name,
        kind: decl.kind,
        type: ty and formatTypeWithBindings(ctx, ty) or nil,
      })
    }
  }

  // 2. Add declarations from imported modules (reachable files)
  let fileNames = keys(index.declarationsByFile)
  for let i = 0; i < len(fileNames); i = i + 1 {
    let fname = fileNames[i]
    if fname == filename { continue }
    let decls = index.declarationsByFile[fname]
    for let j = 0; j < len(decls); j = j + 1 {
      let decl = decls[j]
      if !seen[decl.name] {
        seen[decl.name] = true
        // Only include top-level declarations from other files
        // (Could filter by import graph in the future)
        let ty = decl.declNode and ctx.types[nodeKeyFor(ctx, decl.declNode)]
        push(completions, .{
          label: decl.name,
          kind: decl.kind,
          type: ty and formatTypeWithBindings(ctx, ty) or nil,
        })
      }
    }
  }

  // 3. Add builtins (lowest priority - shadowed by locals)
  let builtinNames = keys(index.builtins)
  builtinNames = builtinNames->sort(stringLess)
  for let i = 0; i < len(builtinNames); i = i + 1 {
    let name = builtinNames[i]
    if !seen[name] {
      seen[name] = true
      push(completions, .{
        label: name,
        kind: "function",
      })
    }
  }

  .{ success: true, completions }
}

fn queryCompletion(ctx, filename, line, col) {
  validateCtxOnce(ctx)

  let sel = nodeAtPosWithTies(ctx, filename, line, col)
  let n = sel.node

  if !n {
    // No node found - provide identifier completions
    return completeIdentifiers(ctx, filename, line, col)
  }

  // Check if we're completing a dot property
  if n.type == NODE.Dot {
    return completeDotProperties(ctx, n, filename, line, col)
  }

  // Check if we're on a property within a dot expression
  // This handles cases where cursor is on the property identifier
  if n.type == NODE.Identifier or n.type == NODE.String {
    let dotNode = findDotByPropertyNode(ctx, n)
    if dotNode {
      return completeDotProperties(ctx, dotNode, filename, line, col)
    }
  }

  // Default: complete identifiers
  return completeIdentifiers(ctx, filename, line, col)
}

// ========================================
// Module Exports
// ========================================

.{
  // High-level API (recommended)
  compile,
  compileFast,
  compileWithOpts,
  compileWithDriver,

  // Low-level API (for advanced use cases)
  queryInit,
  queryHover,
  queryGotoDefinition,
  queryDiagnostics,
  queryCompletion,
}
