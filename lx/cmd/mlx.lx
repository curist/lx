let driver = import "src/driver.lx"
let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let anf = import "src/anf.lx"
let codegen = import "src/codegen.lx"
let verify = import "src/verify-bytecode.lx"
let objbuilder = import "src/objbuilder.lx"
let errors = import "src/errors.lx"
let tohex = (import "src/lib.lx").tohex
let OP = (import "src/types.lx").OP

fn resolvePath(path) {
  if path and path[0] == "@" {
    let s = "~/lx/"
    let length = len(path)
    for let i = 1; i < length; i = i + 1 {
      s = s + path[i]
    }
    return s
  }
  path
}

fn loadSource(path, sourceOverride, overridePath) {
  if sourceOverride and path == overridePath {
    return sourceOverride
  }
  let realPath = resolvePath(path)
  slurp(realPath)
}


fn makeDriverWithSource(source, path) {
  driver.make(.{
    withTypecheck: false,
    loadSource: fn(p) { loadSource(p, source, path) },
  })
}

fn compileWithDriver(driverInstance, path) {
  let moduleCache = .{}

  fn codegenModule(modulePath) {
    let cached = moduleCache[modulePath]
    if cached { return cached }

    let result = driverInstance.compileModule(modulePath)
    if !result or result.status != "done" {
      errors.printErrors(errors.collectErrors(result or .{}), result)
      return nil
    }

    let ast = result.passes.anf and result.passes.anf.ast or result.passes.lower.ast
    let cg = codegen(ast, result.passes.resolve, .{
      codegenModule: codegenModule,
    })
    result.codegenResult = cg
    if !cg.success {
      errors.printErrors(cg.errors, result)
      return nil
    }

    // Verify bytecode stack discipline (mandatory phase)
    let verifyResult = verify.verifyFunction(cg.function)
    result.verifyResult = verifyResult
    if !verifyResult.success {
      errors.printErrors(verifyResult.errors, result)
      return nil
    }

    moduleCache[modulePath] = cg.function
    cg.function
  }

  codegenModule(path)
}

fn handleBuildFunction(cb) {
  let argsLength = len(Lx.args)
  let DEBUG_BUILD = true
  let usageMessage = join(["Usage:", Lx.args[0], "compile <path> [-o|--output <output>]"], " ")
  if argsLength < 3 {
    groanln(usageMessage)
    Lx.exit(28)
  }
  let path = nil
  let outputPath = nil
  let i = 2
  for i < argsLength {
    let arg = Lx.args[i]
    if arg == "-o" or arg == "--output" {
      if i + 1 >= argsLength {
        groanln(usageMessage)
        Lx.exit(28)
      }
      outputPath = Lx.args[i + 1]
      i = i + 2
      continue
    }
    if !path {
      path = arg
    }
    i = i + 1
  }
  if !path {
    groanln(usageMessage)
    Lx.exit(28)
  }
  let source = loadSource(path, nil, nil)
  if !source {
    groanln("Failed to open", path)
    Lx.exit(2)
  }

  let driverInstance = makeDriverWithSource(nil, nil)
  let func = compileWithDriver(driverInstance, path)
  if !func {
    Lx.exit(65)
  }
  cb(func, DEBUG_BUILD, outputPath)
}

let handlers = .{
  compile: fn() {
    handleBuildFunction(fn(func, DEBUG_BUILD, outputPath) {
      if outputPath {
        let bytes = objbuilder(func, DEBUG_BUILD).bytes()
        // Convert byte numbers to string
        let byteString = ""
        for let i = 0; i < len(bytes); i = i + 1 {
          byteString = byteString + chr(bytes[i])
        }
        let ok = spit(outputPath, byteString)
        if ok != true {
          groanln(ok or "Failed to write output.")
          Lx.exit(74)
        }
      } else {
        objbuilder(func, DEBUG_BUILD).dump()
      }
    })
  },
  run: fn() {
    handleBuildFunction(fn(func, DEBUG_BUILD) {
      objbuilder(func, DEBUG_BUILD).bytes()
    })
  },
  eval: fn() {
    if !__lx_input__ {
      return "Empty input."
    }
    let path = "[LX EVAL]"
    let driverInstance = makeDriverWithSource(__lx_input__, path)
    let func = compileWithDriver(driverInstance, path)
    if !func {
      return "Compile failed."
    }
    return objbuilder(func, false).bytes()
  },
  repl: fn() {
    if !__lx_input__ {
      return "Empty input."
    }
    let path = "[LX REPL]"
    let driverInstance = makeDriverWithSource(__lx_input__, path)
    let func = compileWithDriver(driverInstance, path)
    if !func {
      return "Compile failed."
    }
    if func.chunk.bytecode->len() == 1 {
      func.chunk.bytecode = [OP.NIL, OP.RETURN]->map(tohex)
    }
    return objbuilder(func, false).bytes()
  },
}

fn handleUnknownCommand() {
  if Lx.args[1] {
    groanln(Lx.args[0] + " " + Lx.args[1] + ": unknown command")
  }
  groanln("Run '" + Lx.args[0] + " help' for usage.")
  Lx.exit(28)
}

{Lx.args[1] and handlers[Lx.args[1]] or handleUnknownCommand}()
