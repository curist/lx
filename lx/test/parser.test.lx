let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let types = import "src/types.lx"
let TOKEN = types.TOKEN

// Helper to get first statement from parsed program
fn first(result) {
  result.ast.body[0]
}

// Helper to parse from fixture file
fn parseFixture(path) {
  let src = slurp(path)
  parse(src, path)
}

test("parser - number literal", fn(assert) {
  let result = parse("42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Number")
  assert.equal(node.value, 42)
  assert.equal(node.lexeme, "42")
  assert.equal(node.line, 1)
  assert.equal(node.filename, "test.lx")
})

test("parser - string literal", fn(assert) {
  let result = parse("\"hello\"", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "String")
  assert.equal(node.value, "hello")
  assert.equal(node.lexeme, "\"hello\"")
})

test("parser - bool literals", fn(assert) {
  let result = parse("true", "test.lx")
  assert.truthy(result.success)
  let node = first(result)
  assert.equal(node.type, "Bool")
  assert.equal(node.value, true)

  result = parse("false", "test.lx")
  assert.truthy(result.success)
  node = first(result)
  assert.equal(node.type, "Bool")
  assert.equal(node.value, false)
})

test("parser - nil literal", fn(assert) {
  let result = parse("nil", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Nil")
  assert.equal(node.lexeme, "nil")
})

test("parser - identifier", fn(assert) {
  let result = parse("foo", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Identifier")
  assert.equal(node.name, "foo")
  assert.equal(node.lexeme, "foo")
})

test("parser - binary expression", fn(assert) {
  let result = parse("1 + 2", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Binary")
  assert.equal(node.left.type, "Number")
  assert.equal(node.left.value, 1)
  assert.equal(node.operator.type, TOKEN.PLUS)
  assert.equal(node.operator.lexeme, "+")
  assert.equal(node.right.type, "Number")
  assert.equal(node.right.value, 2)
})

test("parser - binary precedence", fn(assert) {
  let result = parse("1 + 2 * 3", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Should be: 1 + (2 * 3)
  assert.equal(node.type, "Binary")
  assert.equal(node.operator.type, TOKEN.PLUS)
  assert.equal(node.left.value, 1)
  assert.equal(node.right.type, "Binary")
  assert.equal(node.right.operator.type, TOKEN.STAR)
})

test("parser - unary expression", fn(assert) {
  let result = parse("-42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Unary")
  assert.equal(node.operator.type, TOKEN.MINUS)
  assert.equal(node.operand.type, "Number")
  assert.equal(node.operand.value, 42)
})

test("parser - grouping", fn(assert) {
  let result = parse("(1 + 2) * 3", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Should be: (1 + 2) * 3
  assert.equal(node.type, "Binary")
  assert.equal(node.operator.type, TOKEN.STAR)
  assert.equal(node.left.type, "Grouping")
  assert.equal(node.left.expression.type, "Binary")
})

test("parser - logical and", fn(assert) {
  let result = parse("true and false", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.AND)
  assert.equal(node.left.type, "Bool")
  assert.equal(node.right.type, "Bool")
})

test("parser - logical or", fn(assert) {
  let result = parse("true or false", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.OR)
})

test("parser - let without init", fn(assert) {
  let result = parse("let x", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Let")
  assert.equal(node.name.name, "x")
  assert.equal(node.init, nil)
})

test("parser - let with init", fn(assert) {
  let result = parse("let x = 42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Let")
  assert.equal(node.name.name, "x")
  assert.equal(node.init.type, "Number")
  assert.equal(node.init.value, 42)
})

test("parser - assignment", fn(assert) {
  let result = parse("x = 10", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Assignment")
  assert.equal(node.target.type, "Identifier")
  assert.equal(node.target.name, "x")
  assert.equal(node.value.type, "Number")
  assert.equal(node.value.value, 10)
})

test("parser - array literal", fn(assert) {
  let result = parse("[1, 2, 3]", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Array")
  assert.equal(len(node.elements), 3)
  assert.equal(node.elements[0].value, 1)
  assert.equal(node.elements[1].value, 2)
  assert.equal(node.elements[2].value, 3)
})

test("parser - empty array", fn(assert) {
  let result = parse("[]", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Array")
  assert.equal(len(node.elements), 0)
})

test("parser - hashmap literal", fn(assert) {
  let result = parse(".{ a: 1, b: 2 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Hashmap")
  assert.equal(len(node.pairs), 2)
  assert.equal(node.pairs[0].key.value, "a")
  assert.equal(node.pairs[0].value.value, 1)
  assert.equal(node.pairs[1].key.value, "b")
  assert.equal(node.pairs[1].value.value, 2)
})

test("parser - hashmap with computed key", fn(assert) {
  let result = parse(".{ [x]: 1 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Hashmap")
  assert.equal(len(node.pairs), 1)
  assert.equal(node.pairs[0].key.type, "Identifier")
  assert.equal(node.pairs[0].key.name, "x")
})

test("parser - hashmap key positions", fn(assert) {
  // ".{ a: 1 }" - key "a" should have correct position
  let result = parse(".{ a: 1 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  let key = node.pairs[0].key

  // Scanner reports "a" token with col=3
  // So: startCol = 3 - len("a") = 2, endCol = 3
  assert.equal(key.col, 3)
  assert.equal(key.endCol, 4)
  assert.equal(key.value, "a")

  // Should not be zero-length
  assert.truthy(key.endCol > key.col)
})

test("parser - function call", fn(assert) {
  let result = parse("foo(1, 2)", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Call")
  assert.equal(node.callee.type, "Identifier")
  assert.equal(node.callee.name, "foo")
  assert.equal(len(node.args), 2)
  assert.equal(node.args[0].value, 1)
  assert.equal(node.args[1].value, 2)
})

test("parser - arrow operator", fn(assert) {
  let result = parse("x->foo()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Arrow")
  assert.equal(node.left.type, "Identifier")
  assert.equal(node.left.name, "x")
  assert.equal(node.right.type, "Call")
  assert.equal(node.right.callee.name, "foo")
})

test("parser - dot access", fn(assert) {
  let result = parse("obj.prop", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Dot")
  assert.equal(node.object.type, "Identifier")
  assert.equal(node.object.name, "obj")
  assert.equal(node.property.type, "String")
  assert.equal(node.property.value, "prop")
})

test("parser - index access", fn(assert) {
  let result = parse("arr[0]", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Index")
  assert.equal(node.object.type, "Identifier")
  assert.equal(node.object.name, "arr")
  assert.equal(node.index.type, "Number")
  assert.equal(node.index.value, 0)
})

test("parser - dot assignment", fn(assert) {
  let result = parse("obj.prop = 5", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Assignment")
  assert.equal(node.target.type, "Dot")
  assert.equal(node.target.property.type, "String")
  assert.equal(node.target.property.value, "prop")
  assert.equal(node.value.value, 5)
})

test("parser - index assignment", fn(assert) {
  let result = parse("arr[0] = 5", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Assignment")
  assert.equal(node.target.type, "Index")
  assert.equal(node.value.value, 5)
})

test("parser - block", fn(assert) {
  let result = parse("{ 1 2 3 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Block")
  assert.equal(len(node.expressions), 3)
  assert.equal(node.expressions[0].value, 1)
  assert.equal(node.expressions[2].value, 3)
})

test("parser - if expression", fn(assert) {
  let result = parse("if true { 1 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "If")
  assert.equal(node.condition.type, "Bool")
  assert.equal(node.then.type, "Block")
  assert.equal(node.else, nil)
})

test("parser - if else expression", fn(assert) {
  let result = parse("if true { 1 } else { 2 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "If")
  assert.equal(node.then.type, "Block")
  assert.equal(node.else.type, "Block")
})

test("parser - if else if", fn(assert) {
  let result = parse("if true { 1 } else if false { 2 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "If")
  assert.equal(node.else.type, "If")
})

test("parser - for while loop", fn(assert) {
  let result = parse("for x < 10 { x }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "For")
  assert.equal(node.init, nil)
  assert.equal(node.condition.type, "Binary")
  assert.equal(node.update, nil)
  assert.equal(node.body.type, "Block")
})

test("parser - for c-style loop", fn(assert) {
  let result = parse("for let i = 0; i < 10; i = i + 1 { i }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "For")
  assert.equal(node.init.type, "Let")
  assert.equal(node.condition.type, "Binary")
  assert.equal(node.update.type, "Assignment")
  assert.equal(node.body.type, "Block")
})

test("parser - anonymous function", fn(assert) {
  let result = parse("fn(x) { x }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Function")
  assert.equal(node.name, nil)
  assert.equal(len(node.params), 1)
  assert.equal(node.params[0].name, "x")
  assert.equal(node.body.type, "Block")
})

test("parser - named function", fn(assert) {
  let result = parse("fn add(a, b) { a + b }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Function")
  assert.equal(node.name.name, "add")
  assert.equal(len(node.params), 2)
  assert.equal(node.params[0].name, "a")
  assert.equal(node.params[1].name, "b")
})

test("parser - return statement", fn(assert) {
  let result = parse("return 42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Return")
  assert.equal(node.value.type, "Number")
  assert.equal(node.value.value, 42)
})

test("parser - return without value", fn(assert) {
  let result = parse("return", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Return")
  assert.equal(node.value, nil)
})

test("parser - break in loop", fn(assert) {
  let result = parse("for true { break }", "test.lx")
  assert.truthy(result.success)

  let body = first(result).body
  assert.equal(body.expressions[0].type, "Break")
  assert.equal(body.expressions[0].value, nil)
})

test("parser - break with value in loop", fn(assert) {
  let result = parse("for true { break 10 }", "test.lx")
  assert.truthy(result.success)

  let body = first(result).body
  assert.equal(body.expressions[0].type, "Break")
  assert.equal(body.expressions[0].value.value, 10)
})

test("parser - continue in loop", fn(assert) {
  let result = parse("for true { continue }", "test.lx")
  assert.truthy(result.success)

  let body = first(result).body
  assert.equal(body.expressions[0].type, "Continue")
})

test("parser - import", fn(assert) {
  let result = parse("import \"foo.lx\"", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Import")
  assert.equal(node.path.type, "String")
  assert.equal(node.path.value, "foo.lx")
})

test("parser - multiple statements", fn(assert) {
  let result = parse("let x = 1\nlet y = 2", "test.lx")
  assert.truthy(result.success)

  assert.equal(len(result.ast.body), 2)
  assert.equal(result.ast.body[0].type, "Let")
  assert.equal(result.ast.body[1].type, "Let")
})

test("parser - position tracking", fn(assert) {
  let result = parse("let x = 42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.line, 1)
  // Scanner skips whitespace, so col starts where 'let' token begins
  assert.truthy(node.col >= 0)
  assert.equal(node.endLine, 1)
  // endCol should be at the end of the expression
  assert.truthy(node.endCol > node.col)
})

test("parser - filename tracking", fn(assert) {
  let result = parse("42", "my/file.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.filename, "my/file.lx")
})

test("parser - complex expression", fn(assert) {
  // Test precedence: -> (CALL) > * (FACTOR) > + (TERM) > and (AND)
  // So this should parse as: (1 + (2 * (3->foo(4)))) and true
  let result = parse("1 + 2 and true", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // The top level should be Logical (and)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.AND)
  // Left side should be Binary (1 + 2)
  assert.equal(node.left.type, "Binary")
})

test("parser - demo example 1: let with arithmetic", fn(assert) {
  let result = parse("let x = 1 + 2 * 3", "demo.lx")
  assert.truthy(result.success)
  assert.equal(result.ast.type, "Program")
  assert.equal(len(result.ast.body), 1)

  let stmt = first(result)
  assert.equal(stmt.type, "Let")
  assert.equal(stmt.name.name, "x")
  assert.equal(stmt.init.type, "Binary")
  assert.equal(stmt.filename, "demo.lx")
})

test("parser - demo example 2: function with body", fn(assert) {
  let result = parse("fn add(a, b) { a + b }", "demo.lx")
  assert.truthy(result.success)

  let funcNode = first(result)
  assert.equal(funcNode.type, "Function")
  assert.equal(funcNode.name.name, "add")
  assert.equal(len(funcNode.params), 2)
  assert.equal(funcNode.params[0].name, "a")
  assert.equal(funcNode.params[1].name, "b")
  assert.equal(funcNode.body.type, "Block")
  assert.equal(len(funcNode.body.expressions), 1)
})

test("parser - demo example 3: arrow with lambda", fn(assert) {
  let result = parse("[1, 2, 3]->map(fn(x) { x * 2 })", "demo.lx")
  assert.truthy(result.success)

  let expr = first(result)
  assert.equal(expr.type, "Arrow")
  assert.equal(expr.left.type, "Array")
  assert.equal(expr.right.type, "Call")
  assert.equal(expr.right.callee.name, "map")
  assert.equal(len(expr.right.args), 1)
  assert.equal(expr.right.args[0].type, "Function")
})

test("parser - demo example 4: error handling", fn(assert) {
  let result = parse("let x = ", "demo.lx")
  assert.truthy(!result.success)
  assert.truthy(len(result.errors) > 0)
})

test("parser - result structure", fn(assert) {
  let result = parse("42", "test.lx")
  // Check that result has the expected structure
  assert.truthy(result.success)
  assert.truthy(result.ast)
  assert.truthy(result.errors)
})

test("parser - error messages include position", fn(assert) {
  let result = parse("1 +", "test.lx")
  assert.truthy(!result.success)
  assert.truthy(len(result.errors) > 0)
  // Error message should contain filename and line info
  let errorMsg = result.errors[0]
  assert.truthy(len(errorMsg) > 0)
})

// Issue #1: For-loop with empty init but semicolons
test("parser - for loop empty init with condition and update", fn(assert) {
  let result = parse("for ; i < 10; i = i + 1 { i }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "For")
  assert.equal(node.init, nil)
  assert.equal(node.condition.type, "Binary")
  assert.equal(node.update.type, "Assignment")
})

test("parser - for loop variations from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/for-variations.lx")
  assert.truthy(result.success)

  // Should have 4 different for-loop styles
  assert.equal(len(result.ast.body), 4)

  // All should be For nodes
  assert.equal(result.ast.body[0].type, "For")
  assert.equal(result.ast.body[1].type, "For")
  assert.equal(result.ast.body[2].type, "For")
  assert.equal(result.ast.body[3].type, "For")
})

// Issue #2: Token position accuracy
test("parser - token position ranges", fn(assert) {
  let result = parse("let x = 42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // The node should have a meaningful range, not zero-length
  assert.truthy(node.endCol > node.col)

  // The init value (42) should also have a proper range
  let initNode = node.init
  assert.truthy(initNode.endCol > initNode.col)
})

test("parser - identifier exact position", fn(assert) {
  // "x" at column 0
  let result = parse("x", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 1)  // After 'x'
})

test("parser - number literal exact position", fn(assert) {
  // "42" starts at column 0
  let result = parse("42", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 2)  // After '42'
})

test("parser - string literal with quotes", fn(assert) {
  // "hello" includes the quotes
  let result = parse("\"hello\"", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 7)  // After closing quote
})

test("parser - binary expression positions", fn(assert) {
  // "1 + 2" - each token has correct position
  let result = parse("1 + 2", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Left operand "1" at column 0
  assert.equal(node.left.col, 0)
  assert.equal(node.left.endCol, 1)

  // Operator "+" at column 2
  assert.equal(node.operator.col, 2)

  // Right operand "2" at column 4
  assert.equal(node.right.col, 4)
  assert.equal(node.right.endCol, 5)

  // Whole expression spans from 0 to 5
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 5)
})

test("parser - function call with parens", fn(assert) {
  // "foo()" - should track opening and closing parens
  let result = parse("foo()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Callee "foo" starts at 0
  assert.equal(node.callee.col, 0)
  assert.equal(node.callee.endCol, 3)

  // Call should span from "foo" to after ")"
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 5)  // After ')'
})

test("parser - dot access positions", fn(assert) {
  // "obj.prop" - track object, dot, and property
  let result = parse("obj.prop", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Object "obj" at column 0
  assert.equal(node.object.col, 0)
  assert.equal(node.object.endCol, 3)

  // Property "prop" after the dot
  assert.equal(node.property.col, 4)
  assert.equal(node.property.endCol, 8)

  // Whole expression spans from obj to end of prop
  assert.equal(node.col, 0)
  assert.equal(node.endCol, 8)
})

test("parser - operator position in binary expr", fn(assert) {
  let result = parse("1 + 2", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Operator should have its own position
  assert.truthy(node.operator.col >= 0)
  // The whole expression should span from 1 to 2
  assert.truthy(node.endCol > node.col)
})

// Issue #3: Control-flow validity
// NOTE: Semantic validation tests moved to test/resolve.test.lx
// Parser now only validates syntax and AST structure.
// Contextual legality (return/break placement) is validated in resolve phase.

test("parser - valid control flow from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/control-flow.lx")
  assert.truthy(result.success)
})

test("parser - valid loop control from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/loop-control.lx")
  assert.truthy(result.success)
})

// ===== Code Review Issue Tests =====
// These tests demonstrate the issues found in code review

test("parser - and associativity should be left-to-right", fn(assert) {
  // a and b and c should parse as (a and b) and c (left-assoc)
  let result = parse("a and b and c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Top level should be: (a and b) and c
  // So the operator at top is 'and', left is Logical(a and b), right is 'c'
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.AND)
  assert.equal(node.left.type, "Logical")  // (a and b)
  assert.equal(node.left.left.name, "a")
  assert.equal(node.left.right.name, "b")
  assert.equal(node.right.name, "c")
})

test("parser - or associativity should be left-to-right", fn(assert) {
  // a or b or c should parse as (a or b) or c (left-assoc)
  let result = parse("a or b or c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Top level should be: (a or b) or c
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.OR)
  assert.equal(node.left.type, "Logical")  // (a or b)
  assert.equal(node.left.left.name, "a")
  assert.equal(node.left.right.name, "b")
  assert.equal(node.right.name, "c")
})

test("parser - arrow precedence vs addition", fn(assert) {
  // For a pipeline operator, we'd expect: a + b -> foo() to parse as (a + b) -> foo()
  // This test verifies the correct parse tree structure
  let result = parse("a + b->foo()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)

  // Expected for pipeline (lower precedence than +):
  // Arrow { left: Binary(a + b), right: Call(foo) }
  assert.equal(node.type, "Arrow")
  assert.equal(node.left.type, "Binary")
  assert.equal(node.left.operator.type, TOKEN.PLUS)
  assert.equal(node.left.left.name, "a")
  assert.equal(node.left.right.name, "b")
  assert.equal(node.right.type, "Call")
  assert.equal(node.right.callee.name, "foo")
})

test("parser - arrow associativity", fn(assert) {
  // a->f()->g() should be left-assoc for pipeline: (a->f())->g()
  let result = parse("a->f()->g()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  // Expected: Arrow { left: Arrow(a, f()), right: g() }
  assert.equal(node.type, "Arrow")
  assert.equal(node.left.type, "Arrow")
  assert.equal(node.left.left.name, "a")
  assert.equal(node.left.right.type, "Call")
  assert.equal(node.left.right.callee.name, "f")
  assert.equal(node.right.type, "Call")
  assert.equal(node.right.callee.name, "g")
})

test("parser - subtraction is left-associative", fn(assert) {
  // Verify that binary operators work correctly: a - b - c = (a - b) - c
  let result = parse("a - b - c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Binary")
  assert.equal(node.operator.type, TOKEN.MINUS)
  assert.equal(node.left.type, "Binary")  // (a - b)
  assert.equal(node.left.operator.type, TOKEN.MINUS)
  assert.equal(node.right.name, "c")
})

test("parser - assignment is right-associative", fn(assert) {
  // a = b = c should parse as a = (b = c) (right-assoc)
  let result = parse("a = b = c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Assignment")
  assert.equal(node.target.name, "a")
  assert.equal(node.value.type, "Assignment")  // (b = c)
  assert.equal(node.value.target.name, "b")
  assert.equal(node.value.value.name, "c")
})

test("parser - invalid assignment target with grouping", fn(assert) {
  // (a) = 1 should fail with "Invalid assignment target"
  let result = parse("(a) = 1", "test.lx")
  assert.truthy(!result.success)
  assert.truthy(len(result.errors) > 0)
})

test("parser - invalid assignment target with binary expr", fn(assert) {
  // a + b = 1 should fail with "Invalid assignment target"
  let result = parse("a + b = 1", "test.lx")
  assert.truthy(!result.success)
  assert.truthy(len(result.errors) > 0)
})

// ===== Pipeline Precedence Tests =====
test("parser - pipeline precedence vs or (pipeline tighter)", fn(assert) {
  // a->b or c should parse as (a->b) or c
  let result = parse("a->f() or c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.OR)
  assert.equal(node.left.type, "Arrow")  // (a->f())
  assert.equal(node.right.name, "c")
})

test("parser - pipeline precedence vs or (right side)", fn(assert) {
  // a or b->c should parse as a or (b->c)
  let result = parse("a or b->f()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.OR)
  assert.equal(node.left.name, "a")
  assert.equal(node.right.type, "Arrow")  // (b->f())
})

test("parser - pipeline precedence vs and", fn(assert) {
  // a->b and c should parse as (a->b) and c
  let result = parse("a->f() and c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.AND)
  assert.equal(node.left.type, "Arrow")  // (a->f())
  assert.equal(node.right.name, "c")
})

test("parser - pipeline precedence vs assignment", fn(assert) {
  // a = b->c should parse as a = (b->c) because PIPELINE > ASSIGNMENT
  let result = parse("a = b->f()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Assignment")
  assert.equal(node.target.name, "a")
  assert.equal(node.value.type, "Arrow")  // (b->f())
})

test("parser - pipeline right of or", fn(assert) {
  // a or b->c should parse as a or (b->c) because PIPELINE > OR
  let result = parse("a or b->f()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.OR)
  assert.equal(node.left.name, "a")
  assert.equal(node.right.type, "Arrow")  // (b->f())
  assert.equal(node.right.left.name, "b")
})

test("parser - pipeline with and", fn(assert) {
  // a->b and c should parse as (a->b) and c because PIPELINE > AND
  let result = parse("a->f() and c", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Logical")
  assert.equal(node.operator.type, TOKEN.AND)
  assert.equal(node.left.type, "Arrow")  // (a->f())
  assert.equal(node.right.name, "c")
})

test("parser - pipeline chain associativity", fn(assert) {
  // a->b->c should parse as (a->b)->c (left-associative)
  let result = parse("a->f()->g()", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Arrow")
  assert.equal(node.left.type, "Arrow")  // (a->f())
  assert.equal(node.left.left.name, "a")
  assert.equal(node.right.type, "Call")
  assert.equal(node.right.callee.name, "g")
})

// ===== Keyword Key Tests =====
test("parser - hashmap with keyword keys", fn(assert) {
  let result = parse(".{ if: 1, return: 2, true: 3 }", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Hashmap")
  assert.equal(len(node.pairs), 3)
  assert.equal(node.pairs[0].key.value, "if")
  assert.equal(node.pairs[1].key.value, "return")
  assert.equal(node.pairs[2].key.value, "true")
})

test("parser - dot access with keyword property", fn(assert) {
  let result = parse("x.if", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Dot")
  assert.equal(node.object.name, "x")
  // Property should be String node (consistent with hashmap keys)
  assert.equal(node.property.type, "String")
  assert.equal(node.property.value, "if")
})

test("parser - dot access with multiple keyword properties", fn(assert) {
  let result = parse("x.return.true.nil", "test.lx")
  assert.truthy(result.success)

  let node = first(result)
  assert.equal(node.type, "Dot")
  // x.return.true.nil = ((x.return).true).nil
  assert.equal(node.property.type, "String")
  assert.equal(node.property.value, "nil")
  assert.equal(node.object.type, "Dot")
  assert.equal(node.object.property.type, "String")
  assert.equal(node.object.property.value, "true")
})

// ===== Semicolon Tests =====
test("parser - return with trailing semicolon", fn(assert) {
  let result = parse("fn() { return 1; }", "test.lx")
  assert.truthy(result.success)

  let funcNode = first(result)
  assert.equal(funcNode.type, "Function")
  assert.equal(funcNode.body.expressions[0].type, "Return")
})

test("parser - top level statements with semicolons", fn(assert) {
  let result = parse("let a = 1; let b = 2;", "test.lx")
  assert.truthy(result.success)

  assert.equal(len(result.ast.body), 2)
  assert.equal(result.ast.body[0].type, "Let")
  assert.equal(result.ast.body[1].type, "Let")
})

test("parser - block with semicolons", fn(assert) {
  let result = parse("{ let x = 1; x + 1; }", "test.lx")
  assert.truthy(result.success)

  let block = first(result)
  assert.equal(block.type, "Block")
  assert.equal(len(block.expressions), 2)
})

// NOTE: "return not at end" validation moved to test/resolve.test.lx
// Parser accepts this syntactically; resolve phase will reject it semantically.

test("parser - return with multiple trailing semicolons", fn(assert) {
  let result = parse("fn() { return 1;; }", "test.lx")
  assert.truthy(result.success)

  let funcNode = first(result)
  assert.equal(funcNode.type, "Function")
  assert.equal(funcNode.body.expressions[0].type, "Return")
})

test("parser - with linebreak", fn(assert) {
  let result = parse("let x = 42\nx", "text.lx")
  assert.truthy(result.success)
  assert.equal(result.ast.body[len(result.ast.body) - 1].col, 0)
})

suite.run()
