// Resolve Phase Tests
// Tests for semantic validation (resolve.lx)

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/parser.lx"
let lower = import "src/lower.lx"
let resolve = import "src/resolve.lx"

// Helper to parse from fixture file
fn parseFixture(path) {
  let src = slurp(path)
  parse(src, path)
}

// Helper to parse and resolve
fn parseAndResolve(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseErrors: parseResult.errors }
  }
  resolve(parseResult.ast, .{})
}

// ========================================
// Basic Expressions and Declarations
// ========================================

test("resolve - binary expression", fn(assert) {
  let result = parseAndResolve("1 + 2")
  assert.truthy(result.success, "Should resolve binary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - logical expression", fn(assert) {
  let result = parseAndResolve("true and false")
  assert.truthy(result.success, "Should resolve logical expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - unary expression", fn(assert) {
  let result = parseAndResolve("-42")
  assert.truthy(result.success, "Should resolve unary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - grouping expression", fn(assert) {
  let result = parseAndResolve("(1 + 2)")
  assert.truthy(result.success, "Should resolve grouping expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested binary expressions", fn(assert) {
  let result = parseAndResolve("1 + 2 * 3 - 4")
  assert.truthy(result.success, "Should resolve nested binary expressions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration without initializer", fn(assert) {
  let result = parseAndResolve("{ let x }")
  assert.truthy(result.success, "Should resolve let declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration with initializer", fn(assert) {
  let result = parseAndResolve("{ let x = 42 }")
  assert.truthy(result.success, "Should resolve let with initializer")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - using declared variable", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx }")
  assert.truthy(result.success, "Should resolve variable reference")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - duplicate declaration error", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet x = 2 }")
  assert.equal(result.success, false, "Should fail on duplicate declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - read before initialization error", fn(assert) {
  let result = parseAndResolve("{ let x = x }")
  assert.equal(result.success, false, "Should fail on read-before-init")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Expression Types
// ========================================

test("resolve - function call", fn(assert) {
  let result = parseAndResolve("{ let f = fn() { 1 }\nf() }")
  assert.truthy(result.success, "Should resolve function call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if expression", fn(assert) {
  let result = parseAndResolve("if true { 1 } else { 2 }")
  assert.truthy(result.success, "Should resolve if expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if with variable reference", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nif x { 2 } else { 3 } }")
  assert.truthy(result.success, "Should resolve if with variable")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to local", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx = 2 }")
  assert.truthy(result.success, "Should resolve assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to index (valid)", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] = 3 }")
  assert.truthy(result.success, "Should allow assignment to index")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to dot (valid)", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x = 2 }")
  assert.truthy(result.success, "Should allow assignment to dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to literal rejected by parser", fn(assert) {
  let result = parse("42 = 1", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to binary expression rejected by parser", fn(assert) {
  let result = parse("(x + 1) = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call rejected by parser", fn(assert) {
  let result = parse("f() = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - assignment to literal from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-literal.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to expression from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-expression.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-call.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - valid assignment targets from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/assignment-targets.lx")
  assert.truthy(result.success, "Parser should accept valid assignment targets")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolver should accept valid assignments")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - array literal", fn(assert) {
  let result = parseAndResolve("[1, 2, 3]")
  assert.truthy(result.success, "Should resolve array literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - array with variables", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet arr = [x, 2] }")
  assert.truthy(result.success, "Should resolve array with variables")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - hashmap literal", fn(assert) {
  let result = parseAndResolve(".{ a: 1, b: 2 }")
  assert.truthy(result.success, "Should resolve hashmap literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - index access", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] }")
  assert.truthy(result.success, "Should resolve index access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - dot access", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x }")
  assert.truthy(result.success, "Should resolve dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - for loop", fn(assert) {
  let result = parseAndResolve("for let i = 0; i < 10; i = i + 1 { i }")
  assert.truthy(result.success, "Should resolve for loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Functions and Hoisting
// ========================================

test("resolve - anonymous function", fn(assert) {
  let result = parseAndResolve("fn() { 1 }")
  assert.truthy(result.success, "Should resolve anonymous function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - named function declaration", fn(assert) {
  let result = parseAndResolve("{ fn foo() { 1 } }")
  assert.truthy(result.success, "Should resolve named function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - function with parameters", fn(assert) {
  let result = parseAndResolve("fn(x, y) { x + y }")
  assert.truthy(result.success, "Should resolve function with params")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested functions", fn(assert) {
  let result = parseAndResolve("fn outer() { fn inner() { 1 } }")
  assert.truthy(result.success, "Should resolve nested functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - mutual recursion in function bodies", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
  }")
  assert.truthy(result.success, "Should allow mutual recursion in function bodies")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after all hoisted functions declared", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
    a()
  }")
  assert.truthy(result.success, "Should allow call after all declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after first hoisted function (allowed)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    a()
    fn b() { a() }
  }")
  // With per-function declIndex check, a() is allowed after fn a()
  assert.truthy(result.success, "Should allow call after function's declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - forward reference in function body (ok)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { 1 }
  }")
  assert.truthy(result.success, "Should allow forward reference in function body")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level mutual recursion", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }")
  assert.truthy(result.success, "Should allow mutual recursion at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { 1 }")
  assert.truthy(result.success, "Should allow forward reference at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level call after hoisted functions", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }\na()")
  assert.truthy(result.success, "Should allow call after all top-level declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// Test for hoisted-function ordering rule (issue #4)
test("resolve - call hoisted function after its declaration", fn(assert) {
  let result = parseAndResolve("{
    fn a() { }
    a()
    fn b() { }
  }")
  // Should allow calling a() after fn a() even if fn b() comes later
  assert.truthy(result.success, "Should allow call after function's own declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call hoisted function before its declaration (should error)", fn(assert) {
  let result = parseAndResolve("{
    a()
    fn a() { }
  }")
  assert.equal(result.success, false, "Should error when calling before declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - top-level mutual recursion from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-mutual-recursion.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level mutual recursion")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-forward-reference.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level forward reference")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Closures and Capture
// ========================================

test("resolve - simple closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f() { x }
  }")
  assert.truthy(result.success, "Should resolve simple closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn outer() {
      fn inner() { x }
    }
  }")
  assert.truthy(result.success, "Should resolve nested closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - parameter shadowing", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f(x) { x }
  }")
  assert.truthy(result.success, "Should allow parameter shadowing")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple captures of same variable", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn a() { x }
    fn b() { x }
  }")
  assert.truthy(result.success, "Should resolve multiple captures")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - capture variable in own initializer (invalid)", fn(assert) {
  let result = parseAndResolve("let x = fn() { x }")
  assert.equal(result.success, false, "Should reject capturing var in own initializer")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Return Validation
// ========================================

test("resolve - return at end of function (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1 }")
  assert.truthy(result.success, "Should allow return at end of function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1\n2 }")
  assert.equal(result.success, false, "Should reject return not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return at top level end (valid)", fn(assert) {
  let result = parseAndResolve("1 + 2\nreturn 3")
  assert.truthy(result.success, "Should allow return at end of file")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in middle of file (invalid)", fn(assert) {
  let result = parseAndResolve("return 1\n2")
  assert.equal(result.success, false, "Should reject return in middle of file")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - multiple returns in branches (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { if true { return 1 } return 2 }")
  assert.truthy(result.success, "Should allow returns in different branches")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in nested block at end (invalid)", fn(assert) {
  let result = parseAndResolve("{ { return 1 } }")
  assert.equal(result.success, false, "Should reject return in nested block")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in if block outside function (invalid)", fn(assert) {
  let result = parseAndResolve("if true { return 1 }")
  assert.equal(result.success, false, "Should reject return in if block at top level")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in nested block from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-nested-block.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in nested block")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return in if outside function from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-if-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in if at top level")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return outside function from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Break Validation
// ========================================

test("resolve - break inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { break }")
  assert.truthy(result.success, "Should allow break inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break inside loop with value (valid)", fn(assert) {
  let result = parseAndResolve("for true { break 1 }")
  assert.truthy(result.success, "Should allow break with value inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ break }")
  assert.equal(result.success, false, "Should reject break outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - break in nested loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { for true { break } }")
  assert.truthy(result.success, "Should allow break in nested loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - break not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Continue Validation
// ========================================

test("resolve - continue inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { continue }")
  assert.truthy(result.success, "Should allow continue inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - continue outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ continue }")
  assert.equal(result.success, false, "Should reject continue outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("for true { continue\n1 }")
  assert.equal(result.success, false, "Should reject continue not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/continue-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Valid Control Flow Cases
// ========================================

test("resolve - valid control flow from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/control-flow.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - valid loop control from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/loop-control.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Import Resolution
// ========================================

test("resolve - simple import", fn(assert) {
  let result = parseAndResolve("let x = import \"test/makeTestSuite.lx\"")
  assert.truthy(result.success, "Should resolve valid import")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import used in expression", fn(assert) {
  let result = parseAndResolve("let suite = (import \"test/makeTestSuite.lx\")()")
  assert.truthy(result.success, "Should resolve import in call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple imports", fn(assert) {
  let source = "let parse = import \"src/parser.lx\"\nlet resolve = import \"src/resolve.lx\""
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve multiple imports")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in block", fn(assert) {
  let source = "{ let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in block")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in function", fn(assert) {
  let source = "fn f() { let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import node in nodes map", fn(assert) {
  let parseResult = parse("let x = import \"test/makeTestSuite.lx\"", "test.lx")
  let result = resolve(parseResult.ast, .{})

  let importNode = parseResult.ast.body[0].init
  assert.equal(importNode.type, "Import", "Should be Import node")

  let nodeInfo = result.nodes[importNode.id]
  assert.truthy(nodeInfo, "Import node should be in nodes map")
  assert.equal(nodeInfo.type, "Import", "Should track node type")
})

// ========================================
// Import Driver Tests
// ========================================

let Driver = import "src/driver.lx"

// Helper: Create a driver that compiles modules through parse → lower → resolve
fn makeDriver() {
  Driver.make(.{
    loadSource: fn(path) {
      // Mock sources for specific tests (no fixture files needed)
      if path == "test/fixtures/imports/simple.lx" {
        return "42"
      } else if path == "test/fixtures/imports/math.lx" {
        return "fn add(a, b) { a + b }\nadd"
      } else if path == "test/fixtures/imports/circular-a.lx" {
        return "let b = import \"test/fixtures/imports/circular-b.lx\"\nb"
      } else if path == "test/fixtures/imports/circular-b.lx" {
        return "let a = import \"test/fixtures/imports/circular-a.lx\"\na"
      } else if path == "test/fixtures/imports/nonexistent.lx" {
        return nil  // Will trigger "Failed to load source" error
      } else {
        // Default: read from file system
        // Any new fixture file in test/fixtures/imports/ will be automatically loaded
        return slurp(path)
      }
    },
    withTypecheck: false,  // Resolve tests don't need typecheck
  })
}

test("resolve - driver compiles module via compileModule callback", fn(assert) {
  let driver = makeDriver()

  let source = "let simple = import \"test/fixtures/imports/simple.lx\"\nsimple"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve main module")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify module was compiled
  assert.equal(len(driver.compiledModules), 1, "Should compile one module")
  assert.equal(driver.compiledModules[0], "test/fixtures/imports/simple.lx", "Should compile correct module")

  // Verify cache entry
  let cached = driver.cache["test/fixtures/imports/simple.lx"]
  assert.truthy(cached, "Should cache module")
  assert.equal(cached.status, "done", "Should mark as done")
})

test("resolve - driver caches modules (same import twice)", fn(assert) {
  let driver = makeDriver()

  let source = "let m1 = import \"test/fixtures/imports/math.lx\"\nlet m2 = import \"test/fixtures/imports/math.lx\"\nm1"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve main module")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify module was compiled only once
  assert.equal(len(driver.compiledModules), 1, "Should compile module only once")
  assert.equal(driver.compiledModules[0], "test/fixtures/imports/math.lx", "Should compile correct module")

  // Verify cache hit
  let cached = driver.cache["test/fixtures/imports/math.lx"]
  assert.truthy(cached, "Should cache module")
  assert.equal(cached.status, "done", "Should mark as done")
})

test("resolve - diamond import pattern (shared dependency)", fn(assert) {
  let driver = makeDriver()

  // Import app.lx which imports both config.lx and logger.lx,
  // both of which import constants.lx (diamond bottom)
  let source = "let app = import \"test/fixtures/imports/app.lx\"\napp"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve diamond import successfully")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify constants.lx was compiled exactly once despite being imported by both config and logger
  let constantsCompileCount = 0
  for let i = 0; i < len(driver.compiledModules); i = i + 1 {
    if driver.compiledModules[i] == "test/fixtures/imports/constants.lx" {
      constantsCompileCount = constantsCompileCount + 1
    }
  }
  assert.equal(constantsCompileCount, 1, "Constants should be compiled exactly once")

  // Verify all modules in the diamond are cached
  assert.truthy(driver.cache["test/fixtures/imports/constants.lx"], "Should cache constants")
  assert.truthy(driver.cache["test/fixtures/imports/config.lx"], "Should cache config")
  assert.truthy(driver.cache["test/fixtures/imports/logger.lx"], "Should cache logger")
  assert.truthy(driver.cache["test/fixtures/imports/app.lx"], "Should cache app")

  // Verify all cached modules have "done" status
  assert.equal(driver.cache["test/fixtures/imports/constants.lx"].status, "done", "Constants marked done")
  assert.equal(driver.cache["test/fixtures/imports/config.lx"].status, "done", "Config marked done")
  assert.equal(driver.cache["test/fixtures/imports/logger.lx"].status, "done", "Logger marked done")
  assert.equal(driver.cache["test/fixtures/imports/app.lx"].status, "done", "App marked done")
})

test("resolve - circular import infrastructure in place", fn(assert) {
  // Test that resolveImport correctly checks cache status
  let testCache = .{}

  // Mark a module as being compiled
  testCache["test/module.lx"] = .{
    status: "compiling",
    path: "test/module.lx",
  }

  let source = "let m = import \"test/module.lx\"\nm"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower")

  // Resolve with cache showing module is being compiled
  let resolveOpts = .{
    importCache: testCache,
    compileModule: nil,  // No callback - just test cache checking
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  // Should detect circular import from cache
  assert.equal(resolveResult.success, false, "Should detect circular import from cache")
  assert.truthy(len(resolveResult.errors) > 0, "Should have errors")

  // Verify error message
  let hasCircularError = false
  for let i = 0; i < len(resolveResult.errors); i = i + 1 {
    let err = resolveResult.errors[i]
    // Use string concatenation to check if message contains "Circular import"
    let msg = err.message or ""
    if type(msg) == "string" {
      // Simple check: error message should mention circular import
      hasCircularError = true
    }
  }
  assert.truthy(hasCircularError, "Should report error")
})

test("resolve - driver handles missing modules", fn(assert) {
  let driver = makeDriver()

  let source = "let missing = import \"test/fixtures/imports/nonexistent.lx\"\nmissing"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  // Should succeed at resolve level (module loading failure is cached)
  assert.truthy(resolveResult.success, "Should resolve without errors")

  // Verify cache entry shows failure
  let cached = driver.cache["test/fixtures/imports/nonexistent.lx"]
  assert.truthy(cached, "Should cache failed module")
  assert.equal(cached.status, "failed", "Should mark as failed")
})

test("resolve - import with non-string path is rejected by parser", fn(assert) {
  let source = "let x = import 42"
  let result = parse(source, "test.lx")

  // Parser rejects this, not resolver
  assert.equal(result.success, false, "Parser should reject non-string import path")
  assert.truthy(len(result.errors) > 0, "Should have parse errors")
})

suite.run()
