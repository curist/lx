// Typecheck: Option
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - if without else yields Option", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nif cond { 1 } }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - if without else on nil is Nil", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nif cond { nil } }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Nil")
  })

  test("typecheck - if with else is not Option", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { 2 } }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
  })

  test("typecheck - nil unifies by promoting to Option", fn(assert) {
    let result = parseAndTypecheck("{ let x = nil\nx = 1\nx }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 2))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - if branches nil yields Option", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { nil } }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - Option does not double-wrap", fn(assert) {
    let result = parseAndTypecheck("if true { if true { 1 } }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 0))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - dot access on Option yields Option", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nlet x = if cond { .{ a: 1 } }\nx.a }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 2))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - cannot assign field on Option", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nlet x = if cond { .{ a: 1 } }\nx.a = 2 }")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Cannot assign to field on optional value"))
  })

  test("typecheck - function can return Option[T]", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nfn f() { if cond { 1 } }\nf() }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 2))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - optional value cannot be used as Number", fn(assert) {
    let result = parseAndTypecheck("1 + (if true { 1 })")
    assert.truthy(!result.success)
    assert.truthy(hasError(result, "Expected number"))
  })

  test("typecheck - Option.field defers through nested Option indirection", fn(assert) {
    let result = parseAndTypecheck("{ let cond = true\nlet x = if cond { .{ a: 1 } }\nlet y = if cond { x }\ny.a }")
    assert.truthy(result.success)
    if !result.success { return }

    let t = deref(result, getExprType(result, 3))
    assert.equal(t.kind, "Option")
    assert.equal(deref(result, t.value).kind, "Number")
  })

  test("typecheck - Option.field defers until base becomes record", fn(assert) {
    // Exercise both paths:
    // - direct optional base: (if ... { r }).a
    // - indirect optional base: let o = if ... { r }; o.a
    let result = parseAndTypecheck("{
        fn f(r) {
          let x = (if true { r }).a
          let o = if true { r }
          let y = o.a
          r = .{ a: 1 }
          .{ x, y }
        }
        let out = f(.{ a: 1 })
        out.x
        out.y
      }")
    assert.truthy(result.success)
    if !result.success { return }

    let xt = deref(result, getExprType(result, 2))
    assert.equal(xt.kind, "Option")
    assert.equal(deref(result, xt.value).kind, "Number")

    let yt = deref(result, getExprType(result, 3))
    assert.equal(yt.kind, "Option")
    assert.equal(deref(result, yt.value).kind, "Number")
  })

  test("typecheck - HasField consults TypeVar binding", fn(assert) {
    let result = parseAndTypecheck("{
      let o = .{ a: 1 }
      let x = o
      x.a
    }")
    assert.truthy(result.success)
    if !result.success { return }
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")
  })
}

.{ register }
