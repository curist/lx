let TOKEN = enum(100) {
  LEFT_PAREN,
  RIGHT_PAREN,
  LEFT_BRACE,
  RIGHT_BRACE,
  LEFT_BRACKET,
  RIGHT_BRACKET,
  COMMA,
  DOT,
  MINUS,
  PLUS,
  SEMICOLON,
  SLASH,
  STAR,
  COLON,
  MOD,

  // One or two character tokens.
  BANG = 200,
  BANG_EQUAL,
  EQUAL,
  EQUAL_EQUAL,
  GREATER,
  GREATER_EQUAL,
  GREATER_GREATER,
  LESS,
  LESS_EQUAL,
  LESS_LESS,
  DOT_BRACE,
  MINUS_GREATER,
  AMPERSAND,
  PIPE,
  CARET,

  // Literals.
  IDENTIFIER = 300,
  STRING,
  NUMBER,

  // Keywords.
  AND = 400,
  OR,
  IF,
  ELSE,
  FN,
  FOR,
  NIL,
  RETURN,
  TRUE,
  FALSE,
  LET,
  ENUM,
  BREAK,
  CONTINUE,
  IMPORT,
  IN,
  COLLECT,

  // Termination
  ERROR = 990,
  EOF = 999,
}

let KEYWORDS = keys(TOKEN)->fold(.{}, fn(acc, k) {
  let index = TOKEN[k]
  if index >= 400 and index < 500 {
    acc[tolower(k)] = true
  }
  acc
})

let CmpKind = enum {
  LT,  // <
  LE,  // <=
  GT,  // >
  GE,  // >=
  EQ,  // ==
  NE,  // !=
}

// NOTE: need to keep this in sync with clox
let OP = enum {
  // Control flow
  NOP,
  JUMP,
  JUMP_IF_TRUE,
  JUMP_IF_FALSE,
  LOOP,
  CALL,
  CLOSURE,
  CLOSURE_LONG,
  CLOSE_UPVALUE,
  UNWIND,

  // Constants
  CONSTANT,
  CONSTANT_LONG,
  CONST_BYTE,
  NIL,
  TRUE,
  FALSE,

  // Stack manipulation
  POP,
  DUP,

  // Variables
  GET_LOCAL,
  SET_LOCAL,
  GET_GLOBAL,
  GET_GLOBAL_LONG,
  DEFINE_GLOBAL,
  DEFINE_GLOBAL_LONG,
  SET_GLOBAL,
  SET_GLOBAL_LONG,
  GET_UPVALUE,
  GET_UPVALUE_LONG,
  SET_UPVALUE,
  SET_UPVALUE_LONG,

  // Arithmetic (baseline)
  ADD,
  SUBTRACT,
  MULTIPLY,
  DIVIDE,
  MOD,
  NEGATE,

  // Arithmetic (specialized int)
  ADD_INT,
  SUBTRACT_INT,
  MULTIPLY_INT,
  NEGATE_INT,

  // Arithmetic (quickened)
  ADD_NUM,
  ADD_STR,

  // Comparison
  EQUAL,
  GREATER,
  LESS,

  // Logical
  NOT,

  // Bitwise
  BIT_AND,
  BIT_OR,
  BIT_XOR,
  BIT_LSHIFT,
  BIT_RSHIFT,

  // Data structures
  ARRAY,
  HASHMAP,
  ENUM,
  LENGTH,
  GET_BY_INDEX,
  SET_BY_INDEX,
  GET_BY_CONST,        // GET_BY_INDEX with key from constant pool
  GET_BY_CONST_LONG,
  SET_BY_CONST,        // SET_BY_INDEX with key from constant pool
  SET_BY_CONST_LONG,
  ASSOC,
  APPEND,

  // Superinstructions
  ADD_LOCAL_IMM,    // GET_LOCAL + CONST_BYTE + ADD + SET_LOCAL
  STORE_LOCAL,      // SET_LOCAL + POP
  GETI,             // GET_LOCAL×2 + GET_BY_INDEX
  SETI,             // GET_LOCAL×3 + SET_BY_INDEX
  ADD_LOCALS,       // GET_LOCAL×2 + ADD + SET_LOCAL (dest = lhs + rhs)
  SUB_LOCALS,       // GET_LOCAL×2 + SUB + SET_LOCAL (dest = lhs - rhs)
  MUL_LOCALS,       // GET_LOCAL×2 + MUL + SET_LOCAL (dest = lhs * rhs)
  DIV_LOCALS,       // GET_LOCAL×2 + DIV + SET_LOCAL (dest = lhs / rhs)

  // Local arithmetic with constant (expression form - pushes result)
  ADD_LOCAL_K,      // GET_LOCAL + CONST_BYTE + ADD (push local + k)
  SUB_LOCAL_K,      // GET_LOCAL + CONST_BYTE + SUB (push local - k)
  MUL_LOCAL_K,      // GET_LOCAL + CONST_BYTE + MUL (push local * k)
  DIV_LOCAL_K,      // GET_LOCAL + CONST_BYTE + DIV (push local / k)
  CMP_LOCAL_K,      // GET_LOCAL + CONST_BYTE + CMP (push comparison result)

  // Special/optimization
  COALESCE_CONST,   // Replace TOS with constant if TOS is falsy
  COALESCE_CONST_LONG,
  MOD_CONST_BYTE,   // TOS = TOS % imm8 (specialized for constant modulo)
  EQ_CONST_BYTE,    // TOS = (TOS == imm8) (specialized for constant equality)

  // Fused numeric for loops
  FORPREP_1,        // Numeric for loop prepare (step=1)
  FORLOOP_1,        // Numeric for loop iterate (step=1)
  FORPREP,          // Numeric for loop prepare (arbitrary signed step)
  FORLOOP,          // Numeric for loop iterate (arbitrary signed step)

  // Superinstructions
  GET_PROPERTY,     // GET_LOCAL + CONSTANT + GET_BY_INDEX (property access)
  SET_PROPERTY,     // GET_LOCAL + CONSTANT + GET_LOCAL + SET_BY_INDEX

  RETURN = 255,
}

let ValueType = enum { BOOL, NIL, NUMBER, OBJ }

// AST Node kinds (stored on AST nodes as `node.type`)
let NODE = enum {
  // Literals / leaf
  Number,
  String,
  Bool,
  Nil,
  Identifier,

  // Expressions / statements
  Binary,
  Unary,
  Logical,
  Grouping,
  Let,
  Block,
  Function,
  Call,
  Arrow,
  If,
  For,
  ForIn,
  Collect,
  CollectIn,
  Return,
  Break,
  Continue,
  Array,
  Hashmap,
  Index,
  Dot,
  Assignment,
  Import,
  IntrinsicCall,

  // Historical / optional wrapper
  ExprStmt,

  // Parser-only forms (should be lowered away)
  LetDestructure,
}

.{
  TOKEN,
  KEYWORDS,
  CmpKind,
  OP,
  ValueType,
  NODE,
}
