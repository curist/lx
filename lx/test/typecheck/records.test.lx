// Typecheck: records and field access
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - record literal and field access", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1, b: 2 }\nr.a }")
    let recordT = deref(result, getExprType(result, 0))
    assert.equal(recordT.kind, "Record")
    assert.equal(deref(result, recordT.fields["a"]).kind, "Number")
    assert.equal(deref(result, recordT.fields["b"]).kind, "Number")
    let fieldT = deref(result, getExprType(result, 1))
    assert.equal(fieldT.kind, "Number")
  })

  test("typecheck - missing record field reports error", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1 }\nr.b }")
    assert.truthy(hasError(result, "Missing field: b"))
  })

  test("typecheck - call propagates record field into function return", fn(assert) {
    let result = parseAndTypecheck("{ fn getName(x) { x.name }\nlet a = .{ name: \"A\" }\ngetName(a) }")
    let fnT = deref(result, getExprType(result, 0))
    let callT = deref(result, getExprType(result, 2))
    assert.equal(fnT.kind, "Function")
    assert.equal(deref(result, fnT.params[0]).kind, "Record")
    assert.equal(deref(result, fnT.return).kind, "String")
    assert.equal(callT.kind, "String")
  })

  test("typecheck - numeric field propagation via call", fn(assert) {
    let result = parseAndTypecheck("{ fn getA(x) { x.a }\nlet r = .{ a: 1 }\ngetA(r) }")
    let fnT = deref(result, getExprType(result, 0))
    let callT = deref(result, getExprType(result, 2))
    assert.equal(deref(result, fnT.params[0]).kind, "Record")
    assert.equal(deref(result, fnT.return).kind, "Number")
    assert.equal(callT.kind, "Number")
  })

  test("typecheck - missing record field surfaces error at call", fn(assert) {
    let result = parseAndTypecheck("{ fn getA(x) { x.a }\nlet b = .{ b: 1 }\ngetA(b) }")
    assert.truthy(hasError(result, "Argument mismatch") or hasError(result, "Missing field: a"))
  })

  test("typecheck - dot on non-record contains to Any", fn(assert) {
    let result = parseAndTypecheck("{ let n = 1\nn.x }")
    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Any")
    assert.truthy(len(result.errors) > 0)
  })

  test("typecheck - conflicting call shapes degrade to Any", fn(assert) {
    let result = parseAndTypecheck("{ fn pick(x) { x.v }\nlet a = .{ v: 1 }\nlet b = .{ v: \"s\" }\npick(a)\npick(b) }")
    let secondCall = deref(result, getExprType(result, 4))
    assert.truthy(secondCall.kind == "Any" or secondCall.kind == "Number")
    assert.truthy(len(result.errors) > 0)
  })

  test("typecheck - dot assignment constrains field type", fn(assert) {
    // Demonstrates current limitation: dot-assignment does not constrain the field.
    let result = parseAndTypecheck("{ let x\nlet r = .{ x }\nr.x = 2\nr.x }")
    let t = deref(result, getExprType(result, 3))
    assert.equal(t.kind, "Number")
  })

  test("typecheck - dot assignment mismatch reports error", fn(assert) {
    // If dot-assignment is typed, the second write should mismatch the first.
    let result = parseAndTypecheck("{ let x\nlet r = .{ x }\nr.x = 1\nr.x = \"s\" }")
    assert.truthy(hasError(result, "Assignment mismatch"))
  })

  test("typecheck - dot assignment does not create new record fields", fn(assert) {
    // Closed record model: `x.a = ...` does not turn `x` into a record.
    let result = parseAndTypecheck("{ let x\nx.a = 1 }")
    assert.truthy(hasError(result, "Missing field: a"))
  })
}

.{ register }
