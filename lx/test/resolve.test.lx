// Resolve Phase Tests
// Tests for semantic validation (resolve.lx)

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let parse = import "src/passes/frontend/parser.lx"
let lower = import "src/passes/frontend/lower.lx"
let resolve = import "src/passes/frontend/resolve.lx"
let makeResolveHelpers = import "test/resolveTestHelpers.lx"
let types = import "src/types.lx"
let ModuleResolution = import "src/module_resolution.lx"

let NODE = types.NODE

// Helper to parse from fixture file
fn parseFixture(path) {
  let resolver = ModuleResolution.forEntry("test/resolve.test.lx")
  let src = resolver.slurp(path)
  parse(src, path)
}

// Helper to parse and resolve
fn parseAndResolve(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseErrors: parseResult.errors }
  }
  resolve(parseResult.ast, .{})
}

fn parseLowerResolve(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseErrors: parseResult.errors }
  }
  let lowerResult = lower(parseResult.ast, .{ startNodeId: parseResult.nextNodeId })
  if !lowerResult.success {
    return .{ success: false, lowerErrors: lowerResult.errors }
  }
  let resolveResult = resolve(lowerResult.ast, .{})
  .{
    success: resolveResult.success,
    errors: resolveResult.errors,
    parseResult: parseResult,
    lowerResult: lowerResult,
    resolveResult: resolveResult,
  }
}

// Helper to parse, resolve, and create test helpers
fn parseResolveWithHelpers(source) {
  let parseResult = parse(source, "test.lx")
  if !parseResult.success {
    return .{ success: false, parseErrors: parseResult.errors }
  }
  let resolveResult = resolve(parseResult.ast, .{})
  let helpers = makeResolveHelpers(parseResult, resolveResult)
  .{
    success: resolveResult.success,
    errors: resolveResult.errors,
    helpers: helpers,
    parseResult: parseResult,
    resolveResult: resolveResult,
  }
}

// ========================================
// Basic Expressions and Declarations
// ========================================

test("resolve - binary expression", fn(assert) {
  let result = parseAndResolve("1 + 2")
  assert.truthy(result.success, "Should resolve binary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - logical expression", fn(assert) {
  let result = parseAndResolve("true and false")
  assert.truthy(result.success, "Should resolve logical expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - unary expression", fn(assert) {
  let result = parseAndResolve("-42")
  assert.truthy(result.success, "Should resolve unary expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - grouping expression", fn(assert) {
  let result = parseAndResolve("(1 + 2)")
  assert.truthy(result.success, "Should resolve grouping expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested binary expressions", fn(assert) {
  let result = parseAndResolve("1 + 2 * 3 - 4")
  assert.truthy(result.success, "Should resolve nested binary expressions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration without initializer", fn(assert) {
  let result = parseAndResolve("{ let x }")
  assert.truthy(result.success, "Should resolve let declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - let declaration with initializer", fn(assert) {
  let result = parseAndResolve("{ let x = 42 }")
  assert.truthy(result.success, "Should resolve let with initializer")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - using declared variable", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx }")
  assert.truthy(result.success, "Should resolve variable reference")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - duplicate declaration error", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet x = 2 }")
  assert.equal(result.success, false, "Should fail on duplicate declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - read before initialization error", fn(assert) {
  let result = parseAndResolve("{ let x = x }")
  assert.equal(result.success, false, "Should fail on read-before-init")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Expression Types
// ========================================

test("resolve - function call", fn(assert) {
  let result = parseAndResolve("{ let f = fn() { 1 }\nf() }")
  assert.truthy(result.success, "Should resolve function call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if expression", fn(assert) {
  let result = parseAndResolve("if true { 1 } else { 2 }")
  assert.truthy(result.success, "Should resolve if expression")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - if with variable reference", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nif x { 2 } else { 3 } }")
  assert.truthy(result.success, "Should resolve if with variable")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to local", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nx = 2 }")
  assert.truthy(result.success, "Should resolve assignment")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to index (valid)", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] = 3 }")
  assert.truthy(result.success, "Should allow assignment to index")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to dot (valid)", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x = 2 }")
  assert.truthy(result.success, "Should allow assignment to dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - assignment to literal rejected by parser", fn(assert) {
  let result = parse("42 = 1", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to binary expression rejected by parser", fn(assert) {
  let result = parse("(x + 1) = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call rejected by parser", fn(assert) {
  let result = parse("f() = 2", "test.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - assignment to literal from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-literal.lx")
  assert.equal(result.success, false, "Parser should reject assignment to literal")
})

test("resolve - assignment to expression from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-expression.lx")
  assert.equal(result.success, false, "Parser should reject assignment to expression")
})

test("resolve - assignment to call from fixture rejected by parser", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/assignment-to-call.lx")
  assert.equal(result.success, false, "Parser should reject assignment to call")
})

test("resolve - valid assignment targets from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/assignment-targets.lx")
  assert.truthy(result.success, "Parser should accept valid assignment targets")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolver should accept valid assignments")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - array literal", fn(assert) {
  let result = parseAndResolve("[1, 2, 3]")
  assert.truthy(result.success, "Should resolve array literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - array with variables", fn(assert) {
  let result = parseAndResolve("{ let x = 1\nlet arr = [x, 2] }")
  assert.truthy(result.success, "Should resolve array with variables")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - hashmap literal", fn(assert) {
  let result = parseAndResolve(".{ a: 1, b: 2 }")
  assert.truthy(result.success, "Should resolve hashmap literal")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - index access", fn(assert) {
  let result = parseAndResolve("{ let arr = [1, 2]\narr[0] }")
  assert.truthy(result.success, "Should resolve index access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - dot access", fn(assert) {
  let result = parseAndResolve("{ let obj = .{ x: 1 }\nobj.x }")
  assert.truthy(result.success, "Should resolve dot access")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - for loop", fn(assert) {
  let result = parseAndResolve("for let i = 0; i < 10; i = i + 1 { i }")
  assert.truthy(result.success, "Should resolve for loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Functions and Hoisting
// ========================================

test("resolve - anonymous function", fn(assert) {
  let result = parseAndResolve("fn() { 1 }")
  assert.truthy(result.success, "Should resolve anonymous function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - named function declaration", fn(assert) {
  let result = parseAndResolve("{ fn foo() { 1 } }")
  assert.truthy(result.success, "Should resolve named function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - function with parameters", fn(assert) {
  let result = parseAndResolve("fn(x, y) { x + y }")
  assert.truthy(result.success, "Should resolve function with params")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested functions", fn(assert) {
  let result = parseAndResolve("fn outer() { fn inner() { 1 } }")
  assert.truthy(result.success, "Should resolve nested functions")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - mutual recursion in function bodies", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
  }")
  assert.truthy(result.success, "Should allow mutual recursion in function bodies")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after all hoisted functions declared", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { a() }
    a()
  }")
  assert.truthy(result.success, "Should allow call after all declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call after first hoisted function (allowed)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    a()
    fn b() { a() }
  }")
  // With per-function declIndex check, a() is allowed after fn a()
  assert.truthy(result.success, "Should allow call after function's declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - forward reference in function body (ok)", fn(assert) {
  let result = parseAndResolve("{
    fn a() { b() }
    fn b() { 1 }
  }")
  assert.truthy(result.success, "Should allow forward reference in function body")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level mutual recursion", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }")
  assert.truthy(result.success, "Should allow mutual recursion at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { 1 }")
  assert.truthy(result.success, "Should allow forward reference at top level")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - top-level call after hoisted functions", fn(assert) {
  let result = parseAndResolve("fn a() { b() }\nfn b() { a() }\na()")
  assert.truthy(result.success, "Should allow call after all top-level declarations")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// Test for hoisted-function ordering rule (issue #4)
test("resolve - call hoisted function after its declaration", fn(assert) {
  let result = parseAndResolve("{
    fn a() { }
    a()
    fn b() { }
  }")
  // Should allow calling a() after fn a() even if fn b() comes later
  assert.truthy(result.success, "Should allow call after function's own declaration")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - call hoisted function before its declaration (should error)", fn(assert) {
  let result = parseAndResolve("{
    a()
    fn a() { }
  }")
  assert.equal(result.success, false, "Should error when calling before declaration")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - top-level mutual recursion from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-mutual-recursion.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level mutual recursion")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - top-level forward reference from fixture", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/valid/top-level-forward-reference.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Should allow top-level forward reference")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Closures and Capture
// ========================================

test("resolve - simple closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f() { x }
  }")
  assert.truthy(result.success, "Should resolve simple closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested closure", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn outer() {
      fn inner() { x }
    }
  }")
  assert.truthy(result.success, "Should resolve nested closure")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - parameter shadowing", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn f(x) { x }
  }")
  assert.truthy(result.success, "Should allow parameter shadowing")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple captures of same variable", fn(assert) {
  let result = parseAndResolve("{
    let x = 1
    fn a() { x }
    fn b() { x }
  }")
  assert.truthy(result.success, "Should resolve multiple captures")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - capture variable in own initializer (invalid)", fn(assert) {
  let result = parseAndResolve("let x = fn() { x }")
  assert.equal(result.success, false, "Should reject capturing var in own initializer")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Return Validation
// ========================================

test("resolve - return at end of function (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1 }")
  assert.truthy(result.success, "Should allow return at end of function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("fn f() { return 1\n2 }")
  assert.equal(result.success, false, "Should reject return not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return at top level end (valid)", fn(assert) {
  let result = parseAndResolve("1 + 2\nreturn 3")
  assert.truthy(result.success, "Should allow return at end of file")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in middle of file (invalid)", fn(assert) {
  let result = parseAndResolve("return 1\n2")
  assert.equal(result.success, false, "Should reject return in middle of file")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - multiple returns in branches (valid)", fn(assert) {
  let result = parseAndResolve("fn f() { if true { return 1 } return 2 }")
  assert.truthy(result.success, "Should allow returns in different branches")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - return in nested block at end (invalid)", fn(assert) {
  let result = parseAndResolve("{ { return 1 } }")
  assert.equal(result.success, false, "Should reject return in nested block")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in if block outside function (invalid)", fn(assert) {
  let result = parseAndResolve("if true { return 1 }")
  assert.equal(result.success, false, "Should reject return in if block at top level")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - return in nested block from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-nested-block.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in nested block")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return in if outside function from fixture (invalid)", fn(assert) {
  let result = parseFixture("test/fixtures/resolve/invalid/return-in-if-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Should reject return in if at top level")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return outside function from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-outside-function.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - return not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/return-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Break Validation
// ========================================

test("resolve - break inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { break }")
  assert.truthy(result.success, "Should allow break inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ break }")
  assert.equal(result.success, false, "Should reject break outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - break in nested loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { for true { break } }")
  assert.truthy(result.success, "Should allow break in nested loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - break outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

test("resolve - break not at end from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/break-not-at-end.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Control Flow - Continue Validation
// ========================================

test("resolve - continue inside loop (valid)", fn(assert) {
  let result = parseAndResolve("for true { continue }")
  assert.truthy(result.success, "Should allow continue inside loop")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - continue outside loop (invalid)", fn(assert) {
  let result = parseAndResolve("{ continue }")
  assert.equal(result.success, false, "Should reject continue outside loop")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue not at end of block (invalid)", fn(assert) {
  let result = parseAndResolve("for true { continue\n1 }")
  assert.equal(result.success, false, "Should reject continue not at end")
  assert.truthy(len(result.errors) > 0, "Should have errors")
})

test("resolve - continue outside loop from fixture should be rejected", fn(assert) {
  let result = parseFixture("test/fixtures/parser/invalid/continue-outside-loop.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.equal(resolved.success, false, "Resolve should reject")
  assert.truthy(len(resolved.errors) > 0, "Should have errors")
})

// ========================================
// Valid Control Flow Cases
// ========================================

test("resolve - valid control flow from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/control-flow.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

test("resolve - valid loop control from fixture should be accepted", fn(assert) {
  let result = parseFixture("test/fixtures/parser/valid/loop-control.lx")
  assert.truthy(result.success, "Parser should accept")

  let resolved = resolve(result.ast, .{})
  assert.truthy(resolved.success, "Resolve should accept")
  assert.equal(len(resolved.errors), 0, "Should have no errors")
})

// ========================================
// Import Resolution
// ========================================

test("resolve - simple import", fn(assert) {
  let result = parseAndResolve("let x = import \"test/makeTestSuite.lx\"")
  assert.truthy(result.success, "Should resolve valid import")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import used in expression", fn(assert) {
  let result = parseAndResolve("let suite = (import \"test/makeTestSuite.lx\")()")
  assert.truthy(result.success, "Should resolve import in call")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - multiple imports", fn(assert) {
  let source = "let parse = import \"src/passes/frontend/parser.lx\"\nlet resolve = import \"src/passes/frontend/resolve.lx\""
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve multiple imports")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in block", fn(assert) {
  let source = "{ let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in block")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import in function", fn(assert) {
  let source = "fn f() { let mod = import \"test/makeTestSuite.lx\" }"
  let result = parseAndResolve(source)
  assert.truthy(result.success, "Should resolve import in function")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - import node in nodes map", fn(assert) {
  let parseResult = parse("let x = import \"test/makeTestSuite.lx\"", "test.lx")
  let result = resolve(parseResult.ast, .{})

  let importNode = parseResult.ast.expressions[0].init
  assert.equal(importNode.type, NODE.Import, "Should be Import node")

  let nodeInfo = result.nodes[importNode.id]
  assert.truthy(nodeInfo, "Import node should be in nodes map")
  assert.equal(nodeInfo.type, NODE.Import, "Should track node type")
})

test("resolve - let destructure binds names in scope", fn(assert) {
  let result = parseLowerResolve("let .{ A } = .{ A: 1 }\nA")
  assert.truthy(result.success, "Should resolve successfully")
  assert.equal(len(result.errors), 0, "Should have no errors")

  let ast = result.lowerResult.ast
  let last = ast.expressions[len(ast.expressions) - 1]
  assert.truthy(last and last.type == NODE.Identifier and last.name == "A", "Last expr should be A identifier")

  let binding = result.resolveResult.resolvedNames[last.id]
  assert.truthy(binding, "Should have binding for A")
  assert.equal(binding.kind, "local", "A should resolve as local")
})

test("resolve - named function expression binds name in its own body", fn(assert) {
  let result = parseAndResolve("let foo = fn bar() { bar() }\nfoo()", "test.lx")
  assert.truthy(result.success, "Named function expression recursion should resolve")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Import Driver Tests
// ========================================

let Driver = import "src/driver.lx"

// Helper: Create a driver that compiles modules through parse → lower → resolve
fn makeDriver() {
  Driver.make(.{
    loadSource: fn(path) {
      // Mock sources for specific tests (no fixture files needed)
      if path == "test/fixtures/imports/simple.lx" {
        return "42"
      } else if path == "test/fixtures/imports/math.lx" {
        return "fn add(a, b) { a + b }\nadd"
      } else if path == "test/fixtures/imports/circular-a.lx" {
        return "let b = import \"test/fixtures/imports/circular-b.lx\"\nb"
      } else if path == "test/fixtures/imports/circular-b.lx" {
        return "let a = import \"test/fixtures/imports/circular-a.lx\"\na"
      } else if path == "test/fixtures/imports/nonexistent.lx" {
        return nil  // Will trigger "Failed to load source" error
      } else {
        // Default: read from file system
        // Any new fixture file in test/fixtures/imports/ will be automatically loaded
        let resolver = ModuleResolution.forEntry("test/resolve.test.lx")
        return resolver.slurp(path)
      }
    },
    withTypecheck: false,  // Resolve tests don't need typecheck
  })
}

test("resolve - driver compiles module via compileModule callback", fn(assert) {
  let driver = makeDriver()

  let source = "let simple = import \"test/fixtures/imports/simple.lx\"\nsimple"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve main module")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify module was compiled
  assert.equal(len(driver.compiledModules), 1, "Should compile one module")
  assert.equal(driver.compiledModules[0], "test/fixtures/imports/simple.lx", "Should compile correct module")

  // Verify cache entry
  let cached = driver.cache["test/fixtures/imports/simple.lx"]
  assert.truthy(cached, "Should cache module")
  assert.equal(cached.status, "done", "Should mark as done")
})

test("resolve - driver caches modules (same import twice)", fn(assert) {
  let driver = makeDriver()

  let source = "let m1 = import \"test/fixtures/imports/math.lx\"\nlet m2 = import \"test/fixtures/imports/math.lx\"\nm1"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve main module")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify module was compiled only once
  assert.equal(len(driver.compiledModules), 1, "Should compile module only once")
  assert.equal(driver.compiledModules[0], "test/fixtures/imports/math.lx", "Should compile correct module")

  // Verify cache hit
  let cached = driver.cache["test/fixtures/imports/math.lx"]
  assert.truthy(cached, "Should cache module")
  assert.equal(cached.status, "done", "Should mark as done")
})

test("resolve - diamond import pattern (shared dependency)", fn(assert) {
  let driver = makeDriver()

  // Import app.lx which imports both config.lx and logger.lx,
  // both of which import constants.lx (diamond bottom)
  let source = "let app = import \"test/fixtures/imports/app.lx\"\napp"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  assert.truthy(resolveResult.success, "Should resolve diamond import successfully")
  assert.equal(len(resolveResult.errors), 0, "Should have no errors")

  // Verify constants.lx was compiled exactly once despite being imported by both config and logger
  let constantsCompileCount = 0
  for let i = 0; i < len(driver.compiledModules); i = i + 1 {
    if driver.compiledModules[i] == "test/fixtures/imports/constants.lx" {
      constantsCompileCount = constantsCompileCount + 1
    }
  }
  assert.equal(constantsCompileCount, 1, "Constants should be compiled exactly once")

  // Verify all modules in the diamond are cached
  assert.truthy(driver.cache["test/fixtures/imports/constants.lx"], "Should cache constants")
  assert.truthy(driver.cache["test/fixtures/imports/config.lx"], "Should cache config")
  assert.truthy(driver.cache["test/fixtures/imports/logger.lx"], "Should cache logger")
  assert.truthy(driver.cache["test/fixtures/imports/app.lx"], "Should cache app")

  // Verify all cached modules have "done" status
  assert.equal(driver.cache["test/fixtures/imports/constants.lx"].status, "done", "Constants marked done")
  assert.equal(driver.cache["test/fixtures/imports/config.lx"].status, "done", "Config marked done")
  assert.equal(driver.cache["test/fixtures/imports/logger.lx"].status, "done", "Logger marked done")
  assert.equal(driver.cache["test/fixtures/imports/app.lx"].status, "done", "App marked done")
})

test("resolve - circular import infrastructure in place", fn(assert) {
  // Test that resolveImport correctly checks cache status
  let testCache = .{}

  // Mark a module as being compiled
  testCache["test/module.lx"] = .{
    status: "compiling",
    path: "test/module.lx",
  }

  let source = "let m = import \"test/module.lx\"\nm"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower")

  // Resolve with cache showing module is being compiled
  let resolveOpts = .{
    importCache: testCache,
    compileModule: nil,  // No callback - just test cache checking
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  // Should detect circular import from cache
  assert.equal(resolveResult.success, false, "Should detect circular import from cache")
  assert.truthy(len(resolveResult.errors) > 0, "Should have errors")

  // Verify error message
  let hasCircularError = false
  for let i = 0; i < len(resolveResult.errors); i = i + 1 {
    let err = resolveResult.errors[i]
    // Use string concatenation to check if message contains "Circular import"
    let msg = err.message or ""
    if type(msg) == "string" {
      // Simple check: error message should mention circular import
      hasCircularError = true
    }
  }
  assert.truthy(hasCircularError, "Should report error")
})

test("resolve - driver handles missing modules", fn(assert) {
  let driver = makeDriver()

  let source = "let missing = import \"test/fixtures/imports/nonexistent.lx\"\nmissing"
  let parseResult = parse(source, "main.lx")
  assert.truthy(parseResult.success, "Should parse main module")

  let lowerResult = lower(parseResult.ast, .{
    startNodeId: parseResult.nextNodeId,
  })
  assert.truthy(lowerResult.success, "Should lower main module")

  let resolveOpts = .{
    importCache: driver.cache,
    compileModule: driver.compileModule,
  }
  let resolveResult = resolve(lowerResult.ast, resolveOpts)

  // Should fail at resolve level when module loading fails
  assert.equal(resolveResult.success, false, "Should fail with missing import")
  assert.truthy(len(resolveResult.errors) > 0, "Should have errors for failed import")

  // Verify cache entry shows failure
  let cached = driver.cache["test/fixtures/imports/nonexistent.lx"]
  assert.truthy(cached, "Should cache failed module")
  assert.equal(cached.status, "failed", "Should mark as failed")
})

test("resolve - import with non-string path is rejected by parser", fn(assert) {
  let source = "let x = import 42"
  let result = parse(source, "test.lx")

  // Parser rejects this, not resolver
  assert.equal(result.success, false, "Parser should reject non-string import path")
  assert.truthy(len(result.errors) > 0, "Should have parse errors")
})

// ========================================
// Closure Upvalue Resolution
// ========================================

test("resolve - multiple upvalues in closure with block scopes", fn(assert) {
  let result = parseAndResolve("fn makeGetter(x, y) {
    fn get(key) {
      if key == \"x\" { return x }
      if key == \"y\" { return y }
    }
    return get
  }")
  assert.truthy(result.success, "Should resolve multiple upvalues across block scopes")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - closure capturing multiple parameters", fn(assert) {
  let result = parseAndResolve("{
    fn outer(x, y, z) {
      fn inner() {
        return x + y + z
      }
      return inner
    }
  }")
  assert.truthy(result.success, "Should resolve closure capturing multiple parameters")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - nested closures with intermediate block scopes", fn(assert) {
  let result = parseAndResolve("fn vector(x, y) {
    fn object(message) {
      fn add(other) {
        return vector(x + other(\"x\"), y + other(\"y\"))
      }
      if message == \"x\" { return x }
      if message == \"y\" { return y }
      if message == \"add\" { return add }
    }
    return object
  }")
  assert.truthy(result.success, "Should resolve nested closures with block scopes")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

test("resolve - upvalues only added to function scopes not blocks", fn(assert) {
  // This tests that upvalues are correctly accumulated in function scopes
  // even when references occur in different block scopes (if statements)
  let result = parseAndResolve("{
    fn makeCounter(a, b, c) {
      fn get(which) {
        if which == 1 { return a }
        if which == 2 { return b }
        if which == 3 { return c }
        return 0
      }
      return get
    }
  }")
  assert.truthy(result.success, "Should resolve upvalues correctly across blocks")
  assert.equal(len(result.errors), 0, "Should have no errors")
})

// ========================================
// Detailed Upvalue Resolution Tests
// ========================================

test("resolve - local variable slot assignment", fn(assert) {
  let result = parseResolveWithHelpers("{ let x = 1\nx }")
  assert.truthy(result.success, "Should resolve successfully")

  // Find the x reference (there's only one Identifier node - the reference)
  let xRef = result.helpers.findNthIdentifier("x", 0)
  assert.truthy(xRef, "Should find x reference")

  let binding = result.helpers.getBinding(xRef)
  assert.equal(binding.kind, "local", "x should be resolved as local")
  assert.equal(binding.slot, 0, "x should be in slot 0")
})

test("resolve - simple closure with direct upvalue", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    fn f() { x }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Find x reference inside function (first occurrence is the reference)
  let xRef = result.helpers.findNthIdentifier("x", 0)
  assert.truthy(xRef, "Should find x reference")

  let binding = result.helpers.getBinding(xRef)
  assert.equal(binding.kind, "upvalue", "x should be resolved as upvalue")
  assert.equal(binding.upvalueIndex, 0, "x should be upvalue index 0")

  // Find the function node and check its upvalues
  // The function is the second expression in the inner block
  let innerBlock = result.parseResult.ast.expressions[0]
  let functionNode = innerBlock.expressions[1]
  assert.equal(functionNode.type, NODE.Function, "Should be a function node")

  let upvalues = result.helpers.getUpvalues(functionNode)
  assert.truthy(upvalues, "Function should have upvalues")
  assert.equal(len(upvalues), 1, "Function should have 1 upvalue")

  let uv0 = upvalues[0]
  assert.equal(uv0.isLocal, true, "Upvalue should be local (direct capture)")
  // Note: Named function 'f' is hoisted and takes slot 0, so 'x' gets slot 1
  assert.equal(uv0.slot, 1, "Upvalue should point to slot 1 (x, after hoisted fn name)")
})

test("resolve - closure with intermediate block scope", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    {
      fn f() { x }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Find x reference inside function
  let xRef = result.helpers.findNthIdentifier("x", 0)
  assert.truthy(xRef, "Should find x reference")

  let binding = result.helpers.getBinding(xRef)
  assert.equal(binding.kind, "upvalue", "x should be resolved as upvalue")

  // Navigate: ast -> outer block -> inner block -> fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let innerBlock = outerBlock.expressions[1]
  assert.equal(innerBlock.type, NODE.Block, "Should be a block")

  let functionNode = innerBlock.expressions[0]
  assert.equal(functionNode.type, NODE.Function, "Should be a function node")

  let upvalues = result.helpers.getUpvalues(functionNode)
  assert.truthy(upvalues, "Function should have upvalues")
  assert.equal(len(upvalues), 1, "Function should have 1 upvalue")

  let uv0 = upvalues[0]
  assert.equal(uv0.isLocal, true, "Upvalue should be local despite intermediate block")
  assert.equal(uv0.slot, 0, "Upvalue should point to slot 0 (x)")
})

test("resolve - closure with intermediate loop scope", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    for true {
      fn f() { x }
      break
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Find x reference inside function
  let xRef = result.helpers.findNthIdentifier("x", 0)
  assert.truthy(xRef, "Should find x reference")

  let binding = result.helpers.getBinding(xRef)
  assert.equal(binding.kind, "upvalue", "x should be resolved as upvalue")

  // Navigate: ast -> outer block -> for loop -> fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let loopNode = outerBlock.expressions[1]
  assert.equal(loopNode.type, NODE.For, "Should be a for loop")

  let functionNode = loopNode.body.expressions[0]
  assert.equal(functionNode.type, NODE.Function, "Should be a function node")

  let upvalues = result.helpers.getUpvalues(functionNode)
  assert.truthy(upvalues, "Function should have upvalues")
  assert.equal(len(upvalues), 1, "Function should have 1 upvalue")

  let uv0 = upvalues[0]
  assert.equal(uv0.isLocal, true, "Upvalue should be local despite intermediate loop")
  assert.equal(uv0.slot, 0, "Upvalue should point to slot 0 (x)")
})

test("resolve - closure with multiple intermediate block scopes", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    {
      {
        fn f() { x }
      }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> block1 -> block2 -> fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let block1 = outerBlock.expressions[1]
  let block2 = block1.expressions[0]
  let functionNode = block2.expressions[0]

  let upvalues = result.helpers.getUpvalues(functionNode)
  assert.equal(len(upvalues), 1, "Function should have 1 upvalue")

  let uv0 = upvalues[0]
  assert.equal(uv0.isLocal, true, "Upvalue should be local despite multiple intermediate blocks")
  assert.equal(uv0.slot, 0, "Upvalue should point to slot 0 (x)")
})

test("resolve - closure with block and loop intermediate scopes", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    {
      for true {
        {
          fn f() { x }
          break
        }
      }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> block1 -> loop -> block2 -> fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let block1 = outerBlock.expressions[1]
  let loopNode = block1.expressions[0]
  let block2 = loopNode.body.expressions[0]
  let functionNode = block2.expressions[0]

  let upvalues = result.helpers.getUpvalues(functionNode)
  assert.equal(len(upvalues), 1, "Function should have 1 upvalue")

  let uv0 = upvalues[0]
  assert.equal(uv0.isLocal, true, "Upvalue should be local despite mixed intermediate scopes")
  assert.equal(uv0.slot, 0, "Upvalue should point to slot 0 (x)")
})

test("resolve - nested closure (indirect upvalue)", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    fn outer() {
      fn inner() { x }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> outer fn -> inner fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let outerFn = outerBlock.expressions[1]
  let innerFn = outerFn.body.expressions[0]

  // Check outer function's upvalue
  let outerUpvalues = result.helpers.getUpvalues(outerFn)
  assert.equal(len(outerUpvalues), 1, "Outer should have 1 upvalue")
  assert.equal(outerUpvalues[0].isLocal, true, "Outer's upvalue should be local")
  // Note: Named function 'outer' is hoisted and takes slot 0, so 'x' gets slot 1
  assert.equal(outerUpvalues[0].slot, 1, "Outer's upvalue should point to slot 1 (x)")

  // Check inner function's upvalue
  let innerUpvalues = result.helpers.getUpvalues(innerFn)
  assert.equal(len(innerUpvalues), 1, "Inner should have 1 upvalue")
  assert.equal(innerUpvalues[0].isLocal, false, "Inner's upvalue should be indirect")
  assert.equal(innerUpvalues[0].slot, 0, "Inner's upvalue should point to outer's upvalue 0")
})

test("resolve - nested closure with intermediate blocks", fn(assert) {
  let result = parseResolveWithHelpers("{
    let x = 1
    {
      fn outer() {
        {
          fn inner() { x }
        }
      }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> block1 -> outer fn -> block2 -> inner fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let block1 = outerBlock.expressions[1]
  let outerFn = block1.expressions[0]
  let block2 = outerFn.body.expressions[0]
  let innerFn = block2.expressions[0]

  // Check outer function's upvalue
  let outerUpvalues = result.helpers.getUpvalues(outerFn)
  assert.equal(len(outerUpvalues), 1, "Outer should have 1 upvalue")
  assert.equal(outerUpvalues[0].isLocal, true, "Outer's upvalue should be local despite block")
  assert.equal(outerUpvalues[0].slot, 0, "Outer's upvalue should point to slot 0")

  // Check inner function's upvalue
  let innerUpvalues = result.helpers.getUpvalues(innerFn)
  assert.equal(len(innerUpvalues), 1, "Inner should have 1 upvalue")
  assert.equal(innerUpvalues[0].isLocal, false, "Inner's upvalue should be indirect")
  assert.equal(innerUpvalues[0].slot, 0, "Inner's upvalue should point to outer's upvalue 0")
})

test("resolve - multiple upvalues in one function", fn(assert) {
  let result = parseResolveWithHelpers("{
    let a = 1
    let b = 2
    fn f() {
      a
      b
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> fn (3rd expression)
  let outerBlock = result.parseResult.ast.expressions[0]
  let functionNode = outerBlock.expressions[2]
  let upvalues = result.helpers.getUpvalues(functionNode)

  assert.equal(len(upvalues), 2, "Function should have 2 upvalues")

  // Note: Named function 'f' is hoisted and takes slot 0
  // So 'a' gets slot 1, 'b' gets slot 2
  assert.equal(upvalues[0].isLocal, true, "First upvalue should be local")
  assert.equal(upvalues[0].slot, 1, "First upvalue should point to slot 1 (a)")

  assert.equal(upvalues[1].isLocal, true, "Second upvalue should be local")
  assert.equal(upvalues[1].slot, 2, "Second upvalue should point to slot 2 (b)")
})

test("resolve - capturing function parameters", fn(assert) {
  let result = parseResolveWithHelpers("{
    fn outer(x, y) {
      fn inner() {
        x
        y
      }
    }
  }")
  assert.truthy(result.success, "Should resolve successfully")

  // Navigate: ast -> outer block -> outer fn -> inner fn
  let outerBlock = result.parseResult.ast.expressions[0]
  let outerFn = outerBlock.expressions[0]
  let innerFn = outerFn.body.expressions[0]

  let innerUpvalues = result.helpers.getUpvalues(innerFn)
  assert.equal(len(innerUpvalues), 2, "Inner should have 2 upvalues")

  // Note: Named function 'outer' binds its own name in slot 0 for recursion
  // So parameters x and y are at slots 1 and 2
  assert.equal(innerUpvalues[0].isLocal, true, "First upvalue should be local (param)")
  assert.equal(innerUpvalues[0].slot, 1, "First upvalue should point to param x at slot 1")

  assert.equal(innerUpvalues[1].isLocal, true, "Second upvalue should be local (param)")
  assert.equal(innerUpvalues[1].slot, 2, "Second upvalue should point to param y at slot 2")
})

suite.run()
