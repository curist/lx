// Query Service - Position-based IDE queries over compiler artifacts
//
// Provides hover (type at position) and goto definition (jump to declaration)
// for editor tooling integration.
//
// Read-only: no inference, no unification, just table lookups + span selection.

// ========================================
// Helpers
// ========================================

fn rangeOf(n) {
  .{
    filename: n.filename,
    line: n.line,
    col: n.col,
    endLine: n.endLine,
    endCol: n.endCol,
  }
}

// ========================================
// Indexing
// ========================================

fn collectAllNodes(node, nodes) {
  if type(node) != "map" { return }

  nodes[node.id] = node

  // Traverse common node fields
  if node.name { collectAllNodes(node.name, nodes) }
  if node.init { collectAllNodes(node.init, nodes) }
  if node.value { collectAllNodes(node.value, nodes) }
  if node.left { collectAllNodes(node.left, nodes) }
  if node.right { collectAllNodes(node.right, nodes) }
  if node.operand { collectAllNodes(node.operand, nodes) }
  if node.callee { collectAllNodes(node.callee, nodes) }
  if node.object { collectAllNodes(node.object, nodes) }
  if node.property { collectAllNodes(node.property, nodes) }
  if node.index { collectAllNodes(node.index, nodes) }
  if node.target { collectAllNodes(node.target, nodes) }
  if node.test { collectAllNodes(node.test, nodes) }
  if node.then { collectAllNodes(node.then, nodes) }
  if node.else { collectAllNodes(node.else, nodes) }
  if node.condition { collectAllNodes(node.condition, nodes) }

  // Traverse arrays
  if node.params and type(node.params) == "array" {
    for let i = 0; i < len(node.params); i = i + 1 {
      collectAllNodes(node.params[i], nodes)
    }
  }
  if node.args and type(node.args) == "array" {
    for let i = 0; i < len(node.args); i = i + 1 {
      collectAllNodes(node.args[i], nodes)
    }
  }
  if node.elements and type(node.elements) == "array" {
    for let i = 0; i < len(node.elements); i = i + 1 {
      collectAllNodes(node.elements[i], nodes)
    }
  }
  if node.pairs and type(node.pairs) == "array" {
    for let i = 0; i < len(node.pairs); i = i + 1 {
      let pair = node.pairs[i]
      collectAllNodes(pair.key, nodes)
      collectAllNodes(pair.value, nodes)
    }
  }
  if node.expressions and type(node.expressions) == "array" {
    for let i = 0; i < len(node.expressions); i = i + 1 {
      collectAllNodes(node.expressions[i], nodes)
    }
  }
  if node.body and type(node.body) == "array" {
    for let i = 0; i < len(node.body); i = i + 1 {
      collectAllNodes(node.body[i], nodes)
    }
  }
}

fn buildFileIndex(ctx) {
  each(keys(ctx.nodes), fn(id) {
    let n = ctx.nodes[id]
    if !n or !n.filename {
      return
    }

    let fname = n.filename
    if !ctx.fileNodeIds[fname] {
      ctx.fileNodeIds[fname] = []
    }
    push(ctx.fileNodeIds[fname], id)
  })
}

// ========================================
// Node Selection
// ========================================

fn contains(n, line, col) {
  if line < n.line or line > n.endLine {
    return false
  }
  if line == n.line and col < n.col {
    return false
  }
  if line == n.endLine and col >= n.endCol {
    return false
  }
  true
}

fn spanScore(n) {
  (n.endLine - n.line) * 100000 + (n.endCol - n.col)
}

fn nodeAtPos(ctx, filename, line, col) {
  if !ctx or !ctx.nodes {
    return nil
  }

  let ids = nil
  if ctx.fileNodeIds and type(ctx.fileNodeIds) == "map" and ctx.fileNodeIds[filename] {
    ids = ctx.fileNodeIds[filename]
  } else {
    ids = keys(ctx.nodes)
  }

  let best = nil
  let bestScore = nil

  each(ids, fn(id) {
    let n = ctx.nodes[id]
    if !n or n.filename != filename {
      return
    }
    if !contains(n, line, col) {
      return
    }

    let s = spanScore(n)
    // Prefer smaller span, or if tied, prefer larger ID (more specific/nested node)
    // Also skip Program nodes if we have alternatives
    if !best or s < bestScore or (s == bestScore and n.id > best.id) {
      best = n
      bestScore = s
    }
  })

  best
}

fn propNameFromNode(n) {
  if !n { return nil }
  if n.type == "Identifier" { return n.name }
  if n.type == "String" { return n.value }
  nil
}

fn lastExprFromAst(ast) {
  if ast and ast.expressions and len(ast.expressions) > 0 {
    return ast.expressions[len(ast.expressions) - 1]
  }
  if ast and ast.body and len(ast.body) > 0 {
    return ast.body[len(ast.body) - 1]
  }
  nil
}

fn findLetByNameId(ctx, nameId) {
  let ids = keys(ctx.nodes)
  for let i = 0; i < len(ids); i = i + 1 {
    let n = ctx.nodes[ids[i]]
    if n and n.type == "Let" and n.name and n.name.id == nameId {
      return n
    }
  }
  nil
}

fn findDotByPropertyNode(ctx, propNode) {
  if !propNode {
    return nil
  }
  let ids = keys(ctx.nodes)
  for let i = 0; i < len(ids); i = i + 1 {
    let n = ctx.nodes[ids[i]]
    if n and n.type == "Dot" and n.property {
      let p = n.property
      if p.filename == propNode.filename and
         p.line == propNode.line and p.col == propNode.col and
         p.endLine == propNode.endLine and p.endCol == propNode.endCol {
        return n
      }
    }
  }
  nil
}

fn findRecordField(recordNode, fieldName) {
  if !recordNode or recordNode.type != "Hashmap" or !recordNode.pairs {
    return nil
  }
  for let i = 0; i < len(recordNode.pairs); i = i + 1 {
    let pair = recordNode.pairs[i]
    let key = pair and pair.key
    if key and key.type == "String" and key.value == fieldName {
      return .{ key: key, value: pair.value }
    }
  }
  nil
}

fn findDotAssignmentValue(ctx, filename, objectName, propName) {
  let ids = ctx.fileNodeIds and ctx.fileNodeIds[filename] or keys(ctx.nodes)
  for let i = 0; i < len(ids); i = i + 1 {
    let n = ctx.nodes[ids[i]]
    if n and n.type == "Assignment" and n.target and n.target.type == "Dot" {
      let target = n.target
      let obj = target.object
      let prop = target.property
      if obj and obj.type == "Identifier" and obj.name == objectName {
        let tProp = propNameFromNode(prop)
        if tProp == propName {
          return n.value
        }
      }
    }
  }
  nil
}

fn resolveExprToRecord(ctx, expr, seen) {
  if !expr {
    return nil
  }
  if expr.id and seen and seen[expr.id] {
    return nil
  }
  if expr.id and seen {
    seen[expr.id] = true
  }

  if expr.type == "Hashmap" {
    return expr
  }

  if expr.type == "Block" {
    let last = lastExprFromAst(expr)
    return resolveExprToRecord(ctx, last, seen)
  }

  if expr.type == "Grouping" {
    return resolveExprToRecord(ctx, expr.expression, seen)
  }

  if expr.type == "Identifier" {
    let r = ctx.resolvedNames[expr.id]
    if !r or !r.declaredAt {
      return nil
    }
    let decl = ctx.nodes[r.declaredAt]
    if !decl {
      return nil
    }
    let letNode = findLetByNameId(ctx, decl.id)
    if !letNode or !letNode.init {
      return nil
    }
    if letNode.init.type == "Import" and letNode.init.path {
      let modulePath = letNode.init.path.value
      let moduleAst = ctx.moduleAsts and ctx.moduleAsts[modulePath]
      let moduleReturn = moduleAst and lastExprFromAst(moduleAst)
      if moduleReturn {
        return resolveExprToRecord(ctx, moduleReturn, seen)
      }
    }
    return resolveExprToRecord(ctx, letNode.init, seen)
  }

  if expr.type == "Dot" {
    let propName = propNameFromNode(expr.property)
    if !propName {
      return nil
    }

    // If base is an imported module, look for assignments in the module file.
    if expr.object and expr.object.type == "Identifier" {
      let r = ctx.resolvedNames[expr.object.id]
      if r and r.declaredAt {
        let decl = ctx.nodes[r.declaredAt]
        let letNode = decl and findLetByNameId(ctx, decl.id)
        if letNode and letNode.init and letNode.init.type == "Import" and letNode.init.path {
          let modulePath = letNode.init.path.value
          let moduleAst = ctx.moduleAsts and ctx.moduleAsts[modulePath]
          let moduleReturn = moduleAst and lastExprFromAst(moduleAst)
          if moduleReturn and moduleReturn.type == "Identifier" {
            let rootName = moduleReturn.name
            let assignedValue = findDotAssignmentValue(ctx, modulePath, rootName, propName)
            if assignedValue {
              return resolveExprToRecord(ctx, assignedValue, seen)
            }
          }
          // Fall back to module return record literal, if any.
          if moduleReturn {
            let moduleRecord = resolveExprToRecord(ctx, moduleReturn, seen)
            if moduleRecord {
              let field = findRecordField(moduleRecord, propName)
              if field and field.value {
                return resolveExprToRecord(ctx, field.value, seen)
              }
            }
          }
        }
      }
    }

    let baseRecord = resolveExprToRecord(ctx, expr.object, seen)
    if !baseRecord {
      return nil
    }
    let field = findRecordField(baseRecord, propName)
    if field and field.value {
      return resolveExprToRecord(ctx, field.value, seen)
    }
  }

  nil
}

// ========================================
// Goto Definition Normalization
// ========================================

fn normalizeDeclTarget(ctx, declNodeId) {
  let decl = ctx.nodes[declNodeId]
  if !decl {
    return nil
  }

  // If resolver stored the Function node id for named functions,
  // prefer jumping to the name identifier span when available.
  if decl.type == "Function" and decl.name and decl.name.id {
    let nameNode = ctx.nodes[decl.name.id]
    if nameNode {
      return nameNode
    }
  }

  // Otherwise use the node itself (Identifier bindings already land perfectly)
  decl
}

// ========================================
// Type Formatting
// ========================================

fn formatType(ty) {
  if !ty {
    return "Unknown"
  }

  let kind = ty.kind

  // Primitives
  if kind == "Number" { return "Number" }
  if kind == "String" { return "String" }
  if kind == "Bool" { return "Bool" }
  if kind == "Nil" { return "Nil" }
  if kind == "Any" { return "Any" }
  if kind == "Unknown" { return "Unknown" }

  // TypeVar - show as T<id> for now
  if kind == "TypeVar" {
    return "T" + str(ty.id)
  }

  // Array
  if kind == "Array" {
    return "Array<" + formatType(ty.elem) + ">"
  }

  // Option
  if kind == "Option" {
    return "Option<" + formatType(ty.value) + ">"
  }

  // Map
  if kind == "Map" {
    return "Map<" + formatType(ty.key) + ", " + formatType(ty.elem) + ">"
  }

  // Function
  if kind == "Function" {
    let params = ty.params
    let paramStrs = []
    for let i = 0; i < len(params); i = i + 1 {
      push(paramStrs, formatType(params[i]))
    }
    let paramStr = join(paramStrs, ", ")
    return "fn(" + paramStr + ") -> " + formatType(ty.return)
  }

  // Record - check field count for expansion
  if kind == "Record" {
    let fields = ty.fields
    let fieldNames = keys(fields)
    let fieldCount = len(fieldNames)

    // Small records: expand inline
    if fieldCount <= 6 {
      let fieldStrs = []
      for let i = 0; i < fieldCount; i = i + 1 {
        let fname = fieldNames[i]
        push(fieldStrs, fname + ": " + formatType(fields[fname]))
      }
      return ".{ " + join(fieldStrs, ", ") + " }"
    }

    // Large records: collapse
    return ".{ ... }"
  }

  // Tagged unions
  if kind == "Tagged" {
    let tagField = ty.tagField
    let cases = ty.cases
    let caseNames = keys(cases)
    return tagField + "(" + join(caseNames, " | ") + ")"
  }

  // RecordTop, LenableTop (constraint types)
  if kind == "RecordTop" { return "Record" }
  if kind == "LenableTop" { return "Lenable" }

  // Scheme (polymorphic type schemes)
  if kind == "Scheme" {
    return formatType(ty.type)
  }

  // Fallback
  "(" + kind + ")"
}

fn formatTypeWithBindings(ctx, ty) {
  fn fmt(t, seen) {
    if !t {
      return "Unknown"
    }

    let kind = t.kind

    if kind == "TypeVar" {
      let id = t.id
      if ctx.typeVarBindings and id and !seen[id] {
        let binding = ctx.typeVarBindings[id]
        if binding {
          seen[id] = true
          return fmt(binding, seen)
        }
      }
      // Unbound type var
      return "'T" + str(id)
    }

    if kind == "Array" {
      return "Array<" + fmt(t.elem, seen) + ">"
    }
    if kind == "Option" {
      return "Option<" + fmt(t.value, seen) + ">"
    }
    if kind == "Map" {
      return "Map<" + fmt(t.key, seen) + ", " + fmt(t.elem, seen) + ">"
    }
    if kind == "Function" {
      let params = t.params
      let paramStrs = []
      for let i = 0; i < len(params); i = i + 1 {
        push(paramStrs, fmt(params[i], seen))
      }
      return "fn(" + join(paramStrs, ", ") + ") -> " + fmt(t.return, seen)
    }
    if kind == "Record" {
      let fields = t.fields
      let fieldNames = keys(fields)
      let fieldCount = len(fieldNames)

      if fieldCount <= 6 {
        let fieldStrs = []
        for let i = 0; i < fieldCount; i = i + 1 {
          let fname = fieldNames[i]
          push(fieldStrs, fname + ": " + fmt(fields[fname], seen))
        }
        return ".{ " + join(fieldStrs, ", ") + " }"
      }
      return ".{ ... }"
    }
    if kind == "Tagged" {
      let tagField = t.tagField
      let cases = t.cases
      let caseNames = keys(cases)
      return tagField + "(" + join(caseNames, " | ") + ")"
    }
    if kind == "RecordTop" { return "Record" }
    if kind == "LenableTop" { return "Lenable" }
    if kind == "Scheme" { return fmt(t.type, seen) }
    if kind == "Number" { return "Number" }
    if kind == "String" { return "String" }
    if kind == "Bool" { return "Bool" }
    if kind == "Nil" { return "Nil" }
    if kind == "Any" { return "Any" }
    if kind == "Unknown" { return "Unknown" }

    "(" + kind + ")"
  }

  fmt(ty, .{})
}

// Given a string key node inside a record literal, return the value's type if known.
fn valueTypeForRecordKey(ctx, keyNode) {
  if !keyNode or !keyNode.id {
    return nil
  }

  let fname = keyNode.filename
  let ids = ctx.fileNodeIds[fname] or keys(ctx.nodes)

  for let i = 0; i < len(ids); i = i + 1 {
    let cand = ctx.nodes[ids[i]]
    if !cand or cand.type != "Hashmap" or cand.filename != fname {
      continue
    }

    if !cand.pairs or type(cand.pairs) != "array" {
      continue
    }

    for let j = 0; j < len(cand.pairs); j = j + 1 {
      let pair = cand.pairs[j]
      if pair.key and pair.key.id == keyNode.id {
        if pair.value {
          return ctx.types[pair.value.id]
        }
      }
    }
  }

  nil
}

// Build richer hover payload: always include formatted type, and when possible,
// attach symbol resolution + declaration info for identifiers.
fn buildSymbolInfo(ctx, n) {
  if !n or n.type != "Identifier" {
    return nil
  }

  let info = .{ name: n.name or n.lexeme or "(anonymous)" }
  let r = ctx.resolvedNames[n.id]

  if !r {
    info.kind = "unresolved"
    return info
  }

  info.kind = r.kind

  if r.kind == "builtin" and r.name {
    info.builtinName = r.name
  }

  if r.declaredAt {
    let declNode = ctx.nodes[r.declaredAt]
    if declNode {
      info.declaration = rangeOf(declNode)
      info.declarationNodeType = declNode.type

      let declType = ctx.types[declNode.id]
      if declType {
        info.declarationType = formatTypeWithBindings(ctx, declType)
      }
    }
  }

  info
}

fn buildHoverContents(ctx, n, ty) {
  // If hovering a record key, prefer the field's value type over the literal String type.
  if n.type == "String" {
    let fieldType = valueTypeForRecordKey(ctx, n)
    if fieldType {
      ty = fieldType
    }
  }

  let contents = .{ type: formatTypeWithBindings(ctx, ty) }
  let symbol = buildSymbolInfo(ctx, n)
  if symbol {
    contents.symbol = symbol
  }
  contents
}

// ========================================
// Public API
// ========================================

fn queryInit(ast, resolveResult, typecheckResult, opts) {
  // Start with resolver's nodes, then collect any missing nodes from AST
  let nodes = resolveResult.nodes
  collectAllNodes(ast, nodes)

  let ctx = .{
    ast: ast,
    nodes: nodes,
    resolvedNames: resolveResult.resolvedNames,
    types: typecheckResult.types,
    typeVarBindings: typecheckResult.typeVarBindings,
    fileNodeIds: .{},
  }

  let buildIndex = !(opts and opts.buildIndex == false)
  if buildIndex {
    buildFileIndex(ctx)
  }

  .{ success: true, ctx: ctx }
}

fn queryHover(ctx, filename, line, col) {
  let n = nodeAtPos(ctx, filename, line, col)
  if n and n.type == "String" {
    let dotNode = findDotByPropertyNode(ctx, n)
    if dotNode {
      n = dotNode
    }
  }
  // If we landed on a Let node but the cursor is within the name span,
  // prefer the identifier (some resolvers omit name nodes from the index).
  if n and n.type == "Let" and n.name and contains(n.name, line, col) {
    n = n.name
  }
  if !n {
    return .{ success: false, kind: "hover", message: "No node at position" }
  }

  let ty = ctx.types[n.id]
  let contents = buildHoverContents(ctx, n, ty)

  let details = .{ nodeType: n.type, nodeId: n.id }

  if n.type == "Identifier" {
    let r = ctx.resolvedNames[n.id]
    if r {
      details.resolved = r
    }
  }

  .{
    success: true,
    kind: "hover",
    range: rangeOf(n),
    contents: contents,
    details: details,
  }
}

fn queryGotoDefinition(ctx, filename, line, col) {
  let n = nodeAtPos(ctx, filename, line, col)
  if !n {
    return .{ success: false, kind: "goto", message: "No node at position" }
  }

  if n.type == "String" {
    let dotNode = findDotByPropertyNode(ctx, n)
    let propName = propNameFromNode(n)
    if dotNode and propName {
      let record = resolveExprToRecord(ctx, dotNode.object, .{})
      if record {
        let field = findRecordField(record, propName)
        if field and field.key {
          return .{
            success: true,
            kind: "goto",
            target: rangeOf(field.key),
          }
        }
      }
    }
  }

  if n.type == "Dot" {
    let propName = propNameFromNode(n.property)
    if propName {
      let record = resolveExprToRecord(ctx, n.object, .{})
      if record {
        let field = findRecordField(record, propName)
        if field and field.key {
          return .{
            success: true,
            kind: "goto",
            target: rangeOf(field.key),
          }
        }
      }
    }
  }

  if n.type != "Identifier" {
    return .{ success: false, kind: "goto", message: "Not an identifier" }
  }

  let r = ctx.resolvedNames[n.id]
  if !r {
    return .{ success: false, kind: "goto", message: "Unresolved identifier" }
  }

  if r.kind == "builtin" {
    return .{ success: false, kind: "goto", message: "Builtin has no tracked definition" }
  }

  let declNodeId = r.declaredAt
  if !declNodeId {
    return .{ success: false, kind: "goto", message: "Missing declaredAt (compiler bug)" }
  }

  let targetNode = normalizeDeclTarget(ctx, declNodeId)
  if !targetNode {
    return .{ success: false, kind: "goto", message: "Declaration node missing (compiler bug)" }
  }

  .{
    success: true,
    kind: "goto",
    target: rangeOf(targetNode),
  }
}

// ========================================
// High-Level API
// ========================================

let Driver = import "src/driver.lx"

fn stringLess(a, b) {
  if !a and b { return true }
  if a and !b { return false }
  if !a and !b { return false }

  let alen = len(a)
  let blen = len(b)
  let n = alen < blen and alen or blen
  for let i = 0; i < n; i = i + 1 {
    let ca = ord(a[i])
    let cb = ord(b[i])
    if ca < cb { return true }
    if ca > cb { return false }
  }
  alen < blen
}

fn keyLess(a, b) {
  let ta = type(a)
  let tb = type(b)
  if ta == "Number" and tb == "Number" {
    return a < b
  }
  stringLess(str(a), str(b))
}

fn idMapGet(map, id) {
  if map[id] {
    return map[id]
  }
  let sid = str(id)
  if map[sid] {
    return map[sid]
  }
  nil
}

// Remap type vars and node ids for merged query context.
fn remapType(t, typeVarMap, nodeIdMap, nextTypeVarIdRef) {
  if !t {
    return nil
  }

  let out = .{}
  let ks = keys(t)
  for let i = 0; i < len(ks); i = i + 1 {
    let k = ks[i]
    out[k] = t[k]
  }

  if t.kind == "TypeVar" {
    let oldId = t.id
    let newId = idMapGet(typeVarMap, oldId)
    if !newId {
      newId = nextTypeVarIdRef.value
      nextTypeVarIdRef.value = newId + 1
      typeVarMap[oldId] = newId
      typeVarMap[str(oldId)] = newId
    }
    out.id = newId
    return out
  }

  if t.kind == "Function" {
    if t.params {
      let params = []
      for let i = 0; i < len(t.params); i = i + 1 {
        push(params, remapType(t.params[i], typeVarMap, nodeIdMap, nextTypeVarIdRef))
      }
      out.params = params
    }
    out.return = remapType(t.return, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Array" {
    out.elem = remapType(t.elem, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Map" {
    out.key = remapType(t.key, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    out.elem = remapType(t.elem, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Record" {
    let fields = .{}
    let fieldKeys = t.fields and keys(t.fields) or []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      fields[k] = remapType(t.fields[k], typeVarMap, nodeIdMap, nextTypeVarIdRef)
    }
    out.fields = fields
    return out
  }

  if t.kind == "Option" {
    out.value = remapType(t.value, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    return out
  }

  if t.kind == "Indexable" {
    out.elem = remapType(t.elem, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    out.key = remapType(t.key, typeVarMap, nodeIdMap, nextTypeVarIdRef)
    let oldNodeId = t.nodeId
    let newNodeId = idMapGet(nodeIdMap, oldNodeId)
    if newNodeId {
      out.nodeId = newNodeId
    }
    return out
  }

  out
}

// Compile file and create query context in one step
// This is the recommended API for IDE/LSP tooling
fn compile(filepath) {
  // Create driver that loads from filesystem
  let driver = Driver.make(.{
    loadSource: fn(path) { slurp(path) },
    withTypecheck: true,
  })

  // Compile module through full pipeline
  let result = driver.compileModule(filepath)

  // Check for compilation failure
  if result.status != "done" {
    let phase = "unknown"
    let errors = []

    if result.parseErrors {
      phase = "parse"
      errors = result.parseErrors
    } else if result.lowerErrors {
      phase = "lower"
      errors = result.lowerErrors
    } else if result.resolveResult and !result.resolveResult.success {
      phase = "resolve"
      errors = result.resolveResult.errors
    } else if result.typecheckResult and !result.typecheckResult.success {
      phase = "typecheck"
      errors = result.typecheckResult.errors
    }

    return .{
      success: false,
      phase: phase,
      errors: errors,
      compileResult: result,
    }
  }

  // Merge all compiled modules into a single query context with global IDs.
  let merged = .{
    ast: result.lowerResult and result.lowerResult.ast,
    nodes: .{},
    resolvedNames: .{},
    types: .{},
    typeVarBindings: .{},
    fileNodeIds: .{},
    moduleAsts: .{},
  }

  let nextNodeId = 1
  let nextTypeVarId = .{ value: 1 }
  let cacheKeys = keys(driver.cache)
  cacheKeys->sort(keyLess)
  for let i = 0; i < len(cacheKeys); i = i + 1 {
    let k = cacheKeys[i]
    let mod = driver.cache[k]
    if mod and mod.status == "done" and mod.resolveResult and mod.typecheckResult {
      if mod.lowerResult and mod.lowerResult.ast and mod.path {
        merged.moduleAsts[mod.path] = mod.lowerResult.ast
      }
      let moduleNodes = .{}
      let baseNodeKeys = keys(mod.resolveResult.nodes)
      for let j = 0; j < len(baseNodeKeys); j = j + 1 {
        let id = baseNodeKeys[j]
        moduleNodes[id] = mod.resolveResult.nodes[id]
      }
      if mod.lowerResult and mod.lowerResult.ast {
        collectAllNodes(mod.lowerResult.ast, moduleNodes)
      }

      let nodeIdMap = .{}
      let nodeKeys = keys(moduleNodes)
      nodeKeys->sort(keyLess)

      for let j = 0; j < len(nodeKeys); j = j + 1 {
        let oldId = nodeKeys[j]
        nodeIdMap[oldId] = nextNodeId
        nodeIdMap[str(oldId)] = nextNodeId
        nextNodeId = nextNodeId + 1
      }

      // Remap and merge nodes
      for let j = 0; j < len(nodeKeys); j = j + 1 {
        let oldId = nodeKeys[j]
        let node = moduleNodes[oldId]
        if node {
          let newId = idMapGet(nodeIdMap, oldId)
          node.id = newId
          merged.nodes[newId] = node
        }
      }

      // Remap and merge resolved names
      let resKeys = keys(mod.resolveResult.resolvedNames)
      resKeys->sort(keyLess)
      for let j = 0; j < len(resKeys); j = j + 1 {
        let oldId = resKeys[j]
        let r = mod.resolveResult.resolvedNames[oldId]
        if r {
          let newId = idMapGet(nodeIdMap, oldId)
          let r2 = .{}
          let rks = keys(r)
          for let k = 0; k < len(rks); k = k + 1 {
            let rk = rks[k]
            r2[rk] = r[rk]
          }
          if r2.declaredAt {
            let newDecl = idMapGet(nodeIdMap, r2.declaredAt)
            if newDecl {
              r2.declaredAt = newDecl
            }
          }
          merged.resolvedNames[newId] = r2
        }
      }

      // Remap and merge types + bindings
      let typeVarMap = .{}
      let typeKeys = keys(mod.typecheckResult.types)
      typeKeys->sort(keyLess)
      for let j = 0; j < len(typeKeys); j = j + 1 {
        let oldId = typeKeys[j]
        let newId = idMapGet(nodeIdMap, oldId)
        if newId {
          merged.types[newId] = remapType(
            mod.typecheckResult.types[oldId],
            typeVarMap,
            nodeIdMap,
            nextTypeVarId
          )
        }
      }

      let bindKeys = keys(mod.typecheckResult.typeVarBindings)
      bindKeys->sort(keyLess)
      for let j = 0; j < len(bindKeys); j = j + 1 {
        let oldTid = bindKeys[j]
        let newTid = idMapGet(typeVarMap, oldTid)
        if !newTid {
          newTid = nextTypeVarId.value
          nextTypeVarId.value = newTid + 1
          typeVarMap[oldTid] = newTid
          typeVarMap[str(oldTid)] = newTid
        }
        merged.typeVarBindings[newTid] = remapType(
          mod.typecheckResult.typeVarBindings[oldTid],
          typeVarMap,
          nodeIdMap,
          nextTypeVarId
        )
      }
    }
  }

  buildFileIndex(merged)

  // Return query context ready to use
  .{
    success: true,
    ctx: merged,
    compileResult: result,
  }
}

// ========================================
// Module Exports
// ========================================

.{
  // High-level API (recommended)
  compile: compile,

  // Low-level API (for advanced use cases)
  queryInit: queryInit,
  queryHover: queryHover,
  queryGotoDefinition: queryGotoDefinition,
}
