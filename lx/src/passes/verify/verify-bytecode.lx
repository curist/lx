// Bytecode Stack-Height Verifier
//
// Validates bytecode for VALUE STACK discipline:
// - No underflow (both delta-based and minimum-height checking)
// - Control-flow joins have consistent stack heights
// - OP_RETURN has expected height relative to frame baseline
//
// This runs as a dataflow analysis over instruction addresses.
//
// Contract Model: SINGLE-STACK (unified value stack)
// - All values (locals, temporaries, args) live on the value stack
// - Module entry: height=0
// - Function entry: height=1+arity (closure+args on value stack)
// - GET_LOCAL: effect=+1 (pushes copy of slot value to stack top)
//              → Future: varies (DUP or stack-relative access)
// - SET_LOCAL: effect=-1 (consumes value, updates local)
//              → Future: effect=0 (updates stack slot in-place)

let .{ OP } = import "src/types.lx"

// ========================================
// Stack Effect Tables
// ========================================

// Minimum required stack height before executing each opcode
// This catches underflow bugs that delta-only checking misses
// Example: binary op with inHeight=1 has effect=-1, outHeight=0 (not negative!)
//          but it needs 2 inputs, so it should fail
let STACK_MIN = .{
  // Need 0 inputs (push/create operations)
  [OP.NIL]:           0,
  [OP.TRUE]:          0,
  [OP.FALSE]:         0,
  [OP.CONSTANT]:      0,
  [OP.CONSTANT_LONG]: 0,
  [OP.CONST_BYTE]:    0,
  [OP.GET_LOCAL]:     0,
  [OP.GET_GLOBAL]:    0,
  [OP.GET_GLOBAL_LONG]: 0,
  [OP.GET_UPVALUE]:   0,
  [OP.GET_UPVALUE_LONG]: 0,
  [OP.HASHMAP]:       0,
  [OP.ENUM]:          0,
  [OP.ARRAY]:         0,
  [OP.CLOSURE]:       0,
  [OP.CLOSURE_LONG]:  0,
  [OP.JUMP]:          0,
  [OP.LOOP]:          0,
  [OP.NOP]:           0,

  // Need 1 input
  [OP.POP]:           1,
  [OP.NOT]:           1,
  [OP.NEGATE]:        1,
  [OP.NEGATE_INT]:    1,
  [OP.LENGTH]:        1,
  [OP.SET_LOCAL]:     1,  // Needs value to store
  [OP.SET_GLOBAL]:    1,
  [OP.SET_GLOBAL_LONG]: 1,
  [OP.SET_UPVALUE]:   1,
  [OP.SET_UPVALUE_LONG]: 1,
  [OP.DEFINE_GLOBAL]: 1,
  [OP.DEFINE_GLOBAL_LONG]: 1,
  [OP.DUP]:           1,
  [OP.JUMP_IF_TRUE]:  1,
  [OP.JUMP_IF_FALSE]: 1,
  [OP.RETURN]:        1,
  [OP.COALESCE_CONST]: 1,  // Needs value to check
  [OP.COALESCE_CONST_LONG]: 1,
  [OP.MOD_CONST_BYTE]: 1,  // Needs value to mod
  [OP.EQ_CONST_BYTE]:  1,  // Needs value to compare

  // Need 0 inputs
  [OP.CLOSE_UPVALUE]: 0,  // Closes upvalue + pops from value stack

  // Need 2 inputs
  [OP.EQUAL]:         2,
  [OP.GREATER]:       2,
  [OP.LESS]:          2,
  [OP.ADD]:           2,
  [OP.ADD_INT]:       2,
  [OP.ADD_NUM]:       2,
  [OP.ADD_STR]:       2,
  [OP.SUBTRACT]:      2,
  [OP.SUBTRACT_INT]:  2,
  [OP.MULTIPLY]:      2,
  [OP.MULTIPLY_INT]:  2,
  [OP.DIVIDE]:        2,
  [OP.MOD]:           2,
  [OP.BIT_AND]:       2,
  [OP.BIT_OR]:        2,
  [OP.BIT_XOR]:       2,
  [OP.BIT_LSHIFT]:    2,
  [OP.BIT_RSHIFT]:    2,
  [OP.GET_BY_INDEX]:  2,
  [OP.APPEND]:        2,

  // GET/SET_BY_CONST: key from constant pool
  [OP.GET_BY_CONST]:      1,  // pop object, push result
  [OP.GET_BY_CONST_LONG]: 1,
  [OP.SET_BY_CONST]:      2,  // pop object and value, push result
  [OP.SET_BY_CONST_LONG]: 2,

  // Need 3 inputs
  [OP.SET_BY_INDEX]:  3,
  [OP.ASSOC]:         3,

  // CALL is dynamic: needs argCount + 1 (callee + args)
  // Handled specially in processInstruction
  // CALL_LOCAL / CALL_SELF are dynamic: need argCount (args only)
  // Handled specially in processInstruction

  // UNWIND is dynamic: needs count values
  // Handled specially in processInstruction

  // Superinstructions (misc)
  [OP.INC_L]:              0,  // local[a] += imm: reads from local slot
  [OP.STORE_LOCAL]:        1,  // SET_LOCAL + POP: needs value to store
  [OP.GETI]:  0,    // GET_LOCAL×2 + GET_BY_INDEX: reads all from local slots
  [OP.SETI]:  0,    // GET_LOCAL×3 + SET_BY_INDEX: reads all from local slots

  // Arithmetic superinstructions - statement form
  [OP.ADD_LL_SET]: 0,  // local[d] = local[a] + local[b]: reads all from local slots
  [OP.SUB_LL_SET]: 0,  // local[d] = local[a] - local[b]: reads all from local slots
  [OP.MUL_LL_SET]: 0,  // local[d] = local[a] * local[b]: reads all from local slots
  [OP.DIV_LL_SET]: 0,  // local[d] = local[a] / local[b]: reads all from local slots

  // Arithmetic superinstructions - expression form with two locals
  [OP.ADD_LL]: 0,  // push(local[a] + local[b]): reads from local slots
  [OP.SUB_LL]: 0,  // push(local[a] - local[b]): reads from local slots
  [OP.MUL_LL]: 0,  // push(local[a] * local[b]): reads from local slots
  [OP.DIV_LL]: 0,  // push(local[a] / local[b]): reads from local slots

  // Arithmetic superinstructions - expression form with constant
  [OP.ADD_LK]: 0,  // push(local[a] + k): reads from local slot
  [OP.SUB_LK]: 0,  // push(local[a] - k): reads from local slot
  [OP.MUL_LK]: 0,  // push(local[a] * k): reads from local slot
  [OP.DIV_LK]: 0,  // push(local[a] / k): reads from local slot
  [OP.CMP_LK]: 0,  // push(local[a] cmp k): reads from local slot
  [OP.GET_PROPERTY]:  0,    // GET_LOCAL + CONSTANT + GET_BY_INDEX: reads from local slot
  [OP.SET_PROPERTY]:  0,    // GET_LOCAL + CONSTANT + GET_LOCAL + SET_BY_INDEX: reads from local slots

  // Fused numeric for loops
  [OP.FORPREP_1]:          0,  // Operates on locals only
  [OP.FORLOOP_1]:          0,  // Operates on locals only
  [OP.FORPREP]:            0,  // Operates on locals only
  [OP.FORLOOP]:            0,  // Operates on locals only

  // Dynamic calls (handled specially)
  [OP.CALL_LOCAL]:         0,
  [OP.CALL_SELF]:          0,
}

// Static table of stack effects for each opcode
// Special cases (CALL, RETURN) handled in stackEffect()
let STACK_EFFECTS = .{
  // Push 1 value (+1)
  [OP.CONSTANT]:      1,
  [OP.CONSTANT_LONG]: 1,
  [OP.CONST_BYTE]:    1,
  [OP.NIL]:           1,
  [OP.TRUE]:          1,
  [OP.FALSE]:         1,
  [OP.GET_LOCAL]:     1,
  [OP.GET_GLOBAL]:    1,
  [OP.GET_GLOBAL_LONG]: 1,
  [OP.GET_UPVALUE]:   1,
  [OP.GET_UPVALUE_LONG]: 1,
  [OP.HASHMAP]:       1,
  [OP.ENUM]:          1,
  [OP.ARRAY]:         1,
  [OP.DUP]:           1,
  [OP.CLOSURE]:       1,
  [OP.CLOSURE_LONG]:  1,

  // Pop 1 value (-1)
  [OP.POP]:           -1,

  // Neutral (0): peek value, perform operation, leave on stack
  [OP.NOT]:           0,   // pop 1, push 1 (bool)
  [OP.NEGATE]:        0,   // pop 1, push 1 (number)
  [OP.NEGATE_INT]:    0,   // pop 1, push 1 (number)
  [OP.LENGTH]:        0,
  [OP.SET_LOCAL]:     0,   // Current: peek value, update local, leave on stack (followed by POP)
                            // Future single-stack: will be 0 (updates in-place)
  [OP.SET_GLOBAL]:    0,   // Peek value, set global, leave on stack
  [OP.SET_GLOBAL_LONG]: 0,
  [OP.SET_UPVALUE]:   0,   // Peek value, set upvalue, leave on stack
  [OP.SET_UPVALUE_LONG]: 0,
  [OP.DEFINE_GLOBAL]: 0,   // Peek value, define global, leave on stack
  [OP.DEFINE_GLOBAL_LONG]: 0,
  [OP.NOP]:           0,
  [OP.CLOSE_UPVALUE]: 0,   // Closes upvalue + pops from value stack
  [OP.COALESCE_CONST]: 0,  // Conditionally replaces TOS, always leaves 1 value
  [OP.COALESCE_CONST_LONG]: 0,
  [OP.MOD_CONST_BYTE]: 0,  // pop 1 (value), push 1 (result)
  [OP.EQ_CONST_BYTE]:  0,  // pop 1 (value), push 1 (bool)

  // Binary operations (-1): pop 2, push 1
  [OP.EQUAL]:         -1,
  [OP.GREATER]:       -1,
  [OP.LESS]:          -1,
  [OP.ADD]:           -1,
  [OP.ADD_INT]:       -1,
  [OP.ADD_NUM]:       -1,
  [OP.ADD_STR]:       -1,
  [OP.SUBTRACT]:      -1,
  [OP.SUBTRACT_INT]:  -1,
  [OP.MULTIPLY]:      -1,
  [OP.MULTIPLY_INT]:  -1,
  [OP.DIVIDE]:        -1,
  [OP.MOD]:           -1,
  [OP.BIT_AND]:       -1,
  [OP.BIT_OR]:        -1,
  [OP.BIT_XOR]:       -1,
  [OP.BIT_LSHIFT]:    -1,
  [OP.BIT_RSHIFT]:    -1,
  [OP.GET_BY_INDEX]:  -1,  // pop 2, push 1
  [OP.APPEND]:        -1,  // consumes value, keeps array

  // GET/SET_BY_CONST: key from constant pool
  [OP.GET_BY_CONST]:      0,   // pop 1 (object), push 1 (result)
  [OP.GET_BY_CONST_LONG]: 0,
  [OP.SET_BY_CONST]:     -1,   // pop 2 (object, value), push 1 (result)
  [OP.SET_BY_CONST_LONG]: -1,

  // Pop 3, push 1 (-2)
  [OP.SET_BY_INDEX]:  -2,
  [OP.ASSOC]:         -2,

  // Control flow (0)
  [OP.JUMP]:          0,
  [OP.LOOP]:          0,

  // Conditional jumps (-1): consume condition
  [OP.JUMP_IF_TRUE]:  -1,
  [OP.JUMP_IF_FALSE]: -1,

  // Superinstructions (misc)
  [OP.INC_L]:              0,   // local[a] += imm (statement-only, no value on stack)
  [OP.STORE_LOCAL]:       -1,   // SET_LOCAL + POP: net -1
  [OP.GETI]:  1,     // GET_LOCAL×2 + GET_BY_INDEX: net +1 (2 pushes, GET_BY_INDEX is -1)
  [OP.SETI]:  0,     // arr[idx] = val (statement-only, no value on stack)

  // Arithmetic superinstructions - statement form
  [OP.ADD_LL_SET]: 0,     // local[d] = local[a] + local[b] (statement-only)
  [OP.SUB_LL_SET]: 0,     // local[d] = local[a] - local[b] (statement-only)
  [OP.MUL_LL_SET]: 0,     // local[d] = local[a] * local[b] (statement-only)
  [OP.DIV_LL_SET]: 0,     // local[d] = local[a] / local[b] (statement-only)

  // Arithmetic superinstructions - expression form with two locals
  [OP.ADD_LL]:  1,     // push(local[a] + local[b]): net +1
  [OP.SUB_LL]:  1,     // push(local[a] - local[b]): net +1
  [OP.MUL_LL]:  1,     // push(local[a] * local[b]): net +1
  [OP.DIV_LL]:  1,     // push(local[a] / local[b]): net +1

  // Arithmetic superinstructions - expression form with constant
  [OP.ADD_LK]:  1,     // push(local[a] + k): net +1
  [OP.SUB_LK]:  1,     // push(local[a] - k): net +1
  [OP.MUL_LK]:  1,     // push(local[a] * k): net +1
  [OP.DIV_LK]:  1,     // push(local[a] / k): net +1
  [OP.CMP_LK]:  1,     // push(local[a] cmp k): net +1
  [OP.GET_PROPERTY]:  1,     // GET_LOCAL + CONSTANT + GET_BY_INDEX: net +1
  [OP.SET_PROPERTY]:  0,     // obj.field = val or obj[const] = val (statement-only, no value on stack)

  // Fused numeric for loops (stack-neutral, operate on locals)
  [OP.FORPREP_1]:          0,
  [OP.FORLOOP_1]:          0,
  [OP.FORPREP]:            0,
  [OP.FORLOOP]:            0,

  // RETURN (0): special handling in stackEffect()
  [OP.RETURN]:        0,

  // UNWIND: special handling in stackEffect()
}

// Static table of instruction lengths
// Special case: CLOSURE handled in instructionLength()
let INSTRUCTION_LENGTHS = .{
  // 1-byte operand (length = 2)
  [OP.CONSTANT]:      2,
  [OP.CONST_BYTE]:    2,
  [OP.GET_LOCAL]:     2,
  [OP.SET_LOCAL]:     2,
  [OP.GET_GLOBAL]:    2,
  [OP.DEFINE_GLOBAL]: 2,
  [OP.SET_GLOBAL]:    2,
  [OP.GET_UPVALUE]:   2,
  [OP.SET_UPVALUE]:   2,
  [OP.CALL]:          2,
  [OP.CALL_SELF]:     2,
  [OP.COALESCE_CONST]: 2,  // opcode + constant index

  // 2-byte operand (length = 3)
  [OP.CONSTANT_LONG]: 3,
  [OP.GET_GLOBAL_LONG]: 3,
  [OP.DEFINE_GLOBAL_LONG]: 3,
  [OP.SET_GLOBAL_LONG]: 3,
  [OP.GET_UPVALUE_LONG]: 3,
  [OP.SET_UPVALUE_LONG]: 3,
  [OP.COALESCE_CONST_LONG]: 3,
  [OP.JUMP]:          3,
  [OP.JUMP_IF_TRUE]:  3,
  [OP.JUMP_IF_FALSE]: 3,
  [OP.LOOP]:          3,

  // No operand (length = 1)
  [OP.NOP]:           1,
  [OP.NIL]:           1,
  [OP.TRUE]:          1,
  [OP.FALSE]:         1,
  [OP.EQUAL]:         1,
  [OP.POP]:           1,
  [OP.DUP]:           1,
  [OP.GET_BY_INDEX]:  1,
  [OP.SET_BY_INDEX]:  1,
  [OP.GET_BY_CONST]:  2,  // opcode + 1-byte constIdx
  [OP.GET_BY_CONST_LONG]: 3,  // opcode + 2-byte constIdx
  [OP.SET_BY_CONST]:  2,  // opcode + 1-byte constIdx
  [OP.SET_BY_CONST_LONG]: 3,  // opcode + 2-byte constIdx
  [OP.GREATER]:       1,
  [OP.LESS]:          1,
  [OP.ADD]:           1,
  [OP.SUBTRACT]:      1,
  [OP.MULTIPLY]:      1,
  [OP.DIVIDE]:        1,
  [OP.NOT]:           1,
  [OP.MOD]:           1,
  [OP.NEGATE]:        1,
  [OP.BIT_AND]:       1,
  [OP.BIT_OR]:        1,
  [OP.BIT_XOR]:       1,
  [OP.BIT_LSHIFT]:    1,
  [OP.BIT_RSHIFT]:    1,
  [OP.ASSOC]:         1,
  [OP.APPEND]:        1,
  [OP.HASHMAP]:       1,
  [OP.ENUM]:          1,
  [OP.ARRAY]:         1,
  [OP.LENGTH]:        1,
  [OP.CLOSE_UPVALUE]: 1,
  [OP.CALL_LOCAL]:    3,  // opcode + slot + argc
  [OP.UNWIND]:        3,  // opcode + count + keep
  [OP.RETURN]:        1,
  [OP.MOD_CONST_BYTE]: 2,  // opcode + imm8
  [OP.EQ_CONST_BYTE]:  2,  // opcode + imm8
  [OP.ADD_INT]:       1,  // No operands
  [OP.ADD_NUM]:       1,  // No operands
  [OP.ADD_STR]:       1,  // No operands
  [OP.SUBTRACT_INT]:  1,  // No operands
  [OP.MULTIPLY_INT]:  1,  // No operands
  [OP.NEGATE_INT]:    1,  // No operands

  // Superinstructions (misc)
  [OP.INC_L]:              3,  // opcode + slot + imm
  [OP.STORE_LOCAL]:        2,  // opcode + slot
  [OP.GETI]:    3,  // opcode + arr_slot + idx_slot
  [OP.SETI]:    4,  // opcode + arr_slot + idx_slot + val_slot

  // Arithmetic superinstructions - statement form
  [OP.ADD_LL_SET]: 4,  // opcode + dest_slot + lhs_slot + rhs_slot
  [OP.SUB_LL_SET]: 4,  // opcode + dest_slot + lhs_slot + rhs_slot
  [OP.MUL_LL_SET]: 4,  // opcode + dest_slot + lhs_slot + rhs_slot
  [OP.DIV_LL_SET]: 4,  // opcode + dest_slot + lhs_slot + rhs_slot

  // Arithmetic superinstructions - expression form with two locals
  [OP.ADD_LL]:    3,  // opcode + lhs_slot + rhs_slot
  [OP.SUB_LL]:    3,  // opcode + lhs_slot + rhs_slot
  [OP.MUL_LL]:    3,  // opcode + lhs_slot + rhs_slot
  [OP.DIV_LL]:    3,  // opcode + lhs_slot + rhs_slot

  // Arithmetic superinstructions - expression form with constant
  [OP.ADD_LK]:    3,  // opcode + slot + k
  [OP.SUB_LK]:    3,  // opcode + slot + k
  [OP.MUL_LK]:    3,  // opcode + slot + k
  [OP.DIV_LK]:    3,  // opcode + slot + k
  [OP.CMP_LK]:    4,  // opcode + slot + k + cmp_kind
  [OP.GET_PROPERTY]:  3,  // opcode + obj_slot + const_idx
  [OP.SET_PROPERTY]:  4,  // opcode + obj_slot + const_idx + val_slot

  // Fused numeric for loops
  [OP.FORPREP_1]:          6,  // opcode + i_slot + limit_slot + cmp_kind + offset[2]
  [OP.FORLOOP_1]:          6,  // opcode + i_slot + limit_slot + cmp_kind + offset[2]
  [OP.FORPREP]:            7,  // opcode + i_slot + limit_slot + cmp_kind + step + offset[2]
  [OP.FORLOOP]:            7,  // opcode + i_slot + limit_slot + cmp_kind + step + offset[2]
}

fn stackEffect(opcode, operand, operand2) {
  // Returns: stack delta for this instruction
  // operand: used for CALL/CALL_LOCAL/CALL_SELF (argCount) and UNWIND (count)
  // operand2: used for UNWIND (keep)
  // Returns: nil if opcode is unknown (caller must handle error)

  // Special case: CALL has dynamic effect based on argCount
  // pop (argCount + 1), push 1 → net effect: -argCount
  if opcode == OP.CALL {
    return 0 - operand
  }

  // Special case: CALL_LOCAL/CALL_SELF have dynamic effect based on argCount
  // pop (argCount), push 1 → net effect: 1 - argCount
  if opcode == OP.CALL_LOCAL or opcode == OP.CALL_SELF {
    return 1 - operand
  }

  // Special case: UNWIND has dynamic effect based on count and keep
  // keep=0: pop count → Δ = -count
  // keep=1: preserve top, pop count under it → Δ = -count
  if opcode == OP.UNWIND {
    return 0 - operand
  }

  // Lookup in table
  return STACK_EFFECTS[opcode]
}

// ========================================
// Operand Decoding
// ========================================

fn readByte(code, ip) {
  // Bytecode now stored as numbers, not hex strings
  return code[ip]
}

fn readShort(code, ip) {
  // Assumes bounds already checked by caller
  let high = readByte(code, ip)
  let low = readByte(code, ip + 1)
  return (high * 256) + low
}

fn safeReadByte(code, ip, verifier, errorIp) {
  // Returns: byte value or nil if out of bounds
  if ip < 0 or ip >= len(code) {
    addError(verifier, errorIp, "[verify-bytecode] Operand read out of bounds: ip=" + str(ip) + ", code length=" + str(len(code)))
    return nil
  }
  return readByte(code, ip)
}

fn safeReadShort(code, ip, verifier, errorIp) {
  // Returns: short value or nil if out of bounds
  if ip + 1 < 0 or ip + 1 >= len(code) {
    addError(verifier, errorIp, "[verify-bytecode] Operand read out of bounds: ip=" + str(ip) + ", code length=" + str(len(code)))
    return nil
  }
  return readShort(code, ip)
}

fn instructionLength(chunk, ip) {
  // Returns: number of bytes this instruction occupies
  // Returns: nil if opcode is unknown, CLOSURE decode fails, or out of bounds
  let code = chunk.bytecode
  let opcode = readByte(code, ip)  // Convert hex string to number

  // Special case: CLOSURE has variable length
  // Format: OP_CLOSURE + constant_idx + (upvalueCount * 2 bytes)
  if opcode == OP.CLOSURE {
    // Bounds check before reading operand
    if ip + 1 >= len(code) {
      return nil  // Out of bounds
    }
    let constantIdx = readByte(code, ip + 1)
    let constant = chunk.constants[constantIdx]
    if !constant or !constant.value or !constant.value.value {
      return nil  // Failed to unwrap constant Value -> Object -> Function
    }
    // Unwrap: Value.value -> Object, Object.value -> Function
    let upvalueCount = constant.value.value.upvalueCount or 0
    let totalLen = 2 + (upvalueCount * 2)
    // Verify the full instruction fits in bytecode
    if ip + totalLen > len(code) {
      return nil  // Instruction extends past end of code
    }
    return totalLen
  }

  if opcode == OP.CLOSURE_LONG {
    // Bounds check before reading 2-byte operand
    if ip + 2 >= len(code) {
      return nil  // Out of bounds
    }
    // 2-byte constant index (big-endian)
    let constIdxHigh = readByte(code, ip + 1)
    let constIdxLow = readByte(code, ip + 2)
    let constantIdx = (constIdxHigh << 8) + constIdxLow
    let constant = chunk.constants[constantIdx]
    if !constant or !constant.value or !constant.value.value {
      return nil  // Failed to unwrap constant Value -> Object -> Function
    }
    // Unwrap: Value.value -> Object, Object.value -> Function
    let upvalueCount = constant.value.value.upvalueCount or 0
    let totalLen = 3 + (upvalueCount * 2)  // opcode + 2-byte index + upvalue data
    // Verify the full instruction fits in bytecode
    if ip + totalLen > len(code) {
      return nil  // Instruction extends past end of code
    }
    return totalLen
  }

  // Lookup in table
  return INSTRUCTION_LENGTHS[opcode]
}

// ========================================
// Verifier State
// ========================================

fn makeVerifier(fnObj) {
  // Determine initial stack height based on function type
  // Module (name == ""): starts at 0 (no closure on stack)
  // Regular function: starts at 1 + arity (closure + args on stack)
  let isModule = fnObj.name == ""
  let initialHeight = isModule and 0 or (1 + fnObj.arity)

  .{
    fnObj: fnObj,
    chunk: fnObj.chunk,
    arity: fnObj.arity,

    // heightAt[ip] = stack height upon entry to instruction at ip
    heightAt: .{},

    // Worklist of IPs to process
    worklist: [],

    // Errors
    errors: [],
    hadError: false,

    // Initial height: single-stack model baseline
    initialHeight: initialHeight,
  }
}

fn addError(verifier, ip, message) {
  // Look up nodeId from chunk.nodeIds array
  let nodeIds = verifier.chunk.nodeIds
  let nodeId = (nodeIds and ip >= 0 and ip < len(nodeIds)) and nodeIds[ip] or 0

  push(verifier.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
  verifier.hadError = true
}

// ========================================
// Dataflow Propagation
// ========================================

fn propagateHeight(verifier, ip, height) {
  // Propagate height to instruction at ip
  // Returns: true if this is new information

  // Bounds check
  let codeLen = len(verifier.chunk.bytecode)
  if ip < 0 or ip >= codeLen {
    addError(verifier, ip, "[verify-bytecode] Jump target out of bounds: " + str(ip) + " (code length: " + str(codeLen) + ")")
    return false
  }

  let existing = verifier.heightAt[str(ip)]

  if existing or existing == 0 {
    // Already visited this IP
    if existing != height {
      addError(verifier, ip,
        "[verify-bytecode] Inconsistent stack height at join: expected " + str(existing) +
        " but reached with " + str(height))
      return false
    }
    return false  // No new information
  }

  // New IP - record height and add to worklist
  verifier.heightAt[str(ip)] = height
  push(verifier.worklist, ip)
  return true
}

fn processInstruction(verifier, ip) {
  let code = verifier.chunk.bytecode
  let inHeight = verifier.heightAt[str(ip)]
  let opcode = readByte(code, ip)  // Convert hex string to number

  // Get operand for dynamic opcodes (with bounds checking)
  let operand = 0
  let operand2 = 0
  if opcode == OP.CALL {
    operand = safeReadByte(code, ip + 1, verifier, ip)
    if !operand and operand != 0 {
      return nil  // Out of bounds (safeReadByte returns nil on error)
    }
  }
  if opcode == OP.CALL_LOCAL {
    let slot = safeReadByte(code, ip + 1, verifier, ip)
    if !slot and slot != 0 {
      return nil
    }
    operand = safeReadByte(code, ip + 2, verifier, ip)  // argc
    if !operand and operand != 0 {
      return nil
    }
  }
  if opcode == OP.CALL_SELF {
    operand = safeReadByte(code, ip + 1, verifier, ip)  // argc
    if !operand and operand != 0 {
      return nil
    }
  }
  if opcode == OP.UNWIND {
    operand = safeReadByte(code, ip + 1, verifier, ip)  // count
    if !operand and operand != 0 {
      return nil  // Out of bounds
    }
    operand2 = safeReadByte(code, ip + 2, verifier, ip)  // keep
    if !operand2 and operand2 != 0 {
      return nil  // Out of bounds
    }
  }

  // Check minimum required stack height BEFORE execution
  // This catches underflow bugs that delta-only checking misses
  let minRequired = STACK_MIN[opcode]
  if opcode == OP.CALL {
    minRequired = operand + 1  // callee + args
  }
  if opcode == OP.CALL_LOCAL or opcode == OP.CALL_SELF {
    minRequired = operand  // args only
  }
  if opcode == OP.UNWIND {
    // keep=0: needs count values
    // keep=1: needs count+1 values (kept value + count to discard)
    if operand2 == 0 {
      minRequired = operand
    } else {
      minRequired = operand + 1
    }
  }
  let opName = nameOf(OP, opcode) or ("UNKNOWN(" + str(opcode) + ")")

  if !minRequired {
    // minRequired is nil or false (unknown opcode)
    // Note: 0 is truthy in lx, so this doesn't trigger for opcodes that need 0 inputs
    addError(verifier, ip, "[verify-bytecode] Unknown opcode: " + opName)
    return nil  // Fatal
  }
  if inHeight < minRequired {
    addError(verifier, ip,
      "[verify-bytecode] Insufficient stack for " + opName + ": " +
      "height=" + str(inHeight) + ", required=" + str(minRequired))
    return nil
  }

  // Get stack effect - fatal error if unknown
  let effect = stackEffect(opcode, operand, operand2)
  if !effect and effect != 0 {
    // effect is nil or false (unknown opcode)
    // Note: 0 is truthy in lx, so we need to check != 0 for neutral opcodes
    addError(verifier, ip, "[verify-bytecode] Unknown opcode: " + opName)
    return nil  // Fatal - stop processing this path
  }

  let outHeight = inHeight + effect

  // Note: outHeight < 0 check is now redundant (minRequired + effect >= 0 by design)
  // but keep it as a sanity check
  if outHeight < 0 {
    addError(verifier, ip, "[verify-bytecode] Stack underflow: height would be " + str(outHeight))
    return nil
  }

  // Special handling for RETURN
  if opcode == OP.RETURN {
    // Current dual-stack: expect height >= base (value stack may be empty)
    // Future single-stack: will require height >= base + 1 (must have return value)
    let base = verifier.initialHeight
    if inHeight < base {
      addError(verifier, ip,
        "[verify-bytecode] OP_RETURN with insufficient stack: " + str(inHeight) +
        " (expected >= " + str(base) + ")")
    }
    return nil  // Terminal instruction
  }

  // Propagate to successors
  let instrLen = instructionLength(verifier.chunk, ip)
  if !instrLen {
    addError(verifier, ip, "[verify-bytecode] Failed to decode instruction length for " + opName)
    return nil  // Fatal
  }
  let nextIp = ip + instrLen

  // Jump targets (handle explicitly to avoid redundant propagation)
  if opcode == OP.JUMP {
    let offset = safeReadShort(code, ip + 1, verifier, ip)
    if !offset {
      return nil  // Out of bounds (safeReadShort returns nil on error)
    }
    let target = nextIp + offset
    propagateHeight(verifier, target, outHeight)
  } else if opcode == OP.JUMP_IF_TRUE or opcode == OP.JUMP_IF_FALSE {
    let offset = safeReadShort(code, ip + 1, verifier, ip)
    if !offset {
      return nil  // Out of bounds
    }
    let target = nextIp + offset
    // Both branches get the same height (after consuming condition)
    propagateHeight(verifier, target, outHeight)
    propagateHeight(verifier, nextIp, outHeight)
  } else if opcode == OP.LOOP {
    let offset = safeReadShort(code, ip + 1, verifier, ip)
    if !offset {
      return nil  // Out of bounds
    }
    let target = nextIp - offset
    propagateHeight(verifier, target, outHeight)
    // LOOP falls through to next instruction
    propagateHeight(verifier, nextIp, outHeight)
  } else if opcode != OP.RETURN {
    // Fallthrough for all other non-terminal instructions
    propagateHeight(verifier, nextIp, outHeight)
  }
}

// ========================================
// Main Verification
// ========================================

fn verifyFunction(fnObj) {
  let verifier = makeVerifier(fnObj)

  // Initialize entry point
  propagateHeight(verifier, 0, verifier.initialHeight)

  // Worklist algorithm (simple queue)
  let worklistHead = 0
  for worklistHead < len(verifier.worklist) {
    let ip = verifier.worklist[worklistHead]
    worklistHead = worklistHead + 1

    processInstruction(verifier, ip)
  }

  // Return result object
  return .{
    success: !verifier.hadError,
    errors: verifier.errors,
  }
}

// ========================================
// Export
// ========================================

.{
  verifyFunction: verifyFunction,
  stackEffect: stackEffect,  // For testing
  instructionLength: instructionLength,  // For peephole pass
}
