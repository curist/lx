// Driver - Orchestrates compilation pipeline (passes): parse → lower → anf → resolve → anf-inline → typecheck
//
// Responsibilities:
// - Coordinate pass execution
// - Manage import cache for multi-file compilation
// - Handle circular import detection
// - Provide compilation artifacts for query service and codegen
// - ANF runs after lower (optional, default on)
// - ANF inline runs post-resolve (optional, default on)

let parse = import "src/passes/frontend/parser.lx"
let lower = import "src/passes/frontend/lower.lx"
let anf = import "src/passes/frontend/anf.lx"
let anfInline = import "src/passes/frontend/anf-inline.lx"
let resolve = import "src/passes/frontend/resolve.lx"
let typecheck = import "src/passes/frontend/typecheck.lx"
let pipeline = import "src/passes/pipeline.lx"
let types = import "src/types.lx"

let NODE = types.NODE

// ========================================
// Profile Definitions
// ========================================

fn getProfile(name) {
  // Returns .{ withLower, withAnf, withAnfInline, withTypecheck } for the given profile
  // Profiles define curated pass combinations for specific use cases

  if name == "default" {
    // Current compiler semantics: all passes enabled
    // parse → lower → anf → resolve → anf-inline → typecheck (non-fatal)
    return .{
      withLower: true,
      withAnf: true,
      withAnfInline: true,
      withTypecheck: true,
    }
  }

  if name == "tooling" {
    // Best AST/tables for IDE/LSP
    // Same as default: parse → lower → anf → resolve → anf-inline → typecheck (non-fatal)
    return .{
      withLower: true,
      withAnf: true,
      withAnfInline: true,
      withTypecheck: true,
    }
  }

  if name == "O0" {
    // No optimizations, but keep passes that establish correctness invariants
    // parse → lower → anf → resolve → typecheck (non-fatal)
    // Skip anf-inline optimization
    return .{
      withLower: true,
      withAnf: true,
      withAnfInline: false,
      withTypecheck: true,
    }
  }

  if name == "query" {
    // Fast, tooling-oriented pipeline for IDE queries that don't require type inference:
    // parse → lower → resolve
    // (Query service prefers non-ANF AST so imports/structure stay intact.)
    return .{
      withLower: true,
      withAnf: false,
      withAnfInline: false,
      withTypecheck: false,
    }
  }

  if name == "resolve" {
    // Fastest name-resolution pipeline for IDE queries:
    // parse → resolve
    // Skips lowering/ANF/typecheck entirely.
    return .{
      withLower: false,
      withAnf: false,
      withAnfInline: false,
      withTypecheck: false,
    }
  }

  // Unknown profile - return nil to signal error
  nil
}

// ========================================
// Build Pass List
// ========================================

fn buildPassList(ctx) {
  // Build the list of passes with their adapters
  // ctx contains: importCache, compileModule, opts (withAnf, withAnfInline, withTypecheck)

  [
    // PASS 1: Parse
    .{
      name: "parse",
      mutatesAst: false,
      provides: ["ast", "parseTree"],
      run: fn(ctx, state) {
        parse(state.source, state.path)
      },
    },

    // PASS 2: Lower
    .{
      name: "lower",
      mutatesAst: false,
      requires: ["ast"],
      provides: ["loweredAst"],
      enabled: fn(ctx, state) {
        if !ctx.opts { return true }
        if ctx.opts.withLower == false { return false }
        true
      },
      run: fn(ctx, state) {
        let result = lower(state.ast, .{ startNodeId: state.nextNodeId })

        // Remap parse enum info (if present) onto lowered node IDs via origin.
        let parseResult = state.passes and state.passes.parse
        if parseResult and parseResult.enumInfo and result and result.origin {
          let remapped = .{}
          let newIds = keys(result.origin)
          for let i = 0; i < len(newIds); i = i + 1 {
            let newId = newIds[i]
            let oldId = result.origin[newId]
            if (type(oldId) == "number" or type(oldId) == "string") {
              let info = parseResult.enumInfo[oldId]
              if info { remapped[newId] = info }
            }
          }
          return .{
            success: result.success,
            ast: result.ast,
            origin: result.origin,
            errors: result.errors,
            nextNodeId: result.nextNodeId,
            enumInfo: remapped,
          }
        }

        result
      },
    },

    // PASS 3: ANF (optional, default on)
    .{
      name: "anf",
      mutatesAst: false,
      requires: ["loweredAst"],
      provides: ["anfAst", "loweredAst"],  // ANF is a refinement, still satisfies loweredAst contracts
      enabled: fn(ctx, state) {
        // Explicit boolean: default to true if opts missing
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        true
      },
      run: fn(ctx, state) {
        let result = anf(state.ast, .{ startNodeId: state.nextNodeId })

        // Remap enum info through ANF transform (node IDs change again).
        let prev = state.passes and state.passes.lower
        if prev and prev.enumInfo and result and result.origin {
          let remapped = .{}
          let newIds = keys(result.origin)
          for let i = 0; i < len(newIds); i = i + 1 {
            let newId = newIds[i]
            let oldId = result.origin[newId]
            if (type(oldId) == "number" or type(oldId) == "string") {
              let info = prev.enumInfo[oldId]
              if info { remapped[newId] = info }
            }
          }
          return .{
            success: result.success,
            ast: result.ast,
            origin: result.origin,
            errors: result.errors,
            nextNodeId: result.nextNodeId,
            enumInfo: remapped,
          }
        }

        result
      },
    },

    // PASS 4: Resolve
    .{
      name: "resolve",
      mutatesAst: false,  // Phase 2: import metadata moved to side tables
      requires: ["ast"],  // Works on parse, lowered, or ANF AST
      provides: ["resolution", "scopeInfo"],
      run: fn(ctx, state) {
        let opts = .{
          importCache: ctx.importCache,
          compileModule: ctx.compileModule,
        }
        resolve(state.ast, opts)
      },
    },

    // PASS 5: ANF Inline Optimization (optional, default on, post-resolve)
    .{
      name: "anf-inline",
      mutatesAst: true,  // Explicitly mutates AST in-place
      requires: ["anfAst", "resolution"],
      provides: ["optimizedAst"],
      enabled: fn(ctx, state) {
        // Only run if both ANF and ANF-inline are enabled
        if !ctx.opts { return true }
        if ctx.opts.withAnf == false { return false }
        if ctx.opts.withAnfInline == false { return false }
        true
      },
      run: fn(ctx, state) {
        let resolveResult = state.passes.resolve
        anfInline(state.ast, resolveResult)
      },
    },
  ]
}

// ========================================
// Driver Factory
// ========================================

fn make(opts) {
  let cache = .{}
  let compiledModules = []  // Track compilation order
  let loadSource = opts["loadSource"]

  // Profile support: profile sets defaults, explicit flags override
  // Use `opts["..."]` for optional keys so callers can omit them.
  let profileName = opts["profile"] or "default"
  let profileDefaults = getProfile(profileName)

  if !profileDefaults {
    // Unknown profile - error
    groanln("Error: Unknown profile '" + profileName + "'")
    groanln("Available profiles: default, tooling, O0, query, resolve")
    return nil
  }

  // Apply profile defaults, then override with explicit flags
  // Check if flag is explicitly set (not nil), if so use it, else use profile default
  let withLower = nil
  let explicitWithLower = opts["withLower"]
  if explicitWithLower != nil {
    withLower = explicitWithLower
  } else {
    withLower = profileDefaults.withLower
  }

  let withTypecheck = nil
  let explicitWithTypecheck = opts["withTypecheck"]
  if explicitWithTypecheck != nil {
    withTypecheck = explicitWithTypecheck
  } else {
    withTypecheck = profileDefaults.withTypecheck
  }

  let withAnf = nil
  let explicitWithAnf = opts["withAnf"]
  if explicitWithAnf != nil {
    withAnf = explicitWithAnf
  } else {
    withAnf = profileDefaults.withAnf
  }

  let withAnfInline = nil
  let explicitWithAnfInline = opts["withAnfInline"]
  if explicitWithAnfInline != nil {
    withAnfInline = explicitWithAnfInline
  } else {
    withAnfInline = profileDefaults.withAnfInline
  }

  // Optional import overrides (used when compiling transitive imports).
  // Defaults to top-level behavior unless overridden.
  let withImportLower = opts["withImportLower"]
  if withImportLower == nil { withImportLower = withLower }

  // Debug flags (optional)
  let debug = opts["debug"]
  let wholeProgramTypecheckDone = false
  let compileDepth = 0

  let compileModule = nil

  fn inferCaps(result) {
    let passes = result and result.passes or .{}
    .{
      withLower: passes.lower != nil,
      withAnf: passes.anf != nil,
      withAnfInline: passes["anf-inline"] != nil,
      withTypecheck: passes.typecheck != nil,
    }
  }

  fn meetsNeeds(result, needs) {
    if !result { return false }
    let caps = (result.buildOpts and .{
      withLower: result.buildOpts.withLower == true,
      withAnf: result.buildOpts.withAnf == true,
      withAnfInline: result.buildOpts.withAnfInline == true,
      withTypecheck: result.buildOpts.withTypecheck == true,
    }) or inferCaps(result)

    if needs.withLower == true and caps.withLower != true { return false }
    if needs.withAnf == true and caps.withAnf != true { return false }
    if needs.withAnfInline == true and caps.withAnfInline != true { return false }
    if needs.withTypecheck == true and caps.withTypecheck != true { return false }
    true
  }

  let runWholeProgramTypecheck = fn(entryResult) {
    // Typecheck in reverse discovery order so imports are processed first.
    let programExports = .{}

    for let i = len(compiledModules) - 1; i >= 0; i = i - 1 {
      let path = compiledModules[i]
      let r = cache[path]
      if !r or r.status != "done" { continue }
      let passes = r.passes or .{}
      let resolveResult = passes.resolve
      if !resolveResult or resolveResult.success != true { continue }

      let ast = (passes["anf-inline"] and passes["anf-inline"].ast) or
                (passes.anf and passes.anf.ast) or
                (passes.lower and passes.lower.ast) or
                (passes.parse and passes.parse.ast)
      if !ast { continue }

      let enumInfo =
        (passes.anf and passes.anf.enumInfo) or
        (passes.lower and passes.lower.enumInfo) or
        (passes.parse and passes.parse.enumInfo)

      let tc = typecheck(ast, resolveResult, .{
        enumInfo: enumInfo,
        program: .{ exports: programExports },
      }) or .{ success: false, errors: ["typecheck returned nil"], types: .{}, typeVarBindings: .{} }

      // Attach as a non-fatal pass result for tooling to inspect.
      passes.typecheck = tc
      r.passes = passes
      if r.passOrder { push(r.passOrder, "typecheck") }

      // Record module's export type (type of last expression) for downstream imports.
      if ast.type == NODE.Block and ast.expressions and len(ast.expressions) > 0 {
        let last = ast.expressions[len(ast.expressions) - 1]
        if last and tc.types and tc.types[last.id] {
          programExports[path] = tc.types[last.id]
        }
      }
    }

    wholeProgramTypecheckDone = true
    entryResult
  }

  let compileModuleInternal = fn compileModuleInternal(path) {
    let isImport = compileDepth > 1
    let effectiveWithLower = isImport and withImportLower or withLower
    let effectiveWithAnf = withAnf
    let effectiveWithAnfInline = withAnfInline
    let effectiveWithTypecheck = withTypecheck
    // If lower is disabled, downstream passes depending on lowered AST must be disabled.
    if effectiveWithLower == false {
      effectiveWithAnf = false
      effectiveWithAnfInline = false
      effectiveWithTypecheck = false
    }

    let needs = .{
      withLower: effectiveWithLower == true,
      withAnf: effectiveWithAnf == true,
      withAnfInline: effectiveWithAnfInline == true,
      withTypecheck: effectiveWithTypecheck == true,
    }

    // Check cache first
    let cached = cache[path]
    if cached {
      // Respect "compiling" sentinel for circular import detection.
      if cached.status != "done" and cached.status != "failed" {
        return cached
      }
      if meetsNeeds(cached, needs) {
        return cached
      }
      // Otherwise: upgrade/downgrade by recompiling with current needs.
    }

    // Track compilation (first time only)
    push(compiledModules, path)
    // Graph changed; any previous whole-program typecheck results are stale.
    wholeProgramTypecheckDone = false

    // Mark as compiling (for circular import detection)
    cache[path] = .{
      status: "compiling",
      path: path,
    }

    // Load source via callback
    let source = nil
    if loadSource {
      source = loadSource(path)
    }

    if !source {
      // Source loading failed - represent as failed parse pass
      let result = .{
        status: "failed",
        success: false,
        path: path,
        failedPass: "parse",
        passOrder: ["parse"],
        passes: .{
          parse: .{
            success: false,
            errors: ["Failed to load source: " + path],
          },
        },
      }
      cache[path] = result
      return result
    }

    // ========================================
    // Run Pipeline
    // ========================================

    // Build context for passes
    let ctx = .{
      importCache: cache,
      // Use the public wrapper so nested imports bump compileDepth, enabling
      // per-import build options like `withImportLower`.
      compileModule: compileModule,
      opts: .{
        withLower: effectiveWithLower,
        withAnf: effectiveWithAnf,
        withAnfInline: effectiveWithAnfInline,
        withTypecheck: effectiveWithTypecheck,
      },
      debug: debug,
    }

    // Build initial state
    let state = .{
      path: path,
      source: source,
      ast: nil,
      nextNodeId: 1,
      passes: .{},
    }

    // Execute passes
    let passList = buildPassList(ctx)
    let pipelineResult = pipeline.runPasses(passList, ctx, state)

    // Build result with pipeline fields
    let result = .{
      // Core fields
      status: pipelineResult.status,
      success: pipelineResult.success,
      path: path,
      failedPass: pipelineResult.failedPass,
      buildOpts: needs,

      // Pipeline fields
      passOrder: pipelineResult.passOrder,
      passes: pipelineResult.passes,
    }

    cache[path] = result
    return result
  }

  compileModule = fn compileModule(path) {
    compileDepth = compileDepth + 1
    let isTop = compileDepth == 1
    let result = compileModuleInternal(path)
    compileDepth = compileDepth - 1

    if isTop and withTypecheck != false and !wholeProgramTypecheckDone {
      return runWholeProgramTypecheck(result)
    }

    result
  }

  .{
    cache: cache,
    compiledModules: compiledModules,
    loadSource: loadSource,
    withLower: withLower,
    withTypecheck: withTypecheck,
    withAnf: withAnf,
    withAnfInline: withAnfInline,
    debug: debug,
    compileModule: compileModule,
  }
}

// ========================================
// Module Exports
// ========================================

.{
  make: make
}
