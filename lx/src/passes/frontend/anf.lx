// ANF Phase - Normalize expressions into sequenced, atomic subexpressions
// Responsibility: Preserve evaluation order and make block results explicit
//   - Introduce temp lets for non-atomic subexpressions
//   - Keep control-flow semantics (short-circuit, return, break)
//   - Do not perform name resolution or semantic validation
//
// IMPORTANT: ANF MUST NOT mutate input AST nodes.

let .{ NODE } = import "src/types.lx"
let nodeUtils = import "src/passes/node-utils.lx"

// ========================================
// Error handling
// ========================================

fn addError(anf, nodeId, message) {
  push(anf.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Node Creation Helpers
// ========================================

fn allocNodeId(anf) {
  let id = anf.nextId
  anf.nextId = anf.nextId + 1
  id
}

fn copyNodeShallow(anf, node) {
  nodeUtils.copyNodeShallow(allocNodeId, anf, node)
}

fn makeIdentifier(anf, templateNode, name) {
  let node = .{
    type: NODE.Identifier,
    filename: templateNode.filename,
    id: allocNodeId(anf),
    line: templateNode.line,
    col: templateNode.col,
    endLine: templateNode.endLine,
    endCol: templateNode.endCol,
    name: name,
  }
  anf.origin[node.id] = templateNode.id
  node
}

fn makeLet(anf, templateNode, nameNode, initNode) {
  let node = .{
    type: NODE.Let,
    filename: templateNode.filename,
    id: allocNodeId(anf),
    line: templateNode.line,
    col: templateNode.col,
    endLine: templateNode.endLine,
    endCol: templateNode.endCol,
    name: nameNode,
    init: initNode,
  }
  anf.origin[node.id] = templateNode.id
  node
}

fn makeBlock(anf, templateNode, expressions) {
  let node = .{
    type: NODE.Block,
    filename: templateNode.filename,
    id: allocNodeId(anf),
    line: templateNode.line,
    col: templateNode.col,
    endLine: templateNode.endLine,
    endCol: templateNode.endCol,
    expressions: expressions,
    anfSynthetic: true,
  }
  anf.origin[node.id] = templateNode.id
  node
}

// ========================================
// Scope + Temp Handling
// ========================================

fn isNameTaken(anf, name) {
  for let i = len(anf.scopeStack) - 1; i >= 0; i = i - 1 {
    if anf.scopeStack[i][name] { return true }
  }
  false
}

fn addName(anf, name) {
  if len(anf.scopeStack) == 0 { return }
  anf.scopeStack[len(anf.scopeStack) - 1][name] = true
}

fn pushScope(anf, names) {
  let scope = .{}
  for let i = 0; i < len(names); i = i + 1 {
    scope[names[i]] = true
  }
  push(anf.scopeStack, scope)
}

fn popScope(anf) {
  pop(anf.scopeStack)
}

fn collectBlockNames(node) {
  let names = []
  let exprs = node.expressions or []
  for let i = 0; i < len(exprs); i = i + 1 {
    let expr = exprs[i]
    if expr.type == NODE.Let and expr.name {
      push(names, expr.name.name)
    } else if expr.type == NODE.Function and expr.name {
      push(names, expr.name.name)
    }
  }
  names
}

fn collectFunctionNames(node) {
  let names = []
  if node.name { push(names, node.name.name) }
  let params = node.params or []
  for let i = 0; i < len(params); i = i + 1 {
    push(names, params[i].name)
  }
  names
}

fn collectForNames(node) {
  let names = []
  if node.init and node.init.type == NODE.Let and node.init.name {
    push(names, node.init.name.name)
  }
  names
}

fn freshTempName(anf) {
  let name = "$anf." + str(anf.tempCounter)
  for isNameTaken(anf, name) {
    anf.tempCounter = anf.tempCounter + 1
    name = "$anf." + str(anf.tempCounter)
  }
  anf.tempCounter = anf.tempCounter + 1
  addName(anf, name)
  name
}

// ========================================
// ANF Helpers
// ========================================

fn isAtomic(node) {
  if node.type == NODE.Number or node.type == NODE.String or node.type == NODE.Bool or
     node.type == NODE.Nil or node.type == NODE.Identifier or node.type == NODE.Function {
    return true
  }

  // Treat simple property/index reads as atomic if their inputs are atomic.
  // This is safe because our stack machine evaluates these in order without
  // needing intermediate locals.
  if node.type == NODE.Dot {
    return isAtomic(node.object) and (node.property and node.property.type == NODE.String)
  }

  if node.type == NODE.Index {
    return isAtomic(node.object) and isAtomic(node.index)
  }

  false
}

fn appendAll(dst, src) {
  if !src { return dst }
  for let i = 0; i < len(src); i = i + 1 {
    push(dst, src[i])
  }
  dst
}

fn wrapWithPrelude(anf, templateNode, pre, expr) {
  if len(pre) == 0 { return expr }
  if expr and expr.type == NODE.Block and expr.expressions {
    let exprs = []
    appendAll(exprs, pre)
    appendAll(exprs, expr.expressions)
    return makeBlock(anf, templateNode, exprs)
  }
  let exprs = []
  appendAll(exprs, pre)
  push(exprs, expr)
  makeBlock(anf, templateNode, exprs)
}


fn anfToValue(anf, node) {
  // Normalize an expression for value position, ensuring no Let appears as subexpression
  // This enforces Invariant S: Let nodes only appear in Block.expressions (statement position)
  if !node { return nil }

  let expr = anfExpr(anf, node)

  // If anfExpr returned a Let, wrap it in a block to move it to statement position
  // Transform: let x = init  =>  { let x = init; x }
  if expr.type == NODE.Let {
    return makeBlock(anf, node, [expr, makeIdentifier(anf, expr, expr.name.name)])
  }

  return expr
}

fn anfToAtomic(anf, node) {
  // Special case: Let in expression position
  // Enforces Invariant S by extracting Let to statement position
  // Transform: anfToAtomic(let x = init)
  //         => pre: [let x = <atomic-init>], expr: x
  if node.type == NODE.Let {
    let letNode = copyNodeShallow(anf, node)
    let letName = copyNodeShallow(anf, node.name)
    letNode.name = letName

    let pre = []

    if node.init {
      let initAtomic = anfToAtomic(anf, node.init)
      pre = initAtomic.pre
      letNode.init = initAtomic.expr
    } else {
      // Make default explicit
      letNode.init = .{
        type: NODE.Nil,
        filename: node.filename,
        id: allocNodeId(anf),
        line: node.line, col: node.col,
        endLine: node.endLine, endCol: node.endCol,
      }
      anf.origin[letNode.init.id] = node.id
    }

    addName(anf, letName.name)

    let outPre = []
    appendAll(outPre, pre)
    push(outPre, letNode)
    return .{
      pre: outPre,
      expr: makeIdentifier(anf, node, letName.name),
    }
  }

  // Normal case: complex expressions
  let expr = anfExpr(anf, node)
  if isAtomic(expr) {
    return .{ pre: [], expr: expr }
  }
  let name = freshTempName(anf)
  let nameNode = makeIdentifier(anf, node, name)
  let letNode = makeLet(anf, node, nameNode, expr)
  .{ pre: [letNode], expr: makeIdentifier(anf, node, name) }
}

fn anfAssignmentValue(anf, node) {
  // Special handling for assignment RHS to avoid unnecessary temps
  // Returns: { pre: [...], expr: ... }
  //
  // Don't create temps for "simple" expressions that can be directly
  // consumed by the assignment operation.

  if isAtomic(node) {
    return .{ pre: [], expr: copyNodeShallow(anf, node) }
  }

  // Simple binary: both operands atomic
  if node.type == NODE.Binary {
    let left = anfToAtomic(anf, node.left)
    let right = anfToAtomic(anf, node.right)

    // Only skip temp if BOTH operands are atomic (no prelude needed)
    if len(left.pre) == 0 and len(right.pre) == 0 {
      let newNode = copyNodeShallow(anf, node)
      newNode.left = left.expr
      newNode.right = right.expr
      newNode.operator = copyNodeShallow(anf, node.operator)
      return .{ pre: [], expr: newNode }
    }
  }

  // Simple unary: operand atomic
  if node.type == NODE.Unary {
    let operand = anfToAtomic(anf, node.operand)

    if len(operand.pre) == 0 {
      let newNode = copyNodeShallow(anf, node)
      newNode.operand = operand.expr
      newNode.operator = copyNodeShallow(anf, node.operator)
      return .{ pre: [], expr: newNode }
    }
  }

  // Fall back to normal anfToAtomic for complex cases
  anfToAtomic(anf, node)
}

// ========================================
// Expression Lowering
// ========================================

fn anfBinary(anf, node) {
  // Default binary handling
  let left = anfToAtomic(anf, node.left)
  let right = anfToAtomic(anf, node.right)
  let newNode = copyNodeShallow(anf, node)
  newNode.left = left.expr
  newNode.right = right.expr
  let pre = []
  appendAll(pre, left.pre)
  appendAll(pre, right.pre)
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfUnary(anf, node) {
  let operand = anfToAtomic(anf, node.operand)
  let newNode = copyNodeShallow(anf, node)
  newNode.operand = operand.expr
  wrapWithPrelude(anf, node, operand.pre, newNode)
}

fn anfLogical(anf, node) {
  let left = anfToAtomic(anf, node.left)
  let right = anfToValue(anf, node.right)
  let newNode = copyNodeShallow(anf, node)
  newNode.left = left.expr
  newNode.right = right
  wrapWithPrelude(anf, node, left.pre, newNode)
}

fn anfGrouping(anf, node) {
  let expr = anfToValue(anf, node.expression)
  let newNode = copyNodeShallow(anf, node)
  newNode.expression = expr
  newNode
}

fn anfLetNoWrap(anf, node) {
  // ANF-normalize a Let without wrapping it in a block
  // Returns { pre: [...], letNode: <Let> }
  // Used for For.init to preserve Let node kind
  let newNode = copyNodeShallow(anf, node)
  newNode.name = copyNodeShallow(anf, node.name)

  let pre = []
  if node.init {
    let initAtomic = anfToAtomic(anf, node.init)
    pre = initAtomic.pre
    newNode.init = initAtomic.expr
  }

  addName(anf, newNode.name.name)
  .{ pre: pre, letNode: newNode }
}

fn anfLet(anf, node) {
  let lowered = anfLetNoWrap(anf, node)
  wrapWithPrelude(anf, node, lowered.pre, lowered.letNode)
}

fn anfBlock(anf, node) {
  let newNode = copyNodeShallow(anf, node)
  pushScope(anf, collectBlockNames(node))
  let newExprs = []
  for let i = 0; i < len(node.expressions); i = i + 1 {
    let expr = anfExpr(anf, node.expressions[i])
    if expr and expr.type == NODE.Block and expr.anfSynthetic and expr.expressions {
      appendAll(newExprs, expr.expressions)
    } else {
      push(newExprs, expr)
    }
  }
  popScope(anf)
  newNode.expressions = newExprs
  newNode
}

fn anfFunction(anf, node) {
  let newNode = copyNodeShallow(anf, node)
  if node.name {
    newNode.name = copyNodeShallow(anf, node.name)
  }
  let newParams = []
  for let i = 0; i < len(node.params); i = i + 1 {
    push(newParams, copyNodeShallow(anf, node.params[i]))
  }
  newNode.params = newParams
  pushScope(anf, collectFunctionNames(node))
  newNode.body = anfToValue(anf, node.body)
  popScope(anf)
  newNode
}

fn anfCall(anf, node) {
  let callee = anfToAtomic(anf, node.callee)
  let pre = []
  appendAll(pre, callee.pre)
  let args = []
  for let i = 0; i < len(node.args); i = i + 1 {
    let arg = anfToAtomic(anf, node.args[i])
    appendAll(pre, arg.pre)
    push(args, arg.expr)
  }
  let newNode = copyNodeShallow(anf, node)
  newNode.callee = callee.expr
  newNode.args = args
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfIntrinsicCall(anf, node) {
  // IntrinsicCall doesn't have a callee, just args
  let pre = []
  let args = []
  for let i = 0; i < len(node.args or []); i = i + 1 {
    let arg = anfToAtomic(anf, node.args[i])
    appendAll(pre, arg.pre)
    push(args, arg.expr)
  }
  let newNode = copyNodeShallow(anf, node)
  newNode.args = args
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfIf(anf, node) {
  let cond = anfToAtomic(anf, node.condition)
  let newNode = copyNodeShallow(anf, node)
  newNode.condition = cond.expr
  newNode.then = anfToValue(anf, node.then)
  if node.else {
    newNode.else = anfToValue(anf, node.else)
  }
  wrapWithPrelude(anf, node, cond.pre, newNode)
}

fn anfFor(anf, node) {
  let newNode = copyNodeShallow(anf, node)
  pushScope(anf, collectForNames(node))

  let pre = []

  if node.init and node.init.type == NODE.Let {
    // Special case: preserve Let node kind for resolver
    // If init produces preludes, hoist them before the for
    let lowered = anfLetNoWrap(anf, node.init)
    appendAll(pre, lowered.pre)
    newNode.init = lowered.letNode
  } else if node.init {
    newNode.init = anfToValue(anf, node.init)
  }

  if node.condition {
    newNode.condition = anfToValue(anf, node.condition)
  }
  if node.update {
    newNode.update = anfToValue(anf, node.update)
  }
  newNode.body = anfToValue(anf, node.body)

  popScope(anf)

  // If init produced preludes, hoist them before the for
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfReturn(anf, node) {
  let newNode = copyNodeShallow(anf, node)
  if node.value {
    newNode.value = anfToValue(anf, node.value)
  }
  newNode
}

fn anfBreak(anf, node) {
  copyNodeShallow(anf, node)
}

fn anfContinue(anf, node) {
  copyNodeShallow(anf, node)
}

fn anfArray(anf, node) {
  let pre = []
  let elements = []
  for let i = 0; i < len(node.elements); i = i + 1 {
    let elem = anfToAtomic(anf, node.elements[i])
    appendAll(pre, elem.pre)
    push(elements, elem.expr)
  }
  let newNode = copyNodeShallow(anf, node)
  newNode.elements = elements
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfHashmap(anf, node) {
  let pre = []
  let pairs = []
  for let i = 0; i < len(node.pairs); i = i + 1 {
    let pair = node.pairs[i]
    let key = anfToAtomic(anf, pair.key)
    appendAll(pre, key.pre)
    let value = anfToAtomic(anf, pair.value)
    appendAll(pre, value.pre)
    push(pairs, .{ key: key.expr, value: value.expr })
  }
  let newNode = copyNodeShallow(anf, node)
  newNode.pairs = pairs
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfIndex(anf, node) {
  let object = anfToAtomic(anf, node.object)
  let index = anfToAtomic(anf, node.index)
  let newNode = copyNodeShallow(anf, node)
  newNode.object = object.expr
  newNode.index = index.expr
  let pre = []
  appendAll(pre, object.pre)
  appendAll(pre, index.pre)
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfDot(anf, node) {
  let object = anfToAtomic(anf, node.object)
  let newNode = copyNodeShallow(anf, node)
  newNode.object = object.expr
  newNode.property = copyNodeShallow(anf, node.property)
  wrapWithPrelude(anf, node, object.pre, newNode)
}

fn anfAssignment(anf, node) {
  let targetPre = []
  let targetNode = nil
  if node.target.type == NODE.Identifier {
    targetNode = copyNodeShallow(anf, node.target)
  } else if node.target.type == NODE.Index {
    let object = anfToAtomic(anf, node.target.object)
    let index = anfToAtomic(anf, node.target.index)
    targetPre = []
    appendAll(targetPre, object.pre)
    appendAll(targetPre, index.pre)
    let newTarget = copyNodeShallow(anf, node.target)
    newTarget.object = object.expr
    newTarget.index = index.expr
    targetNode = newTarget
  } else if node.target.type == NODE.Dot {
    let object = anfToAtomic(anf, node.target.object)
    targetPre = object.pre
    let newTarget = copyNodeShallow(anf, node.target)
    newTarget.object = object.expr
    newTarget.property = copyNodeShallow(anf, node.target.property)
    targetNode = newTarget
  } else {
    targetNode = copyNodeShallow(anf, node.target)
  }

  // Use special assignment value handling to avoid unnecessary temps
  let value = anfAssignmentValue(anf, node.value)
  let newNode = copyNodeShallow(anf, node)
  newNode.target = targetNode
  newNode.value = value.expr
  let pre = []
  appendAll(pre, targetPre)
  appendAll(pre, value.pre)

  // Only wrap in block if there's actually prelude
  if len(pre) == 0 {
    return newNode
  }
  wrapWithPrelude(anf, node, pre, newNode)
}

fn anfImport(anf, node) {
  let newNode = copyNodeShallow(anf, node)
  newNode.path = anfExpr(anf, node.path)
  newNode
}

// ========================================
// Main Expression Dispatcher
// ========================================

let anfExprHandlers = .{
  [NODE.If]: anfIf,
  [NODE.Binary]: anfBinary,
  [NODE.Unary]: anfUnary,
  [NODE.Logical]: anfLogical,
  [NODE.Grouping]: anfGrouping,
  [NODE.Let]: anfLet,
  [NODE.Block]: anfBlock,
  [NODE.Function]: anfFunction,
  [NODE.Call]: anfCall,
  [NODE.For]: anfFor,
  [NODE.Return]: anfReturn,
  [NODE.Break]: anfBreak,
  [NODE.Continue]: anfContinue,
  [NODE.Array]: anfArray,
  [NODE.Hashmap]: anfHashmap,
  [NODE.Index]: anfIndex,
  [NODE.Dot]: anfDot,
  [NODE.Assignment]: anfAssignment,
  [NODE.Import]: anfImport,
  [NODE.IntrinsicCall]: anfIntrinsicCall,
  [NODE.Number]: fn(anf, node) { copyNodeShallow(anf, node) },
  [NODE.String]: fn(anf, node) { copyNodeShallow(anf, node) },
  [NODE.Bool]: fn(anf, node) { copyNodeShallow(anf, node) },
  [NODE.Nil]: fn(anf, node) { copyNodeShallow(anf, node) },
  [NODE.Identifier]: fn(anf, node) { copyNodeShallow(anf, node) },
}

fn anfExpr(anf, node) {
  if !node { return nil }

  if let handler = anfExprHandlers[node.type] {
    return handler(anf, node)
  }

  addError(anf, node.id, "Unknown node type in ANF: " + (nameOf(NODE, node.type) or str(node.type)))
  node
}

// ========================================
// Main API
// ========================================
// anf(ast, opts) → {
//   success: bool,
//   ast: BlockNode,             // ANF AST
//   origin: { newId → oldId },  // Provenance map
//   errors: [{ nodeId, message, severity }],
//   nextNodeId: number,         // For next phase to continue
// }
//
// opts: {
//   startNodeId: number,  // Where to start fresh IDs
// }
fn anf(ast, opts) {
  let anfer = .{
    nextId: opts.startNodeId or 1,
    origin: .{},
    errors: [],
    tempCounter: 0,
    scopeStack: [],
  }

  let anfAst = anfExpr(anfer, ast)

  .{
    success: len(anfer.errors) == 0,
    ast: anfAst,
    origin: anfer.origin,
    errors: anfer.errors,
    nextNodeId: anfer.nextId,
  }
}

anf
