// Typechecker Skeleton - Infrastructure and Patterns
//
// This file demonstrates the essential patterns for building a type checker:
// 1. How to integrate with other passes (resolve, etc.)
// 2. How to traverse the AST
// 3. How to gather and return results
//
// WHAT THIS FILE CONTAINS:
// - Integration patterns: how to access resolveResult, enumInfo, program data
// - Traversal patterns: how to dispatch on node types and recurse through AST
// - Result gathering: how to store types per node and collect errors
// - Basic type assignments for literals, binaries, functions, etc.
//
// WHAT WAS REMOVED:
// - Constraint generation and solving (Eq, HasField, Call, Index)
// - Type variable unification and binding
// - Function type refinement across multiple passes
// - Indexable shape variables and finalization
// - Option type propagation
// - Complex bidirectional type checking
//
// The reusable components have been extracted to typecheck-helper.lx:
// - Type constructors (typeArray, typeFunction, etc.)
// - Builtin type catalog (builtinTypeByName with hash table lookup)
// - Type utilities (deref, typeEquals, occurs check)
// - Worklist solver and SCC algorithms
//
// This skeleton just assigns simple types (mostly Any) to demonstrate the
// traversal and integration patterns. A real type checker would build on
// these patterns to implement proper type inference.

let helper = import "src/passes/analysis/typecheck-helper.lx"
let .{ NODE } = import "src/types.lx"

// ========================================================
// Type Constructors (from helper)
// ========================================================
// These are available in typecheck-helper.lx and can be reused

let typeAny = helper.typeAny
let typeNil = helper.typeNil
let typeNumber = helper.typeNumber
let typeBool = helper.typeBool
let typeString = helper.typeString
let typeArray = helper.typeArray
let typeFunction = helper.typeFunction

// ========================================================
// Checker State
// ========================================================
// Shows how to structure the checker context with data from other passes

fn makeChecker(resolveResult, opts = .{}) {
  .{
    // === Data from other passes ===
    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,  // Identifier -> binding info
    enumInfo: opts.enumInfo or .{},              // Node ID -> enum metadata
    program: opts.program,                       // Program-level context

    // === Result accumulation ===
    types: .{},                                  // Node ID -> inferred type
    errors: [],                                  // Collected errors
    hadError: false,

    // === Working state (example) ===
    nextTypeVarId: 1,                            // For generating fresh type vars
  }
}

// ========================================================
// Error Reporting Pattern
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================================
// AST Traversal Pattern
// ========================================================
// Shows how to traverse and analyze different node types

// Pattern: ExprStmt wrapper - common in lowered AST
fn checkExprStmt(checker, node) {
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

// Pattern: Literal nodes
fn checkLiteral(checker, node) {
  let t =
    node.type == NODE.Number and typeNumber() or
    node.type == NODE.String and typeString() or
    node.type == NODE.Bool   and typeBool()   or
    typeNil()

  // Store result per node ID
  checker.types[node.id] = t
  t
}

// Pattern: Identifier nodes - shows resolver integration
fn checkIdentifier(checker, node) {
  // Access resolver data via node ID
  let binding = checker.resolvedNames[node.id]

  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Example: Handle builtins differently
  if binding.kind == "builtin" {
    let bt = helper.builtinTypeByName(checker, binding.name)
    if !bt { bt = typeAny() }
    checker.types[node.id] = bt
    return bt
  }

  // For local/upvalue bindings, you'd track their types here
  // This is where type inference would happen
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Pattern: Binary operations - shows recursive traversal
fn checkBinary(checker, node) {
  let op = node.operator.lexeme

  // Recurse into children
  let leftType = synthExpr(checker, node.left)
  let rightType = synthExpr(checker, node.right)

  // Infer result type based on operator
  let resultType =
    (op == "+" or op == "-" or op == "*" or op == "/" or op == "%") and typeNumber() or
    (op == "&" or op == "|" or op == "^" or op == "<<" or op == ">>") and typeNumber() or
    (op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=") and typeBool() or
    typeAny()

  checker.types[node.id] = resultType
  resultType
}

// Pattern: Block - shows iteration over expressions
fn checkBlock(checker, node) {
  let exprs = node.expressions or []
  let lastType = typeNil()

  for expr in exprs {
    lastType = synthExpr(checker, expr)
  }

  // Blocks return the last expression value
  checker.types[node.id] = lastType
  lastType
}

// Pattern: Function - shows how to handle scope
fn checkFunction(checker, node) {
  // You would enter a new scope here
  // let params = node.params or []

  // Analyze body
  if node.body {
    synthExpr(checker, node.body)
  }

  // Functions are typed as Function(params, ret)
  // For skeleton, just use Any->Any
  let t = typeFunction([typeAny()], typeAny())
  checker.types[node.id] = t
  t
}

// Pattern: If expression - shows control flow handling
fn checkIf(checker, node) {
  // Check condition
  synthExpr(checker, node.condition)

  // Check both branches
  let thenType = synthExpr(checker, node.then)
  let elseType = node.else and synthExpr(checker, node.else) or typeNil()

  // Result is union/join of branches
  // For skeleton, just pick the then type
  checker.types[node.id] = thenType
  thenType
}

// Pattern: Array literal - shows collection handling
fn checkArray(checker, node) {
  let elems = node.elements or []

  // Check all elements
  for elem in elems {
    synthExpr(checker, elem)
  }

  // Infer Array[T] - for skeleton just use Array[Any]
  let t = typeArray(typeAny())
  checker.types[node.id] = t
  t
}

// Pattern: Let binding - shows how to track declarations
fn checkLet(checker, node) {
  // Check initializer if present
  if node.init {
    let initType = synthExpr(checker, node.init)
    // In a real checker, you'd track this binding for the name
    if node.name and node.name.id {
      checker.types[node.name.id] = initType
    }
  }

  // Let statements return nil
  let t = typeNil()
  checker.types[node.id] = t
  t
}

// Pattern: Call - shows function application
fn checkCall(checker, node) {
  // Check callee
  synthExpr(checker, node.callee)

  // Check arguments
  let args = node.args or []
  for arg in args {
    synthExpr(checker, arg)
  }

  // Result type would be inferred from callee type
  // For skeleton, just return Any
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Pattern: Unary operations
fn checkUnary(checker, node) {
  let op = node.operator and node.operator.lexeme or ""
  synthExpr(checker, node.operand)

  let t =
    op == "-" and typeNumber() or
    op == "!" and typeBool() or
    typeAny()

  checker.types[node.id] = t
  t
}

// Pattern: Logical operations (and/or)
fn checkLogical(checker, node) {
  synthExpr(checker, node.left)
  synthExpr(checker, node.right)

  // Logical ops can return either operand - for skeleton use Any
  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Pattern: For loops
fn checkFor(checker, node) {
  if node.init { synthExpr(checker, node.init) }
  if node.condition { synthExpr(checker, node.condition) }
  if node.update { synthExpr(checker, node.update) }
  if node.body { synthExpr(checker, node.body) }

  // For loops return nil
  let t = typeNil()
  checker.types[node.id] = t
  t
}

// Main expression synthesizer - dispatches by node type
fn synthExpr(checker, node) {
  if !node { return typeNil() }

  // ExprStmt is very common in lowered AST
  if node.type == NODE.ExprStmt {
    return checkExprStmt(checker, node)
  }

  // Dispatch based on node type
  if node.type == NODE.Number or node.type == NODE.String or
     node.type == NODE.Bool or node.type == NODE.Nil {
    return checkLiteral(checker, node)
  }
  if node.type == NODE.Identifier {
    return checkIdentifier(checker, node)
  }
  if node.type == NODE.Binary {
    return checkBinary(checker, node)
  }
  if node.type == NODE.Unary {
    return checkUnary(checker, node)
  }
  if node.type == NODE.Logical {
    return checkLogical(checker, node)
  }
  if node.type == NODE.Block {
    return checkBlock(checker, node)
  }
  if node.type == NODE.Function {
    return checkFunction(checker, node)
  }
  if node.type == NODE.If {
    return checkIf(checker, node)
  }
  if node.type == NODE.Array {
    return checkArray(checker, node)
  }
  if node.type == NODE.Let {
    return checkLet(checker, node)
  }
  if node.type == NODE.Call {
    return checkCall(checker, node)
  }
  if node.type == NODE.For {
    return checkFor(checker, node)
  }

  // TODO: Handle other node types (Dot, Index, Hashmap, Return, etc.)
  // For unhandled nodes, assign Any to avoid crashes
  let t = typeAny()
  if node.id {
    checker.types[node.id] = t
  }
  t
}

// ========================================================
// Public API
// ========================================================

fn typecheck(ast, resolveResult, opts) {
  // Check preconditions
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  if !ast {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Missing AST", severity: "error" }],
    }
  }

  // Create checker with data from other passes
  let checker = makeChecker(resolveResult, opts)

  // Traverse the AST
  synthExpr(checker, ast)

  // Return results
  .{
    success: !checker.hadError,
    types: checker.types,           // Node ID -> type
    errors: checker.errors,         // List of error objects
  }
}

typecheck
