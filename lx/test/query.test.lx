// Query Service Tests

let suite = (import "test/makeTestSuite.lx")()
let test = suite.defineTest

let Driver = import "src/driver.lx"
let query = import "services/query.lx"
let types = import "src/types.lx"
let ModuleResolution = import "src/module_resolution.lx"

let NODE = types.NODE

// Helper: compile source through full pipeline and create query context
// Tests use lower-level APIs for flexibility (inline source, not filesystem)
fn compileAndQuery(source, filename) {
  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == filename { return source }
      let resolver = ModuleResolution.forEntry(Lx.args[2])
      return resolver.slurp(path)
    },
    withTypecheck: true,
    withAnf: false,  // Query tests need non-ANF AST (imports not hoisted, etc.)
  })

  let result = driver.compileModule(filename)

  if result.status != "done" {
    let phase = "unknown"
    let errors = []
    let passes = result.passes or .{}

    if passes.parse and passes.parse.errors {
      phase = "parse"
      errors = passes.parse.errors
    } else if passes.lower and passes.lower.errors {
      phase = "lower"
      errors = passes.lower.errors
    } else if passes.resolve and !passes.resolve.success {
      phase = "resolve"
      errors = passes.resolve.errors
    }

    return .{ success: false, phase, errors }
  }

  let initResult = query.queryInit(
    result.passes.lower.ast,
    result.passes.resolve,
    result.passes.typecheck,
    .{ buildIndex: true }
  )

  .{
    success: initResult.success,
    ctx: initResult.ctx,
    parseResult: result.passes.parse,
    lowerResult: result.passes.lower,
    resolveResult: result.passes.resolve,
    typecheckResult: result.passes.typecheck,
  }
}

// ========================================
// Core Tests (5 minimum)
// ========================================

test("query - hover on number literal", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
})

test("query - hover on variable shows inferred type", fn(assert) {
  let result = compileAndQuery("let x = 42\nx", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'x' usage (line 2, col 1)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 2, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should show Number type")
  assert.truthy(hoverResult.contents.symbol, "Should include symbol info")
  assert.equal(hoverResult.contents.symbol.name, "x", "Should include symbol name")
  assert.equal(hoverResult.contents.symbol.kind, "local", "Should classify symbol kind")
  assert.truthy(hoverResult.details, "Should have details")
  assert.equal(hoverResult.details.nodeType, "Identifier", "Should identify as Identifier node")
})

test("query - hover resolves bound type variables via bindings", fn(assert) {
  // Manual context with a bound type variable to ensure hover formats binding
  let node = .{
    id: 1,
    type: NODE.Identifier,
    filename: "test.lx",
    line: 1, col: 0,
    endLine: 1, endCol: 1,
  }

  let ctx = .{
    nodes: .{[1]: node},
    resolvedNames: .{},
    types: .{[1]: .{ kind: "TypeVar", id: 123 }},
    typeVarBindings: .{[123]: .{ kind: "Number" }},
    fileNodeIds: .{ ["test.lx"]: [1] },
  }

  let hoverResult = query.queryHover(ctx, "test.lx", 1, 0)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Number", "Should format bound TypeVar as its binding type")
})

test("query - hover on record key shows field value type", fn(assert) {
  let source = ".{ DEBUG: false }"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'DEBUG' key (line 1, col 3)
  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 3)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "Bool", "Should show field value type when hovering key")
})

test("query - goto local variable", fn(assert) {
  let result = compileAndQuery("let x = 1\nx + 1", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'x' usage (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.filename, "test.lx", "Should target same file")
  assert.equal(gotoResult.target.line, 1, "Should target declaration line")
})

test("query - goto function parameter", fn(assert) {
  let result = compileAndQuery("fn f(a) { a + 1 }", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'a' in body (line 1, col 10)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 10)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target parameter declaration")
})

test("query - goto named function normalized to name", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'foo' call (line 2, col 1)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 2, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.line, 1, "Should target function declaration line")
  // The target should be the function name, not the entire function
  // We can verify it's normalized by checking the span is small
  let spanSize = (gotoResult.target.endLine - gotoResult.target.line) * 1000 +
                 (gotoResult.target.endCol - gotoResult.target.col)
  assert.truthy(spanSize < 100, "Should target function name, not entire function body")
})

test("query - goto builtin has no definition", fn(assert) {
  let result = compileAndQuery("println(42)", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'println' (line 1, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail for builtin")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
})

// ========================================
// Edge Case Tests (2 additional)
// ========================================

test("query - hover on empty position returns no node", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Position far beyond code
  let hoverResult = query.queryHover(result.ctx, "test.lx", 100, 100)

  assert.equal(hoverResult.success, false, "Hover should fail")
  assert.equal(hoverResult.kind, "hover", "Should be hover result")
  assert.equal(hoverResult.message, "No node at position: test.lx:100:100", "Hover should include location")
})

test("query - goto on non-identifier fails gracefully", fn(assert) {
  let result = compileAndQuery("42", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on number literal
  let gotoResult = query.queryGotoDefinition(result.ctx, "test.lx", 1, 0)

  assert.equal(gotoResult.success, false, "Goto should fail on non-identifier")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.equal(gotoResult.message, "Not an identifier at test.lx:1:0", "Goto should include location")
})

test("query - goto import path opens module", fn(assert) {
  let useFile = "test/fixtures/query/import-path.lx"
  let result = query.compileFast(useFile)
  assert.truthy(result.success, "Should compile successfully")

  // Goto inside the import string: `"..."`
  let gotoResult = query.queryGotoDefinition(result.ctx, useFile, 1, 16)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target")
  assert.equal(gotoResult.target.filename, "test/fixtures/query/import-target.lx", "Should target imported module file")
  assert.equal(gotoResult.target.line, 1, "Should target start of imported file")
  assert.equal(gotoResult.target.col, 0, "Should target start column")
})

// ========================================
// Multi-Module Import Tests
// ========================================

test("query - hover on imported symbol shows type", fn(assert) {
  // Use proper fixture file - showcases real API usage
  let result = query.compile("test/fixtures/imports/test-hover.lx")

  if !result.success {
    println("Hover test compilation failed!")
    println("Phase:", result.phase)
    if result.errors { println("Errors:", result.errors) }
  }

  assert.truthy(result.success, "Should compile successfully")

  // Hover on 'config.version' (line 5, col 20 - dot expression)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 20)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show imported field type")
})

test("query - hover on imported binding identifier shows type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on local binding 'version' (line 5, col 5)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover.lx", 5, 5)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "String", "Should show type propagated from import")
})

test("query - hover on imported function value shows function type", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-hover-fn.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Hover on imported function binding 'greet' (line 1, col 4)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-hover-fn.lx", 1, 4)

  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "fn(String) -> String", "Should surface imported function type")
})

test("query - goto definition to imported module", fn(assert) {
  // Use proper fixture file
  let result = query.compile("test/fixtures/imports/test-goto.lx")

  if !result.success {
    println("Compilation failed:", result.phase)
    println("Errors:", result.errors)
  }

  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'config' usage (line 7, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-goto.lx", 7, 0)

  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.kind, "goto", "Should be goto result")
  assert.truthy(gotoResult.target, "Should have target location")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-goto.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 2, "Should point to line 2 (let config = ...)")
})

test("query - query works across diamond import structure", fn(assert) {
  // Use proper fixture file with diamond pattern
  let result = query.compile("test/fixtures/imports/test-diamond.lx")

  assert.truthy(result.success, "Should compile with diamond imports")

  // Hover on 'app.start' (line 8, col 4 - the 'start' part)
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 4)

  assert.truthy(hoverResult.success, "Hover should work across imports")
  assert.truthy(hoverResult.contents, "Should have type information")

  // Goto on 'app' usage (line 8, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-diamond.lx", 8, 0)

  assert.truthy(gotoResult.success, "Goto should work across imports")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-diamond.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 4, "Should point to line 4 (let app = ...)")

  // Hover inside an imported module file should work via query context
  let appHover = query.queryHover(result.ctx, "test/fixtures/imports/app.lx", 6, 2)
  assert.truthy(appHover.success, "Hover should work in imported module file")
  assert.truthy(appHover.contents, "Imported module hover should include contents")

  // Goto inside an imported module file should resolve locally
  let appGoto = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/app.lx", 7, 4)
  assert.truthy(appGoto.success, "Goto should work in imported module file")
  assert.equal(appGoto.target.filename, "test/fixtures/imports/app.lx", "Goto should stay in module file")
  assert.equal(appGoto.target.line, 3, "Goto should land on logger binding")
})

test("query - hover in imported module shows constant types", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-diamond.lx")
  assert.truthy(result.success, "Should compile with diamond imports")

  let versionHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 3, 2)
  assert.truthy(versionHover.success, "Hover should work in constants module")
  assert.equal(versionHover.contents.type, "String", "VERSION should be String")

  let sizeHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 4, 2)
  assert.truthy(sizeHover.success, "Hover should work in constants module")
  assert.equal(sizeHover.contents.type, "Number", "MAX_SIZE should be Number")

  let debugHover = query.queryHover(result.ctx, "test/fixtures/imports/constants.lx", 5, 2)
  assert.truthy(debugHover.success, "Hover should work in constants module")
  assert.equal(debugHover.contents.type, "Bool", "DEBUG should be Bool")
})

test("query - goto in imported module resolves local import binding", fn(assert) {
  let result = query.compile("test/fixtures/imports/test-diamond.lx")
  assert.truthy(result.success, "Should compile with diamond imports")

  // Goto on 'constants' usage inside config module (line 5, col 11)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/config.lx", 5, 11)
  assert.truthy(gotoResult.success, "Goto should work inside imported module")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/config.lx", "Goto should stay in config module")
  assert.equal(gotoResult.target.line, 2, "Goto should land on constants binding")
})

test("query - goto dot property resolves record field in imported module", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  // Goto on 'value' property (line 5, col 6)
  let gotoValue = query.queryGotoDefinition(result.ctx, "test/fixtures/query/use.lx", 5, 6)
  assert.truthy(gotoValue.success, "Goto should resolve dot property")
  assert.equal(gotoValue.target.filename, "test/fixtures/query/module.lx", "Goto should land in module file")
  assert.equal(gotoValue.target.line, 3, "Goto should land on value key")
})

test("query - hover dot property shows function type", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  // Hover on 'greet' property (line 6, col 6)
  let hoverGreet = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverGreet.success, "Hover should resolve dot property")
  assert.equal(hoverGreet.contents.type, "fn() -> String", "Should show function type")
  assert.truthy(hoverGreet.contents.property, "Hover should include property definition")
  assert.equal(hoverGreet.contents.property.definedAt.filename, "test/fixtures/query/module.lx", "Definition should point to module")
  assert.equal(hoverGreet.contents.property.definedAt.line, 4, "Definition should point to greet key")
})

test("query - goto dot property resolves enum-like record field", fn(assert) {
  let result = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result.success, "Should compile enum fixture")

  // Goto on 'CONSTANT' in OP.CONSTANT (line 3, col 6)
  let gotoConst = query.queryGotoDefinition(result.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(gotoConst.success, "Goto should resolve OP.CONSTANT")
  assert.equal(gotoConst.target.filename, "test/fixtures/query/enum-module.lx", "Goto should land in module file")
  assert.equal(gotoConst.target.line, 2, "Goto should land on CONSTANT key")
})

test("query - goto dot property resolves alias from imported module", fn(assert) {
  let result = query.compile("test/fixtures/query/alias-use.lx")
  assert.truthy(result.success, "Should compile alias fixture")

  // Goto on 'CONSTANT' in OP.CONSTANT (line 4, col 3)
  let gotoConst = query.queryGotoDefinition(result.ctx, "test/fixtures/query/alias-use.lx", 4, 3)
  assert.truthy(gotoConst.success, "Goto should resolve OP.CONSTANT")
  assert.equal(gotoConst.target.filename, "test/fixtures/query/alias-module.lx", "Goto should land in module file")
  assert.equal(gotoConst.target.line, 3, "Goto should land on CONSTANT key")
})

test("query - diagnostics parse error includes location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-parse.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report parse diagnostics")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-parse.lx", "Diagnostic filename should match")
  assert.truthy(diags[0].line > 0, "Diagnostic line should be positive")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "Expect")) > 1, "Parse message should include expected token")
})

test("query - diagnostics resolve error includes node location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-resolve.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report resolve diagnostics")
  assert.equal(diags[0].phase, "resolve", "Diagnostic phase should be resolve")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-resolve.lx", "Diagnostic filename should match")
  assert.equal(diags[0].line, 1, "Diagnostic line should match")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "undeclared")) > 1, "Resolve message should include undeclared")
})

test("query - diagnostics typecheck error includes node location", fn(assert) {
  let result = query.compile("test/fixtures/query/diag-typecheck.lx")
  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should report typecheck diagnostics")
  assert.equal(diags[0].phase, "typecheck", "Diagnostic phase should be typecheck")
  assert.equal(diags[0].filename, "test/fixtures/query/diag-typecheck.lx", "Diagnostic filename should match")
  assert.equal(diags[0].line, 1, "Diagnostic line should match")
  assert.truthy(diags[0].message, "Diagnostic should include message")
  assert.truthy(len(split(diags[0].message, "len()")) > 1, "Typecheck message should mention len()")
})

test("query - hover reports candidates on ambiguous span", fn(assert) {
  let nodeA = .{ id: 1, type: NODE.Identifier, filename: "test.lx", line: 1, col: 0, endLine: 1, endCol: 1, name: "a" }
  let nodeB = .{ id: 2, type: NODE.Number, filename: "test.lx", line: 1, col: 0, endLine: 1, endCol: 1, value: 1 }

  let ctx = .{
    nodes: .{ [1]: nodeA, [2]: nodeB },
    resolvedNames: .{},
    types: .{ [1]: .{ kind: "Number" }, [2]: .{ kind: "Number" } },
    typeVarBindings: .{},
    fileNodeIds: .{ ["test.lx"]: [1, 2] },
  }

  let hoverResult = query.queryHover(ctx, "test.lx", 1, 0)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.truthy(hoverResult.candidates, "Hover should include candidates")
  assert.equal(len(hoverResult.candidates), 1, "Should include one alternate candidate")
  assert.equal(hoverResult.candidates[0].nodeId, 1, "Candidate should include the non-selected node")
})

test("query - hover on function name returns function type", fn(assert) {
  let result = compileAndQuery("fn foo() { 1 }\nfoo()", "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  let hoverResult = query.queryHover(result.ctx, "test.lx", 1, 3)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.equal(hoverResult.contents.type, "fn() -> Number", "Should show function type")
})

test("query - ctx validation warns once on missing nodes", fn(assert) {
  let result = query.compile("test/fixtures/query/use.lx")
  assert.truthy(result.success, "Should compile query fixture")

  result.ctx.resolvedNames["999999"] = .{ kind: "local", declaredAt: 999999 }
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.truthy(result.ctx.warnings and len(result.ctx.warnings) > 0, "Should warn on missing nodes")

  let count = len(result.ctx.warnings)
  let hoverResult2 = query.queryHover(result.ctx, "test/fixtures/query/use.lx", 6, 6)
  assert.truthy(hoverResult2.success, "Hover should still succeed")
  assert.equal(len(result.ctx.warnings), count, "Warnings should not repeat")
})

test("query - compile twice yields stable goto targets", fn(assert) {
  let result1 = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result1.success, "First compile should succeed")
  let goto1 = query.queryGotoDefinition(result1.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(goto1.success, "First goto should succeed")

  let result2 = query.compile("test/fixtures/query/enum-use.lx")
  assert.truthy(result2.success, "Second compile should succeed")
  let goto2 = query.queryGotoDefinition(result2.ctx, "test/fixtures/query/enum-use.lx", 3, 6)
  assert.truthy(goto2.success, "Second goto should succeed")

  assert.equal(goto1.target.filename, goto2.target.filename, "Goto filename should match")
  assert.equal(goto1.target.line, goto2.target.line, "Goto line should match")
  assert.equal(goto1.target.col, goto2.target.col, "Goto col should match")
})

test("query - compileFast skips typecheck but supports goto", fn(assert) {
  let result = query.compileFast("test/fixtures/imports/test-goto.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Goto on 'config' usage (line 7, col 0)
  let gotoResult = query.queryGotoDefinition(result.ctx, "test/fixtures/imports/test-goto.lx", 7, 0)
  assert.truthy(gotoResult.success, "Goto should succeed without typecheck")
  assert.equal(gotoResult.target.filename, "test/fixtures/imports/test-goto.lx", "Should point to declaration")
  assert.equal(gotoResult.target.line, 2, "Should point to line 2 (let config = ...)")

  // Hover works but has no types.
  let hoverResult = query.queryHover(result.ctx, "test/fixtures/imports/test-goto.lx", 7, 0)
  assert.truthy(hoverResult.success, "Hover should succeed without typecheck")
  assert.equal(hoverResult.contents.type, "Unknown", "Type should be Unknown without typecheck")
})

test("query - goto enum member across import", fn(assert) {
  let useFile = "test/fixtures/query/token-else.lx"
  let typesFile = "src/types.lx"

  fn indexOf(haystack, needle) {
    if type(haystack) != "string" or type(needle) != "string" { return nil }
    let n = len(needle)
    if n == 0 { return 0 }
    let h = len(haystack)
    if n > h { return nil }

    for let i = 0; i <= h - n; i = i + 1 {
      let ok = true
      for let j = 0; j < n; j = j + 1 {
        if haystack[i + j] != needle[j] { ok = false; break }
      }
      if ok { return i }
    }
    nil
  }

  // Find the `ELSE` position in `TOKEN.ELSE` in the use file.
  let resolver = ModuleResolution.forEntry(Lx.args[2])
  let src = resolver.slurp(useFile)
  let lines = split(src, "\n")
  let line = nil
  let col = nil
  for let i = 0; i < len(lines); i = i + 1 {
    let idx = indexOf(lines[i], "TOKEN.ELSE")
    if idx != nil {
      line = i + 1
      col = idx + len("TOKEN.")
      break
    }
  }
  assert.truthy(line != nil and col != nil, "Should find TOKEN.ELSE span in fixture")

  // Find the enum member definition span in src/types.lx.
  let typesSrc = resolver.slurp(typesFile)
  let tlines = split(typesSrc, "\n")
  let defLine = nil
  let defCol = nil
  for let i = 0; i < len(tlines); i = i + 1 {
    // Prefer the enum member line `  ELSE,` over other incidental mentions.
    let idx = indexOf(tlines[i], "ELSE,")
    if idx != nil {
      defLine = i + 1
      defCol = idx
      break
    }
  }
  assert.truthy(defLine != nil and defCol != nil, "Should find ELSE member in src/types.lx")

  let result = query.compileFast(useFile)
  assert.truthy(result.success, "Should compile successfully")

  let gotoResult = query.queryGotoDefinition(result.ctx, useFile, line, col)
  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.filename, typesFile, "Goto should land in src/types.lx")
  assert.equal(gotoResult.target.line, defLine, "Goto line should match enum member definition")
  assert.equal(gotoResult.target.col, defCol, "Goto col should match enum member definition")

  let hoverResult = query.queryHover(result.ctx, useFile, line, col)
  assert.truthy(hoverResult.success, "Hover should succeed")
  assert.truthy(hoverResult.contents and hoverResult.contents.property, "Hover should include property definition")
  assert.equal(hoverResult.contents.property.definedAt.filename, typesFile, "Hover definedAt should land in src/types.lx")
  assert.equal(hoverResult.contents.property.definedAt.line, defLine, "Hover definedAt line should match")
  assert.equal(hoverResult.contents.property.definedAt.col, defCol, "Hover definedAt col should match")
})

test("query - goto through module export record to function decl", fn(assert) {
  let useFile = "test/fixtures/query/use-export-fns.lx"
  let modFile = "test/fixtures/query/export-fns.lx"

  fn indexOf(haystack, needle) {
    if type(haystack) != "string" or type(needle) != "string" { return nil }
    let n = len(needle)
    if n == 0 { return 0 }
    let h = len(haystack)
    if n > h { return nil }

    for let i = 0; i <= h - n; i = i + 1 {
      let ok = true
      for let j = 0; j < n; j = j + 1 {
        if haystack[i + j] != needle[j] { ok = false; break }
      }
      if ok { return i }
    }
    nil
  }

  // Find the `foo` position in `A.foo()` in the use file.
  let resolver = ModuleResolution.forEntry(Lx.args[2])
  let src = resolver.slurp(useFile)
  let lines = split(src, "\n")
  let line = nil
  let col = nil
  for let i = 0; i < len(lines); i = i + 1 {
    let idx = indexOf(lines[i], "A.foo")
    if idx != nil {
      line = i + 1
      col = idx + len("A.")
      break
    }
  }
  assert.truthy(line != nil and col != nil, "Should find A.foo span in fixture")

  // Find the function name span in the exported module file.
  let modSrc = resolver.slurp(modFile)
  let mlines = split(modSrc, "\n")
  let defLine = nil
  let defCol = nil
  for let i = 0; i < len(mlines); i = i + 1 {
    let idx = indexOf(mlines[i], "fn foo")
    if idx != nil {
      defLine = i + 1
      defCol = idx + len("fn ")
      break
    }
  }
  assert.truthy(defLine != nil and defCol != nil, "Should find fn foo in module fixture")

  let result = query.compileFast(useFile)
  assert.truthy(result.success, "Should compile successfully")

  let gotoResult = query.queryGotoDefinition(result.ctx, useFile, line, col)
  assert.truthy(gotoResult.success, "Goto should succeed")
  assert.equal(gotoResult.target.filename, modFile, "Goto should land in module file")
  assert.equal(gotoResult.target.line, defLine, "Goto line should match fn foo")
  assert.equal(gotoResult.target.col, defCol, "Goto col should match fn foo identifier")
})

// ========================================
// Completion Tests
// ========================================

test("query - completion for enum members", fn(assert) {
  let source = "let Status = enum { Success, Error, Pending }\nlet s = Status.S"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on the "S" after "Status." (line 2, col 15)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 2, 15)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.truthy(complResult.completions, "Should return completions")
  assert.equal(len(complResult.completions), 3, "Should have 3 enum members")

  // Check that all enum members are present
  let labels = collect c in complResult.completions { c.label }
  fn stringLess(a, b) {
    for let i = 0; i < len(a) and i < len(b); i = i + 1 {
      if ord(a[i]) < ord(b[i]) { return true }
      if ord(a[i]) > ord(b[i]) { return false }
    }
    len(a) < len(b)
  }
  labels = labels->sort(stringLess)
  assert.equal(labels[0], "Error", "Should include Error")
  assert.equal(labels[1], "Pending", "Should include Pending")
  assert.equal(labels[2], "Success", "Should include Success")

  // Check that they're marked as enum members
  assert.equal(complResult.completions[0].kind, "enumMember", "Should be enumMember kind")
})

test("query - completion for object properties", fn(assert) {
  let source = "let config = .{ host: \"localhost\", port: 8080, timeout: 30 }\nlet p = config.h"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on "h" after "config." (line 2, col 15)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 2, 15)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.truthy(complResult.completions, "Should return completions")
  assert.equal(len(complResult.completions), 3, "Should have 3 properties")

  // Check that all properties are present
  let labels = collect c in complResult.completions { c.label }
  fn stringLess(a, b) {
    for let i = 0; i < len(a) and i < len(b); i = i + 1 {
      if ord(a[i]) < ord(b[i]) { return true }
      if ord(a[i]) > ord(b[i]) { return false }
    }
    len(a) < len(b)
  }
  labels = labels->sort(stringLess)
  assert.equal(labels[0], "host", "Should include host")
  assert.equal(labels[1], "port", "Should include port")
  assert.equal(labels[2], "timeout", "Should include timeout")

  // Check that they're marked as properties
  assert.equal(complResult.completions[0].kind, "property", "Should be property kind")
})

test("query - completion includes builtins", fn(assert) {
  let source = "let x = 42"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete at end of file (line 1, col 10)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 1, 10)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.truthy(complResult.completions, "Should return completions")
  assert.truthy(len(complResult.completions) > 0, "Should have completions")

  // Check that builtins are included
  let labels = collect c in complResult.completions { c.label }
  let hasPrintln = false
  let hasLen = false
  for let i = 0; i < len(labels); i = i + 1 {
    if labels[i] == "println" { hasPrintln = true }
    if labels[i] == "len" { hasLen = true }
  }
  assert.truthy(hasPrintln, "Should include println builtin")
  assert.truthy(hasLen, "Should include len builtin")
})

test("query - completion includes local variables", fn(assert) {
  let source = "let x = 42\nlet y = 10\nlet z = x"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on "x" after "let z = " (line 3, col 8)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 3, 8)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.truthy(complResult.completions, "Should return completions")

  // Check that local variables are included
  let labels = collect c in complResult.completions { c.label }
  let hasX = false
  let hasY = false
  for let i = 0; i < len(labels); i = i + 1 {
    if labels[i] == "x" { hasX = true }
    if labels[i] == "y" { hasY = true }
  }
  assert.truthy(hasX, "Should include x variable")
  assert.truthy(hasY, "Should include y variable")
})

test("query - completion includes function names", fn(assert) {
  let source = "fn greet() { \"hello\" }\nfn add(a, b) { a + b }\nlet x = g"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on "g" after "let x = " (line 3, col 8)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 3, 8)
  assert.truthy(complResult.success, "Completion should succeed")

  // Check that functions are included
  let labels = collect c in complResult.completions { c.label }
  let hasGreet = false
  let hasAdd = false
  for let i = 0; i < len(labels); i = i + 1 {
    if labels[i] == "greet" { hasGreet = true }
    if labels[i] == "add" { hasAdd = true }
  }
  assert.truthy(hasGreet, "Should include greet function")
  assert.truthy(hasAdd, "Should include add function")
})

test("query - completion for nested object properties", fn(assert) {
  let source = "let obj = .{ inner: .{ x: 1, y: 2 } }\nlet val = obj.inner.x"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on "x" after "obj.inner." (line 2, col 20)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 2, 20)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.equal(len(complResult.completions), 2, "Should have 2 properties")

  let labels = collect c in complResult.completions { c.label }
  fn stringLess(a, b) {
    for let i = 0; i < len(a) and i < len(b); i = i + 1 {
      if ord(a[i]) < ord(b[i]) { return true }
      if ord(a[i]) > ord(b[i]) { return false }
    }
    len(a) < len(b)
  }
  labels = labels->sort(stringLess)
  assert.equal(labels[0], "x", "Should include x")
  assert.equal(labels[1], "y", "Should include y")
})

test("query - completion on empty object returns no results", fn(assert) {
  let source = "let obj = .{}\nlet val = obj.x"
  let result = compileAndQuery(source, "test.lx")
  assert.truthy(result.success, "Should compile successfully")

  // Complete on "x" after "obj." (line 2, col 14)
  let complResult = query.queryCompletion(result.ctx, "test.lx", 2, 14)
  assert.truthy(complResult.success, "Completion should succeed")
  assert.equal(len(complResult.completions), 0, "Empty object should have no completions")
})

// ========================================
// Issue Reproduction Tests
// ========================================

test("query - diagnostic on failed module import", fn(assert) {
  // Test that when an import fails, we get a proper diagnostic
  let source = "let mod = import \"nonexistent.lx\"\nmod"
  let result = compileAndQuery(source, "test.lx")

  // Compilation should fail
  assert.equal(result.success, false, "Should fail with missing import")

  // Should get diagnostics with proper location
  let diags = query.queryDiagnostics(result)
  println("Diags type:", type(diags))
  println("Diags length:", len(diags))
  if len(diags) > 0 {
    println("First diag:", diags[0])
  }
  assert.truthy(len(diags) > 0, "Should have diagnostics for failed import")
  assert.truthy(diags[0].filename, "Diagnostic should have filename")
  assert.truthy(diags[0].line > 0, "Diagnostic should have line number")
  assert.truthy(diags[0].message, "Diagnostic should have message")
})

test("query - module import should not stop at destructuring", fn(assert) {
  // Create fixture for destructuring import test
  let modSource = ".{ foo: 1, bar: 2, baz: 3 }"
  let useSource = "let mod = import \"destructure-target.lx\"\nlet .{ foo, bar } = mod\nfoo + bar"

  let driver = Driver.make(.{
    loadSource: fn(path) {
      if path == "test-destructure.lx" { return useSource }
      if path == "destructure-target.lx" { return modSource }
      let resolver = ModuleResolution.forEntry(Lx.args[2])
      return resolver.slurp(path)
    },
    withTypecheck: true,
    withAnf: false,
  })

  let result = driver.compileModule("test-destructure.lx")
  assert.equal(result.status, "done", "Should compile successfully")

  let initResult = query.queryInit(
    result.passes.lower.ast,
    result.passes.resolve,
    result.passes.typecheck,
    .{ buildIndex: true }
  )

  // Hover on 'foo' usage should work (line 3, col 0)
  let hoverResult = query.queryHover(initResult.ctx, "test-destructure.lx", 3, 0)
  assert.truthy(hoverResult.success, "Hover should work on destructured import binding")

  // Goto on 'foo' usage should work
  let gotoResult = query.queryGotoDefinition(initResult.ctx, "test-destructure.lx", 3, 0)
  assert.truthy(gotoResult.success, "Goto should work on destructured import binding")
})

test("query - duplicated declaration span info is correct", fn(assert) {
  // Test that duplicate declaration errors have correct span info
  let source = "let x = 1\nlet x = 2"
  let result = compileAndQuery(source, "test.lx")

  // Should fail with duplicate declaration error
  assert.equal(result.success, false, "Should fail with duplicate declaration")

  let diags = query.queryDiagnostics(result)
  assert.truthy(len(diags) > 0, "Should have diagnostics for duplicate declaration")

  // Check that the diagnostic points to the second declaration (line 2)
  let foundDup = false
  for let i = 0; i < len(diags); i = i + 1 {
    let d = diags[i]
    if d.message and (len(split(d.message, "duplicate")) > 1 or len(split(d.message, "Duplicate")) > 1) {
      foundDup = true
      assert.equal(d.filename, "test.lx", "Duplicate diagnostic should have correct filename")
      assert.equal(d.line, 2, "Duplicate diagnostic should point to second declaration")
      assert.truthy(d.col >= 0, "Duplicate diagnostic should have valid column")
      assert.truthy(d.endLine > 0, "Duplicate diagnostic should have endLine")
      assert.truthy(d.endCol > 0, "Duplicate diagnostic should have endCol")
    }
  }
  assert.truthy(foundDup, "Should find duplicate declaration diagnostic")
})

suite.run()
