// Typecheck: control flow
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError

  test("typecheck - if branches must match", fn(assert) {
    let resultMismatch = parseAndTypecheck("{ let cond = true\nif cond { 1 } else { \"x\" } }")
    assert.truthy(hasError(resultMismatch, "Branch mismatch"))
  })

  test("typecheck - no narrowing on nil check", fn(assert) {
    let result = parseAndTypecheck("{ let x = 1\nif x == nil { }\nx }")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Number")
  })

  test("typecheck - forward reference via predeclare", fn(assert) {
    // Resolve rejects use-before-declare hoisted calls, so assert the resolve error.
    let bad = parseAndTypecheck("{ use(1)\nfn use(x) { x + 1 } }")
    assert.truthy(bad.resolveErrors)

    let good = parseAndTypecheck("{ fn use(x) { x + 1 }\nuse(1) }")
    let callT = deref(good, getExprType(good, 1))
    assert.equal(callT.kind, "Number")
  })

  test("typecheck - logical and/or returns operands", fn(assert) {
    let result = parseAndTypecheck("{ \"a\" or 1\nnil or 1\nfalse and 1\nnil and 1 }")
    assert.truthy(result.success)
    if !result.success { return }

    assert.equal(deref(result, getExprType(result, 0)).kind, "String")
    assert.equal(deref(result, getExprType(result, 1)).kind, "Number")
    assert.equal(deref(result, getExprType(result, 2)).kind, "Bool")
    assert.equal(deref(result, getExprType(result, 3)).kind, "Nil")
  })

  // Nil guard narrowing tests
  test("typecheck - nil guard narrows Option to value type", fn(assert) {
    // f(nil) constrains x to Option[Number], the guard should narrow x to Number
    // so x + 1 typechecks. Return type is Option[Number] due to early return nil.
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(result.success)
    if !result.success { return }
    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    // Return type is Option[Number] because function can return nil or Number
    let retT = deref(result, ft.return)
    assert.equal(retT.kind, "Option")
    assert.equal(deref(result, retT.value).kind, "Number")
  })

  test("typecheck - nil guard with grouped condition", fn(assert) {
    // Groupings like ((!x)) should still trigger narrowing
    let result = parseAndTypecheck("{
      fn f(x) {
        if ((!x)) { return }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(result.success)
    if !result.success { return }
    let ft = deref(result, getExprType(result, 0))
    assert.equal(ft.kind, "Function")
    let retT = deref(result, ft.return)
    assert.equal(retT.kind, "Option")
    assert.equal(deref(result, retT.value).kind, "Number")
  })

  test("typecheck - nil guard only narrows in same block", fn(assert) {
    // Narrowing should not leak into closures
    // inner() captures x with original type (Option), not narrowed type
    // So inner() + 1 should FAIL because inner() returns Option
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        fn inner() { x }
        inner() + 1
      }
      f(nil)
    }")
    // This should fail because closure captures un-narrowed x (Option)
    // and inner() + 1 is Option + Number which is invalid
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard with block body that returns", fn(assert) {
    // Block body { return } should also trigger narrowing
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { { return } }
        x + 1
      }
      f(nil)
    }")
    assert.truthy(result.success)
    if !result.success { return }
    let ft = deref(result, getExprType(result, 0))
    // Return type is Option[Number] because function can return nil or Number
    let retT = deref(result, ft.return)
    assert.equal(retT.kind, "Option")
    assert.equal(deref(result, retT.value).kind, "Number")
  })

  test("typecheck - no narrowing when guard has else branch", fn(assert) {
    // if !x { return } else { ... } should NOT narrow after the if
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return } else { 0 }
        x + 1
      }
      f(nil)
    }")
    // This should fail because x is still Option after an if-else
    assert.truthy(!result.success)
  })

  test("typecheck - nil guard preserves non-Nil lower bounds", fn(assert) {
    // f(true) constrains x to have Bool as lower bound
    // After nil guard, x + 1 should still fail because x could be Bool
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return }
        x + 1
      }
      f(true)
    }")
    // This should fail: Bool is not compatible with Number for +
    assert.truthy(!result.success)
  })

  test("typecheck - constraints between guard and closure persist", fn(assert) {
    // x + 1 before the closure constrains x to Number
    // After the closure, x should still be Number
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        let y = x + 1
        fn inner() { 0 }
        x + 2
      }
      f(nil)
    }")
    assert.truthy(result.success)
    if !result.success { return }
    let ft = deref(result, getExprType(result, 0))
    let retT = deref(result, ft.return)
    assert.equal(retT.kind, "Number")
  })

  test("typecheck - narrowing only when x has Nil bound", fn(assert) {
    // f(1) constrains x to Number only (no Nil bound)
    // The nil guard shouldn't narrow x since it's not optional
    // x + 1 should still work because x is Number
    let result = parseAndTypecheck("{
      fn f(x) {
        if !x { return 0 }
        x + 1
      }
      f(1)
    }")
    assert.truthy(result.success)
  })

  // Statement position tests - if-else used for side effects only
  test("typecheck - if-else in statement position allows mismatched branches", fn(assert) {
    // When if-else result is discarded (not last expression), branches can have different types
    let result = parseAndTypecheck("{
      let x = true
      if x { 1 } else { \"string\" }
      42
    }")
    // Should succeed - the if-else is in statement position, result discarded
    assert.truthy(result.success)
  })

  test("typecheck - if-else in expression position still requires matching branches", fn(assert) {
    // When if-else is the last expression (return value), branches must match
    let result = parseAndTypecheck("{
      let x = true
      if x { 1 } else { \"string\" }
    }")
    // Should fail - the if-else is in expression position (last expr in block)
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - if-else-if chain in statement position allows mismatched branches", fn(assert) {
    // Chained if-else with different types in each branch, result discarded
    let result = parseAndTypecheck("{
      let x = 1
      if x == 1 {
        \"one\"
      } else if x == 2 {
        2
      } else {
        true
      }
      nil
    }")
    // Should succeed - the entire if chain is in statement position
    assert.truthy(result.success)
  })

  test("typecheck - nested if in statement position allows mismatch", fn(assert) {
    // Nested ifs, outer one in statement position
    let result = parseAndTypecheck("{
      let a = true
      let b = false
      if a {
        if b { 1 } else { \"inner\" }
      } else {
        nil
      }
      42
    }")
    // Should succeed - outer if is in statement position
    assert.truthy(result.success)
  })

  test("typecheck - function return still checks branch mismatch", fn(assert) {
    // Function body's last expression is always in expression position
    let result = parseAndTypecheck("{
      fn f(x) {
        if x { 1 } else { \"string\" }
      }
      f(true)
    }")
    // Should fail - function return is always used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - let binding still checks branch mismatch", fn(assert) {
    // Assigned if-else is in expression position
    let result = parseAndTypecheck("{
      let x = true
      let y = if x { 1 } else { \"string\" }
      42
    }")
    // Should fail - assigned value is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - if-else as function argument still checks branch mismatch", fn(assert) {
    // if-else passed as argument is in expression position
    let result = parseAndTypecheck("{
      fn f(x) { x }
      let cond = true
      f(if cond { 1 } else { \"string\" })
    }")
    // Should fail - argument value is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - assignment RHS checks branch mismatch even in statement position", fn(assert) {
    // assignment in non-last position, but RHS value is used
    let result = parseAndTypecheck("{
      let x = nil
      x = if true { 1 } else { \"string\" }
      42
    }")
    // Should fail - assignment RHS is used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - array element checks branch mismatch even in statement position", fn(assert) {
    // array literal in non-last position, but elements are used
    let result = parseAndTypecheck("{
      [if true { 1 } else { \"string\" }]
      42
    }")
    // Should fail - array elements are used
    assert.truthy(hasError(result, "Branch mismatch"))
  })

  test("typecheck - hashmap value checks branch mismatch even in statement position", fn(assert) {
    // hashmap literal in non-last position, but values are used
    let result = parseAndTypecheck("{
      .{ x: if true { 1 } else { \"string\" } }
      42
    }")
    // Should fail - hashmap values are used
    assert.truthy(hasError(result, "Branch mismatch"))
  })
}

.{ register }
