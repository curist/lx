// ========================================================
// Type Constructors
// ========================================================
// Reusable type representations for any type system implementation.

fn typeAny()     { .{ kind: "Any" } }
fn typeNil()     { .{ kind: "Nil" } }
fn typeNumber()  { .{ kind: "Number" } }
fn typeBool()    { .{ kind: "Bool" } }
fn typeString()  { .{ kind: "String" } }
fn typeEnum(fields) { .{ kind: "Enum", fields: fields } }

fn typeVar(id) {
  .{
    kind: "TypeVar",
    id: id,
    lowerBounds: [],  // types this var must be a supertype of
    upperBounds: [],  // types this var must be a subtype of
  }
}

fn typeFunction(params, ret) {
  .{ kind: "Function", params: params, return: ret }
}

fn typeArray(elem) {
  .{ kind: "Array", elem: elem }
}

fn typeRecord(fields) {
  .{ kind: "Record", fields: fields }
}

fn typeMap(key, elem) {
  .{ kind: "Map", key: key, elem: elem }
}

fn typeOption(value) {
  // Avoid Option[Option[T]]
  value and value.kind == "Option" and value or .{ kind: "Option", value: value }
}

fn typeIndexable(elem, key, nodeId) {
  .{
    kind: "Indexable",
    elem: elem,
    key: key,
    nodeId: nodeId,
    sawNumericIndex: false,
  }
}

// ========================================================
// Type Variable Management
// ========================================================

fn freshTypeVar(checker) {
  let id = checker.nextTypeVarId
  checker.nextTypeVarId = id + 1
  typeVar(id)
}

fn getTypeVarBinding(checker, id) {
  checker.typeVarBindings[id]
}

fn bindTypeVar(checker, id, type) {
  let old = checker.typeVarBindings[id]
  if !old {
    checker.typeVarBindings[id] = type
    if checker.changed != nil { checker.changed = true }
    return
  }

  // Avoid counting no-op rebindings as progress.
  if typeEquals(checker, old, type) {
    return
  }

  checker.typeVarBindings[id] = type
  if checker.changed != nil { checker.changed = true }
}

// ========================================================
// Type Utilities
// ========================================================

// Follow type variable bindings until fixed point
fn deref(checker, type) {
  if type.kind == "TypeVar" {
    let bound = getTypeVarBinding(checker, type.id)
    if bound {
      return deref(checker, bound)
    }
  }
  type
}

// Dereference and return both root TypeVar (if any) and final type
fn derefWithRootVar(checker, t) {
  let root = nil
  for t and t.kind == "TypeVar" {
    root = t
    let bound = getTypeVarBinding(checker, t.id)
    if !bound { break }
    t = bound
  }
  .{ root: root, type: t }
}

// Structural type equality
fn typeEquals(checker, a, b) {
  let eq
  eq = fn(x, y, depth) {
    if depth > 200 {
      // Defensive: if something went cyclic due to a bug, be conservative and
      // treat as not equal so we don't suppress progress.
      return false
    }
    x = x and deref(checker, x) or x
    y = y and deref(checker, y) or y

    if !x and !y { return true }
    if !x or !y { return false }

    // Fast paths
    if x.kind != y.kind { return false }
    if x.kind == "Any" or x.kind == "Nil" or x.kind == "Number" or
       x.kind == "Bool" or x.kind == "String" {
      return true
    }
    if x.kind == "TypeVar" { return x.id == y.id }

    if x.kind == "Array" { return eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Map" { return eq(x.key, y.key, depth + 1) and eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Option" { return eq(x.value, y.value, depth + 1) }
    if x.kind == "Indexable" { return eq(x.key, y.key, depth + 1) and eq(x.elem, y.elem, depth + 1) }
    if x.kind == "Function" {
      let xMin = (x.minArity != nil) and x.minArity or len(x.params)
      let yMin = (y.minArity != nil) and y.minArity or len(y.params)
      if xMin != yMin { return false }
      if len(x.params) != len(y.params) { return false }
      for xParam, i in x.params {
        if !eq(xParam, y.params[i], depth + 1) { return false }
      }
      return eq(x.return, y.return, depth + 1)
    }
    if x.kind == "Record" {
      let kx = keys(x.fields)
      let ky = keys(y.fields)
      if len(kx) != len(ky) { return false }
      for k in kx {
        if !y.fields[k] { return false }
        if !eq(x.fields[k], y.fields[k], depth + 1) { return false }
      }
      return true
    }
    if x.kind == "Enum" {
      // Compare enum field sets
      if !x.fields or !y.fields { return false }
      let kx = keys(x.fields)
      let ky = keys(y.fields)
      if len(kx) != len(ky) { return false }
      for k in kx {
        if y.fields[k] == nil { return false }
      }
      return true
    }

    // Fallback: treat as not equal.
    false
  }

  eq(a, b, 0)
}

// Occurs check: prevent infinite types
fn occurs(checker, typeVarId, type) {
  type = deref(checker, type)

  if type.kind == "TypeVar" {
    return type.id == typeVarId
  }

  if type.kind == "Function" {
    for param in type.params {
      if occurs(checker, typeVarId, param) {
        return true
      }
    }
    return occurs(checker, typeVarId, type.return)
  }

  if type.kind == "Array" {
    return occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Map" {
    return occurs(checker, typeVarId, type.key) or occurs(checker, typeVarId, type.elem)
  }

  if type.kind == "Option" {
    return occurs(checker, typeVarId, type.value)
  }

  if type.kind == "Record" {
    for k in keys(type.fields) {
      if occurs(checker, typeVarId, type.fields[k]) {
        return true
      }
    }
  }

  false
}

// Recursively dereference all type variables in a type
fn derefAll(checker, t) {
  t = deref(checker, t)
  if !t { return t }

  if t.kind == "Function" {
    let ps = []
    for param in t.params {
      push(ps, derefAll(checker, param))
    }
    return typeFunction(ps, derefAll(checker, t.return))
  }

  if t.kind == "Array" {
    return typeArray(derefAll(checker, t.elem))
  }

  if t.kind == "Map" {
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Option" {
    let v = derefAll(checker, t.value)
    if v and v.kind == "Nil" {
      return typeNil()
    }
    return typeOption(v)
  }

  if t.kind == "Indexable" {
    // Should be finalized away; default to Map for a stable printed type.
    return typeMap(derefAll(checker, t.key), derefAll(checker, t.elem))
  }

  if t.kind == "Record" {
    let fields = .{}
    for k in keys(t.fields) {
      fields[k] = derefAll(checker, t.fields[k])
    }
    return typeRecord(fields)
  }

  t
}

// ========================================================
// Simple-Sub Constraint Solving
// ========================================================

// Check if a type is a primitive (non-composite) type
fn isPrimitive(t) {
  t.kind == "Nil" or t.kind == "Number" or
  t.kind == "Bool" or t.kind == "String"
}

// Generate a unique key for a type (for caching)
fn typeKey(t) {
  if !t { return "nil" }
  if !t.kind { return "?" }  // Unknown type structure
  if t.kind == "TypeVar" { return "v" + str(t.id) }
  if t.kind == "Nil" or t.kind == "Number" or t.kind == "Bool" or t.kind == "String" or t.kind == "Any" {
    return t.kind
  }
  if t.kind == "Option" { return "O(" + typeKey(t.value) + ")" }
  if t.kind == "Array" { return "A(" + typeKey(t.elem) + ")" }
  if t.kind == "Map" { return "M(" + typeKey(t.key) + "," + typeKey(t.elem) + ")" }
  if t.kind == "Function" {
    let paramKeys = collect p in (t.params or []) { typeKey(p) }
    return "F(" + join(paramKeys, ",") + ")->" + typeKey(t.return)
  }
  if t.kind == "Record" {
    let fields = t.fields
    // Defensive check - ensure fields is a hashmap
    if !fields or type(fields) != "map" {
      return "R{}"
    }
    // Use unsorted keys for simplicity - ordering doesn't affect cache correctness,
    // just means potentially more cache misses for equivalent types
    let fieldKeys = keys(fields)
    let fieldStrings = []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      push(fieldStrings, str(k) + ":" + typeKey(fields[k]))
    }
    return "R{" + join(fieldStrings, ",") + "}"
  }
  if t.kind == "Enum" {
    // Encode enum fields for proper caching - different enums have different fields
    let fields = t.fields
    if !fields or type(fields) != "map" {
      return "E{}"
    }
    let fieldKeys = keys(fields)
    let fieldStrings = []
    for let i = 0; i < len(fieldKeys); i = i + 1 {
      let k = fieldKeys[i]
      push(fieldStrings, str(k))
    }
    return "E{" + join(fieldStrings, ",") + "}"
  }
  t.kind
}

// Generate a cache key for a constraint pair
// Cache all constraint pairs to prevent exponential re-checking
fn constraintCacheKey(lhs, rhs) {
  typeKey(lhs) + "<:" + typeKey(rhs)
}

// Core constraint function: enforce lhs <: rhs
// Returns true if constraint succeeded, false if it failed
fn constrain(checker, lhs, rhs) {
  // Dereference both sides (follow TypeVar bindings)
  lhs = deref(checker, lhs)
  rhs = deref(checker, rhs)

  // Identity check
  if lhs == rhs { return true }

  // Check if both are same TypeVar
  if lhs.kind == "TypeVar" and rhs.kind == "TypeVar" and lhs.id == rhs.id {
    return true
  }

  // Cache check to prevent infinite recursion and exponential re-checking
  let cacheKey = constraintCacheKey(lhs, rhs)
  if checker.constraintCache[cacheKey] { return true }
  checker.constraintCache[cacheKey] = true

  // Rule: Any <: T and T <: Any always hold
  if lhs.kind == "Any" or rhs.kind == "Any" { return true }

  // Rule: T? <: U? => constrain(T, U) - MUST come before general Option rules
  if lhs.kind == "Option" and rhs.kind == "Option" {
    return constrain(checker, lhs.value, rhs.value)
  }

  // Rule: Nil <: T? (Nil is subtype of Option)
  if lhs.kind == "Nil" and rhs.kind == "Option" { return true }

  // Rule: T <: T? (value is subtype of optional)
  if rhs.kind == "Option" {
    // T <: U? allowed if T <: U or T is Nil
    if lhs.kind == "Nil" { return true }
    return constrain(checker, lhs, rhs.value)
  }

  // TypeVar cases - propagate bounds
  // NOTE: These must come BEFORE "Option <: concrete" check because
  // Option[T] can be a valid bound for a TypeVar
  if lhs.kind == "TypeVar" {
    // Occurs check: lhs cannot appear inside rhs (would create infinite type)
    if occurs(checker, lhs.id, rhs) {
      return false
    }
    // Add rhs to lhs.upperBounds
    push(lhs.upperBounds, rhs)
    // Propagate: for each lb in lhs.lowerBounds, constrain(lb, rhs)
    for lb in lhs.lowerBounds {
      if !constrain(checker, lb, rhs) { return false }
    }
    return true
  }

  if rhs.kind == "TypeVar" {
    // Occurs check: rhs cannot appear inside lhs (would create infinite type)
    if occurs(checker, rhs.id, lhs) {
      return false
    }
    // Check for conflicts with existing lower bounds
    // Two concrete primitives (e.g., Number and String) cannot both be subtypes
    // EXCEPT: Nil can coexist with any type (will coalesce to Option[T])
    if isPrimitive(lhs) and lhs.kind != "Nil" {
      for lb in rhs.lowerBounds {
        let dlb = deref(checker, lb)
        // Skip Nil in conflict check - Nil + T â†’ Option[T]
        if dlb.kind == "Nil" { continue }
        if isPrimitive(dlb) and dlb.kind != lhs.kind {
          return false  // Conflict: different concrete primitives
        }
      }
    }
    // Check for Record field conflicts
    if lhs.kind == "Record" {
      for lb in rhs.lowerBounds {
        let dlb = deref(checker, lb)
        if dlb.kind == "Record" {
          // Check overlapping fields for type conflicts
          let lhsFields = lhs.fields or .{}
          let lbFields = dlb.fields or .{}
          for k in keys(lhsFields) {
            let lbField = lbFields[k]
            if lbField {
              let lhsFieldD = deref(checker, lhsFields[k])
              let lbFieldD = deref(checker, lbField)
              // If both are concrete primitives and different, conflict
              if isPrimitive(lhsFieldD) and isPrimitive(lbFieldD) and lhsFieldD.kind != lbFieldD.kind {
                return false  // Conflict: different field types
              }
            }
          }
        }
      }
    }
    // Add lhs to rhs.lowerBounds
    push(rhs.lowerBounds, lhs)
    // Propagate: for each ub in rhs.upperBounds, constrain(lhs, ub)
    for ub in rhs.upperBounds {
      if !constrain(checker, lhs, ub) { return false }
    }
    return true
  }

  // Rule: Option[T] <: concrete non-Option fails (cannot drop optionality)
  // This must come AFTER TypeVar cases since Option can be a valid TypeVar bound
  if lhs.kind == "Option" { return false }

  // Primitives: must be same kind
  if isPrimitive(lhs) and isPrimitive(rhs) {
    return lhs.kind == rhs.kind
  }

  // Function: contravariant params, covariant return
  if lhs.kind == "Function" and rhs.kind == "Function" {
    let lhsParams = lhs.params or []
    let rhsParams = rhs.params or []

    // For function subtyping, we need:
    // - rhs can accept at least as many params as lhs requires
    // - For shared params, contravariant: rhsParam <: lhsParam
    let lhsLen = len(lhsParams)
    let rhsLen = len(rhsParams)
    let minLen = lhsLen < rhsLen and lhsLen or rhsLen

    // Contravariant params: constrain(rhsParam, lhsParam)
    for let i = 0; i < minLen; i = i + 1 {
      if !constrain(checker, rhsParams[i], lhsParams[i]) { return false }
    }

    // Covariant return: constrain(lhsRet, rhsRet)
    return constrain(checker, lhs.return, rhs.return)
  }

  // Record: width + depth subtyping
  // Record(fs0) <: Record(fs1) => for each field in fs1, fs0 must have it with subtype
  if lhs.kind == "Record" and rhs.kind == "Record" {
    let lhsFields = lhs.fields or .{}
    let rhsFields = rhs.fields or .{}

    // For each field in rhs, lhs must have that field with subtype
    for k in keys(rhsFields) {
      let lhsField = lhsFields[k]
      if !lhsField {
        return false  // Missing required field
      }
      if !constrain(checker, lhsField, rhsFields[k]) { return false }
    }
    return true  // Extra fields in lhs are OK (width subtyping)
  }

  // Array: covariant element type
  if lhs.kind == "Array" and rhs.kind == "Array" {
    return constrain(checker, lhs.elem, rhs.elem)
  }

  // Map: covariant in both key and elem
  if lhs.kind == "Map" and rhs.kind == "Map" {
    return constrain(checker, lhs.key, rhs.key) and
           constrain(checker, lhs.elem, rhs.elem)
  }

  // Enum: check field compatibility
  if lhs.kind == "Enum" and rhs.kind == "Enum" {
    let lhsFields = lhs.fields or .{}
    let rhsFields = rhs.fields or .{}
    for k in keys(rhsFields) {
      if lhsFields[k] == nil { return false }
    }
    return true
  }

  // No rule applies
  false
}

// Coalesce a TypeVar's bounds into a final type
// If Nil appears alongside non-nil lower bounds, produce Option[T]
// When bounds disagree (different concrete types), fall back to Any
fn coalesceTypeVar(checker, tv) {
  if !tv or tv.kind != "TypeVar" { return tv }

  let lbs = tv.lowerBounds or []

  // Check if Nil appears in lower bounds
  let hasNil = false
  let nonNilBounds = []
  for lb in lbs {
    let dlb = deref(checker, lb)
    if dlb.kind == "Nil" {
      hasNil = true
    } else if dlb.kind == "TypeVar" {
      // Recursively coalesce nested TypeVars
      let coalesced = coalesceTypeVar(checker, dlb)
      if coalesced.kind == "Nil" {
        hasNil = true
      } else if coalesced.kind == "Option" {
        hasNil = true
        push(nonNilBounds, coalesced.value)
      } else if coalesced.kind != "TypeVar" {
        push(nonNilBounds, coalesced)
      }
    } else {
      push(nonNilBounds, dlb)
    }
  }

  // Check if all non-nil bounds are compatible
  // Bounds are compatible if they're all the same primitive kind, or all Records
  let resultType = nil
  if len(nonNilBounds) > 0 {
    let firstKind = nonNilBounds[0].kind
    let allCompatible = true

    for let i = 1; i < len(nonNilBounds); i = i + 1 {
      let bound = nonNilBounds[i]
      if bound.kind != firstKind {
        // Different kinds - check if we can still merge (e.g., Records can merge fields)
        if firstKind != "Record" or bound.kind != "Record" {
          allCompatible = false
          break
        }
      }
    }

    if allCompatible {
      if firstKind == "Record" and len(nonNilBounds) > 1 {
        // Merge Record fields from all bounds with conflict detection
        let mergedFields = .{}
        let fieldConflict = false
        for bound in nonNilBounds {
          let fields = bound.fields or .{}
          for k in keys(fields) {
            let newType = fields[k]
            if !mergedFields[k] {
              mergedFields[k] = newType
            } else {
              // Field already exists - check for conflicts
              let existingType = mergedFields[k]
              let existingD = deref(checker, existingType)
              let newD = deref(checker, newType)

              // Check if types are compatible
              if existingD.kind and newD.kind {
                // Both are concrete - check if same kind
                if isPrimitive(existingD) and isPrimitive(newD) {
                  if existingD.kind != newD.kind {
                    // Primitive conflict (e.g., Number vs String)
                    fieldConflict = true
                    break
                  }
                } else if existingD.kind != newD.kind {
                  // Different structural kinds (e.g., Record vs Array)
                  if existingD.kind != "TypeVar" and newD.kind != "TypeVar" {
                    fieldConflict = true
                    break
                  }
                }
              }
              // Keep existing type (first wins for compatible types)
            }
          }
          if fieldConflict { break }
        }
        if fieldConflict {
          resultType = typeAny()
        } else {
          resultType = typeRecord(mergedFields)
        }
      } else {
        resultType = nonNilBounds[0]
      }
    } else {
      // Incompatible bounds - fall back to Any
      resultType = typeAny()
    }
  }

  // If we have Nil + other types, coalesce to Option[T]
  if hasNil and resultType {
    return typeOption(resultType)
  }

  // If only Nil bounds, return Nil
  if hasNil and !resultType {
    return typeNil()
  }

  // Return the merged result if we have one
  if resultType {
    return resultType
  }

  // Check upper bounds for a concrete type
  let ubs = tv.upperBounds or []
  for ub in ubs {
    let dub = deref(checker, ub)
    if dub.kind != "TypeVar" {
      return dub
    }
  }

  // Still a type variable - return the TypeVar itself (not Any)
  tv
}

// Pretty-print a type for error messages
fn prettyType(checker, t) {
  t = deref(checker, t)
  if !t { return "?" }

  if t.kind == "TypeVar" {
    let coalesced = coalesceTypeVar(checker, t)
    if coalesced.kind != "TypeVar" {
      return prettyType(checker, coalesced)
    }
    return "?" + str(t.id)
  }

  if t.kind == "Option" {
    return prettyType(checker, t.value) + "?"
  }

  if t.kind == "Array" {
    return "Array[" + prettyType(checker, t.elem) + "]"
  }

  if t.kind == "Map" {
    return "Map[" + prettyType(checker, t.key) + ", " + prettyType(checker, t.elem) + "]"
  }

  if t.kind == "Function" {
    let params = collect p in (t.params or []) { prettyType(checker, p) }
    return "(" + join(params, ", ") + ") -> " + prettyType(checker, t.return)
  }

  if t.kind == "Record" {
    // Sort keys for consistent output
    let sortedKeys = sort(keys(t.fields or .{}), stringLess)
    let fieldStrs = collect k in sortedKeys {
      str(k) + ": " + prettyType(checker, t.fields[k])
    }
    return ".{ " + join(fieldStrs, ", ") + " }"
  }

  if t.kind == "Enum" {
    // Sort keys for consistent output
    let sortedKeys = sort(keys(t.fields or .{}), stringLess)
    let fieldStrs = collect k in sortedKeys { str(k) }
    return "enum { " + join(fieldStrs, ", ") + " }"
  }

  t.kind
}

// ========================================================
// Builtin Type Signatures
// ========================================================
// Comprehensive catalog of stdlib function types.
// Note: Some builtins (push, pop, concat, reverse, slice, each, fold, take, drop, sort, _1, _2)
// use freshTypeVar and thus require a checker context with nextTypeVarId.

let BUILTIN_TYPES = .{
  // Basic I/O (variadic-ish): model as 0-arg fn returning Nil
  print: typeFunction([], typeNil()),
  println: typeFunction([], typeNil()),

  // String operations
  str: typeFunction([typeAny()], typeString()),
  join: typeFunction([typeArray(typeAny()), typeString()], typeString()),
  split: typeFunction([typeString(), typeString()], typeArray(typeString())),
  substr: typeFunction([typeString(), typeNumber()], typeString()),
  startsWith: typeFunction([typeString(), typeString()], typeBool()),
  endsWith: typeFunction([typeString(), typeString()], typeBool()),
  contains: typeFunction([typeAny(), typeAny()], typeBool()),
  tolower: typeFunction([typeString()], typeString()),
  toupper: typeFunction([typeString()], typeString()),
  tonumber: typeFunction([typeString()], typeNumber()),
  chr: typeFunction([typeNumber()], typeString()),
  ord: typeFunction([typeString()], typeNumber()),

  // Reflection
  type: typeFunction([typeAny()], typeString()),
  nameOf: .{ kind: "Function", params: [typeAny(), typeAny()], return: typeOption(typeString()), builtinName: "nameOf" },

  // Collections (special handling at call sites)
  len: .{ kind: "Function", params: [typeAny()], return: typeNumber(), builtinName: "len" },
  range: .{ kind: "Function", params: [typeAny()], return: typeArray(typeAny()), builtinName: "range" },
  keys: .{ kind: "Function", params: [typeAny()], return: typeArray(typeAny()), builtinName: "keys" },

  // Namespaced builtins
  Math: typeRecord(.{
    floor: typeFunction([typeNumber()], typeNumber()),
    sqrt: typeFunction([typeNumber()], typeNumber()),
    random: typeFunction([], typeNumber()),
    max: typeFunction([], typeNumber()),  // variadic
    min: typeFunction([], typeNumber()),  // variadic
  }),

  Date: typeRecord(.{
    RFC3339: typeString(),
    now: typeFunction([], typeNumber()),
    nanotime: typeFunction([], typeNumber()),
    format: typeFunction([typeNumber()], typeString()),
    parse: typeFunction([typeString(), typeString()], typeNumber()),
  }),

  Lx: typeRecord(.{
    args: typeArray(typeString()),
    env: typeMap(typeString(), typeString()),
    version: typeString(),
    globals: typeFunction([], typeArray(typeAny())),
    doubleToUint8Array: typeFunction([typeNumber()], typeArray(typeNumber())),
    isLxObj: typeFunction([typeAny()], typeBool()),
    loadObj: typeFunction([typeAny()], typeAny()),
    pcall: typeFunction([typeAny()], typeRecord(.{
      ok: typeBool(),
      value: typeAny(),
      error: typeAny(),
    })),
    error: typeFunction([typeAny()], typeNil()),
    fs: typeRecord(.{
      cwd: typeFunction([], typeString()),
      exists: typeFunction([typeString()], typeBool()),
      stat: typeFunction([typeString()], typeOption(typeAny())),
      realpath: typeFunction([typeString()], typeOption(typeString())),
      readFile: typeFunction([typeString()], typeString()),
      writeFile: typeFunction([typeString(), typeString()], typeBool()),
    }),
    path: typeRecord(.{
      join: typeFunction([], typeString()),
      dirname: typeFunction([typeString()], typeString()),
      basename: typeFunction([typeString()], typeString()),
    }),
    stdout: typeRecord(.{
      flush: typeFunction([], typeNil()),
      isTTY: typeFunction([], typeBool()),
      putc: typeFunction([], typeNil()),
    }),
    stderr: typeRecord(.{
      print: typeFunction([], typeNil()),
      println: typeFunction([], typeNil()),
      flush: typeFunction([], typeNil()),
      isTTY: typeFunction([], typeBool()),
    }),
    stdin: typeRecord(.{
      readAll: typeFunction([], typeString()),
      readLine: typeFunction([], typeOption(typeString())),
      readBytes: typeFunction([typeNumber()], typeOption(typeString())),
      readFd: typeFunction([typeNumber()], typeOption(typeString())),
      poll: typeFunction([typeNumber()], typeBool()),
      unbuffered: typeFunction([], typeNil()),
    }),
    proc: typeRecord(.{
      system: typeFunction([typeString()], typeNumber()),
      exec: typeFunction([typeString()], typeRecord(.{
        code: typeNumber(),
        out: typeString(),
      })),
    }),
    zlib: typeRecord(.{
      deflate: typeFunction([typeArray(typeNumber())], typeArray(typeNumber())),
      inflate: typeFunction([typeArray(typeNumber())], typeArray(typeNumber())),
      crc32: typeFunction([typeAny()], typeNumber()),
    }),
    exit: typeFunction([], typeNil()),
  }),

  // Prelude builtins (from globals.lx)
  first: typeFunction([typeAny()], typeAny()),
  last: typeFunction([typeAny()], typeAny()),
}

let PARAMETRIC_BUILTIN_TYPES = .{
  // Array operations
  push: fn(checker) {
    let elem = freshTypeVar(checker)
    let arr = typeArray(elem)
    typeFunction([arr, elem], arr)
  },
  pop: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem)], typeOption(elem))
  },
  concat: fn(checker) {
    let elem = freshTypeVar(checker)
    let arr = typeArray(elem)
    typeFunction([arr, arr], arr)
  },
  reverse: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem)], typeArray(elem))
  },
  slice: fn(checker) {
    let elem = freshTypeVar(checker)
    typeFunction([typeArray(elem), typeNumber()], typeArray(elem))
  },

  // Prelude collection helpers
  each: fn(checker) {
    let t = freshTypeVar(checker)
    let abort = typeFunction([], typeNil())
    let cb = typeFunction([t, typeNumber(), typeArray(t), abort], typeAny())
    typeFunction([typeArray(t), cb], typeNil())
  },
  fold: fn(checker) {
    let t = freshTypeVar(checker)
    let acc = freshTypeVar(checker)
    let abort = typeFunction([], typeNil())
    let cb = typeFunction([acc, t, typeNumber(), abort], acc)
    typeFunction([typeArray(t), acc, cb], acc)
  },
  take: fn(checker) {
    let t = freshTypeVar(checker)
    typeFunction([typeArray(t), typeNumber()], typeArray(t))
  },
  drop: fn(checker) {
    let t = freshTypeVar(checker)
    typeFunction([typeArray(t), typeNumber()], typeArray(t))
  },
  sort: fn(checker) {
    let t = freshTypeVar(checker)
    let cmp = typeFunction([t, t], typeBool())
    typeFunction([typeArray(t), cmp], typeArray(t))
  },
}

fn builtinTypeByName(checker, name) {
  // Check static table first (O(1) lookup)
  if let staticType = BUILTIN_TYPES[name] {
    return staticType
  }

  // Check parametric table (O(1) lookup + function call)
  if let parametricFn = PARAMETRIC_BUILTIN_TYPES[name] {
    return parametricFn(checker) 
  }

  nil
}

// ========================================================
// Worklist Solver
// ========================================================
// Repeatedly scans `items`, removing the ones `trySolve(item)` can solve.
// Returns the remaining (unsolved) items once no progress is made.
fn solveWorklist(items, trySolve, opts = .{}) {
  let maxRounds = opts.maxRounds or 1000
  let progress = opts.progress
  let resetProgress = opts.resetProgress

  let round = 0 // number of completed rounds
  let remaining = items or []
  let hitMaxRounds = false

  for round < maxRounds {
    if len(remaining) == 0 { break }
    round = round + 1

    if resetProgress { resetProgress() }

    let work = remaining
    remaining = []
    let solved = 0

    for item in work {
      if trySolve(item) {
        solved = solved + 1
      } else {
        push(remaining, item)
      }
    }

    let didProgress = progress and progress() or solved > 0
    if !didProgress { break }
  }

  if round == maxRounds and len(remaining) > 0 {
    hitMaxRounds = true
    if opts.onMaxRounds {
      opts.onMaxRounds(.{ rounds: round, remaining: remaining })
    }
  }

  .{
    remaining: remaining,
    rounds: round,
    hitMaxRounds: hitMaxRounds,
  }
}

// Tarjan SCC.
// - `nodes`: array of node ids (string/number)
// - `edgesFor`: fn(nodeId) -> array of neighbor node ids
// Returns:
//   .{ components: [[nodeId]], componentOf: .{ [nodeId]: compIndex } }
fn scc(nodes, edgesFor) {
  let indexBy = .{}   // nodeId -> index
  let lowBy = .{}     // nodeId -> lowlink
  let onStack = .{}   // nodeId -> bool
  let stack = []
  let nextIndex = 0

  let components = []
  let componentOf = .{}

  let strongConnect
  strongConnect = fn(v) {
    indexBy[v] = nextIndex
    lowBy[v] = nextIndex
    nextIndex = nextIndex + 1

    push(stack, v)
    onStack[v] = true

    let neighbors = (edgesFor and edgesFor(v)) or []
    for w in neighbors {
      if indexBy[w] == nil {
        strongConnect(w)
        lowBy[v] = Math.min(lowBy[v], lowBy[w])
      } else if onStack[w] {
        lowBy[v] = Math.min(lowBy[v], indexBy[w])
      }
    }

    if lowBy[v] == indexBy[v] {
      let comp = []
      for true {
        let w = pop(stack)
        onStack[w] = false
        push(comp, w)
        if w == v { break }
      }

      let compIndex = len(components)
      for c in comp {
        componentOf[c] = compIndex
      }
      push(components, comp)
    }
  }

  for v in nodes {
    if indexBy[v] == nil {
      strongConnect(v)
    }
  }

  .{ components, componentOf }
}

// Returns SCCs in a topological order of the condensation graph.
fn sccTopo(nodes, edgesFor) {
  let out = scc(nodes, edgesFor)
  let comps = out.components
  let compOf = out.componentOf

  // compEdges: compIndex -> set of neighbor compIndex
  let compEdges = []
  let indegree = []
  for comp in comps {
    push(compEdges, .{})
    push(indegree, 0)
  }

  for v in nodes {
    let vComp = compOf[v]
    let neighbors = (edgesFor and edgesFor(v)) or []
    for w in neighbors {
      let wComp = compOf[w]
      if vComp != wComp {
        // Dedup edges with a set.
        if !compEdges[vComp][wComp] {
          compEdges[vComp][wComp] = true
          indegree[wComp] = indegree[wComp] + 1
        }
      }
    }
  }

  // Kahn's algorithm over SCC DAG.
  let queue = []
  for deg, i in indegree {
    if deg == 0 { push(queue, i) }
  }

  let order = []
  let head = 0
  for head < len(queue) {
    let c = queue[head]
    head = head + 1
    push(order, c)

    for n in keys(compEdges[c]) {
      indegree[n] = indegree[n] - 1
      if indegree[n] == 0 { push(queue, n) }
    }
  }

  let orderedComps = []
  for idx in order {
    push(orderedComps, comps[idx])
  }

  .{
    components: orderedComps,
    componentOf: compOf,
    componentOrder: order,
  }
}

// ========================================================
// Exports
// ========================================================

.{
  // Type constructors
  typeAny,
  typeNil,
  typeNumber,
  typeBool,
  typeString,
  typeEnum,
  typeVar,
  typeFunction,
  typeArray,
  typeRecord,
  typeMap,
  typeOption,
  typeIndexable,

  // Type variable management
  freshTypeVar,
  getTypeVarBinding,
  bindTypeVar,

  // Type utilities
  deref,
  derefWithRootVar,
  typeEquals,
  occurs,
  derefAll,

  // Simple-Sub constraint solving
  isPrimitive,
  constrain,
  coalesceTypeVar,
  prettyType,

  // Builtin catalog
  builtinTypeByName,

  // Algorithms
  solveWorklist,
  scc,
  sccTopo,
}
