// Typecheck: records and field access
let helpers = import "test/typecheck/helpers.lx"

fn register(test) {
  let parseAndTypecheck = helpers.parseAndTypecheck
  let getExprType = helpers.getExprType
  let deref = helpers.deref
  let hasError = helpers.hasError
  let hasErrorContains = fn(result, needle) {
    for let i = 0; i < len(result.errors); i = i + 1 {
      if contains(result.errors[i].message, needle) { return true }
    }
    false
  }

  test("typecheck - record literal and field access", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1, b: 2 }\nr.a }")
    let recordT = deref(result, getExprType(result, 0))
    assert.equal(recordT.kind, "Record")
    assert.equal(deref(result, recordT.fields["a"]).kind, "Number")
    assert.equal(deref(result, recordT.fields["b"]).kind, "Number")
    let fieldT = deref(result, getExprType(result, 1))
    assert.equal(fieldT.kind, "Number")
  })

  test("typecheck - missing record field reports error", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ a: 1 }\nr.b }")
    assert.truthy(hasError(result, "Missing field: b"))
  })

  test("typecheck - nil field makes optional field type", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ foo: nil }\nr.foo }")
    let fieldT = deref(result, getExprType(result, 1))
    assert.equal(fieldT.kind, "Option")
  })

  test("typecheck - missing optional field allowed in assignment", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ foo: nil }\nr = .{} }")
    assert.truthy(result.success)
  })

  test("typecheck - missing non-optional field rejects assignment", fn(assert) {
    let result = parseAndTypecheck("{ let r = .{ foo: 1 }\nr = .{} }")
    assert.truthy(hasErrorContains(result, "Assignment mismatch"))
  })

  test("typecheck - call propagates record field into function return", fn(assert) {
    let result = parseAndTypecheck("{ fn getName(x) { x.name }\nlet a = .{ name: \"A\" }\ngetName(a) }")
    let fnT = deref(result, getExprType(result, 0))
    let callT = deref(result, getExprType(result, 2))
    assert.equal(fnT.kind, "Function")
    assert.equal(deref(result, fnT.params[0]).kind, "Record")
    assert.equal(deref(result, fnT.return).kind, "String")
    assert.equal(callT.kind, "String")
  })

  test("typecheck - numeric field propagation via call", fn(assert) {
    let result = parseAndTypecheck("{ fn getA(x) { x.a }\nlet r = .{ a: 1 }\ngetA(r) }")
    let fnT = deref(result, getExprType(result, 0))
    let callT = deref(result, getExprType(result, 2))
    assert.equal(deref(result, fnT.params[0]).kind, "Record")
    assert.equal(deref(result, fnT.return).kind, "Number")
    assert.equal(callT.kind, "Number")
  })

  test("typecheck - missing record field surfaces error at call", fn(assert) {
    let result = parseAndTypecheck("{ fn getA(x) { x.a }\nlet b = .{ b: 1 }\ngetA(b) }")
    assert.truthy(
      hasErrorContains(result, "Argument 1 (x) mismatch in call to getA") or
      hasError(result, "Missing field: a")
    )
  })

  test("typecheck - dot on non-record contains to Any", fn(assert) {
    let result = parseAndTypecheck("{ let n = 1\nn.x }")
    let t = deref(result, getExprType(result, 1))
    assert.equal(t.kind, "Any")
    assert.truthy(len(result.errors) > 0)
  })

  test("typecheck - conflicting call shapes degrade to Any", fn(assert) {
    let result = parseAndTypecheck("{ fn pick(x) { x.v }\nlet a = .{ v: 1 }\nlet b = .{ v: \"s\" }\npick(a)\npick(b) }")
    let secondCall = deref(result, getExprType(result, 4))
    assert.truthy(secondCall.kind == "Any" or secondCall.kind == "Number")
    assert.truthy(len(result.errors) > 0)
  })

  test("typecheck - dot assignment constrains field type", fn(assert) {
    // Demonstrates current limitation: dot-assignment does not constrain the field.
    let result = parseAndTypecheck("{ let x\nlet r = .{ x }\nr.x = 2\nr.x }")
    let t = deref(result, getExprType(result, 3))
    assert.equal(t.kind, "Number")
  })

  test("typecheck - dot assignment mismatch reports error", fn(assert) {
    // If dot-assignment is typed, the second write should mismatch the first.
    let result = parseAndTypecheck("{ let x\nlet r = .{ x }\nr.x = 1\nr.x = \"s\" }")
    assert.truthy(hasError(result, "Assignment mismatch"))
  })

  test("typecheck - dot assignment on nil-initialized rejects field access", fn(assert) {
    // `let x` means x is nil at runtime, can't access fields on nil
    let result = parseAndTypecheck("{ let x\nx.a = 1 }")
    assert.truthy(!result.success)
  })

  test("typecheck - dot assignment on concrete record rejects new fields", fn(assert) {
    // Closed record model: can't add fields to a concrete record type
    let result = parseAndTypecheck("{ let x = .{ b: 1 }\nx.a = 1 }")
    assert.truthy(hasError(result, "Missing field: a"))
  })

  test("typecheck - computed key from record literal value is allowed", fn(assert) {
    let result = parseAndTypecheck("{ let Keys = .{ A: \"a\" }\nlet r = .{ [Keys.A]: 1 }\nr.a }")
    assert.truthy(!hasError(result, "Record literal computed key must be a literal string, number, or enum member."))
    let t = deref(result, getExprType(result, 2))
    assert.equal(t.kind, "Number")
  })

  test("typecheck - keys(record) index allows calls", fn(assert) {
    let result = parseAndTypecheck("{
      let Spec = .{
        a: .{ requires: fn() { 1 } },
        b: .{ requires: fn() { 2 } },
      }
      for k in keys(Spec) {
        Spec[k].requires()
      }
    }")
    assert.truthy(result.success)
  })

  test("typecheck - keys(record) via let index allows calls", fn(assert) {
    let result = parseAndTypecheck("{
      let Spec = .{
        a: .{ requires: fn() { 1 } },
        b: .{ requires: fn() { 2 } },
      }
      let ks = keys(Spec)
      for k in ks {
        Spec[k].requires()
      }
    }")
    assert.truthy(result.success)
  })
}

.{ register }
