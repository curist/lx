// Simple-Sub Type Checker for lx
//
// Implements Simple-Sub type inference with:
// - Subtyping constraints via constrain(lhs, rhs) enforcing lhs <: rhs
// - Type variables with mutable bounds (lowerBounds/upperBounds)
// - Functions + Records + Nil/Option support
// - Monomorphic let bindings

let helper = import "src/passes/analysis/typecheck/helpers.lx"
let factsModule = import "src/passes/analysis/typecheck/facts.lx"
let rulesModule = import "src/passes/analysis/typecheck/rules.lx"
let .{ NODE } = import "src/types.lx"

// Import utilities from facts module
let unwrapGroupings = factsModule.unwrapGroupings
let branchAlwaysReturns = factsModule.branchAlwaysReturns
let isNilGuard = factsModule.isNilGuard
let computeFacts = factsModule.computeFacts

// ========================================================
// Type Constructors and Utilities (from helper)
// ========================================================

let typeAny = helper.typeAny
let typeNil = helper.typeNil
let typeNumber = helper.typeNumber
let typeBool = helper.typeBool
let typeString = helper.typeString
let typeArray = helper.typeArray
let typeFunction = helper.typeFunction
let typeRecord = helper.typeRecord
let typeMap = helper.typeMap
let typeEnum = helper.typeEnum
let typeIndexable = helper.typeIndexable
let typeBottom = helper.typeBottom
let typeUnion = helper.typeUnion
let typeIntersect = helper.typeIntersect
let typeNot = helper.typeNot
let typeOption = helper.typeOption
let typeTag = helper.typeTag
let freshTypeVar = helper.freshTypeVar
let deref = helper.deref
let derefAll = helper.derefAll
let constrain = helper.constrain
let prettyType = helper.prettyType
let prettyTypeSnapshot = helper.prettyTypeSnapshot
let coalesceTypeVar = helper.coalesceTypeVar
let typeHasNilEvidence = helper.typeHasNilEvidence
let isSubtype = helper.isSubtype

// Check if a type is "optionalish" (has Nil evidence or might become optional)
// Narrowing should only happen when the type could be nil
//
// NOTE: We allow narrowing on empty-bounds TypeVars. At function-body time,
// parameters have no bounds yet; call-site evidence (e.g., f(nil)) arrives
// later. The narrowedTo back-link ensures any later non-Nil bounds propagate
// and keep the type sound. This is "might be optional" semantics rather than
// strict "is optional", but it's necessary for single-pass body synthesis.
fn isOptionalish(checker, t) {
  t = deref(checker, t)
  if !t { return false }
  typeHasNilEvidence(checker, t)
}

// Clone a type tree and freshen TypeVars to avoid cross-module ID collisions.
fn cloneType(checker, t, memo) {
  if !t { return t }

  if t.kind == "TypeVar" {
    let existing = memo[t.id]
    if existing { return existing }
    let fresh = freshTypeVar(checker)
    memo[t.id] = fresh
    let lbs = t.lowerBounds or []
    let ubs = t.upperBounds or []
    fresh.lowerBounds = collect lb in lbs { cloneType(checker, lb, memo) }
    fresh.upperBounds = collect ub in ubs { cloneType(checker, ub, memo) }
    fresh
  } else if t.kind == "Union" {
    let options = collect opt in (t.options or []) { cloneType(checker, opt, memo) }
    typeUnion(options)
  } else if t.kind == "Intersect" {
    let parts = collect part in (t.parts or []) { cloneType(checker, part, memo) }
    typeIntersect(parts)
  } else if t.kind == "Not" {
    typeNot(cloneType(checker, t.value, memo))
  } else if t.kind == "Option" {
    typeOption(cloneType(checker, t.value, memo))
  } else if t.kind == "Array" {
    typeArray(cloneType(checker, t.elem, memo))
  } else if t.kind == "Map" {
    typeMap(cloneType(checker, t.key, memo), cloneType(checker, t.elem, memo))
  } else if t.kind == "Function" {
    let params = collect p in (t.params or []) { cloneType(checker, p, memo) }
    let ret = cloneType(checker, t.return, memo)
    let fnType = typeFunction(params, ret)
    if t.minArity != nil { fnType.minArity = t.minArity }
    if t.paramNames != nil { fnType.paramNames = t.paramNames }
    if t.builtinName != nil { fnType.builtinName = t.builtinName }
    fnType
  } else if t.kind == "Record" {
    let fields = .{}
    for k in keys(t.fields or .{}) {
      fields[k] = cloneType(checker, t.fields[k], memo)
    }
    typeRecord(fields)
  } else if t.kind == "Enum" {
    let fields = .{}
    for k in keys(t.fields or .{}) { fields[k] = t.fields[k] }
    let out = typeEnum(fields)
    if t.enumId != nil { out.enumId = t.enumId }
    if t.enumName != nil { out.enumName = t.enumName }
    out
  } else if t.kind == "Tag" {
    typeTag(t.enumId, t.enumName, t.memberName, t.value)
  } else if t.kind == "Indexable" {
    let out = typeIndexable(
      cloneType(checker, t.elem, memo),
      cloneType(checker, t.key, memo),
      t.nodeId
    )
    out.sawNumericIndex = t.sawNumericIndex
    out
  } else {
    t
  }
}

fn recordLiteralValues(node) {
  if !node or node.type != NODE.Hashmap { return nil }
  let pairs = node.pairs or []
  let values = .{}
  for pair in pairs {
    let keyNode = unwrapGroupings(pair.key)
    let valueNode = unwrapGroupings(pair.value)
    let key = nil
    if keyNode and keyNode.type == NODE.String {
      key = keyNode.value
    } else if keyNode and keyNode.type == NODE.Number {
      key = keyNode.value
    } else {
      return nil
    }
    if !valueNode { return nil }
    if valueNode.type == NODE.String {
      values[key] = valueNode.value
    } else if valueNode.type == NODE.Number {
      values[key] = valueNode.value
    } else {
      return nil
    }
  }
  values
}

// ========================================================
// Checker State
// ========================================================

fn makeChecker(resolveResult, opts = .{}) {
  .{
    // === Data from other passes ===
    resolveResult: resolveResult,
    resolvedNames: resolveResult.resolvedNames,  // Identifier -> binding info
    enumInfo: opts.enumInfo or .{},              // Node ID -> enum metadata
    program: opts.program,                       // Program-level context
    recordValueBindings: .{},                    // declId -> { fieldName: literalValue }

    // === Result accumulation ===
    types: .{},                                  // Node ID -> inferred type
    errors: [],                                  // Collected errors
    hadError: false,

    // === Type inference state ===
    nextTypeVarId: 1,                            // For generating fresh type vars
    typeVarBindings: .{},                        // For backward compat with deref
    constraintCache: .{},                        // Prevent infinite recursion in constrain
    subtypeCache: .{},                           // Cache for subtype checks
    derefEpoch: 0,                               // Current epoch for deref cycle detection
    derefSeen: .{},                              // TypeVar ID -> epoch (reused across deref calls)
    constraintRevision: 0,                       // Incremented when bounds are added (for coalesce cache)

    // === Environment ===
    env: .{},                                    // declNodeId -> type (for locals/upvalues)
    currentReturn: nil,                          // Current function's return type var

    // === Fiber context (for incremental/cancellable typecheck) ===
    fiberCtx: opts.fiberCtx or nil,              // Optional fiber context for yielding
    nodesProcessed: 0,                           // Counter for progress tracking
    yieldInterval: 50,                           // Yield every N nodes (throttling)

    // facts: will be set after makeChecker() by typecheck()
  }
}

// ========================================================
// Error Reporting Pattern
// ========================================================

fn addError(checker, nodeId, message) {
  checker.hadError = true
  push(checker.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================================
// Fiber Support (Progress & Cancellation)
// ========================================================

// Check if we should yield for progress reporting / cancellation
// Returns true if cancelled (caller should abort)
fn maybeYield(checker) {
  if !checker.fiberCtx { return false }

  checker.nodesProcessed = checker.nodesProcessed + 1

  // Throttle yields - only yield every N nodes
  if checker.nodesProcessed % checker.yieldInterval != 0 { return false }

  // Yield progress event
  if checker.fiberCtx.yield {
    checker.fiberCtx.yield(.{
      kind: "PROGRESS",  // Will be mapped to Events.EventKind.PROGRESS
      pass: "typecheck",
      phase: "synthesizing",
      done: checker.nodesProcessed,
      total: nil,  // Unknown total (could estimate from AST size)
    })
  }

  // Check if cancelled
  if checker.fiberCtx.checkCancel and checker.fiberCtx.checkCancel() {
    return true  // Signal cancellation to caller
  }

  false
}

// ========================================================
// Environment Helpers
// ========================================================

fn envLookup(checker, declNodeId) {
  checker.env[declNodeId]
}

fn envBind(checker, declNodeId, t) {
  checker.env[declNodeId] = t
}

// ========================================================
// Type Synthesis Functions
// ========================================================

// ExprStmt wrapper - common in lowered AST
fn synthExprStmt(checker, node) {
  let t = typeNil()
  if node.expr {
    t = synthExpr(checker, node.expr)
  }
  checker.types[node.id] = t
  t
}

// Literal nodes
fn synthLiteral(checker, node) {
  let t =
    node.type == NODE.Number and typeNumber() or
    node.type == NODE.String and typeString() or
    node.type == NODE.Bool   and typeBool()   or
    typeNil()

  checker.types[node.id] = t
  t
}

// Identifier nodes - lookup in env or create fresh TypeVar
fn synthIdentifier(checker, node) {
  let binding = checker.resolvedNames[node.id]

  if !binding {
    addError(checker, node.id, "Unresolved identifier: " + node.name)
    let t = typeAny()
    checker.types[node.id] = t
    return t
  }

  // Handle builtins
  if binding.kind == "builtin" {
    let bt = helper.builtinTypeByName(checker, binding.name)
    if !bt { bt = typeAny() }
    checker.types[node.id] = bt
    return bt
  }

  // Local or upvalue - look up in environment by declaredAt
  let declId = binding.declaredAt
  let t = envLookup(checker, declId)

  if !t {
    // Not yet bound - create fresh type var
    t = freshTypeVar(checker)
    envBind(checker, declId, t)
  }

  checker.types[node.id] = t
  t
}

// Let binding
fn synthLet(checker, node) {
  let declId = node.name and node.name.id

  if node.init {
    let initType = synthExpr(checker, node.init)
    let initD = deref(checker, initType)

    // Special handling for nil init: create a TypeVar with Nil as lower bound
    // This allows the variable to evolve to Option[T] when assigned non-nil later
    if initD.kind == "Nil" {
      let t = freshTypeVar(checker)
      constrain(checker, initType, t)  // Nil <: TypeVar
      if declId {
        envBind(checker, declId, t)
        checker.types[node.name.id] = t
      }
      checker.types[node.id] = t
      return t
    }

    if declId {
      envBind(checker, declId, initType)
      checker.types[node.name.id] = initType
      let literalMap = recordLiteralValues(node.init)
      if literalMap {
        checker.recordValueBindings[declId] = literalMap
      } else if node.init.type == NODE.Identifier {
        let binding = checker.resolvedNames[node.init.id]
        if binding and binding.declaredAt {
          let bound = checker.recordValueBindings[binding.declaredAt]
          if bound { checker.recordValueBindings[declId] = bound }
        }
      }
    }
    checker.types[node.id] = initType
    return initType
  } else {
    // Uninitialized - fresh type var (runtime value is nil)
    let t = freshTypeVar(checker)
    t.uninitializedLocal = true  // Mark for field access checking
    if declId {
      envBind(checker, declId, t)
      checker.types[node.name.id] = t
    }
    checker.types[node.id] = t
    return t
  }
}

// Function definition
fn synthFunction(checker, node) {
  let params = node.params or []
  let defaults = node.defaults or []

  // Compute minArity from trailing defaults (only trailing defaults can be omitted)
  let minArity = len(params)
  if len(defaults) == len(params) and len(defaults) > 0 {
    for let i = len(defaults) - 1; i >= 0; i = i - 1 {
      if defaults[i] != nil {
        minArity = i
      } else {
        break
      }
    }
  }

  // Create fresh type vars for parameters and bind them
  let paramTypes = []
  for param in params {
    let pt = freshTypeVar(checker)
    envBind(checker, param.id, pt)
    checker.types[param.id] = pt
    push(paramTypes, pt)
  }
  let paramNames = collect p in params { p.name }

  // Fresh type var for return
  let retType = freshTypeVar(checker)
  let savedReturn = checker.currentReturn
  checker.currentReturn = retType

  // Create the function type before synthesizing body
  // (allows recursive functions to look up their own type)
  let fnType = typeFunction(paramTypes, retType)
  fnType.minArity = minArity
  fnType.paramNames = paramNames
  checker.types[node.id] = fnType

  // For named functions, bind the function to the environment
  // The resolver's declaredAt points to node.id for named functions
  if node.name and node.name.id {
    envBind(checker, node.id, fnType)
    envBind(checker, node.name.id, fnType)
    checker.types[node.name.id] = fnType
  }

  // Synthesize body
  let bodyType = typeNil()
  if node.body {
    bodyType = synthExpr(checker, node.body)
    // Body type constrains return type
    constrain(checker, bodyType, retType)
  }

  checker.currentReturn = savedReturn
  fnType
}

// Function call
fn synthCall(checker, node) {
  let calleeType = synthExpr(checker, node.callee)
  let args = node.args or []

  // Synthesize argument types (arguments are always used)
  let argTypes = collect arg in args { synthExpr(checker, arg) }

  // Fresh result type
  let resultType = freshTypeVar(checker)

  // Build expected function type from args
  let expectedFnType = typeFunction(argTypes, resultType)

  // Constrain: calleeType <: (args) -> result
  let calleeD = deref(checker, calleeType)
  let calleeName =
    node.callee and node.callee.type == NODE.Identifier and node.callee.name or
    calleeD and calleeD.kind == "Function" and calleeD.builtinName or
    nil

  // Try builtin synthesize rules first (for special builtins like range/keys)
  if calleeD.kind == "Function" and calleeD.builtinName {
    let builtinResult = rulesModule.applyBuiltinRules(
      checker, node, calleeD.builtinName, argTypes, args, addError, envBind, unwrapGroupings, "synthesize"
    )
    if builtinResult and builtinResult.handled {
      checker.types[node.id] = builtinResult.type
      return builtinResult.type
    }
  }

  if calleeD.kind == "Function" {
    // Check arity
    let calleeParams = calleeD.params or []
    let minArity = calleeD.minArity
    if minArity == nil { minArity = len(calleeParams) }

    if len(argTypes) < minArity {
      addError(checker, node.id,
        "Too few arguments: expected at least " + str(minArity) +
        ", got " + str(len(argTypes)))
    } else {
      // Apply builtin validation rules (for len, nameOf, etc.)
      if calleeD.builtinName {
        rulesModule.applyBuiltinRules(
          checker, node, calleeD.builtinName, argTypes, args, addError, envBind, unwrapGroupings, "validate"
        )
      }

      // Constrain argument types (contravariant)
      let numParams = len(calleeParams)
      for let i = 0; i < len(argTypes) and i < numParams; i = i + 1 {
        // Snapshot types BEFORE constraint (derefAll creates immutable copies)
        // Coalesce first to resolve TypeVars to their bounds, then snapshot
        let expectedCoalesced = coalesceTypeVar(checker, deref(checker, calleeParams[i]))
        let actualCoalesced = coalesceTypeVar(checker, deref(checker, argTypes[i]))
        let expectedSnap = derefAll(checker, expectedCoalesced)
        let actualSnap = derefAll(checker, actualCoalesced)

        if !constrain(checker, argTypes[i], calleeParams[i]) {
          // Use snapshot-safe printer to avoid "expected String, got String" errors
          // (constrain() mutates TypeVars, so post-constraint pretty-printing is incorrect)
          let expected = prettyTypeSnapshot(expectedSnap)
          let actual = prettyTypeSnapshot(actualSnap)

          let paramName = calleeD.paramNames and calleeD.paramNames[i]
          let label = "Argument " + str(i + 1)
          if paramName { label = label + " (" + paramName + ")" }
          if calleeName {
            label = label + " mismatch in call to " + calleeName
          } else {
            label = label + " mismatch"
          }
          addError(checker, node.id, label + ": expected " + expected + ", got " + actual)
        }
      }
      // Constrain return type (covariant)
      constrain(checker, calleeD.return, resultType)
    }
  } else if calleeD.kind == "TypeVar" {
    // Unknown callee - constrain it to be a function
    if !constrain(checker, calleeType, expectedFnType) {
      addError(checker, node.id, "Cannot call value")
    }
  } else if calleeD.kind != "Any" {
    addError(checker, node.id,
      "Cannot call value of type " + prettyType(checker, calleeType))
  }

  checker.types[node.id] = resultType
  resultType
}

// Record/Hashmap literal
fn synthHashmap(checker, node) {
  let pairs = node.pairs or []

  // Check if this hashmap is an enum definition (via enumInfo)
  let enumInfo = checker.enumInfo[node.id]
  if enumInfo and enumInfo.members {
    // Create an Enum type with member values
    let enumFields = .{}
    for member in enumInfo.members {
      enumFields[member.name] = member.value
    }
    let t = helper.typeEnum(enumFields)
    t.enumId = node.id
    // Store enum info for later use when accessing members
    checker.enumDefs = checker.enumDefs or .{}
    checker.enumDefs[node.id] = enumInfo
    checker.types[node.id] = t
    return t
  }

  if len(pairs) == 0 {
    let elemType = freshTypeVar(checker)
    let keyType = freshTypeVar(checker)
    let t = typeIndexable(elemType, keyType, node.id)
    checker.types[node.id] = t
    return t
  }

  let fields = .{}
  let hasError = false
  let enumKeyOrigins = []
  let tagInfo = nil

  fn extractTagType(valueNode) {
    let unwrapped = unwrapGroupings(valueNode)
    if !unwrapped or unwrapped.type != NODE.Dot { return nil }

    let objType = checker.types[unwrapped.object.id]
    if !objType { objType = synthExpr(checker, unwrapped.object) }
    let objD = objType and deref(checker, objType)
    if !objD or objD.kind != "Enum" { return nil }

    let memberName = unwrapped.property.value or unwrapped.property.name
    if !memberName { return nil }
    let memberValue = objD.fields and objD.fields[memberName]
    if memberValue == nil { return nil }

    let enumName = unwrapped.object and unwrapped.object.name
    typeTag(objD.enumId, enumName, memberName, memberValue)
  }

  for pair in pairs {
    let keyNode = pair.key
    let valueNode = pair.value

    // Determine field key (preserve original type for numbers)
    let fieldKey = nil
    let isLiteralKey = false

    // Unwrap groupings to find the actual key expression
    let unwrappedKey = unwrapGroupings(keyNode)
    if !unwrappedKey { unwrappedKey = keyNode }

    if unwrappedKey.type == NODE.String {
      fieldKey = unwrappedKey.value
      isLiteralKey = true
      synthExpr(checker, keyNode)
    } else if unwrappedKey.type == NODE.Number {
      fieldKey = unwrappedKey.value  // Keep as number
      isLiteralKey = true
      synthExpr(checker, keyNode)
    } else if unwrappedKey.type == NODE.Dot {
      // Could be enum member access - try to resolve it
      synthExpr(checker, keyNode)
      // Try to get enum member value from the type system
      let objType = checker.types[unwrappedKey.object.id]
      let objD = objType and deref(checker, objType)
      if objD and objD.kind == "Enum" and objD.fields {
        let memberName = unwrappedKey.property.value or unwrappedKey.property.name
        let memberValue = objD.fields[memberName]
        if memberValue != nil {
          fieldKey = memberValue  // Use the enum member's numeric value
          isLiteralKey = true
          // Track enum key origin
          push(enumKeyOrigins, .{
            member: memberName,
            enumName: unwrappedKey.object.name,
          })
        }
      }
      // Also allow computed key from a record literal with string/number values
      if !isLiteralKey {
        let baseObj = unwrapGroupings(unwrappedKey.object)
        if baseObj and baseObj.type == NODE.Identifier {
          let binding = checker.resolvedNames[baseObj.id]
          if binding and binding.declaredAt {
            let recordValues = checker.recordValueBindings[binding.declaredAt]
            if recordValues {
              let memberName = unwrappedKey.property.value or unwrappedKey.property.name
              if memberName and recordValues[memberName] != nil {
                fieldKey = recordValues[memberName]
                isLiteralKey = true
              }
            }
          }
        }
      }
      // If not an enum member access, reject it
      if !isLiteralKey {
        addError(checker, keyNode.id, "Record literal computed key must be a literal string, number, or enum member.")
        hasError = true
      }
    } else {
      // Non-literal computed key (e.g., a variable)
      synthExpr(checker, keyNode)
      addError(checker, keyNode.id, "Record literal computed key must be a literal string, number, or enum member.")
      hasError = true
    }

    let valueType = synthExpr(checker, valueNode)
    let fieldType = valueType
    let unwrappedValue = unwrapGroupings(valueNode)
    if unwrappedValue and unwrappedValue.type == NODE.Nil {
      let tv = freshTypeVar(checker)
      fieldType = typeOption(tv)
    }
    if isLiteralKey and type(fieldKey) == "string" and
       (fieldKey == "tag" or fieldKey == "kind" or fieldKey == "type") {
      let tagType = extractTagType(valueNode)
      if tagType {
        if tagInfo {
          addError(checker, valueNode.id, "Multiple tag fields are not allowed.")
        } else {
          tagInfo = .{ tagType: tagType }
        }
      }
    }
    if fieldKey != nil {
      fields[fieldKey] = fieldType
    }
  }

  // Store enum key origins if any
  if len(enumKeyOrigins) > 0 {
    checker.recordEnumKeyOrigins = checker.recordEnumKeyOrigins or .{}
    checker.recordEnumKeyOrigins[node.id] = enumKeyOrigins
  }

  let recordType = typeRecord(fields)
  let t = recordType
  if tagInfo and tagInfo.tagType {
    t = typeIntersect([recordType, tagInfo.tagType])
  }
  checker.types[node.id] = t
  t
}

// Field access (dot)
// Delegates to rule-based dispatch in rules.lx
fn synthDot(checker, node) {
  let objType = synthExpr(checker, node.object)
  let propNode = node.property
  let fieldName = propNode.value or propNode.name or propNode

  // Apply dot rules to determine result type
  let resultType = rulesModule.applyDotRules(checker, node, objType, fieldName, addError)

  checker.types[node.id] = resultType
  resultType
}

// If expression
fn synthIf(checker, node) {
  // Check condition (lx uses truthiness, not strict Bool)
  synthExpr(checker, node.condition)

  // Branch-scoped overlay for truthy guard narrowing
  let overlay = nil
  let guard = checker.facts and checker.facts.truthyGuardThen and checker.facts.truthyGuardThen[node.id]
  if guard and guard.declId {
    overlay = applyNarrowingOverlay(checker, guard.declId)
    if overlay {
      envBind(checker, guard.declId, overlay.narrowed)
    }
  }

  // Synthesize then branch (sees narrowed env)
  let thenType = synthExpr(checker, node.then)

  // Restore before else branch
  if overlay {
    envBind(checker, guard.declId, overlay.original)
  }

  if node.else {
    // With else: join both branches
    let elseType = synthExpr(checker, node.else)

    let thenD = deref(checker, thenType)
    let elseD = deref(checker, elseType)

    // Check for branch mismatch (incompatible concrete types)
    // Skip if in statement position - result is discarded anyway
    let inStmtPos = checker.facts and checker.facts.stmtPosition[node.id]
    if !inStmtPos {
      if thenD.kind != "TypeVar" and elseD.kind != "TypeVar" and
         thenD.kind != "Any" and elseD.kind != "Any" and
         thenD.kind != "Nil" and elseD.kind != "Nil" {
        // Both are concrete non-nil types - check compatibility
        if thenD.kind != elseD.kind {
          addError(checker, node.id, "Branch mismatch")
          checker.types[node.id] = typeAny()
          return typeAny()
        }
      }
    }

    // Fresh result type, constrain both branches
    let resultType = freshTypeVar(checker)
    constrain(checker, thenType, resultType)
    constrain(checker, elseType, resultType)

    checker.types[node.id] = resultType
    return resultType
  } else {
    // No else branch - result is Option[thenType]
    let thenD = deref(checker, thenType)
    if thenD.kind == "Nil" {
      checker.types[node.id] = typeNil()
      return typeNil()
    }
    if typeHasNilEvidence(checker, thenType) {
      checker.types[node.id] = thenType
      return thenType
    }
    let optType = typeOption(thenType)
    checker.types[node.id] = optType
    return optType
  }
}

// Array literal
fn synthArray(checker, node) {
  let elems = node.elements or []

  if len(elems) == 0 {
    // Empty array - element type is fresh
    let elemType = freshTypeVar(checker)
    let t = typeArray(elemType)
    checker.types[node.id] = t
    return t
  }

  // Non-empty: unify all elements
  let elemType = freshTypeVar(checker)
  for elem in elems {
    let et = synthExpr(checker, elem)
    constrain(checker, et, elemType)
  }

  let t = typeArray(elemType)
  checker.types[node.id] = t
  t
}

// Binary operations
fn synthBinary(checker, node) {
  let op = node.operator and node.operator.lexeme or ""
  let leftType = synthExpr(checker, node.left)
  let rightType = synthExpr(checker, node.right)

  // Arithmetic: both must be Number, result is Number
  if op == "+" or op == "-" or op == "*" or op == "/" or op == "%" {
    if op == "+" {
      // String concatenation check
      // Use coalesceTypeVar to resolve TypeVars with String bounds
      let leftD = deref(checker, leftType)
      let rightD = deref(checker, rightType)
      if leftD.kind == "TypeVar" {
        leftD = coalesceTypeVar(checker, leftD)
      }
      if rightD.kind == "TypeVar" {
        rightD = coalesceTypeVar(checker, rightD)
      }
      if leftD.kind == "String" or rightD.kind == "String" {
        constrain(checker, leftType, typeString())
        constrain(checker, rightType, typeString())
        checker.types[node.id] = typeString()
        return typeString()
      }
    }

    if !constrain(checker, leftType, typeNumber()) {
      addError(checker, node.left.id,
        "Expected Number for left operand of '" + op + "', got " + prettyType(checker, leftType))
    }
    if !constrain(checker, rightType, typeNumber()) {
      addError(checker, node.right.id,
        "Expected Number for right operand of '" + op + "', got " + prettyType(checker, rightType))
    }

    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  // Comparison: result is Bool
  if op == "==" or op == "!=" or op == "<" or op == ">" or
     op == "<=" or op == ">=" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  // Bitwise: both Number, result Number
  if op == "&" or op == "|" or op == "^" or op == "<<" or op == ">>" {
    constrain(checker, leftType, typeNumber())
    constrain(checker, rightType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  checker.types[node.id] = typeAny()
  typeAny()
}

// Unary operations
fn synthUnary(checker, node) {
  let op = node.operator and node.operator.lexeme or ""
  let operandType = synthExpr(checker, node.operand)

  if op == "-" {
    constrain(checker, operandType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  if op == "!" {
    checker.types[node.id] = typeBool()
    return typeBool()
  }

  if op == "~" {
    constrain(checker, operandType, typeNumber())
    checker.types[node.id] = typeNumber()
    return typeNumber()
  }

  checker.types[node.id] = typeAny()
  typeAny()
}

// Logical operations (and/or)
// In lx: `a and b` returns b if a is truthy, else a
//        `a or b` returns a if a is truthy, else b
fn synthLogical(checker, node) {
  let op = node.operator and node.operator.lexeme or ""

  // --------------------------------------------------------
  // Special-case: (cond and X) or Y  ==>  join(X, Y)
  //
  // This matches the common "ternary-ish" idiom and prevents
  // `cond` from leaking into the result type.
  //
  // Semantically: the final value is always either X or Y:
  //   - if cond is falsy: left becomes falsy, so `or` returns Y
  //   - if cond is truthy: left becomes X, so `or` returns X (if truthy) else Y
  // Either way, the final value is in {X, Y}, never cond.
  // --------------------------------------------------------
  if op == "or" {
    let leftNode = unwrapGroupings(node.left)
    let leftOp = leftNode and leftNode.operator and leftNode.operator.lexeme or ""
    if leftNode and leftNode.type == NODE.Logical and leftOp == "and" {
      // Synthesize subparts
      // Note: cond is still synthesized for completeness/side effects,
      // but its type does not contribute to the overall expression type.
      synthExpr(checker, leftNode.left)          // cond
      let xType = synthExpr(checker, leftNode.right)  // X
      let yType = synthExpr(checker, node.right)      // Y

      // Result is a join of X and Y
      let resultType = freshTypeVar(checker)
      constrain(checker, xType, resultType)
      constrain(checker, yType, resultType)

      checker.types[node.id] = resultType
      return resultType
    }
  }

  // -----------------------
  // Existing general logic
  // -----------------------
  let leftNode = unwrapGroupings(node.left)
  let leftLiteralTruthy = false
  let leftLiteralFalsy = false
  if leftNode and leftNode.type == NODE.Nil {
    leftLiteralFalsy = true
  } else if leftNode and leftNode.type == NODE.Bool {
    if leftNode.value { leftLiteralTruthy = true }
    else { leftLiteralFalsy = true }
  }

  let leftType = synthExpr(checker, node.left)
  let rightType = synthExpr(checker, node.right)

  let leftD = deref(checker, leftType)

  // Check if left is definitely falsy (Nil or literal false)
  let leftFalsy = leftLiteralFalsy or leftD.kind == "Nil"

  // Check if left is definitely truthy (literal true or non-nil, non-bool, not TypeVar)
  // In lx, only nil and false are falsy
  let leftTruthy = !leftFalsy and
    (leftLiteralTruthy or
     (!typeHasNilEvidence(checker, leftType) and leftD.kind != "Bool" and leftD.kind != "TypeVar"))

  if op == "and" {
    // `a and b`: if a is falsy, return a; if a is truthy, return b
    if leftFalsy {
      checker.types[node.id] = leftType
      return leftType
    }
    if leftTruthy {
      checker.types[node.id] = rightType
      return rightType
    }
    // Unknown - join both types
    let resultType = freshTypeVar(checker)
    constrain(checker, leftType, resultType)
    constrain(checker, rightType, resultType)
    checker.types[node.id] = resultType
    return resultType
  }

  if op == "or" {
    // `a or b`: if a is truthy, return a; if a is falsy, return b
    if leftTruthy {
      checker.types[node.id] = leftType
      return leftType
    }
    if leftFalsy {
      checker.types[node.id] = rightType
      return rightType
    }
    // Unknown - join both types
    let resultType = freshTypeVar(checker)
    constrain(checker, leftType, resultType)
    constrain(checker, rightType, resultType)
    checker.types[node.id] = resultType
    return resultType
  }

  // Default
  checker.types[node.id] = leftType
  leftType
}

// Helper: Apply narrowing overlay for a declaration
// Returns { original, narrowed } if narrowing was applied, nil otherwise
fn applyNarrowingOverlay(checker, declId) {
  let currentType = envLookup(checker, declId)
  if !currentType { return nil }

  if !isOptionalish(checker, currentType) { return nil }

  // Create narrowed type var
  let narrowedTV = freshTypeVar(checker)
  constrain(checker, narrowedTV, currentType)

  let currentD = deref(checker, currentType)
  if currentD.kind == "TypeVar" {
    narrowedTV.narrowedFrom = currentType
    currentType.narrowedTo = currentType.narrowedTo or []
    push(currentType.narrowedTo, narrowedTV)
  }

  // Return overlay record so caller can restore
  .{ original: currentType, narrowed: narrowedTV }
}

// Block expression
// Uses refinement overlay for nil-guard narrowing:
// - refinements: declId -> { original, narrowed } mapping
// - Closures see original env (not narrowed)
// - Other expressions see narrowed env
// - Refinements don't leak out of block scope
fn synthBlock(checker, node) {
  let exprs = node.expressions or []
  let lastType = typeNil()

  // Refinement overlay: declId -> { original: Type, narrowed: Type }
  let refinements = .{}
  let refinementKeys = []  // Track keys in order for iteration

  for let i = 0; i < len(exprs); i = i + 1 {
    let expr = exprs[i]

    // For closures, temporarily restore original bindings (closures should not see narrowed types)
    let unwrappedExpr = unwrapGroupings(expr)
    let isClosure = unwrappedExpr.type == NODE.Function
    if isClosure and len(refinementKeys) > 0 {
      for declId in refinementKeys {
        envBind(checker, declId, refinements[declId].original)
      }
    }

    // Synthesize current expression
    lastType = synthExpr(checker, expr)

    // Re-apply narrowing after closure synthesis (restore same narrowed TypeVar to preserve constraints)
    if isClosure and len(refinementKeys) > 0 {
      for declId in refinementKeys {
        envBind(checker, declId, refinements[declId].narrowed)
      }
    }

    // Apply refinement from pre-computed facts (not inline detection)
    let guard = checker.facts and checker.facts.nilGuardReturn[expr.id]
    if guard and i < len(exprs) - 1 {
      let declId = guard.declId
      if !refinements[declId] {
        let overlay = applyNarrowingOverlay(checker, declId)
        if overlay {
          // Store in refinement overlay
          refinements[declId] = overlay
          push(refinementKeys, declId)

          // Use narrowed type for subsequent lookups
          envBind(checker, declId, overlay.narrowed)
        }
      }
    }

    // Yield point: after processing each expression in block
    // (state is consistent - expression fully typed, env updated)
    if maybeYield(checker) {
      // Cancelled - return early with partial results
      checker.types[node.id] = typeAny()
      return typeAny()
    }
  }

  // Restore original env (don't leak narrowing out of block)
  for declId in refinementKeys {
    envBind(checker, declId, refinements[declId].original)
  }

  checker.types[node.id] = lastType
  lastType
}

// For loop (C-style)
fn synthFor(checker, node) {
  if node.init { synthExpr(checker, node.init) }
  if node.condition { synthExpr(checker, node.condition) }
  if node.update { synthExpr(checker, node.update) }
  if node.body { synthExpr(checker, node.body) }

  // For loops return nil
  let t = typeNil()
  checker.types[node.id] = t
  t
}

// For-in loop
fn synthForIn(checker, node) {
  let iterableType = synthExpr(checker, node.iterable)

  // Bind the value binder
  if node.valueBinder {
    // Create a fresh type var for the element
    let elemType = freshTypeVar(checker)

    // Constrain iterable to Array[elemType]
    constrain(checker, iterableType, typeArray(elemType))

    // Find the binding for valueBinder and bind it
    // The resolver should have created a local for it
    let binding = checker.resolvedNames[node.id]
    if binding and binding.valueBinderDeclId {
      envBind(checker, binding.valueBinderDeclId, elemType)
    }
  }

  if node.body { synthExpr(checker, node.body) }

  let t = typeNil()
  checker.types[node.id] = t
  t
}

// Collect expression (C-style)
fn synthCollect(checker, node) {
  if node.init { synthExpr(checker, node.init) }
  if node.condition { synthExpr(checker, node.condition) }
  if node.update { synthExpr(checker, node.update) }

  let bodyType = typeAny()
  if node.body {
    bodyType = synthExpr(checker, node.body)
  }

  let t = typeArray(bodyType)
  checker.types[node.id] = t
  t
}

// Collect-in expression
fn synthCollectIn(checker, node) {
  let iterableType = synthExpr(checker, node.iterable)

  // Bind the value binder
  if node.valueBinder {
    let elemType = freshTypeVar(checker)
    constrain(checker, iterableType, typeArray(elemType))

    let binding = checker.resolvedNames[node.id]
    if binding and binding.valueBinderDeclId {
      envBind(checker, binding.valueBinderDeclId, elemType)
    }
  }

  let bodyType = typeAny()
  if node.body {
    bodyType = synthExpr(checker, node.body)
  }

  let t = typeArray(bodyType)
  checker.types[node.id] = t
  t
}

// Return statement
fn synthReturn(checker, node) {
  let valueType = typeNil()
  if node.value {
    valueType = synthExpr(checker, node.value)
  }

  // Constrain to current function's return type
  if checker.currentReturn {
    constrain(checker, valueType, checker.currentReturn)
  }

  checker.types[node.id] = valueType
  valueType
}

// Assignment
fn synthAssignment(checker, node) {
  let valueType = synthExpr(checker, node.value)

  // Special handling for dot assignment (closed record model)
  if node.target.type == NODE.Dot {
    let dotNode = node.target
    let objType = synthExpr(checker, dotNode.object)
    let objD = deref(checker, objType)
    let propNode = dotNode.property
    let fieldName = propNode.value or propNode.name or propNode

    // Cannot assign to field on optional value
    if objD.kind != "TypeVar" and typeHasNilEvidence(checker, objType) {
      addError(checker, node.id, "Cannot assign to field on optional value")
      checker.types[node.id] = valueType
      return valueType
    }

    // For TypeVar, add constraint that it must have this field
    // But error if it's an uninitialized local (nil at runtime)
    if objD.kind == "TypeVar" {
      if objD.uninitializedLocal {
        addError(checker, dotNode.id, "Cannot access field on nil value")
        checker.types[node.id] = valueType
        return valueType
      }
      let requiredRecord = typeRecord(.{ [fieldName]: valueType })
      if !constrain(checker, objType, requiredRecord) {
        addError(checker, dotNode.id, "Cannot access field '" + fieldName + "' on type " + prettyType(checker, objType))
      }
      checker.types[dotNode.id] = valueType
      checker.types[node.id] = valueType
      return valueType
    }

    // For Record, check field exists
    if objD.kind == "Record" {
      let fieldType = objD.fields and objD.fields[fieldName]
      if !fieldType {
        addError(checker, dotNode.id, "Missing field: " + fieldName)
        checker.types[node.id] = valueType
        return valueType
      }
      if fieldType.kind == "TypeVar" {
        let existingBounds = fieldType.lowerBounds or []
        let dv = deref(checker, valueType)
        if dv.kind == "TypeVar" { dv = coalesceTypeVar(checker, dv) }
        for lb in existingBounds {
          let dlb = deref(checker, lb)
          if dlb.kind == "TypeVar" { dlb = coalesceTypeVar(checker, dlb) }
          if dlb.kind == "TypeVar" or dv.kind == "TypeVar" { continue }
          if dlb.kind == "Nil" or dv.kind == "Nil" { continue }
          if isSubtype(checker, dv, dlb) or isSubtype(checker, dlb, dv) {
            continue
          }
          addError(checker, node.id, "Assignment mismatch")
          checker.types[dotNode.id] = fieldType
          checker.types[node.id] = valueType
          return valueType
        }
      }
      // Constrain value to field type
      if !constrain(checker, valueType, fieldType) {
        addError(checker, node.id, "Assignment mismatch")
      }
      checker.types[dotNode.id] = fieldType
      checker.types[node.id] = valueType
      return valueType
    }

    // Non-record type
    if objD.kind != "Any" {
      addError(checker, dotNode.id, "Cannot access field on type " + prettyType(checker, objType))
    }
    checker.types[node.id] = valueType
    return valueType
  }

  // Special handling for index assignment
  if node.target.type == NODE.Index {
    let indexNode = node.target
    let objType = synthExpr(checker, indexNode.object)
    let indexType = synthExpr(checker, indexNode.index)
    let objD = deref(checker, objType)
    let indexTypeD = deref(checker, indexType)

    // Determine if key is numeric or string
    let keyIsNumeric = indexTypeD.kind == "Number"
    let keyIsString = indexTypeD.kind == "String"
    let keyIsTypeVar = indexTypeD.kind == "TypeVar"

    // For hashmap/map key type validation
    if objD.kind == "Record" or objD.kind == "Map" or objD.kind == "TypeVar" or objD.kind == "Indexable" {
      if !keyIsNumeric and !keyIsString and !keyIsTypeVar {
        addError(checker, node.id, "Hashmap key type must be number or string.")
        checker.types[node.id] = valueType
        return valueType
      }
    }

    // Try to get the constant key value
    // First check pre-computed facts for simple literals
    let keyValue = checker.facts and checker.facts.literalKeyValue[indexNode.id]

    // If not found in facts, try enum member access (needs type info)
    if keyValue == nil {
      let unwrappedIndex = unwrapGroupings(indexNode.index)
      if unwrappedIndex.type == NODE.Dot {
        // Check if it's an enum member access
        let objIndexType = checker.types[unwrappedIndex.object.id]
        let objIndexD = objIndexType and deref(checker, objIndexType)
        if objIndexD and objIndexD.kind == "Enum" and objIndexD.fields {
          let memberName = unwrappedIndex.property.value or unwrappedIndex.property.name
          let memberValue = objIndexD.fields[memberName]
          if memberValue != nil {
            keyValue = memberValue
          }
        }
      }
    }

    if objD.kind == "Indexable" {
      constrain(checker, indexType, objD.key)
      constrain(checker, valueType, objD.elem)
      if keyIsNumeric { objD.sawNumericIndex = true }
      checker.types[indexNode.id] = objD.elem
      checker.types[node.id] = valueType
      return valueType
    }

    if objD.kind == "Record" {
      if keyValue != nil {
        // Check if field exists
        let fieldType = objD.fields and objD.fields[keyValue]
        if !fieldType {
          addError(checker, indexNode.id, "Missing field: " + str(keyValue))
          checker.types[node.id] = valueType
          return valueType
        }
        // Constrain value to field type
        if !constrain(checker, valueType, fieldType) {
          addError(checker, node.id, "Assignment mismatch")
        }
        checker.types[indexNode.id] = fieldType
        checker.types[node.id] = valueType
        return valueType
      }
      // Variable key - can't determine field at compile time
      // Return optional based on field types
      let fieldKeys = keys(objD.fields)
      let commonType = freshTypeVar(checker)
      for fk in fieldKeys {
        constrain(checker, objD.fields[fk], commonType)
      }
      constrain(checker, valueType, commonType)
      checker.types[indexNode.id] = commonType
      checker.types[node.id] = valueType
      return valueType
    }

    if objD.kind == "TypeVar" {
      // Unknown object - infer based on key type
      if keyIsNumeric {
        // Numeric key - infer Array
        let arrType = typeArray(valueType)
        constrain(checker, objType, arrType)
        let objBinding = checker.resolvedNames[indexNode.object.id]
        if objBinding and objBinding.declaredAt {
          envBind(checker, objBinding.declaredAt, arrType)
        }
        checker.types[indexNode.id] = valueType
        checker.types[node.id] = valueType
        return valueType
      } else if keyIsString {
        // String key - infer Map
        let mapType = helper.typeMap(indexType, valueType)
        constrain(checker, objType, mapType)
        let objBinding = checker.resolvedNames[indexNode.object.id]
        if objBinding and objBinding.declaredAt {
          envBind(checker, objBinding.declaredAt, mapType)
        }
        checker.types[indexNode.id] = valueType
        checker.types[node.id] = valueType
        return valueType
      }
      // TypeVar key - leave as unknown, constrain to Indexable later if needed
      checker.types[indexNode.id] = valueType
      checker.types[node.id] = valueType
      return valueType
    }
  }

  // Regular assignment
  let targetType = synthExpr(checker, node.target)

  // Constrain: valueType <: targetType
  if !constrain(checker, valueType, targetType) {
    addError(checker, node.id, "Assignment mismatch: cannot assign " +
      prettyType(checker, valueType) + " to " + prettyType(checker, targetType))
  }

  checker.types[node.id] = valueType
  valueType
}

// Index access
fn synthIndex(checker, node) {
  let objType = synthExpr(checker, node.object)
  let indexType = synthExpr(checker, node.index)

  // Fresh result type
  let resultType = freshTypeVar(checker)

  let objD = deref(checker, objType)
  let indexTypeD = deref(checker, indexType)

  if objD.kind == "Array" {
    // Array indexing - index must be Number, return element type directly
    if indexTypeD.kind != "Number" and indexTypeD.kind != "TypeVar" {
      addError(checker, node.id, "Array index must be a number")
      checker.types[node.id] = resultType
      return resultType
    }
    constrain(checker, indexType, typeNumber())
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "Map" {
    // Map indexing - return element type directly
    constrain(checker, indexType, objD.key)
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "Record" {
    // Record indexing with constant key
    // Use pre-computed facts for literal keys
    let keyValue = checker.facts and checker.facts.literalKeyValue[node.id]

    if keyValue != nil and objD.fields {
      let fieldType = objD.fields[keyValue]
      if fieldType {
        checker.types[node.id] = fieldType
        return fieldType
      }
    }

    // Variable key on Record - return Option[fieldType]
    // The key might not exist at runtime, so result is optional
    if objD.fields and len(keys(objD.fields)) > 0 {
      // Get the common type of all fields
      let fieldKeys = keys(objD.fields)
      let commonType = freshTypeVar(checker)
      for fk in fieldKeys {
        constrain(checker, objD.fields[fk], commonType)
      }
      let optType = typeOption(commonType)
      checker.types[node.id] = optType
      return optType
    }
    // Empty record - return fresh Option
  } else if objD.kind == "String" {
    // String indexing - index must be Number
    if indexTypeD.kind != "Number" and indexTypeD.kind != "TypeVar" {
      addError(checker, node.id, "String index must be a number")
      checker.types[node.id] = typeString()
      return typeString()
    }
    constrain(checker, indexType, typeNumber())
    checker.types[node.id] = typeString()
    return typeString()
  } else if objD.kind == "Indexable" {
    constrain(checker, indexType, objD.key)
    if indexTypeD.kind == "Number" { objD.sawNumericIndex = true }
    checker.types[node.id] = objD.elem
    return objD.elem
  } else if objD.kind == "TypeVar" {
    // Unknown object - check if index type has bounds that tell us Array vs Map
    // Look at index TypeVar's lower bounds to see if it's constrained to String or Number
    if indexTypeD.kind == "TypeVar" {
      let indexBounds = indexTypeD.lowerBounds or []
      for lb in indexBounds {
        let dlb = deref(checker, lb)
        if dlb.kind == "String" {
          // Index is constrained to String - infer Map
          let mapType = helper.typeMap(typeString(), resultType)
          constrain(checker, objType, mapType)
          checker.types[node.id] = resultType
          return resultType
        } else if dlb.kind == "Number" {
          // Index is constrained to Number - infer Array
          let arrType = typeArray(resultType)
          constrain(checker, objType, arrType)
          checker.types[node.id] = resultType
          return resultType
        }
      }
    } else if indexTypeD.kind == "String" {
      // Concrete String index - infer Map
      let mapType = helper.typeMap(typeString(), resultType)
      constrain(checker, objType, mapType)
    } else if indexTypeD.kind == "Number" {
      // Concrete Number index - infer Array
      let arrType = typeArray(resultType)
      constrain(checker, objType, arrType)
    }
    // Otherwise leave as fresh for later resolution
  }

  checker.types[node.id] = resultType
  resultType
}

// Import
fn synthImport(checker, node) {
  // Imports return the exported value
  let importInfo = checker.resolveResult and checker.resolveResult.importInfoByNodeId or .{}
  let info = importInfo[node.id]
  let t = info and info.importType
  if !t and checker.program and checker.program.exports {
    let importPath = info and info.importResult and info.importResult.path or nil
    if !importPath and node.path and node.path.type == NODE.String {
      importPath = node.path.value
    }
    if importPath { t = checker.program.exports[importPath] }
  }
  if t {
    let cloned = cloneType(checker, t, .{})
    checker.types[node.id] = cloned
    return cloned
  }
  t = typeAny()
  checker.types[node.id] = t
  t
}

// Arrow operator (pipeline)
fn synthArrow(checker, node) {
  // x->f(a) is like f(x, a)
  // The right side should be a Call node
  if node.right.type == NODE.Call {
    // Synthesize x
    synthExpr(checker, node.left)
    // Synthesize the call (which includes x as implicit first arg)
    return synthExpr(checker, node.right)
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Intrinsic call
fn synthIntrinsicCall(checker, node) {
  let args = node.args or []

  // Handle specific intrinsics
  if node.intrinsic == "array_new" {
    // array_new() creates an empty array with fresh element type
    let elemType = freshTypeVar(checker)
    let t = typeArray(elemType)
    checker.types[node.id] = t
    return t
  }

  if node.intrinsic == "array_push" or node.intrinsic == "array_append" {
    // array_push/array_append(arr, elem) - constrain elem to array's element type
    if len(args) >= 2 {
      let arrType = synthExpr(checker, args[0])
      let elemType = synthExpr(checker, args[1])
      let arrD = deref(checker, arrType)
      if arrD.kind == "Array" {
        constrain(checker, elemType, arrD.elem)
      } else if arrD.kind == "TypeVar" {
        // Constrain arrType to be Array[elemType]
        constrain(checker, arrType, typeArray(elemType))
      }
      let t = typeNil()  // push/append returns nil
      checker.types[node.id] = t
      return t
    }
  }

  // Default: synthesize args and return Any
  for arg in args {
    synthExpr(checker, arg)
  }

  let t = typeAny()
  checker.types[node.id] = t
  t
}

// Main expression synthesizer - dispatches by node type
fn synthExpr(checker, node) {
  if !node { return typeNil() }

  if node.type == NODE.ExprStmt { return synthExprStmt(checker, node) }
  if node.type == NODE.Number or node.type == NODE.String or
     node.type == NODE.Bool or node.type == NODE.Nil {
    return synthLiteral(checker, node)
  }
  if node.type == NODE.Identifier { return synthIdentifier(checker, node) }
  if node.type == NODE.Let { return synthLet(checker, node) }
  if node.type == NODE.Function { return synthFunction(checker, node) }
  if node.type == NODE.Call { return synthCall(checker, node) }
  if node.type == NODE.Hashmap { return synthHashmap(checker, node) }
  if node.type == NODE.Dot { return synthDot(checker, node) }
  if node.type == NODE.If { return synthIf(checker, node) }
  if node.type == NODE.Array { return synthArray(checker, node) }
  if node.type == NODE.Binary { return synthBinary(checker, node) }
  if node.type == NODE.Unary { return synthUnary(checker, node) }
  if node.type == NODE.Logical { return synthLogical(checker, node) }
  if node.type == NODE.Block { return synthBlock(checker, node) }
  if node.type == NODE.Grouping {
    let inner = synthExpr(checker, node.expression)
    checker.types[node.id] = inner
    return inner
  }
  if node.type == NODE.For { return synthFor(checker, node) }
  if node.type == NODE.ForIn { return synthForIn(checker, node) }
  if node.type == NODE.Collect { return synthCollect(checker, node) }
  if node.type == NODE.CollectIn { return synthCollectIn(checker, node) }
  if node.type == NODE.Return { return synthReturn(checker, node) }
  if node.type == NODE.Assignment { return synthAssignment(checker, node) }
  if node.type == NODE.Index { return synthIndex(checker, node) }
  if node.type == NODE.Import { return synthImport(checker, node) }
  if node.type == NODE.Arrow { return synthArrow(checker, node) }
  if node.type == NODE.IntrinsicCall { return synthIntrinsicCall(checker, node) }
  if node.type == NODE.Break or node.type == NODE.Continue {
    checker.types[node.id] = typeNil()
    return typeNil()
  }

  // For unhandled nodes, assign Any
  let t = typeAny()
  if node.id {
    checker.types[node.id] = t
  }
  t
}

// ========================================================
// Public API
// ========================================================

fn typecheck(ast, resolveResult, opts) {
  // Check preconditions
  if !resolveResult.success {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Resolve failed", severity: "error" }],
    }
  }

  if !ast {
    return .{
      success: false,
      types: .{},
      errors: [.{ message: "Missing AST", severity: "error" }],
    }
  }

  // Phase 1: Compute facts (pre-computed static properties)
  let facts = computeFacts(ast, resolveResult)

  // Create checker with data from other passes
  let checker = makeChecker(resolveResult, opts)
  checker.facts = facts  // Store facts in checker for access during synthesis

  // Traverse the AST
  synthExpr(checker, ast)

  // Solve deferred range/keys constraints
  helper.solveBuiltinConstraints(checker)

  // Return results
  .{
    success: !checker.hadError,
    types: checker.types,           // Node ID -> type
    errors: checker.errors,         // List of error objects
    recordEnumKeyOrigins: checker.recordEnumKeyOrigins,  // Track enum keys in records
  }
}

typecheck
