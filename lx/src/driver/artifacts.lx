// Artifacts - Canonical artifact IDs and specifications
//
// These IDs define the compiler's formal build targets and compilation artifacts.
// Artifact-driven compilation: passes exist to produce artifacts; artifacts define
// scheduling, validity, and correctness.

let passesModule = import "src/driver/passes.lx"
let .{ PASS_DEFS } = passesModule

// Canonical artifact IDs
let ARTIFACT = .{
  // Per-module AST artifacts
  AST_FINAL: "ast.final",                          // Authoritative AST after all transforms

  // Per-module analysis artifacts
  ANALYSIS_RESOLVE: "analysis.resolve",            // Name resolution and scope info
  ANALYSIS_RESOLVE_LOWER: "analysis.resolve.lower", // Name resolution on lowered AST
  ANALYSIS_DCE_LOCAL: "analysis.dce.local",        // Local dead code analysis
  ANALYSIS_FASTCHECK: "analysis.fastcheck",        // Fast type representation analysis
  ANALYSIS_TYPECHECK: "analysis.typecheck",        // Optional type inference
  ANALYSIS_DCE_FINAL: "analysis.dce.final",        // DCE after whole-program analysis

  // Per-module bytecode artifacts
  BYTECODE_FUNCTION: "bytecode.function",          // Generated bytecode function
  BYTECODE_VERIFIED: "bytecode.verified",          // Verified bytecode

  // Program-level artifacts
  PROGRAM_MODULE_GRAPH: "program.module_graph",    // Complete module dependency graph
  ANALYSIS_DCE_WHOLE_PROGRAM: "analysis.dce.whole_program",  // Whole-program DCE facts
}

// Artifact specifications defining dependencies between artifacts
let ARTIFACT_SPEC = .{
  ["source"]: .{
    requires: () => [],
    produces: () => [],
  },
  ["ast.pre_resolve"]: .{
    requires: () => ["source"],
    produces: needs => {
      let out = ["parse"]
      if needs.withLower == true { push(out, "lower") }
      if needs.withAnf == true { push(out, "anf") }
      out
    },
  },
  [ARTIFACT.ANALYSIS_RESOLVE]: .{
    requires: () => ["ast.pre_resolve"],
    produces: () => ["resolve"],
  },
  [ARTIFACT.ANALYSIS_RESOLVE_LOWER]: .{
    requires: () => ["ast.pre_resolve"],
    produces: () => ["resolve-lower"],
  },
  [ARTIFACT.ANALYSIS_DCE_LOCAL]: .{
    requires: () => [ARTIFACT.ANALYSIS_RESOLVE],
    produces: needs => { needs.withDce == true and ["dce"] or [] },
  },
  [ARTIFACT.AST_FINAL]: .{
    requires: () => ["ast.pre_resolve", ARTIFACT.ANALYSIS_RESOLVE],
    produces: needs => {
      let out = []
      if needs.withAnfInline == true { push(out, "anf-inline") }
      if needs.withLowerIntrinsics == true { push(out, "lower-intrinsics") }
      out
    },
  },
  [ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM]: .{
    requires: needs => {
      let reqs = [ARTIFACT.PROGRAM_MODULE_GRAPH]
      if needs.withDce == true { push(reqs, ARTIFACT.ANALYSIS_DCE_LOCAL) }
      reqs
    },
    produces: () => [],
  },
  [ARTIFACT.ANALYSIS_DCE_FINAL]: .{
    requires: needs => {
      let reqs = [ARTIFACT.ANALYSIS_DCE_LOCAL, ARTIFACT.AST_FINAL]
      if needs.withDce == true { push(reqs, ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM) }
      reqs
    },
    produces: () => [],
  },
  [ARTIFACT.ANALYSIS_FASTCHECK]: .{
    requires: () => [ARTIFACT.AST_FINAL, ARTIFACT.ANALYSIS_RESOLVE],
    produces: () => [],
  },
  [ARTIFACT.ANALYSIS_TYPECHECK]: .{
    requires: () => [
      ARTIFACT.AST_FINAL,
      ARTIFACT.ANALYSIS_RESOLVE,
      ARTIFACT.ANALYSIS_RESOLVE_LOWER,
    ],
    produces: () => [],
  },
  [ARTIFACT.BYTECODE_FUNCTION]: .{
    requires: () => [
      ARTIFACT.AST_FINAL,
      ARTIFACT.ANALYSIS_RESOLVE,
      ARTIFACT.ANALYSIS_FASTCHECK,
      ARTIFACT.ANALYSIS_DCE_FINAL,
    ],
    produces: () => [],
  },
  [ARTIFACT.BYTECODE_VERIFIED]: .{
    requires: () => [ARTIFACT.BYTECODE_FUNCTION],
    produces: () => [],
  },
  [ARTIFACT.PROGRAM_MODULE_GRAPH]: .{
    requires: () => ["source"],
    produces: () => [],
  },
}

// Get the requires array for an artifact (evaluating if function)
fn artifactRequires(artifactId, needs) {
  let spec = ARTIFACT_SPEC[artifactId]
  if !spec { return [] }
  spec.requires(needs)
}

// Get the produces array for an artifact (evaluating if function)
fn artifactProduces(artifactId, needs) {
  let spec = ARTIFACT_SPEC[artifactId]
  if !spec { return [] }
  spec.produces(needs)
}

// Validate artifact spec consistency
fn validateArtifactSpec(needs) {
  let errors = []
  let artifactIds = keys(ARTIFACT_SPEC)
  let artifactSet = .{}
  for id in artifactIds { artifactSet[id] = true }

  for id in artifactIds {
    let spec = ARTIFACT_SPEC[id]
    let rawReqs = spec and spec.requires or (() => [])
    let evaluatedReqs = rawReqs(needs)
    if type(evaluatedReqs) != "array" {
      push(errors, "Artifact '" + id + "' requires must be an array")
      evaluatedReqs = []
    }
    let reqs = evaluatedReqs
    for req in reqs {
      if req != "source" and !artifactSet[req] {
        push(errors, "Artifact '" + id + "' requires unknown '" + req + "'")
      }
    }

    let rawProduces = spec and spec.produces or (() => [])
    let evaluatedProduces = rawProduces(needs)
    if type(evaluatedProduces) != "array" {
      push(errors, "Artifact '" + id + "' produces must be an array")
      evaluatedProduces = []
    }
    let producers = evaluatedProduces
    for passName in producers {
      if !PASS_DEFS[passName] {
        push(errors, "Artifact '" + id + "' produced by unknown pass '" + passName + "'")
      }
    }
  }

  if len(errors) == 0 { return true }

  Lx.stderr.println("Artifact spec validation failed:")
  for err in errors { Lx.stderr.println("  " + err) }
  false
}

.{
  ARTIFACT,
  ARTIFACT_SPEC,
  artifactRequires,
  artifactProduces,
  validateArtifactSpec,
}
