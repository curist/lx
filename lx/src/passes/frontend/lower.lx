// Lower Phase - Desugar syntax into canonical AST
// Responsibility: Pure syntactic transformations
//   - Arrow operator: x->f(a) → f(x, a)
//   - Future: spread, destructuring, for-loops, etc.
//
// IMPORTANT: Lower MUST NOT introduce synthetic nodes.
// Missing else branches remain as nil (not normalized to empty blocks).

let .{ TOKEN, NODE } = import "src/types.lx"
let nodeUtils = import "src/passes/node-utils.lx"

// ========================================
// Error handling
// ========================================

fn addError(lowerer, nodeId, message) {
  push(lowerer.errors, .{
    nodeId: nodeId,
    message: message,
    severity: "error",
  })
}

// ========================================
// Node Creation Helpers
// ========================================

fn allocNodeId(lowerer) {
  let id = lowerer.nextId
  lowerer.nextId = lowerer.nextId + 1
  id
}

fn copyNodeShallow(lowerer, node) {
  nodeUtils.copyNodeShallow(allocNodeId, lowerer, node)
}

// ========================================
// Node Type Lowering Functions
// ========================================


// Leaf nodes - just copy with new ID
fn lowerLeaf(lowerer, node) {
  copyNodeShallow(lowerer, node)
}

fn lowerBinary(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.left = lowerExpr(lowerer, node.left)
  newNode.right = lowerExpr(lowerer, node.right)
  newNode
}

fn lowerUnary(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.operand = lowerExpr(lowerer, node.operand)
  newNode
}

fn lowerLogical(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.left = lowerExpr(lowerer, node.left)
  newNode.right = lowerExpr(lowerer, node.right)
  newNode
}

fn lowerGrouping(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.expression = lowerExpr(lowerer, node.expression)
  newNode
}

fn lowerLet(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  // Lower the name (Identifier node)
  newNode.name = lowerExpr(lowerer, node.name)

  if node.init {
    newNode.init = lowerExpr(lowerer, node.init)
  }
  newNode
}

fn lowerLetDestructureExprs(lowerer, node) {
  // Desugar:
  //   let .{ A, B: localB } = expr
  // Into (in the *current* scope):
  //   let $destr_<id> = expr
  //   let A = $destr_<id>.A
  //   let localB = $destr_<id>.B

  let loweredInit = node.init and lowerExpr(lowerer, node.init) or nil
  let tmpName = "$destr_" + str(node.id)

  fn makeIdent(name) {
    .{
      type: NODE.Identifier,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  // let $destr = <init>
  let tmpLet = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(tmpName),
    init: loweredInit,
  }
  lowerer.origin[tmpLet.id] = node.id

  let exprs = [tmpLet]

  // For each binding, emit: let <name> = $destr.<key>
  let bindings = node.bindings or []
  for let i = 0; i < len(bindings); i = i + 1 {
    let b = bindings[i]
    let bindName = b and b.name
    let bindKey = b and b.key
    if !bindName or !bindKey {
      continue
    }

    let loweredName = lowerExpr(lowerer, bindName)
    let loweredKey = lowerExpr(lowerer, bindKey)

    let dotExpr = .{
      type: NODE.Dot,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: loweredKey and loweredKey.endLine or node.endLine,
      endCol: loweredKey and loweredKey.endCol or node.endCol,
      object: makeIdent(tmpName),
      property: loweredKey,
    }
    lowerer.origin[dotExpr.id] = node.id

    let fieldLet = .{
      type: NODE.Let,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: bindName.line,
      col: bindName.col,
      endLine: bindName.endLine,
      endCol: bindName.endCol,
      name: loweredName,
      init: dotExpr,
    }
    lowerer.origin[fieldLet.id] = node.id
    push(exprs, fieldLet)
  }

  exprs
}

fn lowerBlock(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredExprs = []
  for let i = 0; i < len(node.expressions); i = i + 1 {
    let expr = node.expressions[i]
    if expr and expr.type == NODE.LetDestructure {
      let expanded = lowerLetDestructureExprs(lowerer, expr)
      for let j = 0; j < len(expanded); j = j + 1 {
        push(loweredExprs, expanded[j])
      }
    } else {
      push(loweredExprs, lowerExpr(lowerer, expr))
    }
  }
  newNode.expressions = loweredExprs

  newNode
}

fn lowerFunction(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  // Lower name (Identifier node or nil for anonymous functions)
  if node.name {
    newNode.name = lowerExpr(lowerer, node.name)
  }

  // Lower params (array of Identifier nodes)
  let loweredParams = []
  for let i = 0; i < len(node.params); i = i + 1 {
    push(loweredParams, lowerExpr(lowerer, node.params[i]))
  }
  newNode.params = loweredParams

  // Lower body
  newNode.body = lowerExpr(lowerer, node.body)

  newNode
}

fn lowerCall(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  newNode.callee = lowerExpr(lowerer, node.callee)

  let loweredArgs = []
  for let i = 0; i < len(node.args); i = i + 1 {
    push(loweredArgs, lowerExpr(lowerer, node.args[i]))
  }
  newNode.args = loweredArgs

  newNode
}

fn lowerArrow(lowerer, node) {
  // Arrow: left->right
  // Transform to: right with left prepended to args

  let left = lowerExpr(lowerer, node.left)
  let right = lowerExpr(lowerer, node.right)

  // Validate RHS is Call
  if right.type != NODE.Call {
    addError(lowerer, node.id, "Arrow operator requires function call on right side")
    return left  // Error recovery: return left side
  }

  // Create new Call node with left prepended to args
  // Need to manually build the prepended args array
  let newArgs = [left]
  for let i = 0; i < len(right.args); i = i + 1 {
    push(newArgs, right.args[i])
  }

  let newCall = .{
    type: NODE.Call,
    filename: right.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    callee: right.callee,
    args: newArgs,
  }

  // Track provenance - this new Call came from the Arrow node
  lowerer.origin[newCall.id] = node.id

  newCall
}

fn lowerIf(lowerer, node) {
  // Special case: if-let pattern needs scoping
  // Desugar: if let x = expr { then } else { else }
  // Into:    { let x = expr; if x { then } else { else } }
  if node.condition and (node.condition.type == NODE.Let or node.condition.type == NODE.LetDestructure) {
    let letNode = lowerExpr(lowerer, node.condition)
    let condIdentifier = nil

    if letNode.type == NODE.Let {
      // For simple let, use the bound variable name
      condIdentifier = .{
        type: NODE.Identifier,
        filename: node.filename,
        id: allocNodeId(lowerer),
        line: letNode.line,
        col: letNode.col,
        endLine: letNode.endLine,
        endCol: letNode.endCol,
        name: letNode.name.name,
        lexeme: letNode.name.lexeme,
      }
      lowerer.origin[condIdentifier.id] = node.condition.id
    } else {
      // For destructuring, we need a synthetic variable
      // This case is less common but should be handled
      let syntheticName = "$iflet_" + str(node.id)
      condIdentifier = .{
        type: NODE.Identifier,
        filename: node.filename,
        id: allocNodeId(lowerer),
        line: letNode.line,
        col: letNode.col,
        endLine: letNode.endLine,
        endCol: letNode.endCol,
        name: syntheticName,
        lexeme: syntheticName,
      }
      lowerer.origin[condIdentifier.id] = node.condition.id
    }

    let ifNode = copyNodeShallow(lowerer, node)
    ifNode.condition = condIdentifier
    ifNode.then = lowerExpr(lowerer, node.then)
    if node.else {
      ifNode.else = lowerExpr(lowerer, node.else)
    }

    let blockNode = .{
      type: NODE.Block,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.endLine,
      endCol: node.endCol,
      expressions: [letNode, ifNode],
    }
    lowerer.origin[blockNode.id] = node.id
    return blockNode
  }

  let newNode = copyNodeShallow(lowerer, node)

  newNode.condition = lowerExpr(lowerer, node.condition)
  newNode.then = lowerExpr(lowerer, node.then)

  // Keep else as-is: nil if missing, or lower if present
  if node.else {
    newNode.else = lowerExpr(lowerer, node.else)
  }
  // else remains nil (no normalization)

  newNode
}

fn lowerFor(lowerer, node) {
  // Special case: allow destructuring in init position by hoisting it before the loop
  // into a wrapping block:
  //   for let .{ a, b } = expr; cond; upd { body }
  // becomes:
  //   { let $destr_<id> = expr; let a = $destr_<id>.a; let b = $destr_<id>.b; for ; cond; upd { body } }
  if node.init and node.init.type == NODE.LetDestructure {
    let initExprs = lowerLetDestructureExprs(lowerer, node.init)

    let forNode = copyNodeShallow(lowerer, node)
    forNode.init = nil
    if node.condition {
      forNode.condition = lowerExpr(lowerer, node.condition)
    }
    if node.update {
      forNode.update = lowerExpr(lowerer, node.update)
    }
    forNode.body = lowerExpr(lowerer, node.body)

    let exprs = []
    for let i = 0; i < len(initExprs); i = i + 1 {
      push(exprs, initExprs[i])
    }
    push(exprs, forNode)

    let outerBlockNode = .{
      type: NODE.Block,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.endLine,
      endCol: node.endCol,
      expressions: exprs,
    }
    lowerer.origin[outerBlockNode.id] = node.id
    return outerBlockNode
  }

  let newNode = copyNodeShallow(lowerer, node)

  if node.init {
    newNode.init = lowerExpr(lowerer, node.init)
  }
  if node.condition {
    newNode.condition = lowerExpr(lowerer, node.condition)
  }
  if node.update {
    newNode.update = lowerExpr(lowerer, node.update)
  }
  newNode.body = lowerExpr(lowerer, node.body)

  newNode
}

fn lowerForIn(lowerer, node) {
  // Desugar: for x, i in arrExpr { body }
  // Into: {
  //   let $arr = arrExpr
  //   let $len = len($arr)
  //   for let $i = 0; $i < $len; $i = $i + 1 {
  //     let x = $arr[$i]
  //     let i = $i
  //     body
  //   }
  // }

  // First, lower the iterable expression
  let loweredIterable = lowerExpr(lowerer, node.iterable)
  let loweredBody = lowerExpr(lowerer, node.body)

  // Generate hygienic names with $ prefix to avoid user conflicts
  let arrName = "$arr_" + str(node.id)
  let lenName = "$len_" + str(node.id)
  let idxName = "$i_" + str(node.id)

  // Helper to create an Identifier node
  fn makeIdent(name) {
    .{
      type: NODE.Identifier,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  // Helper to create a Number node
  fn makeNumber(value) {
    .{
      type: NODE.Number,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      value: value,
      lexeme: str(value),
    }
  }

  // Create: let __arr = arrExpr
  let arrLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(arrName),
    init: loweredIterable,
  }
  lowerer.origin[arrLetNode.id] = node.id

  // Create: len(__arr)
  let lenCallNode = .{
    type: NODE.Call,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    callee: makeIdent("len"),
    args: [makeIdent(arrName)],
  }
  lowerer.origin[lenCallNode.id] = node.id

  // Create: let __len = len(__arr)
  let lenLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(lenName),
    init: lenCallNode,
  }
  lowerer.origin[lenLetNode.id] = node.id

  // Create: let __i = 0
  let initNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(idxName),
    init: makeNumber(0),
  }
  lowerer.origin[initNode.id] = node.id

  // Create: __i < __len
  let conditionNode = .{
    type: NODE.Binary,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.LESS,
      lexeme: "<",
      line: node.line,
      col: node.col,
    },
    right: makeIdent(lenName),
  }
  lowerer.origin[conditionNode.id] = node.id

  // Create: __i = __i + 1
  let updateNode = .{
    type: NODE.Assignment,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    target: makeIdent(idxName),
    value: .{
      type: NODE.Binary,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      left: makeIdent(idxName),
      operator: .{
        type: TOKEN.PLUS,
        lexeme: "+",
        line: node.line,
        col: node.col,
      },
      right: makeNumber(1),
    },
  }
  lowerer.origin[updateNode.id] = node.id

  // Build the inner loop body statements
  let innerBodyExprs = []

  // Add: let x = __arr[__i] (if valueBinder is not "_")
  if node.valueBinder != "_" {
    let indexExpr = .{
      type: NODE.Index,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      object: makeIdent(arrName),
      index: makeIdent(idxName),
    }
    lowerer.origin[indexExpr.id] = node.id

    let valueLetNode = .{
      type: NODE.Let,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.valueBinder),
      init: indexExpr,
    }
    lowerer.origin[valueLetNode.id] = node.id
    push(innerBodyExprs, valueLetNode)
  }

  // Add: let i = __i (if indexBinder is present and not "_")
  if node.indexBinder and node.indexBinder != "_" {
    let indexLetNode = .{
      type: NODE.Let,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.indexBinder),
      init: makeIdent(idxName),
    }
    lowerer.origin[indexLetNode.id] = node.id
    push(innerBodyExprs, indexLetNode)
  }

  // Add original body expressions to inner body
  if loweredBody.type == NODE.Block {
    for let i = 0; i < len(loweredBody.expressions); i = i + 1 {
      push(innerBodyExprs, loweredBody.expressions[i])
    }
  } else {
    push(innerBodyExprs, loweredBody)
  }

  // Create the inner block for the for loop body
  let innerBlockNode = .{
    type: NODE.Block,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: innerBodyExprs,
  }
  lowerer.origin[innerBlockNode.id] = node.id

  // Create the for loop
  let forNode = .{
    type: NODE.For,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: initNode,
    condition: conditionNode,
    update: updateNode,
    body: innerBlockNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Wrap everything in a block
  let outerBlockNode = .{
    type: NODE.Block,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [arrLetNode, lenLetNode, forNode],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerCollect(lowerer, node) {
  // Desugar: collect <for-syntax> { body }
  // Into: {
  //   let $result = []
  //   for <for-syntax> { array_append($result, body) }
  //   $result
  // }

  let loweredBody = lowerExpr(lowerer, node.body)

  // Generate hygienic name
  let resultName = "$result_" + str(node.id)

  // Helper to create an Identifier node
  fn makeIdent(name) {
    .{
      type: NODE.Identifier,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  // Create: let $result = [] (using array_new intrinsic)
  let arrayNewNode = .{
    type: NODE.IntrinsicCall,
    intrinsic: "array_new",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [],
  }
  lowerer.origin[arrayNewNode.id] = node.id

  let resultLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    name: makeIdent(resultName),
    init: arrayNewNode,
  }
  lowerer.origin[resultLetNode.id] = node.id

  // Create: array_append($result, body) intrinsic
  let arrayAppendNode = .{
    type: NODE.IntrinsicCall,
    intrinsic: "array_append",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    args: [makeIdent(resultName), loweredBody],
  }
  lowerer.origin[arrayAppendNode.id] = node.id

  // Lower the init, condition, update (if present)
  let loweredInit = node.init and lowerExpr(lowerer, node.init) or nil
  let loweredCondition = node.condition and lowerExpr(lowerer, node.condition) or nil
  let loweredUpdate = node.update and lowerExpr(lowerer, node.update) or nil

  // Create the for loop
  let forNode = .{
    type: NODE.For,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: loweredInit,
    condition: loweredCondition,
    update: loweredUpdate,
    body: arrayAppendNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Create the outer block: { let $result = []; for ...; $result }
  let outerBlockNode = .{
    type: NODE.Block,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [resultLetNode, forNode, makeIdent(resultName)],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerCollectIn(lowerer, node) {
  // Desugar collect-in directly to For loop structure
  // This avoids creating a ForIn node and lowering it, which causes infinite recursion

  let loweredIterable = lowerExpr(lowerer, node.iterable)
  let loweredBody = lowerExpr(lowerer, node.body)

  let resultName = "$result_" + str(node.id)
  let arrName = "$arr_" + str(node.id)
  let lenName = "$len_" + str(node.id)
  let idxName = "$i_" + str(node.id)

  fn makeIdent(name) {
    .{
      type: NODE.Identifier,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: name,
      lexeme: name,
    }
  }

  fn makeEmptyArray() {
    .{
      type: NODE.Array,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      elements: [],
    }
  }

  fn makeNil() {
    .{
      type: NODE.Nil,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      lexeme: "nil",
    }
  }

  fn makeNumber(val) {
    .{
      type: NODE.Number,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      value: val,
      lexeme: str(val),
    }
  }

  // Create: let $result = [] (using array_new intrinsic)
  let arrayNewNode = .{
    type: NODE.IntrinsicCall,
    intrinsic: "array_new",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [],
  }
  lowerer.origin[arrayNewNode.id] = node.id

  let resultLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(resultName),
    init: arrayNewNode,
  }
  lowerer.origin[resultLetNode.id] = node.id

  // Create: let $arr = iterable
  let arrLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(arrName),
    init: loweredIterable,
  }
  lowerer.origin[arrLetNode.id] = node.id

  // Create: len($arr)
  let lenCallNode = .{
    type: NODE.Call,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    callee: makeIdent("len"),
    args: [makeIdent(arrName)],
  }
  lowerer.origin[lenCallNode.id] = node.id

  // Create: let $len = len($arr)
  let lenLetNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(lenName),
    init: lenCallNode,
  }
  lowerer.origin[lenLetNode.id] = node.id

  // Build the inner loop body expressions
  let innerBodyExprs = []

  // Add: let valueBinder = $arr[$i] (if valueBinder is not "_")
  if node.valueBinder != "_" {
    let indexExpr = .{
      type: NODE.Index,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      object: makeIdent(arrName),
      index: makeIdent(idxName),
    }
    lowerer.origin[indexExpr.id] = node.id

    let valueLetNode = .{
      type: NODE.Let,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.valueBinder),
      init: indexExpr,
    }
    lowerer.origin[valueLetNode.id] = node.id
    push(innerBodyExprs, valueLetNode)
  }

  // Add: let indexBinder = $i (if indexBinder is present and not "_")
  if node.indexBinder and node.indexBinder != "_" {
    let indexLetNode = .{
      type: NODE.Let,
      filename: node.filename,
      id: allocNodeId(lowerer),
      line: node.line,
      col: node.col,
      endLine: node.line,
      endCol: node.col,
      name: makeIdent(node.indexBinder),
      init: makeIdent(idxName),
    }
    lowerer.origin[indexLetNode.id] = node.id
    push(innerBodyExprs, indexLetNode)
  }

  // Create: array_append($result, body) intrinsic
  let arrayAppendNode = .{
    type: NODE.IntrinsicCall,
    intrinsic: "array_append",
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    args: [makeIdent(resultName), loweredBody],
  }
  lowerer.origin[arrayAppendNode.id] = node.id
  push(innerBodyExprs, arrayAppendNode)

  // Create the inner block for the for loop body
  let innerBlockNode = .{
    type: NODE.Block,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: innerBodyExprs,
  }
  lowerer.origin[innerBlockNode.id] = node.id

  // Create: let $i = 0
  let initNode = .{
    type: NODE.Let,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    name: makeIdent(idxName),
    init: makeNumber(0),
  }
  lowerer.origin[initNode.id] = node.id

  // Create: $i < $len
  let conditionNode = .{
    type: NODE.Binary,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.LESS,
      lexeme: "<",
      line: node.line,
      col: node.col,
    },
    right: makeIdent(lenName),
  }
  lowerer.origin[conditionNode.id] = node.id

  // Create: $i = $i + 1
  let addNode = .{
    type: NODE.Binary,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    left: makeIdent(idxName),
    operator: .{
      type: TOKEN.PLUS,
      lexeme: "+",
      line: node.line,
      col: node.col,
    },
    right: makeNumber(1),
  }
  lowerer.origin[addNode.id] = node.id

  let updateNode = .{
    type: NODE.Assignment,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.line,
    endCol: node.col,
    target: makeIdent(idxName),
    value: addNode,
  }
  lowerer.origin[updateNode.id] = node.id

  // Create the for loop
  let forNode = .{
    type: NODE.For,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    init: initNode,
    condition: conditionNode,
    update: updateNode,
    body: innerBlockNode,
  }
  lowerer.origin[forNode.id] = node.id

  // Create the outer block: { let $result = []; let $arr = ...; let $len = ...; for ...; $result }
  let outerBlockNode = .{
    type: NODE.Block,
    filename: node.filename,
    id: allocNodeId(lowerer),
    line: node.line,
    col: node.col,
    endLine: node.endLine,
    endCol: node.endCol,
    expressions: [resultLetNode, arrLetNode, lenLetNode, forNode, makeIdent(resultName)],
  }
  lowerer.origin[outerBlockNode.id] = node.id

  outerBlockNode
}

fn lowerReturn(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  if node.value {
    newNode.value = lowerExpr(lowerer, node.value)
  }
  newNode
}

fn lowerBreak(lowerer, node) {
  copyNodeShallow(lowerer, node)
}

fn lowerContinue(lowerer, node) {
  // Continue has no children, just copy
  copyNodeShallow(lowerer, node)
}

fn lowerArray(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredElements = []
  for let i = 0; i < len(node.elements); i = i + 1 {
    push(loweredElements, lowerExpr(lowerer, node.elements[i]))
  }
  newNode.elements = loweredElements

  newNode
}

fn lowerHashmap(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)

  let loweredPairs = []
  for let i = 0; i < len(node.pairs); i = i + 1 {
    let pair = node.pairs[i]
    let loweredPair = .{
      key: lowerExpr(lowerer, pair.key),
      value: lowerExpr(lowerer, pair.value),
    }
    push(loweredPairs, loweredPair)
  }
  newNode.pairs = loweredPairs

  newNode
}

fn lowerIndex(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.object = lowerExpr(lowerer, node.object)
  newNode.index = lowerExpr(lowerer, node.index)
  newNode
}

fn lowerDot(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.object = lowerExpr(lowerer, node.object)
  // property is a StringKey node, needs lowering
  newNode.property = lowerExpr(lowerer, node.property)
  newNode
}

fn lowerAssignment(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  newNode.target = lowerExpr(lowerer, node.target)
  newNode.value = lowerExpr(lowerer, node.value)
  newNode
}

fn lowerImport(lowerer, node) {
  let newNode = copyNodeShallow(lowerer, node)
  // Lower the path (String node)
  newNode.path = lowerExpr(lowerer, node.path)
  newNode
}

// ========================================
// Main Expression Dispatcher
// ========================================

let lowerExprHandlers = .{
  [NODE.Arrow]: lowerArrow,
  [NODE.If]: lowerIf,
  [NODE.Binary]: lowerBinary,
  [NODE.Unary]: lowerUnary,
  [NODE.Logical]: lowerLogical,
  [NODE.Grouping]: lowerGrouping,
  [NODE.Let]: lowerLet,
  [NODE.Block]: lowerBlock,
  [NODE.Function]: lowerFunction,
  [NODE.Call]: lowerCall,
  [NODE.For]: lowerFor,
  [NODE.ForIn]: lowerForIn,
  [NODE.Collect]: lowerCollect,
  [NODE.CollectIn]: lowerCollectIn,
  [NODE.Return]: lowerReturn,
  [NODE.Break]: lowerBreak,
  [NODE.Continue]: lowerContinue,
  [NODE.Array]: lowerArray,
  [NODE.Hashmap]: lowerHashmap,
  [NODE.Index]: lowerIndex,
  [NODE.Dot]: lowerDot,
  [NODE.Assignment]: lowerAssignment,
  [NODE.Import]: lowerImport,
  [NODE.Number]: lowerLeaf,
  [NODE.String]: lowerLeaf,
  [NODE.Bool]: lowerLeaf,
  [NODE.Nil]: lowerLeaf,
  [NODE.Identifier]: lowerLeaf,
}

fn lowerExpr(lowerer, node) {
  if !node { return nil }

  if let handler = lowerExprHandlers[node.type] {
    return handler(lowerer, node)
  }

  // Unknown node type - this should never happen if parser is correct
  addError(lowerer, node.id, "Unknown node type in lowering: " + (nameOf(NODE, node.type) or str(node.type)))
  node
}

// ========================================
// Main API
// ========================================
// lower(ast, opts) → {
//   success: bool,
//   ast: BlockNode,             // Lowered AST (no Arrow nodes)
//   origin: { newId → oldId },  // Provenance map
//   errors: [{ nodeId, message, severity }],
//   nextNodeId: number,         // For next phase to continue
// }
//
// opts: {
//   startNodeId: number,  // Where to start fresh IDs (from parseResult.nextNodeId)
// }
fn lower(ast, opts) {
  let lowerer = .{
    nextId: opts.startNodeId or 1,  // Continue module ID sequence
    origin: .{},                     // newId → oldId mapping
    errors: [],                      // Lowering errors
    filename: ast.filename,          // For creating new nodes
  }

  let loweredAst = lowerExpr(lowerer, ast)

  .{
    success: len(lowerer.errors) == 0,
    ast: loweredAst,
    origin: lowerer.origin,
    errors: lowerer.errors,
    nextNodeId: lowerer.nextId,
  }
}

lower
