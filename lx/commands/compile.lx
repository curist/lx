let common = import "commands/common.lx"
let driver = import "src/driver.lx"

let ARTIFACT = driver.ARTIFACT

let PLAN_ARTIFACTS = [
  ARTIFACT.AST_FINAL,
  ARTIFACT.ANALYSIS_RESOLVE,
  ARTIFACT.ANALYSIS_DCE_LOCAL,
  ARTIFACT.ANALYSIS_DCE_WHOLE_PROGRAM,
  ARTIFACT.ANALYSIS_DCE_FINAL,
  ARTIFACT.ANALYSIS_FASTCHECK,
  ARTIFACT.ANALYSIS_TYPECHECK,
  ARTIFACT.BYTECODE_FUNCTION,
  ARTIFACT.BYTECODE_VERIFIED,
  ARTIFACT.PROGRAM_MODULE_GRAPH,
]

let COLOR = .{
  reset: "\e[0m",
  bold: "\e[1m",
  dim: "\e[2m",
  cyan: "\e[36m",
  green: "\e[32m",
  yellow: "\e[33m",
  gray: "\e[90m",
}

fn wantsColor() {
  let env = Lx.env or .{}
  if env["NO_COLOR"] { return false }
  if env["FORCE_COLOR"] { return true }
  let out = Lx.stdout
  out and out.isTTY and out.isTTY() == true
}

fn colorize(text, code, enabled) {
  enabled and code + text + COLOR.reset or text
}

fn colorArtifact(name, enabled) {
  if !enabled { return name }
  if name == "source" { return colorize(name, COLOR.gray, enabled) }
  colorize(name, COLOR.cyan, enabled)
}

fn isKnownArtifact(artifactId) {
  if artifactId == "ast.pre_resolve" { return true }
  for id in PLAN_ARTIFACTS {
    if id == artifactId { return true }
  }
  false
}

fn printPlanTree(artifactId, graph, prefix, isLast, isRoot, visited, useColor) {
  let linePrefix = isRoot and "" or (isLast and "`- " or "|- ")
  let childPrefix = prefix + (isRoot and "" or (isLast and "   " or "|  "))

  if visited[artifactId] {
    let label = colorArtifact(artifactId, useColor)
    let note = colorize(" (already listed)", COLOR.dim, useColor)
    println(prefix + linePrefix + label + note)
    return
  }
  visited[artifactId] = true

  let label = colorArtifact(artifactId, useColor)
  println(prefix + linePrefix + label)
  let reqs = graph and graph[artifactId] or []
  for let i = 0; i < len(reqs); i = i + 1 {
    let childIsLast = i == len(reqs) - 1
    printPlanTree(reqs[i], graph, childPrefix, childIsLast, false, visited, useColor)
  }
}

fn printPlan(artifactId) {
  let useColor = wantsColor()
  let title = colorize("Build plan for ", COLOR.bold, useColor) +
    colorArtifact(artifactId, useColor)
  println(title)
  let planner = driver.make(.{})
  let passPlan = planner and planner.planPasses and planner.planPasses(artifactId)
  let passDetails = planner and planner.planPassesDetailed and planner.planPassesDetailed(artifactId)
  let graph = planner and planner.planArtifactGraph and planner.planArtifactGraph(artifactId) or .{}
  if passPlan and len(passPlan) > 0 {
    let label = colorize("Passes:", COLOR.bold, useColor)
    println(label + " " + join(passPlan, " -> "))
  }
  if passDetails and len(passDetails) > 0 {
    println(colorize("Pass flags:", COLOR.bold, useColor))
    for detail in passDetails {
      let status =
        detail.required == true and "required" or
        detail.enabled == true and "enabled" or
        "disabled"
      let colored =
        status == "required" and colorize(status, COLOR.green, useColor) or
        status == "enabled" and colorize(status, COLOR.yellow, useColor) or
        colorize(status, COLOR.gray, useColor)
      println("  " + detail.name + ": " + colored)
    }
  }
  println("")
  let visited = .{}
  printPlanTree(artifactId, graph, "", true, true, visited, useColor)
  println("")
  let note = "Note: ast.pre_resolve is a shorthand for the pre-resolve AST pipeline."
  println(colorize(note, COLOR.dim, useColor))
}

fn printUsage(prog) {
  println("Usage: " + prog + " compile <path> [-o|--output <output>]")
  println("       " + prog + " compile --plan [--artifact <id>] [<path>]")
  println("")
  println("Options:")
  println("  -o, --output <path>  Write lxobj output to file")
  println("  --plan               Print artifact dependency plan and exit")
  println("  --artifact <id>      Artifact to plan (default: " + ARTIFACT.BYTECODE_VERIFIED + ")")
  println("")
  println("Examples:")
  println("  " + prog + " compile hello.lx -o out/hello.lxobj")
  println("  " + prog + " compile --plan --artifact analysis.dce.final")
  println("")
  println("Known artifacts: " + join(PLAN_ARTIFACTS, ", "))
}

fn run(ctx) {
  let argsLength = len(ctx.argv)
  if argsLength < 3 {
    printUsage(ctx.prog)
    Lx.exit(28)
  }

  let path = nil
  let outputPath = nil
  let showPlan = false
  let planArtifact = ARTIFACT.BYTECODE_VERIFIED
  let i = 2
  for i < argsLength {
    let arg = ctx.argv[i]
    if arg == "-o" or arg == "--output" {
      if i + 1 >= argsLength {
        printUsage(ctx.prog)
        Lx.exit(28)
      }
      outputPath = ctx.argv[i + 1]
      i = i + 2
      continue
    }
    if arg == "--plan" {
      showPlan = true
      i = i + 1
      continue
    }
    if arg == "--help" or arg == "-h" {
      printUsage(ctx.prog)
      return
    }
    if arg == "--artifact" {
      if i + 1 >= argsLength {
        printUsage(ctx.prog)
        Lx.exit(28)
      }
      planArtifact = ctx.argv[i + 1]
      i = i + 2
      continue
    }
    if !path { path = arg }
    i = i + 1
  }

  if showPlan {
    if !isKnownArtifact(planArtifact) {
      Lx.stderr.println("Unknown artifact: " + planArtifact)
      Lx.stderr.println("Known artifacts: " + join(PLAN_ARTIFACTS, ", "))
      Lx.exit(28)
    }
    printPlan(planArtifact)
    return
  }

  if !path {
    printUsage(ctx.prog)
    Lx.exit(28)
  }

  let func = common.compilePathToFunction(path, nil)
  if !func { Lx.exit(65) }

  if outputPath {
    let bytes = common.objbuilder(func, common.DEBUG_BUILD, true).bytes()
    let ok = Lx.fs.writeFile(outputPath, common.bytesToString(bytes))
    if ok != true {
      Lx.stderr.println(ok or "Failed to write output.")
      Lx.exit(74)
    }
  } else {
    common.objbuilder(func, common.DEBUG_BUILD, true).dump()
  }
}

.{
  name: "compile",
  aliases: ["c"],
  usage: "compile <path> [-o|--output <output>]\n       compile --plan [--artifact <id>] [<path>]",
  summary: "Compile source to lxobj (-o/--output <output>), or show build plan (--plan)",
  run: run,
}
